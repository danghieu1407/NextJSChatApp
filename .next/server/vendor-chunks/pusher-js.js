/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pusher-js";
exports.ids = ["vendor-chunks/pusher-js"];
exports.modules = {

/***/ "(rsc)/./node_modules/pusher-js/dist/node/pusher.js":
/*!****************************************************!*\
  !*** ./node_modules/pusher-js/dist/node/pusher.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Pusher JavaScript Library v8.3.0\n * https://pusher.com/\n *\n * Copyright 2020, Pusher\n * Released under the MIT licence.\n */ \nmodule.exports = /******/ function(modules) {\n    /******/ // The module cache\n    /******/ var installedModules = {};\n    /******/ /******/ // The require function\n    /******/ function __nested_webpack_require_323__(moduleId) {\n        /******/ /******/ // Check if module is in cache\n        /******/ if (installedModules[moduleId]) {\n            /******/ return installedModules[moduleId].exports;\n        /******/ }\n        /******/ // Create a new module (and put it into the cache)\n        /******/ var module1 = installedModules[moduleId] = {\n            /******/ i: moduleId,\n            /******/ l: false,\n            /******/ exports: {}\n        };\n        /******/ /******/ // Execute the module function\n        /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_323__);\n        /******/ /******/ // Flag the module as loaded\n        /******/ module1.l = true;\n        /******/ /******/ // Return the exports of the module\n        /******/ return module1.exports;\n    /******/ }\n    /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n    /******/ __nested_webpack_require_323__.m = modules;\n    /******/ /******/ // expose the module cache\n    /******/ __nested_webpack_require_323__.c = installedModules;\n    /******/ /******/ // define getter function for harmony exports\n    /******/ __nested_webpack_require_323__.d = function(exports, name, getter) {\n        /******/ if (!__nested_webpack_require_323__.o(exports, name)) {\n            /******/ Object.defineProperty(exports, name, {\n                enumerable: true,\n                get: getter\n            });\n        /******/ }\n    /******/ };\n    /******/ /******/ // define __esModule on exports\n    /******/ __nested_webpack_require_323__.r = function(exports) {\n        /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n            /******/ Object.defineProperty(exports, Symbol.toStringTag, {\n                value: \"Module\"\n            });\n        /******/ }\n        /******/ Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n    /******/ };\n    /******/ /******/ // create a fake namespace object\n    /******/ // mode & 1: value is a module id, require it\n    /******/ // mode & 2: merge all properties of value into the ns\n    /******/ // mode & 4: return value when already ns object\n    /******/ // mode & 8|1: behave like require\n    /******/ __nested_webpack_require_323__.t = function(value, mode) {\n        /******/ if (mode & 1) value = __nested_webpack_require_323__(value);\n        /******/ if (mode & 8) return value;\n        /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n        /******/ var ns = Object.create(null);\n        /******/ __nested_webpack_require_323__.r(ns);\n        /******/ Object.defineProperty(ns, \"default\", {\n            enumerable: true,\n            value: value\n        });\n        /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_323__.d(ns, key, (function(key) {\n            return value[key];\n        }).bind(null, key));\n        /******/ return ns;\n    /******/ };\n    /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n    /******/ __nested_webpack_require_323__.n = function(module1) {\n        /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n            return module1[\"default\"];\n        } : /******/ function getModuleExports() {\n            return module1;\n        };\n        /******/ __nested_webpack_require_323__.d(getter, \"a\", getter);\n        /******/ return getter;\n    /******/ };\n    /******/ /******/ // Object.prototype.hasOwnProperty.call\n    /******/ __nested_webpack_require_323__.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n    };\n    /******/ /******/ // __webpack_public_path__\n    /******/ __nested_webpack_require_323__.p = \"\";\n    /******/ /******/ /******/ // Load entry module and return exports\n    /******/ return __nested_webpack_require_323__(__nested_webpack_require_323__.s = 21);\n/******/ }([\n    /* 0 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! util */ \"util\");\n    /***/ },\n    /* 1 */ /***/ function(module1, exports, __nested_webpack_require_4310__) {\n        /* eslint-disable node/no-deprecated-api */ var buffer = __nested_webpack_require_4310__(22);\n        var Buffer1 = buffer.Buffer;\n        // alternative to using Object.keys for old browsers\n        function copyProps(src, dst) {\n            for(var key in src){\n                dst[key] = src[key];\n            }\n        }\n        if (Buffer1.from && Buffer1.alloc && Buffer1.allocUnsafe && Buffer1.allocUnsafeSlow) {\n            module1.exports = buffer;\n        } else {\n            // Copy properties from require('buffer')\n            copyProps(buffer, exports);\n            exports.Buffer = SafeBuffer;\n        }\n        function SafeBuffer(arg, encodingOrOffset, length) {\n            return Buffer1(arg, encodingOrOffset, length);\n        }\n        // Copy static methods from Buffer\n        copyProps(Buffer1, SafeBuffer);\n        SafeBuffer.from = function(arg, encodingOrOffset, length) {\n            if (typeof arg === \"number\") {\n                throw new TypeError(\"Argument must not be a number\");\n            }\n            return Buffer1(arg, encodingOrOffset, length);\n        };\n        SafeBuffer.alloc = function(size, fill, encoding) {\n            if (typeof size !== \"number\") {\n                throw new TypeError(\"Argument must be a number\");\n            }\n            var buf = Buffer1(size);\n            if (fill !== undefined) {\n                if (typeof encoding === \"string\") {\n                    buf.fill(fill, encoding);\n                } else {\n                    buf.fill(fill);\n                }\n            } else {\n                buf.fill(0);\n            }\n            return buf;\n        };\n        SafeBuffer.allocUnsafe = function(size) {\n            if (typeof size !== \"number\") {\n                throw new TypeError(\"Argument must be a number\");\n            }\n            return Buffer1(size);\n        };\n        SafeBuffer.allocUnsafeSlow = function(size) {\n            if (typeof size !== \"number\") {\n                throw new TypeError(\"Argument must be a number\");\n            }\n            return buffer.SlowBuffer(size);\n        };\n    /***/ },\n    /* 2 */ /***/ function(module1, exports, __nested_webpack_require_6472__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_6472__(1).Buffer, Emitter = __nested_webpack_require_6472__(23).EventEmitter, util = __nested_webpack_require_6472__(0), streams = __nested_webpack_require_6472__(24), Headers = __nested_webpack_require_6472__(9), Reader = __nested_webpack_require_6472__(25);\n        var Base = function(request, url, options) {\n            Emitter.call(this);\n            Base.validateOptions(options || {}, [\n                \"maxLength\",\n                \"masking\",\n                \"requireMasking\",\n                \"protocols\"\n            ]);\n            this._request = request;\n            this._reader = new Reader();\n            this._options = options || {};\n            this._maxLength = this._options.maxLength || this.MAX_LENGTH;\n            this._headers = new Headers();\n            this.__queue = [];\n            this.readyState = 0;\n            this.url = url;\n            this.io = new streams.IO(this);\n            this.messages = new streams.Messages(this);\n            this._bindEventListeners();\n        };\n        util.inherits(Base, Emitter);\n        Base.isWebSocket = function(request) {\n            var connection = request.headers.connection || \"\", upgrade = request.headers.upgrade || \"\";\n            return request.method === \"GET\" && connection.toLowerCase().split(/ *, */).indexOf(\"upgrade\") >= 0 && upgrade.toLowerCase() === \"websocket\";\n        };\n        Base.validateOptions = function(options, validKeys) {\n            for(var key in options){\n                if (validKeys.indexOf(key) < 0) throw new Error(\"Unrecognized option: \" + key);\n            }\n        };\n        var instance = {\n            // This is 64MB, small enough for an average VPS to handle without\n            // crashing from process out of memory\n            MAX_LENGTH: 0x3ffffff,\n            STATES: [\n                \"connecting\",\n                \"open\",\n                \"closing\",\n                \"closed\"\n            ],\n            _bindEventListeners: function() {\n                var self1 = this;\n                // Protocol errors are informational and do not have to be handled\n                this.messages.on(\"error\", function() {});\n                this.on(\"message\", function(event) {\n                    var messages = self1.messages;\n                    if (messages.readable) messages.emit(\"data\", event.data);\n                });\n                this.on(\"error\", function(error) {\n                    var messages = self1.messages;\n                    if (messages.readable) messages.emit(\"error\", error);\n                });\n                this.on(\"close\", function() {\n                    var messages = self1.messages;\n                    if (!messages.readable) return;\n                    messages.readable = messages.writable = false;\n                    messages.emit(\"end\");\n                });\n            },\n            getState: function() {\n                return this.STATES[this.readyState] || null;\n            },\n            addExtension: function(extension) {\n                return false;\n            },\n            setHeader: function(name, value) {\n                if (this.readyState > 0) return false;\n                this._headers.set(name, value);\n                return true;\n            },\n            start: function() {\n                if (this.readyState !== 0) return false;\n                if (!Base.isWebSocket(this._request)) return this._failHandshake(new Error(\"Not a WebSocket request\"));\n                var response;\n                try {\n                    response = this._handshakeResponse();\n                } catch (error) {\n                    return this._failHandshake(error);\n                }\n                this._write(response);\n                if (this._stage !== -1) this._open();\n                return true;\n            },\n            _failHandshake: function(error) {\n                var headers = new Headers();\n                headers.set(\"Content-Type\", \"text/plain\");\n                headers.set(\"Content-Length\", Buffer1.byteLength(error.message, \"utf8\"));\n                headers = [\n                    \"HTTP/1.1 400 Bad Request\",\n                    headers.toString(),\n                    error.message\n                ];\n                this._write(Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\"));\n                this._fail(\"protocol_error\", error.message);\n                return false;\n            },\n            text: function(message) {\n                return this.frame(message);\n            },\n            binary: function(message) {\n                return false;\n            },\n            ping: function() {\n                return false;\n            },\n            pong: function() {\n                return false;\n            },\n            close: function(reason, code) {\n                if (this.readyState !== 1) return false;\n                this.readyState = 3;\n                this.emit(\"close\", new Base.CloseEvent(null, null));\n                return true;\n            },\n            _open: function() {\n                this.readyState = 1;\n                this.__queue.forEach(function(args) {\n                    this.frame.apply(this, args);\n                }, this);\n                this.__queue = [];\n                this.emit(\"open\", new Base.OpenEvent());\n            },\n            _queue: function(message) {\n                this.__queue.push(message);\n                return true;\n            },\n            _write: function(chunk) {\n                var io = this.io;\n                if (io.readable) io.emit(\"data\", chunk);\n            },\n            _fail: function(type, message) {\n                this.readyState = 2;\n                this.emit(\"error\", new Error(message));\n                this.close();\n            }\n        };\n        for(var key in instance)Base.prototype[key] = instance[key];\n        Base.ConnectEvent = function() {};\n        Base.OpenEvent = function() {};\n        Base.CloseEvent = function(code, reason) {\n            this.code = code;\n            this.reason = reason;\n        };\n        Base.MessageEvent = function(data) {\n            this.data = data;\n        };\n        Base.PingEvent = function(data) {\n            this.data = data;\n        };\n        Base.PongEvent = function(data) {\n            this.data = data;\n        };\n        module1.exports = Base;\n    /***/ },\n    /* 3 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! crypto */ \"crypto\");\n    /***/ },\n    /* 4 */ /***/ function(module1, exports, __nested_webpack_require_12950__) {\n        \"use strict\";\n        // Protocol references:\n        //\n        // * http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75\n        // * http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76\n        // * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17\n        var Base = __nested_webpack_require_12950__(2), Client = __nested_webpack_require_12950__(26), Server = __nested_webpack_require_12950__(37);\n        var Driver = {\n            client: function(url, options) {\n                options = options || {};\n                if (options.masking === undefined) options.masking = true;\n                return new Client(url, options);\n            },\n            server: function(options) {\n                options = options || {};\n                if (options.requireMasking === undefined) options.requireMasking = true;\n                return new Server(options);\n            },\n            http: function() {\n                return Server.http.apply(Server, arguments);\n            },\n            isSecureRequest: function(request) {\n                return Server.isSecureRequest(request);\n            },\n            isWebSocket: function(request) {\n                return Base.isWebSocket(request);\n            },\n            validateOptions: function(options, validKeys) {\n                Base.validateOptions(options, validKeys);\n            }\n        };\n        module1.exports = Driver;\n    /***/ },\n    /* 5 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! stream */ \"stream\");\n    /***/ },\n    /* 6 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! url */ \"url\");\n    /***/ },\n    /* 7 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var Event = function(eventType, options) {\n            this.type = eventType;\n            for(var key in options)this[key] = options[key];\n        };\n        Event.prototype.initEvent = function(eventType, canBubble, cancelable) {\n            this.type = eventType;\n            this.bubbles = canBubble;\n            this.cancelable = cancelable;\n        };\n        Event.prototype.stopPropagation = function() {};\n        Event.prototype.preventDefault = function() {};\n        Event.CAPTURING_PHASE = 1;\n        Event.AT_TARGET = 2;\n        Event.BUBBLING_PHASE = 3;\n        module1.exports = Event;\n    /***/ },\n    /* 8 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        // Copyright (C) 2016 Dmitry Chestnykh\n        // MIT License. See LICENSE file for details.\n        var __extends = this && this.__extends || function() {\n            var extendStatics = function(d, b) {\n                extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return extendStatics(d, b);\n            };\n            return function(d, b) {\n                extendStatics(d, b);\n                function __() {\n                    this.constructor = d;\n                }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        }();\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        /**\n * Package base64 implements Base64 encoding and decoding.\n */ // Invalid character used in decoding to indicate\n        // that the character to decode is out of range of\n        // alphabet and cannot be decoded.\n        var INVALID_BYTE = 256;\n        /**\n * Implements standard Base64 encoding.\n *\n * Operates in constant time.\n */ var Coder = /** @class */ function() {\n            // TODO(dchest): methods to encode chunk-by-chunk.\n            function Coder(_paddingCharacter) {\n                if (_paddingCharacter === void 0) {\n                    _paddingCharacter = \"=\";\n                }\n                this._paddingCharacter = _paddingCharacter;\n            }\n            Coder.prototype.encodedLength = function(length) {\n                if (!this._paddingCharacter) {\n                    return (length * 8 + 5) / 6 | 0;\n                }\n                return (length + 2) / 3 * 4 | 0;\n            };\n            Coder.prototype.encode = function(data) {\n                var out = \"\";\n                var i = 0;\n                for(; i < data.length - 2; i += 3){\n                    var c = data[i] << 16 | data[i + 1] << 8 | data[i + 2];\n                    out += this._encodeByte(c >>> 3 * 6 & 63);\n                    out += this._encodeByte(c >>> 2 * 6 & 63);\n                    out += this._encodeByte(c >>> 1 * 6 & 63);\n                    out += this._encodeByte(c >>> 0 * 6 & 63);\n                }\n                var left = data.length - i;\n                if (left > 0) {\n                    var c = data[i] << 16 | (left === 2 ? data[i + 1] << 8 : 0);\n                    out += this._encodeByte(c >>> 3 * 6 & 63);\n                    out += this._encodeByte(c >>> 2 * 6 & 63);\n                    if (left === 2) {\n                        out += this._encodeByte(c >>> 1 * 6 & 63);\n                    } else {\n                        out += this._paddingCharacter || \"\";\n                    }\n                    out += this._paddingCharacter || \"\";\n                }\n                return out;\n            };\n            Coder.prototype.maxDecodedLength = function(length) {\n                if (!this._paddingCharacter) {\n                    return (length * 6 + 7) / 8 | 0;\n                }\n                return length / 4 * 3 | 0;\n            };\n            Coder.prototype.decodedLength = function(s) {\n                return this.maxDecodedLength(s.length - this._getPaddingLength(s));\n            };\n            Coder.prototype.decode = function(s) {\n                if (s.length === 0) {\n                    return new Uint8Array(0);\n                }\n                var paddingLength = this._getPaddingLength(s);\n                var length = s.length - paddingLength;\n                var out = new Uint8Array(this.maxDecodedLength(length));\n                var op = 0;\n                var i = 0;\n                var haveBad = 0;\n                var v0 = 0, v1 = 0, v2 = 0, v3 = 0;\n                for(; i < length - 4; i += 4){\n                    v0 = this._decodeChar(s.charCodeAt(i + 0));\n                    v1 = this._decodeChar(s.charCodeAt(i + 1));\n                    v2 = this._decodeChar(s.charCodeAt(i + 2));\n                    v3 = this._decodeChar(s.charCodeAt(i + 3));\n                    out[op++] = v0 << 2 | v1 >>> 4;\n                    out[op++] = v1 << 4 | v2 >>> 2;\n                    out[op++] = v2 << 6 | v3;\n                    haveBad |= v0 & INVALID_BYTE;\n                    haveBad |= v1 & INVALID_BYTE;\n                    haveBad |= v2 & INVALID_BYTE;\n                    haveBad |= v3 & INVALID_BYTE;\n                }\n                if (i < length - 1) {\n                    v0 = this._decodeChar(s.charCodeAt(i));\n                    v1 = this._decodeChar(s.charCodeAt(i + 1));\n                    out[op++] = v0 << 2 | v1 >>> 4;\n                    haveBad |= v0 & INVALID_BYTE;\n                    haveBad |= v1 & INVALID_BYTE;\n                }\n                if (i < length - 2) {\n                    v2 = this._decodeChar(s.charCodeAt(i + 2));\n                    out[op++] = v1 << 4 | v2 >>> 2;\n                    haveBad |= v2 & INVALID_BYTE;\n                }\n                if (i < length - 3) {\n                    v3 = this._decodeChar(s.charCodeAt(i + 3));\n                    out[op++] = v2 << 6 | v3;\n                    haveBad |= v3 & INVALID_BYTE;\n                }\n                if (haveBad !== 0) {\n                    throw new Error(\"Base64Coder: incorrect characters for decoding\");\n                }\n                return out;\n            };\n            // Standard encoding have the following encoded/decoded ranges,\n            // which we need to convert between.\n            //\n            // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /\n            // Index:   0 - 25                    26 - 51              52 - 61   62  63\n            // ASCII:  65 - 90                    97 - 122             48 - 57   43  47\n            //\n            // Encode 6 bits in b into a new character.\n            Coder.prototype._encodeByte = function(b) {\n                // Encoding uses constant time operations as follows:\n                //\n                // 1. Define comparison of A with B using (A - B) >>> 8:\n                //          if A > B, then result is positive integer\n                //          if A <= B, then result is 0\n                //\n                // 2. Define selection of C or 0 using bitwise AND: X & C:\n                //          if X == 0, then result is 0\n                //          if X != 0, then result is C\n                //\n                // 3. Start with the smallest comparison (b >= 0), which is always\n                //    true, so set the result to the starting ASCII value (65).\n                //\n                // 4. Continue comparing b to higher ASCII values, and selecting\n                //    zero if comparison isn't true, otherwise selecting a value\n                //    to add to result, which:\n                //\n                //          a) undoes the previous addition\n                //          b) provides new value to add\n                //\n                var result = b;\n                // b >= 0\n                result += 65;\n                // b > 25\n                result += 25 - b >>> 8 & 0 - 65 - 26 + 97;\n                // b > 51\n                result += 51 - b >>> 8 & 26 - 97 - 52 + 48;\n                // b > 61\n                result += 61 - b >>> 8 & 52 - 48 - 62 + 43;\n                // b > 62\n                result += 62 - b >>> 8 & 62 - 43 - 63 + 47;\n                return String.fromCharCode(result);\n            };\n            // Decode a character code into a byte.\n            // Must return 256 if character is out of alphabet range.\n            Coder.prototype._decodeChar = function(c) {\n                // Decoding works similar to encoding: using the same comparison\n                // function, but now it works on ranges: result is always incremented\n                // by value, but this value becomes zero if the range is not\n                // satisfied.\n                //\n                // Decoding starts with invalid value, 256, which is then\n                // subtracted when the range is satisfied. If none of the ranges\n                // apply, the function returns 256, which is then checked by\n                // the caller to throw error.\n                var result = INVALID_BYTE; // start with invalid character\n                // c == 43 (c > 42 and c < 44)\n                result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;\n                // c == 47 (c > 46 and c < 48)\n                result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;\n                // c > 47 and c < 58\n                result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;\n                // c > 64 and c < 91\n                result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;\n                // c > 96 and c < 123\n                result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;\n                return result;\n            };\n            Coder.prototype._getPaddingLength = function(s) {\n                var paddingLength = 0;\n                if (this._paddingCharacter) {\n                    for(var i = s.length - 1; i >= 0; i--){\n                        if (s[i] !== this._paddingCharacter) {\n                            break;\n                        }\n                        paddingLength++;\n                    }\n                    if (s.length < 4 || paddingLength > 2) {\n                        throw new Error(\"Base64Coder: incorrect padding\");\n                    }\n                }\n                return paddingLength;\n            };\n            return Coder;\n        }();\n        exports.Coder = Coder;\n        var stdCoder = new Coder();\n        function encode(data) {\n            return stdCoder.encode(data);\n        }\n        exports.encode = encode;\n        function decode(s) {\n            return stdCoder.decode(s);\n        }\n        exports.decode = decode;\n        /**\n * Implements URL-safe Base64 encoding.\n * (Same as Base64, but '+' is replaced with '-', and '/' with '_').\n *\n * Operates in constant time.\n */ var URLSafeCoder = /** @class */ function(_super) {\n            __extends(URLSafeCoder, _super);\n            function URLSafeCoder() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            // URL-safe encoding have the following encoded/decoded ranges:\n            //\n            // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _\n            // Index:   0 - 25                    26 - 51              52 - 61   62  63\n            // ASCII:  65 - 90                    97 - 122             48 - 57   45  95\n            //\n            URLSafeCoder.prototype._encodeByte = function(b) {\n                var result = b;\n                // b >= 0\n                result += 65;\n                // b > 25\n                result += 25 - b >>> 8 & 0 - 65 - 26 + 97;\n                // b > 51\n                result += 51 - b >>> 8 & 26 - 97 - 52 + 48;\n                // b > 61\n                result += 61 - b >>> 8 & 52 - 48 - 62 + 45;\n                // b > 62\n                result += 62 - b >>> 8 & 62 - 45 - 63 + 95;\n                return String.fromCharCode(result);\n            };\n            URLSafeCoder.prototype._decodeChar = function(c) {\n                var result = INVALID_BYTE;\n                // c == 45 (c > 44 and c < 46)\n                result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;\n                // c == 95 (c > 94 and c < 96)\n                result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;\n                // c > 47 and c < 58\n                result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;\n                // c > 64 and c < 91\n                result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;\n                // c > 96 and c < 123\n                result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;\n                return result;\n            };\n            return URLSafeCoder;\n        }(Coder);\n        exports.URLSafeCoder = URLSafeCoder;\n        var urlSafeCoder = new URLSafeCoder();\n        function encodeURLSafe(data) {\n            return urlSafeCoder.encode(data);\n        }\n        exports.encodeURLSafe = encodeURLSafe;\n        function decodeURLSafe(s) {\n            return urlSafeCoder.decode(s);\n        }\n        exports.decodeURLSafe = decodeURLSafe;\n        exports.encodedLength = function(length) {\n            return stdCoder.encodedLength(length);\n        };\n        exports.maxDecodedLength = function(length) {\n            return stdCoder.maxDecodedLength(length);\n        };\n        exports.decodedLength = function(s) {\n            return stdCoder.decodedLength(s);\n        };\n    /***/ },\n    /* 9 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var Headers = function() {\n            this.clear();\n        };\n        Headers.prototype.ALLOWED_DUPLICATES = [\n            \"set-cookie\",\n            \"set-cookie2\",\n            \"warning\",\n            \"www-authenticate\"\n        ];\n        Headers.prototype.clear = function() {\n            this._sent = {};\n            this._lines = [];\n        };\n        Headers.prototype.set = function(name, value) {\n            if (value === undefined) return;\n            name = this._strip(name);\n            value = this._strip(value);\n            var key = name.toLowerCase();\n            if (!this._sent.hasOwnProperty(key) || this.ALLOWED_DUPLICATES.indexOf(key) >= 0) {\n                this._sent[key] = true;\n                this._lines.push(name + \": \" + value + \"\\r\\n\");\n            }\n        };\n        Headers.prototype.toString = function() {\n            return this._lines.join(\"\");\n        };\n        Headers.prototype._strip = function(string) {\n            return string.toString().replace(/^ */, \"\").replace(/ *$/, \"\");\n        };\n        module1.exports = Headers;\n    /***/ },\n    /* 10 */ /***/ function(module1, exports, __nested_webpack_require_29541__) {\n        \"use strict\";\n        var NodeHTTPParser = __nested_webpack_require_29541__(27).HTTPParser, Buffer1 = __nested_webpack_require_29541__(1).Buffer;\n        var TYPES = {\n            request: NodeHTTPParser.REQUEST || \"request\",\n            response: NodeHTTPParser.RESPONSE || \"response\"\n        };\n        var HttpParser = function(type) {\n            this._type = type;\n            this._parser = new NodeHTTPParser(TYPES[type]);\n            this._complete = false;\n            this.headers = {};\n            var current = null, self1 = this;\n            this._parser.onHeaderField = function(b, start, length) {\n                current = b.toString(\"utf8\", start, start + length).toLowerCase();\n            };\n            this._parser.onHeaderValue = function(b, start, length) {\n                var value = b.toString(\"utf8\", start, start + length);\n                if (self1.headers.hasOwnProperty(current)) self1.headers[current] += \", \" + value;\n                else self1.headers[current] = value;\n            };\n            this._parser.onHeadersComplete = this._parser[NodeHTTPParser.kOnHeadersComplete] = function(majorVersion, minorVersion, headers, method, pathname, statusCode) {\n                var info = arguments[0];\n                if (typeof info === \"object\") {\n                    method = info.method;\n                    pathname = info.url;\n                    statusCode = info.statusCode;\n                    headers = info.headers;\n                }\n                self1.method = typeof method === \"number\" ? HttpParser.METHODS[method] : method;\n                self1.statusCode = statusCode;\n                self1.url = pathname;\n                if (!headers) return;\n                for(var i = 0, n = headers.length, key, value; i < n; i += 2){\n                    key = headers[i].toLowerCase();\n                    value = headers[i + 1];\n                    if (self1.headers.hasOwnProperty(key)) self1.headers[key] += \", \" + value;\n                    else self1.headers[key] = value;\n                }\n                self1._complete = true;\n            };\n        };\n        HttpParser.METHODS = {\n            0: \"DELETE\",\n            1: \"GET\",\n            2: \"HEAD\",\n            3: \"POST\",\n            4: \"PUT\",\n            5: \"CONNECT\",\n            6: \"OPTIONS\",\n            7: \"TRACE\",\n            8: \"COPY\",\n            9: \"LOCK\",\n            10: \"MKCOL\",\n            11: \"MOVE\",\n            12: \"PROPFIND\",\n            13: \"PROPPATCH\",\n            14: \"SEARCH\",\n            15: \"UNLOCK\",\n            16: \"BIND\",\n            17: \"REBIND\",\n            18: \"UNBIND\",\n            19: \"ACL\",\n            20: \"REPORT\",\n            21: \"MKACTIVITY\",\n            22: \"CHECKOUT\",\n            23: \"MERGE\",\n            24: \"M-SEARCH\",\n            25: \"NOTIFY\",\n            26: \"SUBSCRIBE\",\n            27: \"UNSUBSCRIBE\",\n            28: \"PATCH\",\n            29: \"PURGE\",\n            30: \"MKCALENDAR\",\n            31: \"LINK\",\n            32: \"UNLINK\"\n        };\n        var VERSION = process.version ? process.version.match(/[0-9]+/g).map(function(n) {\n            return parseInt(n, 10);\n        }) : [];\n        if (VERSION[0] === 0 && VERSION[1] === 12) {\n            HttpParser.METHODS[16] = \"REPORT\";\n            HttpParser.METHODS[17] = \"MKACTIVITY\";\n            HttpParser.METHODS[18] = \"CHECKOUT\";\n            HttpParser.METHODS[19] = \"MERGE\";\n            HttpParser.METHODS[20] = \"M-SEARCH\";\n            HttpParser.METHODS[21] = \"NOTIFY\";\n            HttpParser.METHODS[22] = \"SUBSCRIBE\";\n            HttpParser.METHODS[23] = \"UNSUBSCRIBE\";\n            HttpParser.METHODS[24] = \"PATCH\";\n            HttpParser.METHODS[25] = \"PURGE\";\n        }\n        HttpParser.prototype.isComplete = function() {\n            return this._complete;\n        };\n        HttpParser.prototype.parse = function(chunk) {\n            var consumed = this._parser.execute(chunk, 0, chunk.length);\n            if (typeof consumed !== \"number\") {\n                this.error = consumed;\n                this._complete = true;\n                return;\n            }\n            if (this._complete) this.body = consumed < chunk.length ? chunk.slice(consumed) : Buffer1.alloc(0);\n        };\n        module1.exports = HttpParser;\n    /***/ },\n    /* 11 */ /***/ function(module1, exports, __nested_webpack_require_33840__) {\n        \"use strict\";\n        var Stream = __nested_webpack_require_33840__(5).Stream, util = __nested_webpack_require_33840__(0), driver = __nested_webpack_require_33840__(4), EventTarget = __nested_webpack_require_33840__(16), Event = __nested_webpack_require_33840__(7);\n        var API = function(options) {\n            options = options || {};\n            driver.validateOptions(options, [\n                \"headers\",\n                \"extensions\",\n                \"maxLength\",\n                \"ping\",\n                \"proxy\",\n                \"tls\",\n                \"ca\"\n            ]);\n            this.readable = this.writable = true;\n            var headers = options.headers;\n            if (headers) {\n                for(var name in headers)this._driver.setHeader(name, headers[name]);\n            }\n            var extensions = options.extensions;\n            if (extensions) {\n                [].concat(extensions).forEach(this._driver.addExtension, this._driver);\n            }\n            this._ping = options.ping;\n            this._pingId = 0;\n            this.readyState = API.CONNECTING;\n            this.bufferedAmount = 0;\n            this.protocol = \"\";\n            this.url = this._driver.url;\n            this.version = this._driver.version;\n            var self1 = this;\n            this._driver.on(\"open\", function(e) {\n                self1._open();\n            });\n            this._driver.on(\"message\", function(e) {\n                self1._receiveMessage(e.data);\n            });\n            this._driver.on(\"close\", function(e) {\n                self1._beginClose(e.reason, e.code);\n            });\n            this._driver.on(\"error\", function(error) {\n                self1._emitError(error.message);\n            });\n            this.on(\"error\", function() {});\n            this._driver.messages.on(\"drain\", function() {\n                self1.emit(\"drain\");\n            });\n            if (this._ping) this._pingTimer = setInterval(function() {\n                self1._pingId += 1;\n                self1.ping(self1._pingId.toString());\n            }, this._ping * 1000);\n            this._configureStream();\n            if (!this._proxy) {\n                this._stream.pipe(this._driver.io);\n                this._driver.io.pipe(this._stream);\n            }\n        };\n        util.inherits(API, Stream);\n        API.CONNECTING = 0;\n        API.OPEN = 1;\n        API.CLOSING = 2;\n        API.CLOSED = 3;\n        API.CLOSE_TIMEOUT = 30000;\n        var instance = {\n            write: function(data) {\n                return this.send(data);\n            },\n            end: function(data) {\n                if (data !== undefined) this.send(data);\n                this.close();\n            },\n            pause: function() {\n                return this._driver.messages.pause();\n            },\n            resume: function() {\n                return this._driver.messages.resume();\n            },\n            send: function(data) {\n                if (this.readyState > API.OPEN) return false;\n                if (!(data instanceof Buffer)) data = String(data);\n                return this._driver.messages.write(data);\n            },\n            ping: function(message, callback) {\n                if (this.readyState > API.OPEN) return false;\n                return this._driver.ping(message, callback);\n            },\n            close: function(code, reason) {\n                if (code === undefined) code = 1000;\n                if (reason === undefined) reason = \"\";\n                if (code !== 1000 && (code < 3000 || code > 4999)) throw new Error(\"Failed to execute 'close' on WebSocket: \" + \"The code must be either 1000, or between 3000 and 4999. \" + code + \" is neither.\");\n                if (this.readyState !== API.CLOSED) this.readyState = API.CLOSING;\n                var self1 = this;\n                this._closeTimer = setTimeout(function() {\n                    self1._beginClose(\"\", 1006);\n                }, API.CLOSE_TIMEOUT);\n                this._driver.close(reason, code);\n            },\n            _configureStream: function() {\n                var self1 = this;\n                this._stream.setTimeout(0);\n                this._stream.setNoDelay(true);\n                [\n                    \"close\",\n                    \"end\"\n                ].forEach(function(event) {\n                    this._stream.on(event, function() {\n                        self1._finalizeClose();\n                    });\n                }, this);\n                this._stream.on(\"error\", function(error) {\n                    self1._emitError(\"Network error: \" + self1.url + \": \" + error.message);\n                    self1._finalizeClose();\n                });\n            },\n            _open: function() {\n                if (this.readyState !== API.CONNECTING) return;\n                this.readyState = API.OPEN;\n                this.protocol = this._driver.protocol || \"\";\n                var event = new Event(\"open\");\n                event.initEvent(\"open\", false, false);\n                this.dispatchEvent(event);\n            },\n            _receiveMessage: function(data) {\n                if (this.readyState > API.OPEN) return false;\n                if (this.readable) this.emit(\"data\", data);\n                var event = new Event(\"message\", {\n                    data: data\n                });\n                event.initEvent(\"message\", false, false);\n                this.dispatchEvent(event);\n            },\n            _emitError: function(message) {\n                if (this.readyState >= API.CLOSING) return;\n                var event = new Event(\"error\", {\n                    message: message\n                });\n                event.initEvent(\"error\", false, false);\n                this.dispatchEvent(event);\n            },\n            _beginClose: function(reason, code) {\n                if (this.readyState === API.CLOSED) return;\n                this.readyState = API.CLOSING;\n                this._closeParams = [\n                    reason,\n                    code\n                ];\n                if (this._stream) {\n                    this._stream.destroy();\n                    if (!this._stream.readable) this._finalizeClose();\n                }\n            },\n            _finalizeClose: function() {\n                if (this.readyState === API.CLOSED) return;\n                this.readyState = API.CLOSED;\n                if (this._closeTimer) clearTimeout(this._closeTimer);\n                if (this._pingTimer) clearInterval(this._pingTimer);\n                if (this._stream) this._stream.end();\n                if (this.readable) this.emit(\"end\");\n                this.readable = this.writable = false;\n                var reason = this._closeParams ? this._closeParams[0] : \"\", code = this._closeParams ? this._closeParams[1] : 1006;\n                var event = new Event(\"close\", {\n                    code: code,\n                    reason: reason\n                });\n                event.initEvent(\"close\", false, false);\n                this.dispatchEvent(event);\n            }\n        };\n        for(var method in instance)API.prototype[method] = instance[method];\n        for(var key in EventTarget)API.prototype[key] = EventTarget[key];\n        module1.exports = API;\n    /***/ },\n    /* 12 */ /***/ function(module1, exports, __nested_webpack_require_41112__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_41112__(1).Buffer, crypto = __nested_webpack_require_41112__(3), util = __nested_webpack_require_41112__(0), Extensions = __nested_webpack_require_41112__(29), Base = __nested_webpack_require_41112__(2), Frame = __nested_webpack_require_41112__(34), Message = __nested_webpack_require_41112__(35);\n        var Hybi = function(request, url, options) {\n            Base.apply(this, arguments);\n            this._extensions = new Extensions();\n            this._stage = 0;\n            this._masking = this._options.masking;\n            this._protocols = this._options.protocols || [];\n            this._requireMasking = this._options.requireMasking;\n            this._pingCallbacks = {};\n            if (typeof this._protocols === \"string\") this._protocols = this._protocols.split(/ *, */);\n            if (!this._request) return;\n            var protos = this._request.headers[\"sec-websocket-protocol\"], supported = this._protocols;\n            if (protos !== undefined) {\n                if (typeof protos === \"string\") protos = protos.split(/ *, */);\n                this.protocol = protos.filter(function(p) {\n                    return supported.indexOf(p) >= 0;\n                })[0];\n            }\n            this.version = \"hybi-\" + Hybi.VERSION;\n        };\n        util.inherits(Hybi, Base);\n        Hybi.VERSION = \"13\";\n        Hybi.mask = function(payload, mask, offset) {\n            if (!mask || mask.length === 0) return payload;\n            offset = offset || 0;\n            for(var i = 0, n = payload.length - offset; i < n; i++){\n                payload[offset + i] = payload[offset + i] ^ mask[i % 4];\n            }\n            return payload;\n        };\n        Hybi.generateAccept = function(key) {\n            var sha1 = crypto.createHash(\"sha1\");\n            sha1.update(key + Hybi.GUID);\n            return sha1.digest(\"base64\");\n        };\n        Hybi.GUID = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        var instance = {\n            FIN: 0x80,\n            MASK: 0x80,\n            RSV1: 0x40,\n            RSV2: 0x20,\n            RSV3: 0x10,\n            OPCODE: 0x0F,\n            LENGTH: 0x7F,\n            OPCODES: {\n                continuation: 0,\n                text: 1,\n                binary: 2,\n                close: 8,\n                ping: 9,\n                pong: 10\n            },\n            OPCODE_CODES: [\n                0,\n                1,\n                2,\n                8,\n                9,\n                10\n            ],\n            MESSAGE_OPCODES: [\n                0,\n                1,\n                2\n            ],\n            OPENING_OPCODES: [\n                1,\n                2\n            ],\n            ERRORS: {\n                normal_closure: 1000,\n                going_away: 1001,\n                protocol_error: 1002,\n                unacceptable: 1003,\n                encoding_error: 1007,\n                policy_violation: 1008,\n                too_large: 1009,\n                extension_error: 1010,\n                unexpected_condition: 1011\n            },\n            ERROR_CODES: [\n                1000,\n                1001,\n                1002,\n                1003,\n                1007,\n                1008,\n                1009,\n                1010,\n                1011\n            ],\n            DEFAULT_ERROR_CODE: 1000,\n            MIN_RESERVED_ERROR: 3000,\n            MAX_RESERVED_ERROR: 4999,\n            // http://www.w3.org/International/questions/qa-forms-utf-8.en.php\n            UTF8_MATCH: /^([\\x00-\\x7F]|[\\xC2-\\xDF][\\x80-\\xBF]|\\xE0[\\xA0-\\xBF][\\x80-\\xBF]|[\\xE1-\\xEC\\xEE\\xEF][\\x80-\\xBF]{2}|\\xED[\\x80-\\x9F][\\x80-\\xBF]|\\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}|[\\xF1-\\xF3][\\x80-\\xBF]{3}|\\xF4[\\x80-\\x8F][\\x80-\\xBF]{2})*$/,\n            addExtension: function(extension) {\n                this._extensions.add(extension);\n                return true;\n            },\n            parse: function(chunk) {\n                this._reader.put(chunk);\n                var buffer = true;\n                while(buffer){\n                    switch(this._stage){\n                        case 0:\n                            buffer = this._reader.read(1);\n                            if (buffer) this._parseOpcode(buffer[0]);\n                            break;\n                        case 1:\n                            buffer = this._reader.read(1);\n                            if (buffer) this._parseLength(buffer[0]);\n                            break;\n                        case 2:\n                            buffer = this._reader.read(this._frame.lengthBytes);\n                            if (buffer) this._parseExtendedLength(buffer);\n                            break;\n                        case 3:\n                            buffer = this._reader.read(4);\n                            if (buffer) {\n                                this._stage = 4;\n                                this._frame.maskingKey = buffer;\n                            }\n                            break;\n                        case 4:\n                            buffer = this._reader.read(this._frame.length);\n                            if (buffer) {\n                                this._stage = 0;\n                                this._emitFrame(buffer);\n                            }\n                            break;\n                        default:\n                            buffer = null;\n                    }\n                }\n            },\n            text: function(message) {\n                if (this.readyState > 1) return false;\n                return this.frame(message, \"text\");\n            },\n            binary: function(message) {\n                if (this.readyState > 1) return false;\n                return this.frame(message, \"binary\");\n            },\n            ping: function(message, callback) {\n                if (this.readyState > 1) return false;\n                message = message || \"\";\n                if (callback) this._pingCallbacks[message] = callback;\n                return this.frame(message, \"ping\");\n            },\n            pong: function(message) {\n                if (this.readyState > 1) return false;\n                message = message || \"\";\n                return this.frame(message, \"pong\");\n            },\n            close: function(reason, code) {\n                reason = reason || \"\";\n                code = code || this.ERRORS.normal_closure;\n                if (this.readyState <= 0) {\n                    this.readyState = 3;\n                    this.emit(\"close\", new Base.CloseEvent(code, reason));\n                    return true;\n                } else if (this.readyState === 1) {\n                    this.readyState = 2;\n                    this._extensions.close(function() {\n                        this.frame(reason, \"close\", code);\n                    }, this);\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            frame: function(buffer, type, code) {\n                if (this.readyState <= 0) return this._queue([\n                    buffer,\n                    type,\n                    code\n                ]);\n                if (this.readyState > 2) return false;\n                if (buffer instanceof Array) buffer = Buffer1.from(buffer);\n                if (typeof buffer === \"number\") buffer = buffer.toString();\n                var message = new Message(), isText = typeof buffer === \"string\", payload, copy;\n                message.rsv1 = message.rsv2 = message.rsv3 = false;\n                message.opcode = this.OPCODES[type || (isText ? \"text\" : \"binary\")];\n                payload = isText ? Buffer1.from(buffer, \"utf8\") : buffer;\n                if (code) {\n                    copy = payload;\n                    payload = Buffer1.allocUnsafe(2 + copy.length);\n                    payload.writeUInt16BE(code, 0);\n                    copy.copy(payload, 2);\n                }\n                message.data = payload;\n                var onMessageReady = function(message) {\n                    var frame = new Frame();\n                    frame.final = true;\n                    frame.rsv1 = message.rsv1;\n                    frame.rsv2 = message.rsv2;\n                    frame.rsv3 = message.rsv3;\n                    frame.opcode = message.opcode;\n                    frame.masked = !!this._masking;\n                    frame.length = message.data.length;\n                    frame.payload = message.data;\n                    if (frame.masked) frame.maskingKey = crypto.randomBytes(4);\n                    this._sendFrame(frame);\n                };\n                if (this.MESSAGE_OPCODES.indexOf(message.opcode) >= 0) this._extensions.processOutgoingMessage(message, function(error, message) {\n                    if (error) return this._fail(\"extension_error\", error.message);\n                    onMessageReady.call(this, message);\n                }, this);\n                else onMessageReady.call(this, message);\n                return true;\n            },\n            _sendFrame: function(frame) {\n                var length = frame.length, header = length <= 125 ? 2 : length <= 65535 ? 4 : 10, offset = header + (frame.masked ? 4 : 0), buffer = Buffer1.allocUnsafe(offset + length), masked = frame.masked ? this.MASK : 0;\n                buffer[0] = (frame.final ? this.FIN : 0) | (frame.rsv1 ? this.RSV1 : 0) | (frame.rsv2 ? this.RSV2 : 0) | (frame.rsv3 ? this.RSV3 : 0) | frame.opcode;\n                if (length <= 125) {\n                    buffer[1] = masked | length;\n                } else if (length <= 65535) {\n                    buffer[1] = masked | 126;\n                    buffer.writeUInt16BE(length, 2);\n                } else {\n                    buffer[1] = masked | 127;\n                    buffer.writeUInt32BE(Math.floor(length / 0x100000000), 2);\n                    buffer.writeUInt32BE(length % 0x100000000, 6);\n                }\n                frame.payload.copy(buffer, offset);\n                if (frame.masked) {\n                    frame.maskingKey.copy(buffer, header);\n                    Hybi.mask(buffer, frame.maskingKey, offset);\n                }\n                this._write(buffer);\n            },\n            _handshakeResponse: function() {\n                var secKey = this._request.headers[\"sec-websocket-key\"], version = this._request.headers[\"sec-websocket-version\"];\n                if (version !== Hybi.VERSION) throw new Error(\"Unsupported WebSocket version: \" + version);\n                if (typeof secKey !== \"string\") throw new Error(\"Missing handshake request header: Sec-WebSocket-Key\");\n                this._headers.set(\"Upgrade\", \"websocket\");\n                this._headers.set(\"Connection\", \"Upgrade\");\n                this._headers.set(\"Sec-WebSocket-Accept\", Hybi.generateAccept(secKey));\n                if (this.protocol) this._headers.set(\"Sec-WebSocket-Protocol\", this.protocol);\n                var extensions = this._extensions.generateResponse(this._request.headers[\"sec-websocket-extensions\"]);\n                if (extensions) this._headers.set(\"Sec-WebSocket-Extensions\", extensions);\n                var start = \"HTTP/1.1 101 Switching Protocols\", headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                return Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\");\n            },\n            _shutdown: function(code, reason, error) {\n                delete this._frame;\n                delete this._message;\n                this._stage = 5;\n                var sendCloseFrame = this.readyState === 1;\n                this.readyState = 2;\n                this._extensions.close(function() {\n                    if (sendCloseFrame) this.frame(reason, \"close\", code);\n                    this.readyState = 3;\n                    if (error) this.emit(\"error\", new Error(reason));\n                    this.emit(\"close\", new Base.CloseEvent(code, reason));\n                }, this);\n            },\n            _fail: function(type, message) {\n                if (this.readyState > 1) return;\n                this._shutdown(this.ERRORS[type], message, true);\n            },\n            _parseOpcode: function(octet) {\n                var rsvs = [\n                    this.RSV1,\n                    this.RSV2,\n                    this.RSV3\n                ].map(function(rsv) {\n                    return (octet & rsv) === rsv;\n                });\n                var frame = this._frame = new Frame();\n                frame.final = (octet & this.FIN) === this.FIN;\n                frame.rsv1 = rsvs[0];\n                frame.rsv2 = rsvs[1];\n                frame.rsv3 = rsvs[2];\n                frame.opcode = octet & this.OPCODE;\n                this._stage = 1;\n                if (!this._extensions.validFrameRsv(frame)) return this._fail(\"protocol_error\", \"One or more reserved bits are on: reserved1 = \" + (frame.rsv1 ? 1 : 0) + \", reserved2 = \" + (frame.rsv2 ? 1 : 0) + \", reserved3 = \" + (frame.rsv3 ? 1 : 0));\n                if (this.OPCODE_CODES.indexOf(frame.opcode) < 0) return this._fail(\"protocol_error\", \"Unrecognized frame opcode: \" + frame.opcode);\n                if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && !frame.final) return this._fail(\"protocol_error\", \"Received fragmented control frame: opcode = \" + frame.opcode);\n                if (this._message && this.OPENING_OPCODES.indexOf(frame.opcode) >= 0) return this._fail(\"protocol_error\", \"Received new data frame but previous continuous frame is unfinished\");\n            },\n            _parseLength: function(octet) {\n                var frame = this._frame;\n                frame.masked = (octet & this.MASK) === this.MASK;\n                frame.length = octet & this.LENGTH;\n                if (frame.length >= 0 && frame.length <= 125) {\n                    this._stage = frame.masked ? 3 : 4;\n                    if (!this._checkFrameLength()) return;\n                } else {\n                    this._stage = 2;\n                    frame.lengthBytes = frame.length === 126 ? 2 : 8;\n                }\n                if (this._requireMasking && !frame.masked) return this._fail(\"unacceptable\", \"Received unmasked frame but masking is required\");\n            },\n            _parseExtendedLength: function(buffer) {\n                var frame = this._frame;\n                frame.length = this._readUInt(buffer);\n                this._stage = frame.masked ? 3 : 4;\n                if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && frame.length > 125) return this._fail(\"protocol_error\", \"Received control frame having too long payload: \" + frame.length);\n                if (!this._checkFrameLength()) return;\n            },\n            _checkFrameLength: function() {\n                var length = this._message ? this._message.length : 0;\n                if (length + this._frame.length > this._maxLength) {\n                    this._fail(\"too_large\", \"WebSocket frame length too large\");\n                    return false;\n                } else {\n                    return true;\n                }\n            },\n            _emitFrame: function(buffer) {\n                var frame = this._frame, payload = frame.payload = Hybi.mask(buffer, frame.maskingKey), opcode = frame.opcode, message, code, reason, callbacks, callback;\n                delete this._frame;\n                if (opcode === this.OPCODES.continuation) {\n                    if (!this._message) return this._fail(\"protocol_error\", \"Received unexpected continuation frame\");\n                    this._message.pushFrame(frame);\n                }\n                if (opcode === this.OPCODES.text || opcode === this.OPCODES.binary) {\n                    this._message = new Message();\n                    this._message.pushFrame(frame);\n                }\n                if (frame.final && this.MESSAGE_OPCODES.indexOf(opcode) >= 0) return this._emitMessage(this._message);\n                if (opcode === this.OPCODES.close) {\n                    code = payload.length >= 2 ? payload.readUInt16BE(0) : null;\n                    reason = payload.length > 2 ? this._encode(payload.slice(2)) : null;\n                    if (!(payload.length === 0) && !(code !== null && code >= this.MIN_RESERVED_ERROR && code <= this.MAX_RESERVED_ERROR) && this.ERROR_CODES.indexOf(code) < 0) code = this.ERRORS.protocol_error;\n                    if (payload.length > 125 || payload.length > 2 && !reason) code = this.ERRORS.protocol_error;\n                    this._shutdown(code || this.DEFAULT_ERROR_CODE, reason || \"\");\n                }\n                if (opcode === this.OPCODES.ping) {\n                    this.frame(payload, \"pong\");\n                    this.emit(\"ping\", new Base.PingEvent(payload.toString()));\n                }\n                if (opcode === this.OPCODES.pong) {\n                    callbacks = this._pingCallbacks;\n                    message = this._encode(payload);\n                    callback = callbacks[message];\n                    delete callbacks[message];\n                    if (callback) callback();\n                    this.emit(\"pong\", new Base.PongEvent(payload.toString()));\n                }\n            },\n            _emitMessage: function(message) {\n                var message = this._message;\n                message.read();\n                delete this._message;\n                this._extensions.processIncomingMessage(message, function(error, message) {\n                    if (error) return this._fail(\"extension_error\", error.message);\n                    var payload = message.data;\n                    if (message.opcode === this.OPCODES.text) payload = this._encode(payload);\n                    if (payload === null) return this._fail(\"encoding_error\", \"Could not decode a text frame as UTF-8\");\n                    else this.emit(\"message\", new Base.MessageEvent(payload));\n                }, this);\n            },\n            _encode: function(buffer) {\n                try {\n                    var string = buffer.toString(\"binary\", 0, buffer.length);\n                    if (!this.UTF8_MATCH.test(string)) return null;\n                } catch (e) {}\n                return buffer.toString(\"utf8\", 0, buffer.length);\n            },\n            _readUInt: function(buffer) {\n                if (buffer.length === 2) return buffer.readUInt16BE(0);\n                return buffer.readUInt32BE(0) * 0x100000000 + buffer.readUInt32BE(4);\n            }\n        };\n        for(var key in instance)Hybi.prototype[key] = instance[key];\n        module1.exports = Hybi;\n    /***/ },\n    /* 13 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var RingBuffer = function(bufferSize) {\n            this._bufferSize = bufferSize;\n            this.clear();\n        };\n        RingBuffer.prototype.clear = function() {\n            this._buffer = new Array(this._bufferSize);\n            this._ringOffset = 0;\n            this._ringSize = this._bufferSize;\n            this._head = 0;\n            this._tail = 0;\n            this.length = 0;\n        };\n        RingBuffer.prototype.push = function(value) {\n            var expandBuffer = false, expandRing = false;\n            if (this._ringSize < this._bufferSize) {\n                expandBuffer = this._tail === 0;\n            } else if (this._ringOffset === this._ringSize) {\n                expandBuffer = true;\n                expandRing = this._tail === 0;\n            }\n            if (expandBuffer) {\n                this._tail = this._bufferSize;\n                this._buffer = this._buffer.concat(new Array(this._bufferSize));\n                this._bufferSize = this._buffer.length;\n                if (expandRing) this._ringSize = this._bufferSize;\n            }\n            this._buffer[this._tail] = value;\n            this.length += 1;\n            if (this._tail < this._ringSize) this._ringOffset += 1;\n            this._tail = (this._tail + 1) % this._bufferSize;\n        };\n        RingBuffer.prototype.peek = function() {\n            if (this.length === 0) return void 0;\n            return this._buffer[this._head];\n        };\n        RingBuffer.prototype.shift = function() {\n            if (this.length === 0) return void 0;\n            var value = this._buffer[this._head];\n            this._buffer[this._head] = void 0;\n            this.length -= 1;\n            this._ringOffset -= 1;\n            if (this._ringOffset === 0 && this.length > 0) {\n                this._head = this._ringSize;\n                this._ringOffset = this.length;\n                this._ringSize = this._bufferSize;\n            } else {\n                this._head = (this._head + 1) % this._ringSize;\n            }\n            return value;\n        };\n        module1.exports = RingBuffer;\n    /***/ },\n    /* 14 */ /***/ function(module1, exports, __nested_webpack_require_61911__) {\n        \"use strict\";\n        var RingBuffer = __nested_webpack_require_61911__(13);\n        var Pledge = function() {\n            this._complete = false;\n            this._callbacks = new RingBuffer(Pledge.QUEUE_SIZE);\n        };\n        Pledge.QUEUE_SIZE = 4;\n        Pledge.all = function(list) {\n            var pledge = new Pledge(), pending = list.length, n = pending;\n            if (pending === 0) pledge.done();\n            while(n--)list[n].then(function() {\n                pending -= 1;\n                if (pending === 0) pledge.done();\n            });\n            return pledge;\n        };\n        Pledge.prototype.then = function(callback) {\n            if (this._complete) callback();\n            else this._callbacks.push(callback);\n        };\n        Pledge.prototype.done = function() {\n            this._complete = true;\n            var callbacks = this._callbacks, callback;\n            while(callback = callbacks.shift())callback();\n        };\n        module1.exports = Pledge;\n    /***/ },\n    /* 15 */ /***/ function(module1, exports, __nested_webpack_require_62979__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_62979__(1).Buffer, Base = __nested_webpack_require_62979__(2), util = __nested_webpack_require_62979__(0);\n        var Draft75 = function(request, url, options) {\n            Base.apply(this, arguments);\n            this._stage = 0;\n            this.version = \"hixie-75\";\n            this._headers.set(\"Upgrade\", \"WebSocket\");\n            this._headers.set(\"Connection\", \"Upgrade\");\n            this._headers.set(\"WebSocket-Origin\", this._request.headers.origin);\n            this._headers.set(\"WebSocket-Location\", this.url);\n        };\n        util.inherits(Draft75, Base);\n        var instance = {\n            close: function() {\n                if (this.readyState === 3) return false;\n                this.readyState = 3;\n                this.emit(\"close\", new Base.CloseEvent(null, null));\n                return true;\n            },\n            parse: function(chunk) {\n                if (this.readyState > 1) return;\n                this._reader.put(chunk);\n                this._reader.eachByte(function(octet) {\n                    var message;\n                    switch(this._stage){\n                        case -1:\n                            this._body.push(octet);\n                            this._sendHandshakeBody();\n                            break;\n                        case 0:\n                            this._parseLeadingByte(octet);\n                            break;\n                        case 1:\n                            this._length = (octet & 0x7F) + 128 * this._length;\n                            if (this._closing && this._length === 0) {\n                                return this.close();\n                            } else if ((octet & 0x80) !== 0x80) {\n                                if (this._length === 0) {\n                                    this._stage = 0;\n                                } else {\n                                    this._skipped = 0;\n                                    this._stage = 2;\n                                }\n                            }\n                            break;\n                        case 2:\n                            if (octet === 0xFF) {\n                                this._stage = 0;\n                                message = Buffer1.from(this._buffer).toString(\"utf8\", 0, this._buffer.length);\n                                this.emit(\"message\", new Base.MessageEvent(message));\n                            } else {\n                                if (this._length) {\n                                    this._skipped += 1;\n                                    if (this._skipped === this._length) this._stage = 0;\n                                } else {\n                                    this._buffer.push(octet);\n                                    if (this._buffer.length > this._maxLength) return this.close();\n                                }\n                            }\n                            break;\n                    }\n                }, this);\n            },\n            frame: function(buffer) {\n                if (this.readyState === 0) return this._queue([\n                    buffer\n                ]);\n                if (this.readyState > 1) return false;\n                if (typeof buffer !== \"string\") buffer = buffer.toString();\n                var length = Buffer1.byteLength(buffer), frame = Buffer1.allocUnsafe(length + 2);\n                frame[0] = 0x00;\n                frame.write(buffer, 1);\n                frame[frame.length - 1] = 0xFF;\n                this._write(frame);\n                return true;\n            },\n            _handshakeResponse: function() {\n                var start = \"HTTP/1.1 101 Web Socket Protocol Handshake\", headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                return Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\");\n            },\n            _parseLeadingByte: function(octet) {\n                if ((octet & 0x80) === 0x80) {\n                    this._length = 0;\n                    this._stage = 1;\n                } else {\n                    delete this._length;\n                    delete this._skipped;\n                    this._buffer = [];\n                    this._stage = 2;\n                }\n            }\n        };\n        for(var key in instance)Draft75.prototype[key] = instance[key];\n        module1.exports = Draft75;\n    /***/ },\n    /* 16 */ /***/ function(module1, exports, __nested_webpack_require_67489__) {\n        \"use strict\";\n        var Event = __nested_webpack_require_67489__(7);\n        var EventTarget = {\n            onopen: null,\n            onmessage: null,\n            onerror: null,\n            onclose: null,\n            addEventListener: function(eventType, listener, useCapture) {\n                this.on(eventType, listener);\n            },\n            removeEventListener: function(eventType, listener, useCapture) {\n                this.removeListener(eventType, listener);\n            },\n            dispatchEvent: function(event) {\n                event.target = event.currentTarget = this;\n                event.eventPhase = Event.AT_TARGET;\n                if (this[\"on\" + event.type]) this[\"on\" + event.type](event);\n                this.emit(event.type, event);\n            }\n        };\n        module1.exports = EventTarget;\n    /***/ },\n    /* 17 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        // Copyright (C) 2016 Dmitry Chestnykh\n        // MIT License. See LICENSE file for details.\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        /**\n * Package utf8 implements UTF-8 encoding and decoding.\n */ var INVALID_UTF16 = \"utf8: invalid string\";\n        var INVALID_UTF8 = \"utf8: invalid source encoding\";\n        /**\n * Encodes the given string into UTF-8 byte array.\n * Throws if the source string has invalid UTF-16 encoding.\n */ function encode(s) {\n            // Calculate result length and allocate output array.\n            // encodedLength() also validates string and throws errors,\n            // so we don't need repeat validation here.\n            var arr = new Uint8Array(encodedLength(s));\n            var pos = 0;\n            for(var i = 0; i < s.length; i++){\n                var c = s.charCodeAt(i);\n                if (c < 0x80) {\n                    arr[pos++] = c;\n                } else if (c < 0x800) {\n                    arr[pos++] = 0xc0 | c >> 6;\n                    arr[pos++] = 0x80 | c & 0x3f;\n                } else if (c < 0xd800) {\n                    arr[pos++] = 0xe0 | c >> 12;\n                    arr[pos++] = 0x80 | c >> 6 & 0x3f;\n                    arr[pos++] = 0x80 | c & 0x3f;\n                } else {\n                    i++; // get one more character\n                    c = (c & 0x3ff) << 10;\n                    c |= s.charCodeAt(i) & 0x3ff;\n                    c += 0x10000;\n                    arr[pos++] = 0xf0 | c >> 18;\n                    arr[pos++] = 0x80 | c >> 12 & 0x3f;\n                    arr[pos++] = 0x80 | c >> 6 & 0x3f;\n                    arr[pos++] = 0x80 | c & 0x3f;\n                }\n            }\n            return arr;\n        }\n        exports.encode = encode;\n        /**\n * Returns the number of bytes required to encode the given string into UTF-8.\n * Throws if the source string has invalid UTF-16 encoding.\n */ function encodedLength(s) {\n            var result = 0;\n            for(var i = 0; i < s.length; i++){\n                var c = s.charCodeAt(i);\n                if (c < 0x80) {\n                    result += 1;\n                } else if (c < 0x800) {\n                    result += 2;\n                } else if (c < 0xd800) {\n                    result += 3;\n                } else if (c <= 0xdfff) {\n                    if (i >= s.length - 1) {\n                        throw new Error(INVALID_UTF16);\n                    }\n                    i++; // \"eat\" next character\n                    result += 4;\n                } else {\n                    throw new Error(INVALID_UTF16);\n                }\n            }\n            return result;\n        }\n        exports.encodedLength = encodedLength;\n        /**\n * Decodes the given byte array from UTF-8 into a string.\n * Throws if encoding is invalid.\n */ function decode(arr) {\n            var chars = [];\n            for(var i = 0; i < arr.length; i++){\n                var b = arr[i];\n                if (b & 0x80) {\n                    var min = void 0;\n                    if (b < 0xe0) {\n                        // Need 1 more byte.\n                        if (i >= arr.length) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        var n1 = arr[++i];\n                        if ((n1 & 0xc0) !== 0x80) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        b = (b & 0x1f) << 6 | n1 & 0x3f;\n                        min = 0x80;\n                    } else if (b < 0xf0) {\n                        // Need 2 more bytes.\n                        if (i >= arr.length - 1) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        var n1 = arr[++i];\n                        var n2 = arr[++i];\n                        if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | n2 & 0x3f;\n                        min = 0x800;\n                    } else if (b < 0xf8) {\n                        // Need 3 more bytes.\n                        if (i >= arr.length - 2) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        var n1 = arr[++i];\n                        var n2 = arr[++i];\n                        var n3 = arr[++i];\n                        if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | n3 & 0x3f;\n                        min = 0x10000;\n                    } else {\n                        throw new Error(INVALID_UTF8);\n                    }\n                    if (b < min || b >= 0xd800 && b <= 0xdfff) {\n                        throw new Error(INVALID_UTF8);\n                    }\n                    if (b >= 0x10000) {\n                        // Surrogate pair.\n                        if (b > 0x10ffff) {\n                            throw new Error(INVALID_UTF8);\n                        }\n                        b -= 0x10000;\n                        chars.push(String.fromCharCode(0xd800 | b >> 10));\n                        b = 0xdc00 | b & 0x3ff;\n                    }\n                }\n                chars.push(String.fromCharCode(b));\n            }\n            return chars.join(\"\");\n        }\n        exports.decode = decode;\n    /***/ },\n    /* 18 */ /***/ function(module1, exports, __nested_webpack_require_74111__) {\n        \"use strict\";\n        // API references:\n        //\n        // * https://html.spec.whatwg.org/multipage/comms.html#network\n        // * https://dom.spec.whatwg.org/#interface-eventtarget\n        // * https://dom.spec.whatwg.org/#interface-event\n        var util = __nested_webpack_require_74111__(0), driver = __nested_webpack_require_74111__(4), API = __nested_webpack_require_74111__(11);\n        var WebSocket = function(request, socket, body, protocols, options) {\n            options = options || {};\n            this._stream = socket;\n            this._driver = driver.http(request, {\n                maxLength: options.maxLength,\n                protocols: protocols\n            });\n            var self1 = this;\n            if (!this._stream || !this._stream.writable) return;\n            if (!this._stream.readable) return this._stream.end();\n            var catchup = function() {\n                self1._stream.removeListener(\"data\", catchup);\n            };\n            this._stream.on(\"data\", catchup);\n            API.call(this, options);\n            process.nextTick(function() {\n                self1._driver.start();\n                self1._driver.io.write(body);\n            });\n        };\n        util.inherits(WebSocket, API);\n        WebSocket.isWebSocket = function(request) {\n            return driver.isWebSocket(request);\n        };\n        WebSocket.validateOptions = function(options, validKeys) {\n            driver.validateOptions(options, validKeys);\n        };\n        WebSocket.WebSocket = WebSocket;\n        WebSocket.Client = __nested_webpack_require_74111__(39);\n        WebSocket.EventSource = __nested_webpack_require_74111__(42);\n        module1.exports = WebSocket;\n    /***/ },\n    /* 19 */ /***/ function(module1, exports, __nested_webpack_require_75839__) {\n        /**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */ var Url = __nested_webpack_require_75839__(6);\n        var spawn = __nested_webpack_require_75839__(43).spawn;\n        var fs = __nested_webpack_require_75839__(44);\n        exports.XMLHttpRequest = function() {\n            \"use strict\";\n            /**\n   * Private variables\n   */ var self1 = this;\n            var http = __nested_webpack_require_75839__(45);\n            var https = __nested_webpack_require_75839__(46);\n            // Holds http.js objects\n            var request;\n            var response;\n            // Request settings\n            var settings = {};\n            // Disable header blacklist.\n            // Not part of XHR specs.\n            var disableHeaderCheck = false;\n            // Set some default headers\n            var defaultHeaders = {\n                \"User-Agent\": \"node-XMLHttpRequest\",\n                \"Accept\": \"*/*\"\n            };\n            var headers = {};\n            var headersCase = {};\n            // These headers are not user setable.\n            // The following are allowed but banned in the spec:\n            // * user-agent\n            var forbiddenRequestHeaders = [\n                \"accept-charset\",\n                \"accept-encoding\",\n                \"access-control-request-headers\",\n                \"access-control-request-method\",\n                \"connection\",\n                \"content-length\",\n                \"content-transfer-encoding\",\n                \"cookie\",\n                \"cookie2\",\n                \"date\",\n                \"expect\",\n                \"host\",\n                \"keep-alive\",\n                \"origin\",\n                \"referer\",\n                \"te\",\n                \"trailer\",\n                \"transfer-encoding\",\n                \"upgrade\",\n                \"via\"\n            ];\n            // These request methods are not allowed\n            var forbiddenRequestMethods = [\n                \"TRACE\",\n                \"TRACK\",\n                \"CONNECT\"\n            ];\n            // Send flag\n            var sendFlag = false;\n            // Error flag, used when errors occur or abort is called\n            var errorFlag = false;\n            // Event listeners\n            var listeners = {};\n            /**\n   * Constants\n   */ this.UNSENT = 0;\n            this.OPENED = 1;\n            this.HEADERS_RECEIVED = 2;\n            this.LOADING = 3;\n            this.DONE = 4;\n            /**\n   * Public vars\n   */ // Current state\n            this.readyState = this.UNSENT;\n            // default ready state change handler in case one is not set or is set late\n            this.onreadystatechange = null;\n            // Result & response\n            this.responseText = \"\";\n            this.responseXML = \"\";\n            this.status = null;\n            this.statusText = null;\n            // Whether cross-site Access-Control requests should be made using\n            // credentials such as cookies or authorization headers\n            this.withCredentials = false;\n            /**\n   * Private methods\n   */ /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */ var isAllowedHttpHeader = function(header) {\n                return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;\n            };\n            /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */ var isAllowedHttpMethod = function(method) {\n                return method && forbiddenRequestMethods.indexOf(method) === -1;\n            };\n            /**\n   * Public methods\n   */ /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */ this.open = function(method, url, async, user, password) {\n                this.abort();\n                errorFlag = false;\n                // Check for valid request method\n                if (!isAllowedHttpMethod(method)) {\n                    throw new Error(\"SecurityError: Request method not allowed\");\n                }\n                settings = {\n                    \"method\": method,\n                    \"url\": url.toString(),\n                    \"async\": typeof async !== \"boolean\" ? true : async,\n                    \"user\": user || null,\n                    \"password\": password || null\n                };\n                setState(this.OPENED);\n            };\n            /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */ this.setDisableHeaderCheck = function(state) {\n                disableHeaderCheck = state;\n            };\n            /**\n   * Sets a header for the request or appends the value if one is already set.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   */ this.setRequestHeader = function(header, value) {\n                if (this.readyState !== this.OPENED) {\n                    throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n                }\n                if (!isAllowedHttpHeader(header)) {\n                    console.warn('Refused to set unsafe header \"' + header + '\"');\n                    return;\n                }\n                if (sendFlag) {\n                    throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n                }\n                header = headersCase[header.toLowerCase()] || header;\n                headersCase[header.toLowerCase()] = header;\n                headers[header] = headers[header] ? headers[header] + \", \" + value : value;\n            };\n            /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */ this.getResponseHeader = function(header) {\n                if (typeof header === \"string\" && this.readyState > this.OPENED && response && response.headers && response.headers[header.toLowerCase()] && !errorFlag) {\n                    return response.headers[header.toLowerCase()];\n                }\n                return null;\n            };\n            /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */ this.getAllResponseHeaders = function() {\n                if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n                    return \"\";\n                }\n                var result = \"\";\n                for(var i in response.headers){\n                    // Cookie headers are excluded\n                    if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n                        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n                    }\n                }\n                return result.substr(0, result.length - 2);\n            };\n            /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */ this.getRequestHeader = function(name) {\n                if (typeof name === \"string\" && headersCase[name.toLowerCase()]) {\n                    return headers[headersCase[name.toLowerCase()]];\n                }\n                return \"\";\n            };\n            /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */ this.send = function(data) {\n                if (this.readyState !== this.OPENED) {\n                    throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n                }\n                if (sendFlag) {\n                    throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n                }\n                var ssl = false, local = false;\n                var url = Url.parse(settings.url);\n                var host;\n                // Determine the server\n                switch(url.protocol){\n                    case \"https:\":\n                        ssl = true;\n                    // SSL & non-SSL both need host, no break here.\n                    case \"http:\":\n                        host = url.hostname;\n                        break;\n                    case \"file:\":\n                        local = true;\n                        break;\n                    case undefined:\n                    case null:\n                    case \"\":\n                        host = \"localhost\";\n                        break;\n                    default:\n                        throw new Error(\"Protocol not supported.\");\n                }\n                // Load files off the local filesystem (file://)\n                if (local) {\n                    if (settings.method !== \"GET\") {\n                        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n                    }\n                    if (settings.async) {\n                        fs.readFile(url.pathname, \"utf8\", function(error, data) {\n                            if (error) {\n                                self1.handleError(error);\n                            } else {\n                                self1.status = 200;\n                                self1.responseText = data;\n                                setState(self1.DONE);\n                            }\n                        });\n                    } else {\n                        try {\n                            this.responseText = fs.readFileSync(url.pathname, \"utf8\");\n                            this.status = 200;\n                            setState(self1.DONE);\n                        } catch (e) {\n                            this.handleError(e);\n                        }\n                    }\n                    return;\n                }\n                // Default to port 80. If accessing localhost on another port be sure\n                // to use http://localhost:port/path\n                var port = url.port || (ssl ? 443 : 80);\n                // Add query string if one is used\n                var uri = url.pathname + (url.search ? url.search : \"\");\n                // Set the defaults if they haven't been set\n                for(var name in defaultHeaders){\n                    if (!headersCase[name.toLowerCase()]) {\n                        headers[name] = defaultHeaders[name];\n                    }\n                }\n                // Set the Host header or the server may reject the request\n                headers.Host = host;\n                if (!(ssl && port === 443 || port === 80)) {\n                    headers.Host += \":\" + url.port;\n                }\n                // Set Basic Auth if necessary\n                if (settings.user) {\n                    if (typeof settings.password === \"undefined\") {\n                        settings.password = \"\";\n                    }\n                    var authBuf = new Buffer(settings.user + \":\" + settings.password);\n                    headers.Authorization = \"Basic \" + authBuf.toString(\"base64\");\n                }\n                // Set content length header\n                if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n                    data = null;\n                } else if (data) {\n                    headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n                    if (!headers[\"Content-Type\"]) {\n                        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n                    }\n                } else if (settings.method === \"POST\") {\n                    // For a post with no data set Content-Length: 0.\n                    // This is required by buggy servers that don't meet the specs.\n                    headers[\"Content-Length\"] = 0;\n                }\n                var options = {\n                    host: host,\n                    port: port,\n                    path: uri,\n                    method: settings.method,\n                    headers: headers,\n                    agent: false,\n                    withCredentials: self1.withCredentials\n                };\n                // Reset error flag\n                errorFlag = false;\n                // Handle async requests\n                if (settings.async) {\n                    // Use the proper protocol\n                    var doRequest = ssl ? https.request : http.request;\n                    // Request is being sent, set send flag\n                    sendFlag = true;\n                    // As per spec, this is called here for historical reasons.\n                    self1.dispatchEvent(\"readystatechange\");\n                    // Handler for the response\n                    var responseHandler = function responseHandler(resp) {\n                        // Set response var to the response we got back\n                        // This is so it remains accessable outside this scope\n                        response = resp;\n                        // Check for redirect\n                        // @TODO Prevent looped redirects\n                        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n                            // Change URL to the redirect location\n                            settings.url = response.headers.location;\n                            var url = Url.parse(settings.url);\n                            // Set host var in case it's used later\n                            host = url.hostname;\n                            // Options for the new request\n                            var newOptions = {\n                                hostname: url.hostname,\n                                port: url.port,\n                                path: url.path,\n                                method: response.statusCode === 303 ? \"GET\" : settings.method,\n                                headers: headers,\n                                withCredentials: self1.withCredentials\n                            };\n                            // Issue the new request\n                            request = doRequest(newOptions, responseHandler).on(\"error\", errorHandler);\n                            request.end();\n                            // @TODO Check if an XHR event needs to be fired here\n                            return;\n                        }\n                        response.setEncoding(\"utf8\");\n                        setState(self1.HEADERS_RECEIVED);\n                        self1.status = response.statusCode;\n                        response.on(\"data\", function(chunk) {\n                            // Make sure there's some data\n                            if (chunk) {\n                                self1.responseText += chunk;\n                            }\n                            // Don't emit state changes if the connection has been aborted.\n                            if (sendFlag) {\n                                setState(self1.LOADING);\n                            }\n                        });\n                        response.on(\"end\", function() {\n                            if (sendFlag) {\n                                // Discard the end event if the connection has been aborted\n                                setState(self1.DONE);\n                                sendFlag = false;\n                            }\n                        });\n                        response.on(\"error\", function(error) {\n                            self1.handleError(error);\n                        });\n                    };\n                    // Error handler for the request\n                    var errorHandler = function errorHandler(error) {\n                        self1.handleError(error);\n                    };\n                    // Create the request\n                    request = doRequest(options, responseHandler).on(\"error\", errorHandler);\n                    // Node 0.4 and later won't accept empty data. Make sure it's needed.\n                    if (data) {\n                        request.write(data);\n                    }\n                    request.end();\n                    self1.dispatchEvent(\"loadstart\");\n                } else {\n                    // Create a temporary file for communication with the other Node process\n                    var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n                    var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n                    fs.writeFileSync(syncFile, \"\", \"utf8\");\n                    // The async request the other Node process executes\n                    var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\" + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\" + \"var options = \" + JSON.stringify(options) + \";\" + \"var responseText = '';\" + \"var req = doRequest(options, function(response) {\" + \"response.setEncoding('utf8');\" + \"response.on('data', function(chunk) {\" + \"  responseText += chunk;\" + \"});\" + \"response.on('end', function() {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"response.on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"}).on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + (data ? \"req.write('\" + JSON.stringify(data).slice(1, -1).replace(/'/g, \"\\\\'\") + \"');\" : \"\") + \"req.end();\";\n                    // Start the other Node Process, executing this string\n                    var syncProc = spawn(process.argv[0], [\n                        \"-e\",\n                        execString\n                    ]);\n                    while(fs.existsSync(syncFile)){\n                    // Wait while the sync file is empty\n                    }\n                    var resp = JSON.parse(fs.readFileSync(contentFile, \"utf8\"));\n                    // Kill the child process once the file has data\n                    syncProc.stdin.end();\n                    // Remove the temporary file\n                    fs.unlinkSync(contentFile);\n                    if (resp.err) {\n                        self1.handleError(resp.err);\n                    } else {\n                        response = resp.data;\n                        self1.status = resp.data.statusCode;\n                        self1.responseText = resp.data.text;\n                        setState(self1.DONE);\n                    }\n                }\n            };\n            /**\n   * Called when an error is encountered to deal with it.\n   */ this.handleError = function(error) {\n                this.status = 0;\n                this.statusText = error;\n                this.responseText = error.stack;\n                errorFlag = true;\n                setState(this.DONE);\n                this.dispatchEvent(\"error\");\n            };\n            /**\n   * Aborts a request.\n   */ this.abort = function() {\n                if (request) {\n                    request.abort();\n                    request = null;\n                }\n                headers = defaultHeaders;\n                this.status = 0;\n                this.responseText = \"\";\n                this.responseXML = \"\";\n                errorFlag = true;\n                if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {\n                    sendFlag = false;\n                    setState(this.DONE);\n                }\n                this.readyState = this.UNSENT;\n                this.dispatchEvent(\"abort\");\n            };\n            /**\n   * Adds an event listener. Preferred method of binding to events.\n   */ this.addEventListener = function(event, callback) {\n                if (!(event in listeners)) {\n                    listeners[event] = [];\n                }\n                // Currently allows duplicate callbacks. Should it?\n                listeners[event].push(callback);\n            };\n            /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */ this.removeEventListener = function(event, callback) {\n                if (event in listeners) {\n                    // Filter will return a new array with the callback removed\n                    listeners[event] = listeners[event].filter(function(ev) {\n                        return ev !== callback;\n                    });\n                }\n            };\n            /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */ this.dispatchEvent = function(event) {\n                if (typeof self1[\"on\" + event] === \"function\") {\n                    self1[\"on\" + event]();\n                }\n                if (event in listeners) {\n                    for(var i = 0, len = listeners[event].length; i < len; i++){\n                        listeners[event][i].call(self1);\n                    }\n                }\n            };\n            /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */ var setState = function(state) {\n                if (state == self1.LOADING || self1.readyState !== state) {\n                    self1.readyState = state;\n                    if (settings.async || self1.readyState < self1.OPENED || self1.readyState === self1.DONE) {\n                        self1.dispatchEvent(\"readystatechange\");\n                    }\n                    if (self1.readyState === self1.DONE && !errorFlag) {\n                        self1.dispatchEvent(\"load\");\n                        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n                        self1.dispatchEvent(\"loadend\");\n                    }\n                }\n            };\n        };\n    /***/ },\n    /* 20 */ /***/ function(module1, exports, __nested_webpack_require_98680__) {\n        (function(nacl) {\n            \"use strict\";\n            // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n            // Public domain.\n            //\n            // Implementation derived from TweetNaCl version 20140427.\n            // See for details: http://tweetnacl.cr.yp.to/\n            var gf = function(init) {\n                var i, r = new Float64Array(16);\n                if (init) for(i = 0; i < init.length; i++)r[i] = init[i];\n                return r;\n            };\n            //  Pluggable, initialized in high-level API below.\n            var randombytes = function() {\n                throw new Error(\"no PRNG\");\n            };\n            var _0 = new Uint8Array(16);\n            var _9 = new Uint8Array(32);\n            _9[0] = 9;\n            var gf0 = gf(), gf1 = gf([\n                1\n            ]), _121665 = gf([\n                0xdb41,\n                1\n            ]), D = gf([\n                0x78a3,\n                0x1359,\n                0x4dca,\n                0x75eb,\n                0xd8ab,\n                0x4141,\n                0x0a4d,\n                0x0070,\n                0xe898,\n                0x7779,\n                0x4079,\n                0x8cc7,\n                0xfe73,\n                0x2b6f,\n                0x6cee,\n                0x5203\n            ]), D2 = gf([\n                0xf159,\n                0x26b2,\n                0x9b94,\n                0xebd6,\n                0xb156,\n                0x8283,\n                0x149a,\n                0x00e0,\n                0xd130,\n                0xeef3,\n                0x80f2,\n                0x198e,\n                0xfce7,\n                0x56df,\n                0xd9dc,\n                0x2406\n            ]), X = gf([\n                0xd51a,\n                0x8f25,\n                0x2d60,\n                0xc956,\n                0xa7b2,\n                0x9525,\n                0xc760,\n                0x692c,\n                0xdc5c,\n                0xfdd6,\n                0xe231,\n                0xc0a4,\n                0x53fe,\n                0xcd6e,\n                0x36d3,\n                0x2169\n            ]), Y = gf([\n                0x6658,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666,\n                0x6666\n            ]), I = gf([\n                0xa0b0,\n                0x4a0e,\n                0x1b27,\n                0xc4ee,\n                0xe478,\n                0xad2f,\n                0x1806,\n                0x2f43,\n                0xd7a7,\n                0x3dfb,\n                0x0099,\n                0x2b4d,\n                0xdf0b,\n                0x4fc1,\n                0x2480,\n                0x2b83\n            ]);\n            function ts64(x, i, h, l) {\n                x[i] = h >> 24 & 0xff;\n                x[i + 1] = h >> 16 & 0xff;\n                x[i + 2] = h >> 8 & 0xff;\n                x[i + 3] = h & 0xff;\n                x[i + 4] = l >> 24 & 0xff;\n                x[i + 5] = l >> 16 & 0xff;\n                x[i + 6] = l >> 8 & 0xff;\n                x[i + 7] = l & 0xff;\n            }\n            function vn(x, xi, y, yi, n) {\n                var i, d = 0;\n                for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];\n                return (1 & d - 1 >>> 8) - 1;\n            }\n            function crypto_verify_16(x, xi, y, yi) {\n                return vn(x, xi, y, yi, 16);\n            }\n            function crypto_verify_32(x, xi, y, yi) {\n                return vn(x, xi, y, yi, 32);\n            }\n            function core_salsa20(o, p, k, c) {\n                var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;\n                var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;\n                for(var i = 0; i < 20; i += 2){\n                    u = x0 + x12 | 0;\n                    x4 ^= u << 7 | u >>> 32 - 7;\n                    u = x4 + x0 | 0;\n                    x8 ^= u << 9 | u >>> 32 - 9;\n                    u = x8 + x4 | 0;\n                    x12 ^= u << 13 | u >>> 32 - 13;\n                    u = x12 + x8 | 0;\n                    x0 ^= u << 18 | u >>> 32 - 18;\n                    u = x5 + x1 | 0;\n                    x9 ^= u << 7 | u >>> 32 - 7;\n                    u = x9 + x5 | 0;\n                    x13 ^= u << 9 | u >>> 32 - 9;\n                    u = x13 + x9 | 0;\n                    x1 ^= u << 13 | u >>> 32 - 13;\n                    u = x1 + x13 | 0;\n                    x5 ^= u << 18 | u >>> 32 - 18;\n                    u = x10 + x6 | 0;\n                    x14 ^= u << 7 | u >>> 32 - 7;\n                    u = x14 + x10 | 0;\n                    x2 ^= u << 9 | u >>> 32 - 9;\n                    u = x2 + x14 | 0;\n                    x6 ^= u << 13 | u >>> 32 - 13;\n                    u = x6 + x2 | 0;\n                    x10 ^= u << 18 | u >>> 32 - 18;\n                    u = x15 + x11 | 0;\n                    x3 ^= u << 7 | u >>> 32 - 7;\n                    u = x3 + x15 | 0;\n                    x7 ^= u << 9 | u >>> 32 - 9;\n                    u = x7 + x3 | 0;\n                    x11 ^= u << 13 | u >>> 32 - 13;\n                    u = x11 + x7 | 0;\n                    x15 ^= u << 18 | u >>> 32 - 18;\n                    u = x0 + x3 | 0;\n                    x1 ^= u << 7 | u >>> 32 - 7;\n                    u = x1 + x0 | 0;\n                    x2 ^= u << 9 | u >>> 32 - 9;\n                    u = x2 + x1 | 0;\n                    x3 ^= u << 13 | u >>> 32 - 13;\n                    u = x3 + x2 | 0;\n                    x0 ^= u << 18 | u >>> 32 - 18;\n                    u = x5 + x4 | 0;\n                    x6 ^= u << 7 | u >>> 32 - 7;\n                    u = x6 + x5 | 0;\n                    x7 ^= u << 9 | u >>> 32 - 9;\n                    u = x7 + x6 | 0;\n                    x4 ^= u << 13 | u >>> 32 - 13;\n                    u = x4 + x7 | 0;\n                    x5 ^= u << 18 | u >>> 32 - 18;\n                    u = x10 + x9 | 0;\n                    x11 ^= u << 7 | u >>> 32 - 7;\n                    u = x11 + x10 | 0;\n                    x8 ^= u << 9 | u >>> 32 - 9;\n                    u = x8 + x11 | 0;\n                    x9 ^= u << 13 | u >>> 32 - 13;\n                    u = x9 + x8 | 0;\n                    x10 ^= u << 18 | u >>> 32 - 18;\n                    u = x15 + x14 | 0;\n                    x12 ^= u << 7 | u >>> 32 - 7;\n                    u = x12 + x15 | 0;\n                    x13 ^= u << 9 | u >>> 32 - 9;\n                    u = x13 + x12 | 0;\n                    x14 ^= u << 13 | u >>> 32 - 13;\n                    u = x14 + x13 | 0;\n                    x15 ^= u << 18 | u >>> 32 - 18;\n                }\n                x0 = x0 + j0 | 0;\n                x1 = x1 + j1 | 0;\n                x2 = x2 + j2 | 0;\n                x3 = x3 + j3 | 0;\n                x4 = x4 + j4 | 0;\n                x5 = x5 + j5 | 0;\n                x6 = x6 + j6 | 0;\n                x7 = x7 + j7 | 0;\n                x8 = x8 + j8 | 0;\n                x9 = x9 + j9 | 0;\n                x10 = x10 + j10 | 0;\n                x11 = x11 + j11 | 0;\n                x12 = x12 + j12 | 0;\n                x13 = x13 + j13 | 0;\n                x14 = x14 + j14 | 0;\n                x15 = x15 + j15 | 0;\n                o[0] = x0 >>> 0 & 0xff;\n                o[1] = x0 >>> 8 & 0xff;\n                o[2] = x0 >>> 16 & 0xff;\n                o[3] = x0 >>> 24 & 0xff;\n                o[4] = x1 >>> 0 & 0xff;\n                o[5] = x1 >>> 8 & 0xff;\n                o[6] = x1 >>> 16 & 0xff;\n                o[7] = x1 >>> 24 & 0xff;\n                o[8] = x2 >>> 0 & 0xff;\n                o[9] = x2 >>> 8 & 0xff;\n                o[10] = x2 >>> 16 & 0xff;\n                o[11] = x2 >>> 24 & 0xff;\n                o[12] = x3 >>> 0 & 0xff;\n                o[13] = x3 >>> 8 & 0xff;\n                o[14] = x3 >>> 16 & 0xff;\n                o[15] = x3 >>> 24 & 0xff;\n                o[16] = x4 >>> 0 & 0xff;\n                o[17] = x4 >>> 8 & 0xff;\n                o[18] = x4 >>> 16 & 0xff;\n                o[19] = x4 >>> 24 & 0xff;\n                o[20] = x5 >>> 0 & 0xff;\n                o[21] = x5 >>> 8 & 0xff;\n                o[22] = x5 >>> 16 & 0xff;\n                o[23] = x5 >>> 24 & 0xff;\n                o[24] = x6 >>> 0 & 0xff;\n                o[25] = x6 >>> 8 & 0xff;\n                o[26] = x6 >>> 16 & 0xff;\n                o[27] = x6 >>> 24 & 0xff;\n                o[28] = x7 >>> 0 & 0xff;\n                o[29] = x7 >>> 8 & 0xff;\n                o[30] = x7 >>> 16 & 0xff;\n                o[31] = x7 >>> 24 & 0xff;\n                o[32] = x8 >>> 0 & 0xff;\n                o[33] = x8 >>> 8 & 0xff;\n                o[34] = x8 >>> 16 & 0xff;\n                o[35] = x8 >>> 24 & 0xff;\n                o[36] = x9 >>> 0 & 0xff;\n                o[37] = x9 >>> 8 & 0xff;\n                o[38] = x9 >>> 16 & 0xff;\n                o[39] = x9 >>> 24 & 0xff;\n                o[40] = x10 >>> 0 & 0xff;\n                o[41] = x10 >>> 8 & 0xff;\n                o[42] = x10 >>> 16 & 0xff;\n                o[43] = x10 >>> 24 & 0xff;\n                o[44] = x11 >>> 0 & 0xff;\n                o[45] = x11 >>> 8 & 0xff;\n                o[46] = x11 >>> 16 & 0xff;\n                o[47] = x11 >>> 24 & 0xff;\n                o[48] = x12 >>> 0 & 0xff;\n                o[49] = x12 >>> 8 & 0xff;\n                o[50] = x12 >>> 16 & 0xff;\n                o[51] = x12 >>> 24 & 0xff;\n                o[52] = x13 >>> 0 & 0xff;\n                o[53] = x13 >>> 8 & 0xff;\n                o[54] = x13 >>> 16 & 0xff;\n                o[55] = x13 >>> 24 & 0xff;\n                o[56] = x14 >>> 0 & 0xff;\n                o[57] = x14 >>> 8 & 0xff;\n                o[58] = x14 >>> 16 & 0xff;\n                o[59] = x14 >>> 24 & 0xff;\n                o[60] = x15 >>> 0 & 0xff;\n                o[61] = x15 >>> 8 & 0xff;\n                o[62] = x15 >>> 16 & 0xff;\n                o[63] = x15 >>> 24 & 0xff;\n            }\n            function core_hsalsa20(o, p, k, c) {\n                var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;\n                var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;\n                for(var i = 0; i < 20; i += 2){\n                    u = x0 + x12 | 0;\n                    x4 ^= u << 7 | u >>> 32 - 7;\n                    u = x4 + x0 | 0;\n                    x8 ^= u << 9 | u >>> 32 - 9;\n                    u = x8 + x4 | 0;\n                    x12 ^= u << 13 | u >>> 32 - 13;\n                    u = x12 + x8 | 0;\n                    x0 ^= u << 18 | u >>> 32 - 18;\n                    u = x5 + x1 | 0;\n                    x9 ^= u << 7 | u >>> 32 - 7;\n                    u = x9 + x5 | 0;\n                    x13 ^= u << 9 | u >>> 32 - 9;\n                    u = x13 + x9 | 0;\n                    x1 ^= u << 13 | u >>> 32 - 13;\n                    u = x1 + x13 | 0;\n                    x5 ^= u << 18 | u >>> 32 - 18;\n                    u = x10 + x6 | 0;\n                    x14 ^= u << 7 | u >>> 32 - 7;\n                    u = x14 + x10 | 0;\n                    x2 ^= u << 9 | u >>> 32 - 9;\n                    u = x2 + x14 | 0;\n                    x6 ^= u << 13 | u >>> 32 - 13;\n                    u = x6 + x2 | 0;\n                    x10 ^= u << 18 | u >>> 32 - 18;\n                    u = x15 + x11 | 0;\n                    x3 ^= u << 7 | u >>> 32 - 7;\n                    u = x3 + x15 | 0;\n                    x7 ^= u << 9 | u >>> 32 - 9;\n                    u = x7 + x3 | 0;\n                    x11 ^= u << 13 | u >>> 32 - 13;\n                    u = x11 + x7 | 0;\n                    x15 ^= u << 18 | u >>> 32 - 18;\n                    u = x0 + x3 | 0;\n                    x1 ^= u << 7 | u >>> 32 - 7;\n                    u = x1 + x0 | 0;\n                    x2 ^= u << 9 | u >>> 32 - 9;\n                    u = x2 + x1 | 0;\n                    x3 ^= u << 13 | u >>> 32 - 13;\n                    u = x3 + x2 | 0;\n                    x0 ^= u << 18 | u >>> 32 - 18;\n                    u = x5 + x4 | 0;\n                    x6 ^= u << 7 | u >>> 32 - 7;\n                    u = x6 + x5 | 0;\n                    x7 ^= u << 9 | u >>> 32 - 9;\n                    u = x7 + x6 | 0;\n                    x4 ^= u << 13 | u >>> 32 - 13;\n                    u = x4 + x7 | 0;\n                    x5 ^= u << 18 | u >>> 32 - 18;\n                    u = x10 + x9 | 0;\n                    x11 ^= u << 7 | u >>> 32 - 7;\n                    u = x11 + x10 | 0;\n                    x8 ^= u << 9 | u >>> 32 - 9;\n                    u = x8 + x11 | 0;\n                    x9 ^= u << 13 | u >>> 32 - 13;\n                    u = x9 + x8 | 0;\n                    x10 ^= u << 18 | u >>> 32 - 18;\n                    u = x15 + x14 | 0;\n                    x12 ^= u << 7 | u >>> 32 - 7;\n                    u = x12 + x15 | 0;\n                    x13 ^= u << 9 | u >>> 32 - 9;\n                    u = x13 + x12 | 0;\n                    x14 ^= u << 13 | u >>> 32 - 13;\n                    u = x14 + x13 | 0;\n                    x15 ^= u << 18 | u >>> 32 - 18;\n                }\n                o[0] = x0 >>> 0 & 0xff;\n                o[1] = x0 >>> 8 & 0xff;\n                o[2] = x0 >>> 16 & 0xff;\n                o[3] = x0 >>> 24 & 0xff;\n                o[4] = x5 >>> 0 & 0xff;\n                o[5] = x5 >>> 8 & 0xff;\n                o[6] = x5 >>> 16 & 0xff;\n                o[7] = x5 >>> 24 & 0xff;\n                o[8] = x10 >>> 0 & 0xff;\n                o[9] = x10 >>> 8 & 0xff;\n                o[10] = x10 >>> 16 & 0xff;\n                o[11] = x10 >>> 24 & 0xff;\n                o[12] = x15 >>> 0 & 0xff;\n                o[13] = x15 >>> 8 & 0xff;\n                o[14] = x15 >>> 16 & 0xff;\n                o[15] = x15 >>> 24 & 0xff;\n                o[16] = x6 >>> 0 & 0xff;\n                o[17] = x6 >>> 8 & 0xff;\n                o[18] = x6 >>> 16 & 0xff;\n                o[19] = x6 >>> 24 & 0xff;\n                o[20] = x7 >>> 0 & 0xff;\n                o[21] = x7 >>> 8 & 0xff;\n                o[22] = x7 >>> 16 & 0xff;\n                o[23] = x7 >>> 24 & 0xff;\n                o[24] = x8 >>> 0 & 0xff;\n                o[25] = x8 >>> 8 & 0xff;\n                o[26] = x8 >>> 16 & 0xff;\n                o[27] = x8 >>> 24 & 0xff;\n                o[28] = x9 >>> 0 & 0xff;\n                o[29] = x9 >>> 8 & 0xff;\n                o[30] = x9 >>> 16 & 0xff;\n                o[31] = x9 >>> 24 & 0xff;\n            }\n            function crypto_core_salsa20(out, inp, k, c) {\n                core_salsa20(out, inp, k, c);\n            }\n            function crypto_core_hsalsa20(out, inp, k, c) {\n                core_hsalsa20(out, inp, k, c);\n            }\n            var sigma = new Uint8Array([\n                101,\n                120,\n                112,\n                97,\n                110,\n                100,\n                32,\n                51,\n                50,\n                45,\n                98,\n                121,\n                116,\n                101,\n                32,\n                107\n            ]);\n            // \"expand 32-byte k\"\n            function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n                var z = new Uint8Array(16), x = new Uint8Array(64);\n                var u, i;\n                for(i = 0; i < 16; i++)z[i] = 0;\n                for(i = 0; i < 8; i++)z[i] = n[i];\n                while(b >= 64){\n                    crypto_core_salsa20(x, z, k, sigma);\n                    for(i = 0; i < 64; i++)c[cpos + i] = m[mpos + i] ^ x[i];\n                    u = 1;\n                    for(i = 8; i < 16; i++){\n                        u = u + (z[i] & 0xff) | 0;\n                        z[i] = u & 0xff;\n                        u >>>= 8;\n                    }\n                    b -= 64;\n                    cpos += 64;\n                    mpos += 64;\n                }\n                if (b > 0) {\n                    crypto_core_salsa20(x, z, k, sigma);\n                    for(i = 0; i < b; i++)c[cpos + i] = m[mpos + i] ^ x[i];\n                }\n                return 0;\n            }\n            function crypto_stream_salsa20(c, cpos, b, n, k) {\n                var z = new Uint8Array(16), x = new Uint8Array(64);\n                var u, i;\n                for(i = 0; i < 16; i++)z[i] = 0;\n                for(i = 0; i < 8; i++)z[i] = n[i];\n                while(b >= 64){\n                    crypto_core_salsa20(x, z, k, sigma);\n                    for(i = 0; i < 64; i++)c[cpos + i] = x[i];\n                    u = 1;\n                    for(i = 8; i < 16; i++){\n                        u = u + (z[i] & 0xff) | 0;\n                        z[i] = u & 0xff;\n                        u >>>= 8;\n                    }\n                    b -= 64;\n                    cpos += 64;\n                }\n                if (b > 0) {\n                    crypto_core_salsa20(x, z, k, sigma);\n                    for(i = 0; i < b; i++)c[cpos + i] = x[i];\n                }\n                return 0;\n            }\n            function crypto_stream(c, cpos, d, n, k) {\n                var s = new Uint8Array(32);\n                crypto_core_hsalsa20(s, n, k, sigma);\n                var sn = new Uint8Array(8);\n                for(var i = 0; i < 8; i++)sn[i] = n[i + 16];\n                return crypto_stream_salsa20(c, cpos, d, sn, s);\n            }\n            function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n                var s = new Uint8Array(32);\n                crypto_core_hsalsa20(s, n, k, sigma);\n                var sn = new Uint8Array(8);\n                for(var i = 0; i < 8; i++)sn[i] = n[i + 16];\n                return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);\n            }\n            /*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/ var poly1305 = function(key) {\n                this.buffer = new Uint8Array(16);\n                this.r = new Uint16Array(10);\n                this.h = new Uint16Array(10);\n                this.pad = new Uint16Array(8);\n                this.leftover = 0;\n                this.fin = 0;\n                var t0, t1, t2, t3, t4, t5, t6, t7;\n                t0 = key[0] & 0xff | (key[1] & 0xff) << 8;\n                this.r[0] = t0 & 0x1fff;\n                t1 = key[2] & 0xff | (key[3] & 0xff) << 8;\n                this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;\n                t2 = key[4] & 0xff | (key[5] & 0xff) << 8;\n                this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;\n                t3 = key[6] & 0xff | (key[7] & 0xff) << 8;\n                this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;\n                t4 = key[8] & 0xff | (key[9] & 0xff) << 8;\n                this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;\n                this.r[5] = t4 >>> 1 & 0x1ffe;\n                t5 = key[10] & 0xff | (key[11] & 0xff) << 8;\n                this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;\n                t6 = key[12] & 0xff | (key[13] & 0xff) << 8;\n                this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;\n                t7 = key[14] & 0xff | (key[15] & 0xff) << 8;\n                this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;\n                this.r[9] = t7 >>> 5 & 0x007f;\n                this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n                this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n                this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n                this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n                this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n                this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n                this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n                this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n            };\n            poly1305.prototype.blocks = function(m, mpos, bytes) {\n                var hibit = this.fin ? 0 : 1 << 11;\n                var t0, t1, t2, t3, t4, t5, t6, t7, c;\n                var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n                var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];\n                var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];\n                while(bytes >= 16){\n                    t0 = m[mpos + 0] & 0xff | (m[mpos + 1] & 0xff) << 8;\n                    h0 += t0 & 0x1fff;\n                    t1 = m[mpos + 2] & 0xff | (m[mpos + 3] & 0xff) << 8;\n                    h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;\n                    t2 = m[mpos + 4] & 0xff | (m[mpos + 5] & 0xff) << 8;\n                    h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;\n                    t3 = m[mpos + 6] & 0xff | (m[mpos + 7] & 0xff) << 8;\n                    h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;\n                    t4 = m[mpos + 8] & 0xff | (m[mpos + 9] & 0xff) << 8;\n                    h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;\n                    h5 += t4 >>> 1 & 0x1fff;\n                    t5 = m[mpos + 10] & 0xff | (m[mpos + 11] & 0xff) << 8;\n                    h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;\n                    t6 = m[mpos + 12] & 0xff | (m[mpos + 13] & 0xff) << 8;\n                    h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;\n                    t7 = m[mpos + 14] & 0xff | (m[mpos + 15] & 0xff) << 8;\n                    h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;\n                    h9 += t7 >>> 5 | hibit;\n                    c = 0;\n                    d0 = c;\n                    d0 += h0 * r0;\n                    d0 += h1 * (5 * r9);\n                    d0 += h2 * (5 * r8);\n                    d0 += h3 * (5 * r7);\n                    d0 += h4 * (5 * r6);\n                    c = d0 >>> 13;\n                    d0 &= 0x1fff;\n                    d0 += h5 * (5 * r5);\n                    d0 += h6 * (5 * r4);\n                    d0 += h7 * (5 * r3);\n                    d0 += h8 * (5 * r2);\n                    d0 += h9 * (5 * r1);\n                    c += d0 >>> 13;\n                    d0 &= 0x1fff;\n                    d1 = c;\n                    d1 += h0 * r1;\n                    d1 += h1 * r0;\n                    d1 += h2 * (5 * r9);\n                    d1 += h3 * (5 * r8);\n                    d1 += h4 * (5 * r7);\n                    c = d1 >>> 13;\n                    d1 &= 0x1fff;\n                    d1 += h5 * (5 * r6);\n                    d1 += h6 * (5 * r5);\n                    d1 += h7 * (5 * r4);\n                    d1 += h8 * (5 * r3);\n                    d1 += h9 * (5 * r2);\n                    c += d1 >>> 13;\n                    d1 &= 0x1fff;\n                    d2 = c;\n                    d2 += h0 * r2;\n                    d2 += h1 * r1;\n                    d2 += h2 * r0;\n                    d2 += h3 * (5 * r9);\n                    d2 += h4 * (5 * r8);\n                    c = d2 >>> 13;\n                    d2 &= 0x1fff;\n                    d2 += h5 * (5 * r7);\n                    d2 += h6 * (5 * r6);\n                    d2 += h7 * (5 * r5);\n                    d2 += h8 * (5 * r4);\n                    d2 += h9 * (5 * r3);\n                    c += d2 >>> 13;\n                    d2 &= 0x1fff;\n                    d3 = c;\n                    d3 += h0 * r3;\n                    d3 += h1 * r2;\n                    d3 += h2 * r1;\n                    d3 += h3 * r0;\n                    d3 += h4 * (5 * r9);\n                    c = d3 >>> 13;\n                    d3 &= 0x1fff;\n                    d3 += h5 * (5 * r8);\n                    d3 += h6 * (5 * r7);\n                    d3 += h7 * (5 * r6);\n                    d3 += h8 * (5 * r5);\n                    d3 += h9 * (5 * r4);\n                    c += d3 >>> 13;\n                    d3 &= 0x1fff;\n                    d4 = c;\n                    d4 += h0 * r4;\n                    d4 += h1 * r3;\n                    d4 += h2 * r2;\n                    d4 += h3 * r1;\n                    d4 += h4 * r0;\n                    c = d4 >>> 13;\n                    d4 &= 0x1fff;\n                    d4 += h5 * (5 * r9);\n                    d4 += h6 * (5 * r8);\n                    d4 += h7 * (5 * r7);\n                    d4 += h8 * (5 * r6);\n                    d4 += h9 * (5 * r5);\n                    c += d4 >>> 13;\n                    d4 &= 0x1fff;\n                    d5 = c;\n                    d5 += h0 * r5;\n                    d5 += h1 * r4;\n                    d5 += h2 * r3;\n                    d5 += h3 * r2;\n                    d5 += h4 * r1;\n                    c = d5 >>> 13;\n                    d5 &= 0x1fff;\n                    d5 += h5 * r0;\n                    d5 += h6 * (5 * r9);\n                    d5 += h7 * (5 * r8);\n                    d5 += h8 * (5 * r7);\n                    d5 += h9 * (5 * r6);\n                    c += d5 >>> 13;\n                    d5 &= 0x1fff;\n                    d6 = c;\n                    d6 += h0 * r6;\n                    d6 += h1 * r5;\n                    d6 += h2 * r4;\n                    d6 += h3 * r3;\n                    d6 += h4 * r2;\n                    c = d6 >>> 13;\n                    d6 &= 0x1fff;\n                    d6 += h5 * r1;\n                    d6 += h6 * r0;\n                    d6 += h7 * (5 * r9);\n                    d6 += h8 * (5 * r8);\n                    d6 += h9 * (5 * r7);\n                    c += d6 >>> 13;\n                    d6 &= 0x1fff;\n                    d7 = c;\n                    d7 += h0 * r7;\n                    d7 += h1 * r6;\n                    d7 += h2 * r5;\n                    d7 += h3 * r4;\n                    d7 += h4 * r3;\n                    c = d7 >>> 13;\n                    d7 &= 0x1fff;\n                    d7 += h5 * r2;\n                    d7 += h6 * r1;\n                    d7 += h7 * r0;\n                    d7 += h8 * (5 * r9);\n                    d7 += h9 * (5 * r8);\n                    c += d7 >>> 13;\n                    d7 &= 0x1fff;\n                    d8 = c;\n                    d8 += h0 * r8;\n                    d8 += h1 * r7;\n                    d8 += h2 * r6;\n                    d8 += h3 * r5;\n                    d8 += h4 * r4;\n                    c = d8 >>> 13;\n                    d8 &= 0x1fff;\n                    d8 += h5 * r3;\n                    d8 += h6 * r2;\n                    d8 += h7 * r1;\n                    d8 += h8 * r0;\n                    d8 += h9 * (5 * r9);\n                    c += d8 >>> 13;\n                    d8 &= 0x1fff;\n                    d9 = c;\n                    d9 += h0 * r9;\n                    d9 += h1 * r8;\n                    d9 += h2 * r7;\n                    d9 += h3 * r6;\n                    d9 += h4 * r5;\n                    c = d9 >>> 13;\n                    d9 &= 0x1fff;\n                    d9 += h5 * r4;\n                    d9 += h6 * r3;\n                    d9 += h7 * r2;\n                    d9 += h8 * r1;\n                    d9 += h9 * r0;\n                    c += d9 >>> 13;\n                    d9 &= 0x1fff;\n                    c = (c << 2) + c | 0;\n                    c = c + d0 | 0;\n                    d0 = c & 0x1fff;\n                    c = c >>> 13;\n                    d1 += c;\n                    h0 = d0;\n                    h1 = d1;\n                    h2 = d2;\n                    h3 = d3;\n                    h4 = d4;\n                    h5 = d5;\n                    h6 = d6;\n                    h7 = d7;\n                    h8 = d8;\n                    h9 = d9;\n                    mpos += 16;\n                    bytes -= 16;\n                }\n                this.h[0] = h0;\n                this.h[1] = h1;\n                this.h[2] = h2;\n                this.h[3] = h3;\n                this.h[4] = h4;\n                this.h[5] = h5;\n                this.h[6] = h6;\n                this.h[7] = h7;\n                this.h[8] = h8;\n                this.h[9] = h9;\n            };\n            poly1305.prototype.finish = function(mac, macpos) {\n                var g = new Uint16Array(10);\n                var c, mask, f, i;\n                if (this.leftover) {\n                    i = this.leftover;\n                    this.buffer[i++] = 1;\n                    for(; i < 16; i++)this.buffer[i] = 0;\n                    this.fin = 1;\n                    this.blocks(this.buffer, 0, 16);\n                }\n                c = this.h[1] >>> 13;\n                this.h[1] &= 0x1fff;\n                for(i = 2; i < 10; i++){\n                    this.h[i] += c;\n                    c = this.h[i] >>> 13;\n                    this.h[i] &= 0x1fff;\n                }\n                this.h[0] += c * 5;\n                c = this.h[0] >>> 13;\n                this.h[0] &= 0x1fff;\n                this.h[1] += c;\n                c = this.h[1] >>> 13;\n                this.h[1] &= 0x1fff;\n                this.h[2] += c;\n                g[0] = this.h[0] + 5;\n                c = g[0] >>> 13;\n                g[0] &= 0x1fff;\n                for(i = 1; i < 10; i++){\n                    g[i] = this.h[i] + c;\n                    c = g[i] >>> 13;\n                    g[i] &= 0x1fff;\n                }\n                g[9] -= 1 << 13;\n                mask = (c ^ 1) - 1;\n                for(i = 0; i < 10; i++)g[i] &= mask;\n                mask = ~mask;\n                for(i = 0; i < 10; i++)this.h[i] = this.h[i] & mask | g[i];\n                this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;\n                this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;\n                this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;\n                this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;\n                this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;\n                this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;\n                this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;\n                this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff;\n                f = this.h[0] + this.pad[0];\n                this.h[0] = f & 0xffff;\n                for(i = 1; i < 8; i++){\n                    f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;\n                    this.h[i] = f & 0xffff;\n                }\n                mac[macpos + 0] = this.h[0] >>> 0 & 0xff;\n                mac[macpos + 1] = this.h[0] >>> 8 & 0xff;\n                mac[macpos + 2] = this.h[1] >>> 0 & 0xff;\n                mac[macpos + 3] = this.h[1] >>> 8 & 0xff;\n                mac[macpos + 4] = this.h[2] >>> 0 & 0xff;\n                mac[macpos + 5] = this.h[2] >>> 8 & 0xff;\n                mac[macpos + 6] = this.h[3] >>> 0 & 0xff;\n                mac[macpos + 7] = this.h[3] >>> 8 & 0xff;\n                mac[macpos + 8] = this.h[4] >>> 0 & 0xff;\n                mac[macpos + 9] = this.h[4] >>> 8 & 0xff;\n                mac[macpos + 10] = this.h[5] >>> 0 & 0xff;\n                mac[macpos + 11] = this.h[5] >>> 8 & 0xff;\n                mac[macpos + 12] = this.h[6] >>> 0 & 0xff;\n                mac[macpos + 13] = this.h[6] >>> 8 & 0xff;\n                mac[macpos + 14] = this.h[7] >>> 0 & 0xff;\n                mac[macpos + 15] = this.h[7] >>> 8 & 0xff;\n            };\n            poly1305.prototype.update = function(m, mpos, bytes) {\n                var i, want;\n                if (this.leftover) {\n                    want = 16 - this.leftover;\n                    if (want > bytes) want = bytes;\n                    for(i = 0; i < want; i++)this.buffer[this.leftover + i] = m[mpos + i];\n                    bytes -= want;\n                    mpos += want;\n                    this.leftover += want;\n                    if (this.leftover < 16) return;\n                    this.blocks(this.buffer, 0, 16);\n                    this.leftover = 0;\n                }\n                if (bytes >= 16) {\n                    want = bytes - bytes % 16;\n                    this.blocks(m, mpos, want);\n                    mpos += want;\n                    bytes -= want;\n                }\n                if (bytes) {\n                    for(i = 0; i < bytes; i++)this.buffer[this.leftover + i] = m[mpos + i];\n                    this.leftover += bytes;\n                }\n            };\n            function crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n                var s = new poly1305(k);\n                s.update(m, mpos, n);\n                s.finish(out, outpos);\n                return 0;\n            }\n            function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n                var x = new Uint8Array(16);\n                crypto_onetimeauth(x, 0, m, mpos, n, k);\n                return crypto_verify_16(h, hpos, x, 0);\n            }\n            function crypto_secretbox(c, m, d, n, k) {\n                var i;\n                if (d < 32) return -1;\n                crypto_stream_xor(c, 0, m, 0, d, n, k);\n                crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n                for(i = 0; i < 16; i++)c[i] = 0;\n                return 0;\n            }\n            function crypto_secretbox_open(m, c, d, n, k) {\n                var i;\n                var x = new Uint8Array(32);\n                if (d < 32) return -1;\n                crypto_stream(x, 0, 32, n, k);\n                if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;\n                crypto_stream_xor(m, 0, c, 0, d, n, k);\n                for(i = 0; i < 32; i++)m[i] = 0;\n                return 0;\n            }\n            function set25519(r, a) {\n                var i;\n                for(i = 0; i < 16; i++)r[i] = a[i] | 0;\n            }\n            function car25519(o) {\n                var i, v, c = 1;\n                for(i = 0; i < 16; i++){\n                    v = o[i] + c + 65535;\n                    c = Math.floor(v / 65536);\n                    o[i] = v - c * 65536;\n                }\n                o[0] += c - 1 + 37 * (c - 1);\n            }\n            function sel25519(p, q, b) {\n                var t, c = ~(b - 1);\n                for(var i = 0; i < 16; i++){\n                    t = c & (p[i] ^ q[i]);\n                    p[i] ^= t;\n                    q[i] ^= t;\n                }\n            }\n            function pack25519(o, n) {\n                var i, j, b;\n                var m = gf(), t = gf();\n                for(i = 0; i < 16; i++)t[i] = n[i];\n                car25519(t);\n                car25519(t);\n                car25519(t);\n                for(j = 0; j < 2; j++){\n                    m[0] = t[0] - 0xffed;\n                    for(i = 1; i < 15; i++){\n                        m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);\n                        m[i - 1] &= 0xffff;\n                    }\n                    m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);\n                    b = m[15] >> 16 & 1;\n                    m[14] &= 0xffff;\n                    sel25519(t, m, 1 - b);\n                }\n                for(i = 0; i < 16; i++){\n                    o[2 * i] = t[i] & 0xff;\n                    o[2 * i + 1] = t[i] >> 8;\n                }\n            }\n            function neq25519(a, b) {\n                var c = new Uint8Array(32), d = new Uint8Array(32);\n                pack25519(c, a);\n                pack25519(d, b);\n                return crypto_verify_32(c, 0, d, 0);\n            }\n            function par25519(a) {\n                var d = new Uint8Array(32);\n                pack25519(d, a);\n                return d[0] & 1;\n            }\n            function unpack25519(o, n) {\n                var i;\n                for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n                o[15] &= 0x7fff;\n            }\n            function A(o, a, b) {\n                for(var i = 0; i < 16; i++)o[i] = a[i] + b[i];\n            }\n            function Z(o, a, b) {\n                for(var i = 0; i < 16; i++)o[i] = a[i] - b[i];\n            }\n            function M(o, a, b) {\n                var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n                v = a[0];\n                t0 += v * b0;\n                t1 += v * b1;\n                t2 += v * b2;\n                t3 += v * b3;\n                t4 += v * b4;\n                t5 += v * b5;\n                t6 += v * b6;\n                t7 += v * b7;\n                t8 += v * b8;\n                t9 += v * b9;\n                t10 += v * b10;\n                t11 += v * b11;\n                t12 += v * b12;\n                t13 += v * b13;\n                t14 += v * b14;\n                t15 += v * b15;\n                v = a[1];\n                t1 += v * b0;\n                t2 += v * b1;\n                t3 += v * b2;\n                t4 += v * b3;\n                t5 += v * b4;\n                t6 += v * b5;\n                t7 += v * b6;\n                t8 += v * b7;\n                t9 += v * b8;\n                t10 += v * b9;\n                t11 += v * b10;\n                t12 += v * b11;\n                t13 += v * b12;\n                t14 += v * b13;\n                t15 += v * b14;\n                t16 += v * b15;\n                v = a[2];\n                t2 += v * b0;\n                t3 += v * b1;\n                t4 += v * b2;\n                t5 += v * b3;\n                t6 += v * b4;\n                t7 += v * b5;\n                t8 += v * b6;\n                t9 += v * b7;\n                t10 += v * b8;\n                t11 += v * b9;\n                t12 += v * b10;\n                t13 += v * b11;\n                t14 += v * b12;\n                t15 += v * b13;\n                t16 += v * b14;\n                t17 += v * b15;\n                v = a[3];\n                t3 += v * b0;\n                t4 += v * b1;\n                t5 += v * b2;\n                t6 += v * b3;\n                t7 += v * b4;\n                t8 += v * b5;\n                t9 += v * b6;\n                t10 += v * b7;\n                t11 += v * b8;\n                t12 += v * b9;\n                t13 += v * b10;\n                t14 += v * b11;\n                t15 += v * b12;\n                t16 += v * b13;\n                t17 += v * b14;\n                t18 += v * b15;\n                v = a[4];\n                t4 += v * b0;\n                t5 += v * b1;\n                t6 += v * b2;\n                t7 += v * b3;\n                t8 += v * b4;\n                t9 += v * b5;\n                t10 += v * b6;\n                t11 += v * b7;\n                t12 += v * b8;\n                t13 += v * b9;\n                t14 += v * b10;\n                t15 += v * b11;\n                t16 += v * b12;\n                t17 += v * b13;\n                t18 += v * b14;\n                t19 += v * b15;\n                v = a[5];\n                t5 += v * b0;\n                t6 += v * b1;\n                t7 += v * b2;\n                t8 += v * b3;\n                t9 += v * b4;\n                t10 += v * b5;\n                t11 += v * b6;\n                t12 += v * b7;\n                t13 += v * b8;\n                t14 += v * b9;\n                t15 += v * b10;\n                t16 += v * b11;\n                t17 += v * b12;\n                t18 += v * b13;\n                t19 += v * b14;\n                t20 += v * b15;\n                v = a[6];\n                t6 += v * b0;\n                t7 += v * b1;\n                t8 += v * b2;\n                t9 += v * b3;\n                t10 += v * b4;\n                t11 += v * b5;\n                t12 += v * b6;\n                t13 += v * b7;\n                t14 += v * b8;\n                t15 += v * b9;\n                t16 += v * b10;\n                t17 += v * b11;\n                t18 += v * b12;\n                t19 += v * b13;\n                t20 += v * b14;\n                t21 += v * b15;\n                v = a[7];\n                t7 += v * b0;\n                t8 += v * b1;\n                t9 += v * b2;\n                t10 += v * b3;\n                t11 += v * b4;\n                t12 += v * b5;\n                t13 += v * b6;\n                t14 += v * b7;\n                t15 += v * b8;\n                t16 += v * b9;\n                t17 += v * b10;\n                t18 += v * b11;\n                t19 += v * b12;\n                t20 += v * b13;\n                t21 += v * b14;\n                t22 += v * b15;\n                v = a[8];\n                t8 += v * b0;\n                t9 += v * b1;\n                t10 += v * b2;\n                t11 += v * b3;\n                t12 += v * b4;\n                t13 += v * b5;\n                t14 += v * b6;\n                t15 += v * b7;\n                t16 += v * b8;\n                t17 += v * b9;\n                t18 += v * b10;\n                t19 += v * b11;\n                t20 += v * b12;\n                t21 += v * b13;\n                t22 += v * b14;\n                t23 += v * b15;\n                v = a[9];\n                t9 += v * b0;\n                t10 += v * b1;\n                t11 += v * b2;\n                t12 += v * b3;\n                t13 += v * b4;\n                t14 += v * b5;\n                t15 += v * b6;\n                t16 += v * b7;\n                t17 += v * b8;\n                t18 += v * b9;\n                t19 += v * b10;\n                t20 += v * b11;\n                t21 += v * b12;\n                t22 += v * b13;\n                t23 += v * b14;\n                t24 += v * b15;\n                v = a[10];\n                t10 += v * b0;\n                t11 += v * b1;\n                t12 += v * b2;\n                t13 += v * b3;\n                t14 += v * b4;\n                t15 += v * b5;\n                t16 += v * b6;\n                t17 += v * b7;\n                t18 += v * b8;\n                t19 += v * b9;\n                t20 += v * b10;\n                t21 += v * b11;\n                t22 += v * b12;\n                t23 += v * b13;\n                t24 += v * b14;\n                t25 += v * b15;\n                v = a[11];\n                t11 += v * b0;\n                t12 += v * b1;\n                t13 += v * b2;\n                t14 += v * b3;\n                t15 += v * b4;\n                t16 += v * b5;\n                t17 += v * b6;\n                t18 += v * b7;\n                t19 += v * b8;\n                t20 += v * b9;\n                t21 += v * b10;\n                t22 += v * b11;\n                t23 += v * b12;\n                t24 += v * b13;\n                t25 += v * b14;\n                t26 += v * b15;\n                v = a[12];\n                t12 += v * b0;\n                t13 += v * b1;\n                t14 += v * b2;\n                t15 += v * b3;\n                t16 += v * b4;\n                t17 += v * b5;\n                t18 += v * b6;\n                t19 += v * b7;\n                t20 += v * b8;\n                t21 += v * b9;\n                t22 += v * b10;\n                t23 += v * b11;\n                t24 += v * b12;\n                t25 += v * b13;\n                t26 += v * b14;\n                t27 += v * b15;\n                v = a[13];\n                t13 += v * b0;\n                t14 += v * b1;\n                t15 += v * b2;\n                t16 += v * b3;\n                t17 += v * b4;\n                t18 += v * b5;\n                t19 += v * b6;\n                t20 += v * b7;\n                t21 += v * b8;\n                t22 += v * b9;\n                t23 += v * b10;\n                t24 += v * b11;\n                t25 += v * b12;\n                t26 += v * b13;\n                t27 += v * b14;\n                t28 += v * b15;\n                v = a[14];\n                t14 += v * b0;\n                t15 += v * b1;\n                t16 += v * b2;\n                t17 += v * b3;\n                t18 += v * b4;\n                t19 += v * b5;\n                t20 += v * b6;\n                t21 += v * b7;\n                t22 += v * b8;\n                t23 += v * b9;\n                t24 += v * b10;\n                t25 += v * b11;\n                t26 += v * b12;\n                t27 += v * b13;\n                t28 += v * b14;\n                t29 += v * b15;\n                v = a[15];\n                t15 += v * b0;\n                t16 += v * b1;\n                t17 += v * b2;\n                t18 += v * b3;\n                t19 += v * b4;\n                t20 += v * b5;\n                t21 += v * b6;\n                t22 += v * b7;\n                t23 += v * b8;\n                t24 += v * b9;\n                t25 += v * b10;\n                t26 += v * b11;\n                t27 += v * b12;\n                t28 += v * b13;\n                t29 += v * b14;\n                t30 += v * b15;\n                t0 += 38 * t16;\n                t1 += 38 * t17;\n                t2 += 38 * t18;\n                t3 += 38 * t19;\n                t4 += 38 * t20;\n                t5 += 38 * t21;\n                t6 += 38 * t22;\n                t7 += 38 * t23;\n                t8 += 38 * t24;\n                t9 += 38 * t25;\n                t10 += 38 * t26;\n                t11 += 38 * t27;\n                t12 += 38 * t28;\n                t13 += 38 * t29;\n                t14 += 38 * t30;\n                // t15 left as is\n                // first car\n                c = 1;\n                v = t0 + c + 65535;\n                c = Math.floor(v / 65536);\n                t0 = v - c * 65536;\n                v = t1 + c + 65535;\n                c = Math.floor(v / 65536);\n                t1 = v - c * 65536;\n                v = t2 + c + 65535;\n                c = Math.floor(v / 65536);\n                t2 = v - c * 65536;\n                v = t3 + c + 65535;\n                c = Math.floor(v / 65536);\n                t3 = v - c * 65536;\n                v = t4 + c + 65535;\n                c = Math.floor(v / 65536);\n                t4 = v - c * 65536;\n                v = t5 + c + 65535;\n                c = Math.floor(v / 65536);\n                t5 = v - c * 65536;\n                v = t6 + c + 65535;\n                c = Math.floor(v / 65536);\n                t6 = v - c * 65536;\n                v = t7 + c + 65535;\n                c = Math.floor(v / 65536);\n                t7 = v - c * 65536;\n                v = t8 + c + 65535;\n                c = Math.floor(v / 65536);\n                t8 = v - c * 65536;\n                v = t9 + c + 65535;\n                c = Math.floor(v / 65536);\n                t9 = v - c * 65536;\n                v = t10 + c + 65535;\n                c = Math.floor(v / 65536);\n                t10 = v - c * 65536;\n                v = t11 + c + 65535;\n                c = Math.floor(v / 65536);\n                t11 = v - c * 65536;\n                v = t12 + c + 65535;\n                c = Math.floor(v / 65536);\n                t12 = v - c * 65536;\n                v = t13 + c + 65535;\n                c = Math.floor(v / 65536);\n                t13 = v - c * 65536;\n                v = t14 + c + 65535;\n                c = Math.floor(v / 65536);\n                t14 = v - c * 65536;\n                v = t15 + c + 65535;\n                c = Math.floor(v / 65536);\n                t15 = v - c * 65536;\n                t0 += c - 1 + 37 * (c - 1);\n                // second car\n                c = 1;\n                v = t0 + c + 65535;\n                c = Math.floor(v / 65536);\n                t0 = v - c * 65536;\n                v = t1 + c + 65535;\n                c = Math.floor(v / 65536);\n                t1 = v - c * 65536;\n                v = t2 + c + 65535;\n                c = Math.floor(v / 65536);\n                t2 = v - c * 65536;\n                v = t3 + c + 65535;\n                c = Math.floor(v / 65536);\n                t3 = v - c * 65536;\n                v = t4 + c + 65535;\n                c = Math.floor(v / 65536);\n                t4 = v - c * 65536;\n                v = t5 + c + 65535;\n                c = Math.floor(v / 65536);\n                t5 = v - c * 65536;\n                v = t6 + c + 65535;\n                c = Math.floor(v / 65536);\n                t6 = v - c * 65536;\n                v = t7 + c + 65535;\n                c = Math.floor(v / 65536);\n                t7 = v - c * 65536;\n                v = t8 + c + 65535;\n                c = Math.floor(v / 65536);\n                t8 = v - c * 65536;\n                v = t9 + c + 65535;\n                c = Math.floor(v / 65536);\n                t9 = v - c * 65536;\n                v = t10 + c + 65535;\n                c = Math.floor(v / 65536);\n                t10 = v - c * 65536;\n                v = t11 + c + 65535;\n                c = Math.floor(v / 65536);\n                t11 = v - c * 65536;\n                v = t12 + c + 65535;\n                c = Math.floor(v / 65536);\n                t12 = v - c * 65536;\n                v = t13 + c + 65535;\n                c = Math.floor(v / 65536);\n                t13 = v - c * 65536;\n                v = t14 + c + 65535;\n                c = Math.floor(v / 65536);\n                t14 = v - c * 65536;\n                v = t15 + c + 65535;\n                c = Math.floor(v / 65536);\n                t15 = v - c * 65536;\n                t0 += c - 1 + 37 * (c - 1);\n                o[0] = t0;\n                o[1] = t1;\n                o[2] = t2;\n                o[3] = t3;\n                o[4] = t4;\n                o[5] = t5;\n                o[6] = t6;\n                o[7] = t7;\n                o[8] = t8;\n                o[9] = t9;\n                o[10] = t10;\n                o[11] = t11;\n                o[12] = t12;\n                o[13] = t13;\n                o[14] = t14;\n                o[15] = t15;\n            }\n            function S(o, a) {\n                M(o, a, a);\n            }\n            function inv25519(o, i) {\n                var c = gf();\n                var a;\n                for(a = 0; a < 16; a++)c[a] = i[a];\n                for(a = 253; a >= 0; a--){\n                    S(c, c);\n                    if (a !== 2 && a !== 4) M(c, c, i);\n                }\n                for(a = 0; a < 16; a++)o[a] = c[a];\n            }\n            function pow2523(o, i) {\n                var c = gf();\n                var a;\n                for(a = 0; a < 16; a++)c[a] = i[a];\n                for(a = 250; a >= 0; a--){\n                    S(c, c);\n                    if (a !== 1) M(c, c, i);\n                }\n                for(a = 0; a < 16; a++)o[a] = c[a];\n            }\n            function crypto_scalarmult(q, n, p) {\n                var z = new Uint8Array(32);\n                var x = new Float64Array(80), r, i;\n                var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();\n                for(i = 0; i < 31; i++)z[i] = n[i];\n                z[31] = n[31] & 127 | 64;\n                z[0] &= 248;\n                unpack25519(x, p);\n                for(i = 0; i < 16; i++){\n                    b[i] = x[i];\n                    d[i] = a[i] = c[i] = 0;\n                }\n                a[0] = d[0] = 1;\n                for(i = 254; i >= 0; --i){\n                    r = z[i >>> 3] >>> (i & 7) & 1;\n                    sel25519(a, b, r);\n                    sel25519(c, d, r);\n                    A(e, a, c);\n                    Z(a, a, c);\n                    A(c, b, d);\n                    Z(b, b, d);\n                    S(d, e);\n                    S(f, a);\n                    M(a, c, a);\n                    M(c, b, e);\n                    A(e, a, c);\n                    Z(a, a, c);\n                    S(b, a);\n                    Z(c, d, f);\n                    M(a, c, _121665);\n                    A(a, a, d);\n                    M(c, c, a);\n                    M(a, d, f);\n                    M(d, b, x);\n                    S(b, e);\n                    sel25519(a, b, r);\n                    sel25519(c, d, r);\n                }\n                for(i = 0; i < 16; i++){\n                    x[i + 16] = a[i];\n                    x[i + 32] = c[i];\n                    x[i + 48] = b[i];\n                    x[i + 64] = d[i];\n                }\n                var x32 = x.subarray(32);\n                var x16 = x.subarray(16);\n                inv25519(x32, x32);\n                M(x16, x16, x32);\n                pack25519(q, x16);\n                return 0;\n            }\n            function crypto_scalarmult_base(q, n) {\n                return crypto_scalarmult(q, n, _9);\n            }\n            function crypto_box_keypair(y, x) {\n                randombytes(x, 32);\n                return crypto_scalarmult_base(y, x);\n            }\n            function crypto_box_beforenm(k, y, x) {\n                var s = new Uint8Array(32);\n                crypto_scalarmult(s, x, y);\n                return crypto_core_hsalsa20(k, _0, s, sigma);\n            }\n            var crypto_box_afternm = crypto_secretbox;\n            var crypto_box_open_afternm = crypto_secretbox_open;\n            function crypto_box(c, m, d, n, y, x) {\n                var k = new Uint8Array(32);\n                crypto_box_beforenm(k, y, x);\n                return crypto_box_afternm(c, m, d, n, k);\n            }\n            function crypto_box_open(m, c, d, n, y, x) {\n                var k = new Uint8Array(32);\n                crypto_box_beforenm(k, y, x);\n                return crypto_box_open_afternm(m, c, d, n, k);\n            }\n            var K = [\n                0x428a2f98,\n                0xd728ae22,\n                0x71374491,\n                0x23ef65cd,\n                0xb5c0fbcf,\n                0xec4d3b2f,\n                0xe9b5dba5,\n                0x8189dbbc,\n                0x3956c25b,\n                0xf348b538,\n                0x59f111f1,\n                0xb605d019,\n                0x923f82a4,\n                0xaf194f9b,\n                0xab1c5ed5,\n                0xda6d8118,\n                0xd807aa98,\n                0xa3030242,\n                0x12835b01,\n                0x45706fbe,\n                0x243185be,\n                0x4ee4b28c,\n                0x550c7dc3,\n                0xd5ffb4e2,\n                0x72be5d74,\n                0xf27b896f,\n                0x80deb1fe,\n                0x3b1696b1,\n                0x9bdc06a7,\n                0x25c71235,\n                0xc19bf174,\n                0xcf692694,\n                0xe49b69c1,\n                0x9ef14ad2,\n                0xefbe4786,\n                0x384f25e3,\n                0x0fc19dc6,\n                0x8b8cd5b5,\n                0x240ca1cc,\n                0x77ac9c65,\n                0x2de92c6f,\n                0x592b0275,\n                0x4a7484aa,\n                0x6ea6e483,\n                0x5cb0a9dc,\n                0xbd41fbd4,\n                0x76f988da,\n                0x831153b5,\n                0x983e5152,\n                0xee66dfab,\n                0xa831c66d,\n                0x2db43210,\n                0xb00327c8,\n                0x98fb213f,\n                0xbf597fc7,\n                0xbeef0ee4,\n                0xc6e00bf3,\n                0x3da88fc2,\n                0xd5a79147,\n                0x930aa725,\n                0x06ca6351,\n                0xe003826f,\n                0x14292967,\n                0x0a0e6e70,\n                0x27b70a85,\n                0x46d22ffc,\n                0x2e1b2138,\n                0x5c26c926,\n                0x4d2c6dfc,\n                0x5ac42aed,\n                0x53380d13,\n                0x9d95b3df,\n                0x650a7354,\n                0x8baf63de,\n                0x766a0abb,\n                0x3c77b2a8,\n                0x81c2c92e,\n                0x47edaee6,\n                0x92722c85,\n                0x1482353b,\n                0xa2bfe8a1,\n                0x4cf10364,\n                0xa81a664b,\n                0xbc423001,\n                0xc24b8b70,\n                0xd0f89791,\n                0xc76c51a3,\n                0x0654be30,\n                0xd192e819,\n                0xd6ef5218,\n                0xd6990624,\n                0x5565a910,\n                0xf40e3585,\n                0x5771202a,\n                0x106aa070,\n                0x32bbd1b8,\n                0x19a4c116,\n                0xb8d2d0c8,\n                0x1e376c08,\n                0x5141ab53,\n                0x2748774c,\n                0xdf8eeb99,\n                0x34b0bcb5,\n                0xe19b48a8,\n                0x391c0cb3,\n                0xc5c95a63,\n                0x4ed8aa4a,\n                0xe3418acb,\n                0x5b9cca4f,\n                0x7763e373,\n                0x682e6ff3,\n                0xd6b2b8a3,\n                0x748f82ee,\n                0x5defb2fc,\n                0x78a5636f,\n                0x43172f60,\n                0x84c87814,\n                0xa1f0ab72,\n                0x8cc70208,\n                0x1a6439ec,\n                0x90befffa,\n                0x23631e28,\n                0xa4506ceb,\n                0xde82bde9,\n                0xbef9a3f7,\n                0xb2c67915,\n                0xc67178f2,\n                0xe372532b,\n                0xca273ece,\n                0xea26619c,\n                0xd186b8c7,\n                0x21c0c207,\n                0xeada7dd6,\n                0xcde0eb1e,\n                0xf57d4f7f,\n                0xee6ed178,\n                0x06f067aa,\n                0x72176fba,\n                0x0a637dc5,\n                0xa2c898a6,\n                0x113f9804,\n                0xbef90dae,\n                0x1b710b35,\n                0x131c471b,\n                0x28db77f5,\n                0x23047d84,\n                0x32caab7b,\n                0x40c72493,\n                0x3c9ebe0a,\n                0x15c9bebc,\n                0x431d67c4,\n                0x9c100d4c,\n                0x4cc5d4be,\n                0xcb3e42b6,\n                0x597f299c,\n                0xfc657e2a,\n                0x5fcb6fab,\n                0x3ad6faec,\n                0x6c44198c,\n                0x4a475817\n            ];\n            function crypto_hashblocks_hl(hh, hl, m, n) {\n                var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;\n                var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];\n                var pos = 0;\n                while(n >= 128){\n                    for(i = 0; i < 16; i++){\n                        j = 8 * i + pos;\n                        wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];\n                        wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];\n                    }\n                    for(i = 0; i < 80; i++){\n                        bh0 = ah0;\n                        bh1 = ah1;\n                        bh2 = ah2;\n                        bh3 = ah3;\n                        bh4 = ah4;\n                        bh5 = ah5;\n                        bh6 = ah6;\n                        bh7 = ah7;\n                        bl0 = al0;\n                        bl1 = al1;\n                        bl2 = al2;\n                        bl3 = al3;\n                        bl4 = al4;\n                        bl5 = al5;\n                        bl6 = al6;\n                        bl7 = al7;\n                        // add\n                        h = ah7;\n                        l = al7;\n                        a = l & 0xffff;\n                        b = l >>> 16;\n                        c = h & 0xffff;\n                        d = h >>> 16;\n                        // Sigma1\n                        h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));\n                        l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        // Ch\n                        h = ah4 & ah5 ^ ~ah4 & ah6;\n                        l = al4 & al5 ^ ~al4 & al6;\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        // K\n                        h = K[i * 2];\n                        l = K[i * 2 + 1];\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        // w\n                        h = wh[i % 16];\n                        l = wl[i % 16];\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        b += a >>> 16;\n                        c += b >>> 16;\n                        d += c >>> 16;\n                        th = c & 0xffff | d << 16;\n                        tl = a & 0xffff | b << 16;\n                        // add\n                        h = th;\n                        l = tl;\n                        a = l & 0xffff;\n                        b = l >>> 16;\n                        c = h & 0xffff;\n                        d = h >>> 16;\n                        // Sigma0\n                        h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));\n                        l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        // Maj\n                        h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;\n                        l = al0 & al1 ^ al0 & al2 ^ al1 & al2;\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        b += a >>> 16;\n                        c += b >>> 16;\n                        d += c >>> 16;\n                        bh7 = c & 0xffff | d << 16;\n                        bl7 = a & 0xffff | b << 16;\n                        // add\n                        h = bh3;\n                        l = bl3;\n                        a = l & 0xffff;\n                        b = l >>> 16;\n                        c = h & 0xffff;\n                        d = h >>> 16;\n                        h = th;\n                        l = tl;\n                        a += l & 0xffff;\n                        b += l >>> 16;\n                        c += h & 0xffff;\n                        d += h >>> 16;\n                        b += a >>> 16;\n                        c += b >>> 16;\n                        d += c >>> 16;\n                        bh3 = c & 0xffff | d << 16;\n                        bl3 = a & 0xffff | b << 16;\n                        ah1 = bh0;\n                        ah2 = bh1;\n                        ah3 = bh2;\n                        ah4 = bh3;\n                        ah5 = bh4;\n                        ah6 = bh5;\n                        ah7 = bh6;\n                        ah0 = bh7;\n                        al1 = bl0;\n                        al2 = bl1;\n                        al3 = bl2;\n                        al4 = bl3;\n                        al5 = bl4;\n                        al6 = bl5;\n                        al7 = bl6;\n                        al0 = bl7;\n                        if (i % 16 === 15) {\n                            for(j = 0; j < 16; j++){\n                                // add\n                                h = wh[j];\n                                l = wl[j];\n                                a = l & 0xffff;\n                                b = l >>> 16;\n                                c = h & 0xffff;\n                                d = h >>> 16;\n                                h = wh[(j + 9) % 16];\n                                l = wl[(j + 9) % 16];\n                                a += l & 0xffff;\n                                b += l >>> 16;\n                                c += h & 0xffff;\n                                d += h >>> 16;\n                                // sigma0\n                                th = wh[(j + 1) % 16];\n                                tl = wl[(j + 1) % 16];\n                                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;\n                                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);\n                                a += l & 0xffff;\n                                b += l >>> 16;\n                                c += h & 0xffff;\n                                d += h >>> 16;\n                                // sigma1\n                                th = wh[(j + 14) % 16];\n                                tl = wl[(j + 14) % 16];\n                                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;\n                                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);\n                                a += l & 0xffff;\n                                b += l >>> 16;\n                                c += h & 0xffff;\n                                d += h >>> 16;\n                                b += a >>> 16;\n                                c += b >>> 16;\n                                d += c >>> 16;\n                                wh[j] = c & 0xffff | d << 16;\n                                wl[j] = a & 0xffff | b << 16;\n                            }\n                        }\n                    }\n                    // add\n                    h = ah0;\n                    l = al0;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[0];\n                    l = hl[0];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[0] = ah0 = c & 0xffff | d << 16;\n                    hl[0] = al0 = a & 0xffff | b << 16;\n                    h = ah1;\n                    l = al1;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[1];\n                    l = hl[1];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[1] = ah1 = c & 0xffff | d << 16;\n                    hl[1] = al1 = a & 0xffff | b << 16;\n                    h = ah2;\n                    l = al2;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[2];\n                    l = hl[2];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[2] = ah2 = c & 0xffff | d << 16;\n                    hl[2] = al2 = a & 0xffff | b << 16;\n                    h = ah3;\n                    l = al3;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[3];\n                    l = hl[3];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[3] = ah3 = c & 0xffff | d << 16;\n                    hl[3] = al3 = a & 0xffff | b << 16;\n                    h = ah4;\n                    l = al4;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[4];\n                    l = hl[4];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[4] = ah4 = c & 0xffff | d << 16;\n                    hl[4] = al4 = a & 0xffff | b << 16;\n                    h = ah5;\n                    l = al5;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[5];\n                    l = hl[5];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[5] = ah5 = c & 0xffff | d << 16;\n                    hl[5] = al5 = a & 0xffff | b << 16;\n                    h = ah6;\n                    l = al6;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[6];\n                    l = hl[6];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[6] = ah6 = c & 0xffff | d << 16;\n                    hl[6] = al6 = a & 0xffff | b << 16;\n                    h = ah7;\n                    l = al7;\n                    a = l & 0xffff;\n                    b = l >>> 16;\n                    c = h & 0xffff;\n                    d = h >>> 16;\n                    h = hh[7];\n                    l = hl[7];\n                    a += l & 0xffff;\n                    b += l >>> 16;\n                    c += h & 0xffff;\n                    d += h >>> 16;\n                    b += a >>> 16;\n                    c += b >>> 16;\n                    d += c >>> 16;\n                    hh[7] = ah7 = c & 0xffff | d << 16;\n                    hl[7] = al7 = a & 0xffff | b << 16;\n                    pos += 128;\n                    n -= 128;\n                }\n                return n;\n            }\n            function crypto_hash(out, m, n) {\n                var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;\n                hh[0] = 0x6a09e667;\n                hh[1] = 0xbb67ae85;\n                hh[2] = 0x3c6ef372;\n                hh[3] = 0xa54ff53a;\n                hh[4] = 0x510e527f;\n                hh[5] = 0x9b05688c;\n                hh[6] = 0x1f83d9ab;\n                hh[7] = 0x5be0cd19;\n                hl[0] = 0xf3bcc908;\n                hl[1] = 0x84caa73b;\n                hl[2] = 0xfe94f82b;\n                hl[3] = 0x5f1d36f1;\n                hl[4] = 0xade682d1;\n                hl[5] = 0x2b3e6c1f;\n                hl[6] = 0xfb41bd6b;\n                hl[7] = 0x137e2179;\n                crypto_hashblocks_hl(hh, hl, m, n);\n                n %= 128;\n                for(i = 0; i < n; i++)x[i] = m[b - n + i];\n                x[n] = 128;\n                n = 256 - 128 * (n < 112 ? 1 : 0);\n                x[n - 9] = 0;\n                ts64(x, n - 8, b / 0x20000000 | 0, b << 3);\n                crypto_hashblocks_hl(hh, hl, x, n);\n                for(i = 0; i < 8; i++)ts64(out, 8 * i, hh[i], hl[i]);\n                return 0;\n            }\n            function add(p, q) {\n                var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n                Z(a, p[1], p[0]);\n                Z(t, q[1], q[0]);\n                M(a, a, t);\n                A(b, p[0], p[1]);\n                A(t, q[0], q[1]);\n                M(b, b, t);\n                M(c, p[3], q[3]);\n                M(c, c, D2);\n                M(d, p[2], q[2]);\n                A(d, d, d);\n                Z(e, b, a);\n                Z(f, d, c);\n                A(g, d, c);\n                A(h, b, a);\n                M(p[0], e, f);\n                M(p[1], h, g);\n                M(p[2], g, f);\n                M(p[3], e, h);\n            }\n            function cswap(p, q, b) {\n                var i;\n                for(i = 0; i < 4; i++){\n                    sel25519(p[i], q[i], b);\n                }\n            }\n            function pack(r, p) {\n                var tx = gf(), ty = gf(), zi = gf();\n                inv25519(zi, p[2]);\n                M(tx, p[0], zi);\n                M(ty, p[1], zi);\n                pack25519(r, ty);\n                r[31] ^= par25519(tx) << 7;\n            }\n            function scalarmult(p, q, s) {\n                var b, i;\n                set25519(p[0], gf0);\n                set25519(p[1], gf1);\n                set25519(p[2], gf1);\n                set25519(p[3], gf0);\n                for(i = 255; i >= 0; --i){\n                    b = s[i / 8 | 0] >> (i & 7) & 1;\n                    cswap(p, q, b);\n                    add(q, p);\n                    add(p, p);\n                    cswap(p, q, b);\n                }\n            }\n            function scalarbase(p, s) {\n                var q = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ];\n                set25519(q[0], X);\n                set25519(q[1], Y);\n                set25519(q[2], gf1);\n                M(q[3], X, Y);\n                scalarmult(p, q, s);\n            }\n            function crypto_sign_keypair(pk, sk, seeded) {\n                var d = new Uint8Array(64);\n                var p = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ];\n                var i;\n                if (!seeded) randombytes(sk, 32);\n                crypto_hash(d, sk, 32);\n                d[0] &= 248;\n                d[31] &= 127;\n                d[31] |= 64;\n                scalarbase(p, d);\n                pack(pk, p);\n                for(i = 0; i < 32; i++)sk[i + 32] = pk[i];\n                return 0;\n            }\n            var L = new Float64Array([\n                0xed,\n                0xd3,\n                0xf5,\n                0x5c,\n                0x1a,\n                0x63,\n                0x12,\n                0x58,\n                0xd6,\n                0x9c,\n                0xf7,\n                0xa2,\n                0xde,\n                0xf9,\n                0xde,\n                0x14,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0x10\n            ]);\n            function modL(r, x) {\n                var carry, i, j, k;\n                for(i = 63; i >= 32; --i){\n                    carry = 0;\n                    for(j = i - 32, k = i - 12; j < k; ++j){\n                        x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n                        carry = Math.floor((x[j] + 128) / 256);\n                        x[j] -= carry * 256;\n                    }\n                    x[j] += carry;\n                    x[i] = 0;\n                }\n                carry = 0;\n                for(j = 0; j < 32; j++){\n                    x[j] += carry - (x[31] >> 4) * L[j];\n                    carry = x[j] >> 8;\n                    x[j] &= 255;\n                }\n                for(j = 0; j < 32; j++)x[j] -= carry * L[j];\n                for(i = 0; i < 32; i++){\n                    x[i + 1] += x[i] >> 8;\n                    r[i] = x[i] & 255;\n                }\n            }\n            function reduce(r) {\n                var x = new Float64Array(64), i;\n                for(i = 0; i < 64; i++)x[i] = r[i];\n                for(i = 0; i < 64; i++)r[i] = 0;\n                modL(r, x);\n            }\n            // Note: difference from C - smlen returned, not passed as argument.\n            function crypto_sign(sm, m, n, sk) {\n                var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n                var i, j, x = new Float64Array(64);\n                var p = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ];\n                crypto_hash(d, sk, 32);\n                d[0] &= 248;\n                d[31] &= 127;\n                d[31] |= 64;\n                var smlen = n + 64;\n                for(i = 0; i < n; i++)sm[64 + i] = m[i];\n                for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];\n                crypto_hash(r, sm.subarray(32), n + 32);\n                reduce(r);\n                scalarbase(p, r);\n                pack(sm, p);\n                for(i = 32; i < 64; i++)sm[i] = sk[i];\n                crypto_hash(h, sm, n + 64);\n                reduce(h);\n                for(i = 0; i < 64; i++)x[i] = 0;\n                for(i = 0; i < 32; i++)x[i] = r[i];\n                for(i = 0; i < 32; i++){\n                    for(j = 0; j < 32; j++){\n                        x[i + j] += h[i] * d[j];\n                    }\n                }\n                modL(sm.subarray(32), x);\n                return smlen;\n            }\n            function unpackneg(r, p) {\n                var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n                set25519(r[2], gf1);\n                unpack25519(r[1], p);\n                S(num, r[1]);\n                M(den, num, D);\n                Z(num, num, r[2]);\n                A(den, r[2], den);\n                S(den2, den);\n                S(den4, den2);\n                M(den6, den4, den2);\n                M(t, den6, num);\n                M(t, t, den);\n                pow2523(t, t);\n                M(t, t, num);\n                M(t, t, den);\n                M(t, t, den);\n                M(r[0], t, den);\n                S(chk, r[0]);\n                M(chk, chk, den);\n                if (neq25519(chk, num)) M(r[0], r[0], I);\n                S(chk, r[0]);\n                M(chk, chk, den);\n                if (neq25519(chk, num)) return -1;\n                if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);\n                M(r[3], r[0], r[1]);\n                return 0;\n            }\n            function crypto_sign_open(m, sm, n, pk) {\n                var i;\n                var t = new Uint8Array(32), h = new Uint8Array(64);\n                var p = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ], q = [\n                    gf(),\n                    gf(),\n                    gf(),\n                    gf()\n                ];\n                if (n < 64) return -1;\n                if (unpackneg(q, pk)) return -1;\n                for(i = 0; i < n; i++)m[i] = sm[i];\n                for(i = 0; i < 32; i++)m[i + 32] = pk[i];\n                crypto_hash(h, m, n);\n                reduce(h);\n                scalarmult(p, q, h);\n                scalarbase(q, sm.subarray(32));\n                add(p, q);\n                pack(t, p);\n                n -= 64;\n                if (crypto_verify_32(sm, 0, t, 0)) {\n                    for(i = 0; i < n; i++)m[i] = 0;\n                    return -1;\n                }\n                for(i = 0; i < n; i++)m[i] = sm[i + 64];\n                return n;\n            }\n            var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;\n            nacl.lowlevel = {\n                crypto_core_hsalsa20: crypto_core_hsalsa20,\n                crypto_stream_xor: crypto_stream_xor,\n                crypto_stream: crypto_stream,\n                crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n                crypto_stream_salsa20: crypto_stream_salsa20,\n                crypto_onetimeauth: crypto_onetimeauth,\n                crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n                crypto_verify_16: crypto_verify_16,\n                crypto_verify_32: crypto_verify_32,\n                crypto_secretbox: crypto_secretbox,\n                crypto_secretbox_open: crypto_secretbox_open,\n                crypto_scalarmult: crypto_scalarmult,\n                crypto_scalarmult_base: crypto_scalarmult_base,\n                crypto_box_beforenm: crypto_box_beforenm,\n                crypto_box_afternm: crypto_box_afternm,\n                crypto_box: crypto_box,\n                crypto_box_open: crypto_box_open,\n                crypto_box_keypair: crypto_box_keypair,\n                crypto_hash: crypto_hash,\n                crypto_sign: crypto_sign,\n                crypto_sign_keypair: crypto_sign_keypair,\n                crypto_sign_open: crypto_sign_open,\n                crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n                crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n                crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n                crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n                crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n                crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n                crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n                crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n                crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n                crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n                crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n                crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n                crypto_sign_BYTES: crypto_sign_BYTES,\n                crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n                crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n                crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n                crypto_hash_BYTES: crypto_hash_BYTES,\n                gf: gf,\n                D: D,\n                L: L,\n                pack25519: pack25519,\n                unpack25519: unpack25519,\n                M: M,\n                A: A,\n                S: S,\n                Z: Z,\n                pow2523: pow2523,\n                add: add,\n                set25519: set25519,\n                modL: modL,\n                scalarmult: scalarmult,\n                scalarbase: scalarbase\n            };\n            /* High-level API */ function checkLengths(k, n) {\n                if (k.length !== crypto_secretbox_KEYBYTES) throw new Error(\"bad key size\");\n                if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error(\"bad nonce size\");\n            }\n            function checkBoxLengths(pk, sk) {\n                if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error(\"bad public key size\");\n                if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error(\"bad secret key size\");\n            }\n            function checkArrayTypes() {\n                for(var i = 0; i < arguments.length; i++){\n                    if (!(arguments[i] instanceof Uint8Array)) throw new TypeError(\"unexpected type, use Uint8Array\");\n                }\n            }\n            function cleanup(arr) {\n                for(var i = 0; i < arr.length; i++)arr[i] = 0;\n            }\n            nacl.randomBytes = function(n) {\n                var b = new Uint8Array(n);\n                randombytes(b, n);\n                return b;\n            };\n            nacl.secretbox = function(msg, nonce, key) {\n                checkArrayTypes(msg, nonce, key);\n                checkLengths(key, nonce);\n                var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n                var c = new Uint8Array(m.length);\n                for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n                crypto_secretbox(c, m, m.length, nonce, key);\n                return c.subarray(crypto_secretbox_BOXZEROBYTES);\n            };\n            nacl.secretbox.open = function(box, nonce, key) {\n                checkArrayTypes(box, nonce, key);\n                checkLengths(key, nonce);\n                var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n                var m = new Uint8Array(c.length);\n                for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n                if (c.length < 32) return null;\n                if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n                return m.subarray(crypto_secretbox_ZEROBYTES);\n            };\n            nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\n            nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\n            nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n            nacl.scalarMult = function(n, p) {\n                checkArrayTypes(n, p);\n                if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error(\"bad n size\");\n                if (p.length !== crypto_scalarmult_BYTES) throw new Error(\"bad p size\");\n                var q = new Uint8Array(crypto_scalarmult_BYTES);\n                crypto_scalarmult(q, n, p);\n                return q;\n            };\n            nacl.scalarMult.base = function(n) {\n                checkArrayTypes(n);\n                if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error(\"bad n size\");\n                var q = new Uint8Array(crypto_scalarmult_BYTES);\n                crypto_scalarmult_base(q, n);\n                return q;\n            };\n            nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\n            nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n            nacl.box = function(msg, nonce, publicKey, secretKey) {\n                var k = nacl.box.before(publicKey, secretKey);\n                return nacl.secretbox(msg, nonce, k);\n            };\n            nacl.box.before = function(publicKey, secretKey) {\n                checkArrayTypes(publicKey, secretKey);\n                checkBoxLengths(publicKey, secretKey);\n                var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n                crypto_box_beforenm(k, publicKey, secretKey);\n                return k;\n            };\n            nacl.box.after = nacl.secretbox;\n            nacl.box.open = function(msg, nonce, publicKey, secretKey) {\n                var k = nacl.box.before(publicKey, secretKey);\n                return nacl.secretbox.open(msg, nonce, k);\n            };\n            nacl.box.open.after = nacl.secretbox.open;\n            nacl.box.keyPair = function() {\n                var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n                var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n                crypto_box_keypair(pk, sk);\n                return {\n                    publicKey: pk,\n                    secretKey: sk\n                };\n            };\n            nacl.box.keyPair.fromSecretKey = function(secretKey) {\n                checkArrayTypes(secretKey);\n                if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error(\"bad secret key size\");\n                var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n                crypto_scalarmult_base(pk, secretKey);\n                return {\n                    publicKey: pk,\n                    secretKey: new Uint8Array(secretKey)\n                };\n            };\n            nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\n            nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\n            nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\n            nacl.box.nonceLength = crypto_box_NONCEBYTES;\n            nacl.box.overheadLength = nacl.secretbox.overheadLength;\n            nacl.sign = function(msg, secretKey) {\n                checkArrayTypes(msg, secretKey);\n                if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error(\"bad secret key size\");\n                var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);\n                crypto_sign(signedMsg, msg, msg.length, secretKey);\n                return signedMsg;\n            };\n            nacl.sign.open = function(signedMsg, publicKey) {\n                checkArrayTypes(signedMsg, publicKey);\n                if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error(\"bad public key size\");\n                var tmp = new Uint8Array(signedMsg.length);\n                var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n                if (mlen < 0) return null;\n                var m = new Uint8Array(mlen);\n                for(var i = 0; i < m.length; i++)m[i] = tmp[i];\n                return m;\n            };\n            nacl.sign.detached = function(msg, secretKey) {\n                var signedMsg = nacl.sign(msg, secretKey);\n                var sig = new Uint8Array(crypto_sign_BYTES);\n                for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];\n                return sig;\n            };\n            nacl.sign.detached.verify = function(msg, sig, publicKey) {\n                checkArrayTypes(msg, sig, publicKey);\n                if (sig.length !== crypto_sign_BYTES) throw new Error(\"bad signature size\");\n                if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error(\"bad public key size\");\n                var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n                var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n                var i;\n                for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];\n                for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];\n                return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n            };\n            nacl.sign.keyPair = function() {\n                var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n                var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n                crypto_sign_keypair(pk, sk);\n                return {\n                    publicKey: pk,\n                    secretKey: sk\n                };\n            };\n            nacl.sign.keyPair.fromSecretKey = function(secretKey) {\n                checkArrayTypes(secretKey);\n                if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error(\"bad secret key size\");\n                var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n                for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];\n                return {\n                    publicKey: pk,\n                    secretKey: new Uint8Array(secretKey)\n                };\n            };\n            nacl.sign.keyPair.fromSeed = function(seed) {\n                checkArrayTypes(seed);\n                if (seed.length !== crypto_sign_SEEDBYTES) throw new Error(\"bad seed size\");\n                var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n                var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n                for(var i = 0; i < 32; i++)sk[i] = seed[i];\n                crypto_sign_keypair(pk, sk, true);\n                return {\n                    publicKey: pk,\n                    secretKey: sk\n                };\n            };\n            nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\n            nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\n            nacl.sign.seedLength = crypto_sign_SEEDBYTES;\n            nacl.sign.signatureLength = crypto_sign_BYTES;\n            nacl.hash = function(msg) {\n                checkArrayTypes(msg);\n                var h = new Uint8Array(crypto_hash_BYTES);\n                crypto_hash(h, msg, msg.length);\n                return h;\n            };\n            nacl.hash.hashLength = crypto_hash_BYTES;\n            nacl.verify = function(x, y) {\n                checkArrayTypes(x, y);\n                // Zero length arguments are considered not equal.\n                if (x.length === 0 || y.length === 0) return false;\n                if (x.length !== y.length) return false;\n                return vn(x, 0, y, 0, x.length) === 0 ? true : false;\n            };\n            nacl.setPRNG = function(fn) {\n                randombytes = fn;\n            };\n            (function() {\n                // Initialize PRNG if environment provides CSPRNG.\n                // If not, methods calling randombytes will throw.\n                var crypto = typeof self !== \"undefined\" ? self.crypto || self.msCrypto : null;\n                if (crypto && crypto.getRandomValues) {\n                    // Browsers.\n                    var QUOTA = 65536;\n                    nacl.setPRNG(function(x, n) {\n                        var i, v = new Uint8Array(n);\n                        for(i = 0; i < n; i += QUOTA){\n                            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n                        }\n                        for(i = 0; i < n; i++)x[i] = v[i];\n                        cleanup(v);\n                    });\n                } else if (true) {\n                    // Node.js.\n                    crypto = __nested_webpack_require_98680__(3);\n                    if (crypto && crypto.randomBytes) {\n                        nacl.setPRNG(function(x, n) {\n                            var i, v = crypto.randomBytes(n);\n                            for(i = 0; i < n; i++)x[i] = v[i];\n                            cleanup(v);\n                        });\n                    }\n                }\n            })();\n        })( true && module1.exports ? module1.exports : self.nacl = self.nacl || {});\n    /***/ },\n    /* 21 */ /***/ function(module1, exports, __nested_webpack_require_196178__) {\n        module1.exports = __nested_webpack_require_196178__(47).default;\n    /***/ },\n    /* 22 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! buffer */ \"buffer\");\n    /***/ },\n    /* 23 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! events */ \"events\");\n    /***/ },\n    /* 24 */ /***/ function(module1, exports, __nested_webpack_require_196531__) {\n        \"use strict\";\n        /**\n\nStreams in a WebSocket connection\n---------------------------------\n\nWe model a WebSocket as two duplex streams: one stream is for the wire protocol\nover an I/O socket, and the other is for incoming/outgoing messages.\n\n\n                        +----------+      +---------+      +----------+\n    [1] write(chunk) -->| ~~~~~~~~ +----->| parse() +----->| ~~~~~~~~ +--> emit('data') [2]\n                        |          |      +----+----+      |          |\n                        |          |           |           |          |\n                        |    IO    |           | [5]       | Messages |\n                        |          |           V           |          |\n                        |          |      +---------+      |          |\n    [4] emit('data') <--+ ~~~~~~~~ |<-----+ frame() |<-----+ ~~~~~~~~ |<-- write(chunk) [3]\n                        +----------+      +---------+      +----------+\n\n\nMessage transfer in each direction is simple: IO receives a byte stream [1] and\nsends this stream for parsing. The parser will periodically emit a complete\nmessage text on the Messages stream [2]. Similarly, when messages are written\nto the Messages stream [3], they are framed using the WebSocket wire format and\nemitted via IO [4].\n\nThere is a feedback loop via [5] since some input from [1] will be things like\nping, pong and close frames. In these cases the protocol responds by emitting\nresponses directly back to [4] rather than emitting messages via [2].\n\nFor the purposes of flow control, we consider the sources of each Readable\nstream to be as follows:\n\n* [2] receives input from [1]\n* [4] receives input from [1] and [3]\n\nThe classes below express the relationships described above without prescribing\nanything about how parse() and frame() work, other than assuming they emit\n'data' events to the IO and Messages streams. They will work with any protocol\ndriver having these two methods.\n**/ var Stream = __nested_webpack_require_196531__(5).Stream, util = __nested_webpack_require_196531__(0);\n        var IO = function(driver) {\n            this.readable = this.writable = true;\n            this._paused = false;\n            this._driver = driver;\n        };\n        util.inherits(IO, Stream);\n        // The IO pause() and resume() methods will be called when the socket we are\n        // piping to gets backed up and drains. Since IO output [4] comes from IO input\n        // [1] and Messages input [3], we need to tell both of those to return false\n        // from write() when this stream is paused.\n        IO.prototype.pause = function() {\n            this._paused = true;\n            this._driver.messages._paused = true;\n        };\n        IO.prototype.resume = function() {\n            this._paused = false;\n            this.emit(\"drain\");\n            var messages = this._driver.messages;\n            messages._paused = false;\n            messages.emit(\"drain\");\n        };\n        // When we receive input from a socket, send it to the parser and tell the\n        // source whether to back off.\n        IO.prototype.write = function(chunk) {\n            if (!this.writable) return false;\n            this._driver.parse(chunk);\n            return !this._paused;\n        };\n        // The IO end() method will be called when the socket piping into it emits\n        // 'close' or 'end', i.e. the socket is closed. In this situation the Messages\n        // stream will not emit any more data so we emit 'end'.\n        IO.prototype.end = function(chunk) {\n            if (!this.writable) return;\n            if (chunk !== undefined) this.write(chunk);\n            this.writable = false;\n            var messages = this._driver.messages;\n            if (messages.readable) {\n                messages.readable = messages.writable = false;\n                messages.emit(\"end\");\n            }\n        };\n        IO.prototype.destroy = function() {\n            this.end();\n        };\n        var Messages = function(driver) {\n            this.readable = this.writable = true;\n            this._paused = false;\n            this._driver = driver;\n        };\n        util.inherits(Messages, Stream);\n        // The Messages pause() and resume() methods will be called when the app that's\n        // processing the messages gets backed up and drains. If we're emitting\n        // messages too fast we should tell the source to slow down. Message output [2]\n        // comes from IO input [1].\n        Messages.prototype.pause = function() {\n            this._driver.io._paused = true;\n        };\n        Messages.prototype.resume = function() {\n            this._driver.io._paused = false;\n            this._driver.io.emit(\"drain\");\n        };\n        // When we receive messages from the user, send them to the formatter and tell\n        // the source whether to back off.\n        Messages.prototype.write = function(message) {\n            if (!this.writable) return false;\n            if (typeof message === \"string\") this._driver.text(message);\n            else this._driver.binary(message);\n            return !this._paused;\n        };\n        // The Messages end() method will be called when a stream piping into it emits\n        // 'end'. Many streams may be piped into the WebSocket and one of them ending\n        // does not mean the whole socket is done, so just process the input and move\n        // on leaving the socket open.\n        Messages.prototype.end = function(message) {\n            if (message !== undefined) this.write(message);\n        };\n        Messages.prototype.destroy = function() {};\n        exports.IO = IO;\n        exports.Messages = Messages;\n    /***/ },\n    /* 25 */ /***/ function(module1, exports, __nested_webpack_require_202217__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_202217__(1).Buffer;\n        var StreamReader = function() {\n            this._queue = [];\n            this._queueSize = 0;\n            this._offset = 0;\n        };\n        StreamReader.prototype.put = function(buffer) {\n            if (!buffer || buffer.length === 0) return;\n            if (!Buffer1.isBuffer(buffer)) buffer = Buffer1.from(buffer);\n            this._queue.push(buffer);\n            this._queueSize += buffer.length;\n        };\n        StreamReader.prototype.read = function(length) {\n            if (length > this._queueSize) return null;\n            if (length === 0) return Buffer1.alloc(0);\n            this._queueSize -= length;\n            var queue = this._queue, remain = length, first = queue[0], buffers, buffer;\n            if (first.length >= length) {\n                if (first.length === length) {\n                    return queue.shift();\n                } else {\n                    buffer = first.slice(0, length);\n                    queue[0] = first.slice(length);\n                    return buffer;\n                }\n            }\n            for(var i = 0, n = queue.length; i < n; i++){\n                if (remain < queue[i].length) break;\n                remain -= queue[i].length;\n            }\n            buffers = queue.splice(0, i);\n            if (remain > 0 && queue.length > 0) {\n                buffers.push(queue[0].slice(0, remain));\n                queue[0] = queue[0].slice(remain);\n            }\n            return Buffer1.concat(buffers, length);\n        };\n        StreamReader.prototype.eachByte = function(callback, context) {\n            var buffer, n, index;\n            while(this._queue.length > 0){\n                buffer = this._queue[0];\n                n = buffer.length;\n                while(this._offset < n){\n                    index = this._offset;\n                    this._offset += 1;\n                    callback.call(context, buffer[index]);\n                }\n                this._offset = 0;\n                this._queue.shift();\n            }\n        };\n        module1.exports = StreamReader;\n    /***/ },\n    /* 26 */ /***/ function(module1, exports, __nested_webpack_require_204427__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_204427__(1).Buffer, crypto = __nested_webpack_require_204427__(3), url = __nested_webpack_require_204427__(6), util = __nested_webpack_require_204427__(0), HttpParser = __nested_webpack_require_204427__(10), Base = __nested_webpack_require_204427__(2), Hybi = __nested_webpack_require_204427__(12), Proxy = __nested_webpack_require_204427__(36);\n        var Client = function(_url, options) {\n            this.version = \"hybi-\" + Hybi.VERSION;\n            Hybi.call(this, null, _url, options);\n            this.readyState = -1;\n            this._key = Client.generateKey();\n            this._accept = Hybi.generateAccept(this._key);\n            this._http = new HttpParser(\"response\");\n            var uri = url.parse(this.url), auth = uri.auth && Buffer1.from(uri.auth, \"utf8\").toString(\"base64\");\n            if (this.VALID_PROTOCOLS.indexOf(uri.protocol) < 0) throw new Error(this.url + \" is not a valid WebSocket URL\");\n            this._pathname = (uri.pathname || \"/\") + (uri.search || \"\");\n            this._headers.set(\"Host\", uri.host);\n            this._headers.set(\"Upgrade\", \"websocket\");\n            this._headers.set(\"Connection\", \"Upgrade\");\n            this._headers.set(\"Sec-WebSocket-Key\", this._key);\n            this._headers.set(\"Sec-WebSocket-Version\", Hybi.VERSION);\n            if (this._protocols.length > 0) this._headers.set(\"Sec-WebSocket-Protocol\", this._protocols.join(\", \"));\n            if (auth) this._headers.set(\"Authorization\", \"Basic \" + auth);\n        };\n        util.inherits(Client, Hybi);\n        Client.generateKey = function() {\n            return crypto.randomBytes(16).toString(\"base64\");\n        };\n        var instance = {\n            VALID_PROTOCOLS: [\n                \"ws:\",\n                \"wss:\"\n            ],\n            proxy: function(origin, options) {\n                return new Proxy(this, origin, options);\n            },\n            start: function() {\n                if (this.readyState !== -1) return false;\n                this._write(this._handshakeRequest());\n                this.readyState = 0;\n                return true;\n            },\n            parse: function(chunk) {\n                if (this.readyState === 3) return;\n                if (this.readyState > 0) return Hybi.prototype.parse.call(this, chunk);\n                this._http.parse(chunk);\n                if (!this._http.isComplete()) return;\n                this._validateHandshake();\n                if (this.readyState === 3) return;\n                this._open();\n                this.parse(this._http.body);\n            },\n            _handshakeRequest: function() {\n                var extensions = this._extensions.generateOffer();\n                if (extensions) this._headers.set(\"Sec-WebSocket-Extensions\", extensions);\n                var start = \"GET \" + this._pathname + \" HTTP/1.1\", headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                return Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\");\n            },\n            _failHandshake: function(message) {\n                message = \"Error during WebSocket handshake: \" + message;\n                this.readyState = 3;\n                this.emit(\"error\", new Error(message));\n                this.emit(\"close\", new Base.CloseEvent(this.ERRORS.protocol_error, message));\n            },\n            _validateHandshake: function() {\n                this.statusCode = this._http.statusCode;\n                this.headers = this._http.headers;\n                if (this._http.error) return this._failHandshake(this._http.error.message);\n                if (this._http.statusCode !== 101) return this._failHandshake(\"Unexpected response code: \" + this._http.statusCode);\n                var headers = this._http.headers, upgrade = headers[\"upgrade\"] || \"\", connection = headers[\"connection\"] || \"\", accept = headers[\"sec-websocket-accept\"] || \"\", protocol = headers[\"sec-websocket-protocol\"] || \"\";\n                if (upgrade === \"\") return this._failHandshake(\"'Upgrade' header is missing\");\n                if (upgrade.toLowerCase() !== \"websocket\") return this._failHandshake(\"'Upgrade' header value is not 'WebSocket'\");\n                if (connection === \"\") return this._failHandshake(\"'Connection' header is missing\");\n                if (connection.toLowerCase() !== \"upgrade\") return this._failHandshake(\"'Connection' header value is not 'Upgrade'\");\n                if (accept !== this._accept) return this._failHandshake(\"Sec-WebSocket-Accept mismatch\");\n                this.protocol = null;\n                if (protocol !== \"\") {\n                    if (this._protocols.indexOf(protocol) < 0) return this._failHandshake(\"Sec-WebSocket-Protocol mismatch\");\n                    else this.protocol = protocol;\n                }\n                try {\n                    this._extensions.activate(this.headers[\"sec-websocket-extensions\"]);\n                } catch (e) {\n                    return this._failHandshake(e.message);\n                }\n            }\n        };\n        for(var key in instance)Client.prototype[key] = instance[key];\n        module1.exports = Client;\n    /***/ },\n    /* 27 */ /***/ function(module1, exports, __nested_webpack_require_209624__) {\n        /*jshint node:true */ var assert = __nested_webpack_require_209624__(28);\n        exports.HTTPParser = HTTPParser;\n        function HTTPParser(type) {\n            assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);\n            if (type === undefined) {\n            // Node v12+\n            } else {\n                this.initialize(type);\n            }\n            this.maxHeaderSize = HTTPParser.maxHeaderSize;\n        }\n        HTTPParser.prototype.initialize = function(type, async_resource) {\n            assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n            this.type = type;\n            this.state = type + \"_LINE\";\n            this.info = {\n                headers: [],\n                upgrade: false\n            };\n            this.trailers = [];\n            this.line = \"\";\n            this.isChunked = false;\n            this.connection = \"\";\n            this.headerSize = 0; // for preventing too big headers\n            this.body_bytes = null;\n            this.isUserCall = false;\n            this.hadError = false;\n        };\n        HTTPParser.encoding = \"ascii\";\n        HTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\n        HTTPParser.REQUEST = \"REQUEST\";\n        HTTPParser.RESPONSE = \"RESPONSE\";\n        // Note: *not* starting with kOnHeaders=0 line the Node parser, because any\n        //   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!\n        var kOnHeaders = HTTPParser.kOnHeaders = 1;\n        var kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;\n        var kOnBody = HTTPParser.kOnBody = 3;\n        var kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;\n        // Some handler stubs, needed for compatibility\n        HTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function() {};\n        var compatMode0_12 = true;\n        Object.defineProperty(HTTPParser, \"kOnExecute\", {\n            get: function() {\n                // hack for backward compatibility\n                compatMode0_12 = false;\n                return 99;\n            }\n        });\n        var methods = exports.methods = HTTPParser.methods = [\n            \"DELETE\",\n            \"GET\",\n            \"HEAD\",\n            \"POST\",\n            \"PUT\",\n            \"CONNECT\",\n            \"OPTIONS\",\n            \"TRACE\",\n            \"COPY\",\n            \"LOCK\",\n            \"MKCOL\",\n            \"MOVE\",\n            \"PROPFIND\",\n            \"PROPPATCH\",\n            \"SEARCH\",\n            \"UNLOCK\",\n            \"BIND\",\n            \"REBIND\",\n            \"UNBIND\",\n            \"ACL\",\n            \"REPORT\",\n            \"MKACTIVITY\",\n            \"CHECKOUT\",\n            \"MERGE\",\n            \"M-SEARCH\",\n            \"NOTIFY\",\n            \"SUBSCRIBE\",\n            \"UNSUBSCRIBE\",\n            \"PATCH\",\n            \"PURGE\",\n            \"MKCALENDAR\",\n            \"LINK\",\n            \"UNLINK\",\n            \"SOURCE\"\n        ];\n        var method_connect = methods.indexOf(\"CONNECT\");\n        HTTPParser.prototype.reinitialize = HTTPParser;\n        HTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function() {};\n        HTTPParser.prototype._compatMode0_11 = false;\n        HTTPParser.prototype.getAsyncId = function() {\n            return 0;\n        };\n        var headerState = {\n            REQUEST_LINE: true,\n            RESPONSE_LINE: true,\n            HEADER: true\n        };\n        HTTPParser.prototype.execute = function(chunk, start, length) {\n            if (!(this instanceof HTTPParser)) {\n                throw new TypeError(\"not a HTTPParser\");\n            }\n            // backward compat to node < 0.11.4\n            // Note: the start and length params were removed in newer version\n            start = start || 0;\n            length = typeof length === \"number\" ? length : chunk.length;\n            this.chunk = chunk;\n            this.offset = start;\n            var end = this.end = start + length;\n            try {\n                while(this.offset < end){\n                    if (this[this.state]()) {\n                        break;\n                    }\n                }\n            } catch (err) {\n                if (this.isUserCall) {\n                    throw err;\n                }\n                this.hadError = true;\n                return err;\n            }\n            this.chunk = null;\n            length = this.offset - start;\n            if (headerState[this.state]) {\n                this.headerSize += length;\n                if (this.headerSize > (this.maxHeaderSize || HTTPParser.maxHeaderSize)) {\n                    return new Error(\"max header size exceeded\");\n                }\n            }\n            return length;\n        };\n        var stateFinishAllowed = {\n            REQUEST_LINE: true,\n            RESPONSE_LINE: true,\n            BODY_RAW: true\n        };\n        HTTPParser.prototype.finish = function() {\n            if (this.hadError) {\n                return;\n            }\n            if (!stateFinishAllowed[this.state]) {\n                return new Error(\"invalid state for EOF\");\n            }\n            if (this.state === \"BODY_RAW\") {\n                this.userCall()(this[kOnMessageComplete]());\n            }\n        };\n        // These three methods are used for an internal speed optimization, and it also\n        // works if theses are noops. Basically consume() asks us to read the bytes\n        // ourselves, but if we don't do it we get them through execute().\n        HTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function() {};\n        //For correct error handling - see HTTPParser#execute\n        //Usage: this.userCall()(userFunction('arg'));\n        HTTPParser.prototype.userCall = function() {\n            this.isUserCall = true;\n            var self1 = this;\n            return function(ret) {\n                self1.isUserCall = false;\n                return ret;\n            };\n        };\n        HTTPParser.prototype.nextRequest = function() {\n            this.userCall()(this[kOnMessageComplete]());\n            this.reinitialize(this.type);\n        };\n        HTTPParser.prototype.consumeLine = function() {\n            var end = this.end, chunk = this.chunk;\n            for(var i = this.offset; i < end; i++){\n                if (chunk[i] === 0x0a) {\n                    var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);\n                    if (line.charAt(line.length - 1) === \"\\r\") {\n                        line = line.substr(0, line.length - 1);\n                    }\n                    this.line = \"\";\n                    this.offset = i + 1;\n                    return line;\n                }\n            }\n            //line split over multiple chunks\n            this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);\n            this.offset = this.end;\n        };\n        var headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\n        var headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\n        HTTPParser.prototype.parseHeader = function(line, headers) {\n            if (line.indexOf(\"\\r\") !== -1) {\n                throw parseErrorCode(\"HPE_LF_EXPECTED\");\n            }\n            var match = headerExp.exec(line);\n            var k = match && match[1];\n            if (k) {\n                headers.push(k);\n                headers.push(match[2]);\n            } else {\n                var matchContinue = headerContinueExp.exec(line);\n                if (matchContinue && headers.length) {\n                    if (headers[headers.length - 1]) {\n                        headers[headers.length - 1] += \" \";\n                    }\n                    headers[headers.length - 1] += matchContinue[1];\n                }\n            }\n        };\n        var requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\n        HTTPParser.prototype.REQUEST_LINE = function() {\n            var line = this.consumeLine();\n            if (!line) {\n                return;\n            }\n            var match = requestExp.exec(line);\n            if (match === null) {\n                throw parseErrorCode(\"HPE_INVALID_CONSTANT\");\n            }\n            this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n            if (this.info.method === -1) {\n                throw new Error(\"invalid request method\");\n            }\n            this.info.url = match[2];\n            this.info.versionMajor = +match[3];\n            this.info.versionMinor = +match[4];\n            this.body_bytes = 0;\n            this.state = \"HEADER\";\n        };\n        var responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n        HTTPParser.prototype.RESPONSE_LINE = function() {\n            var line = this.consumeLine();\n            if (!line) {\n                return;\n            }\n            var match = responseExp.exec(line);\n            if (match === null) {\n                throw parseErrorCode(\"HPE_INVALID_CONSTANT\");\n            }\n            this.info.versionMajor = +match[1];\n            this.info.versionMinor = +match[2];\n            var statusCode = this.info.statusCode = +match[3];\n            this.info.statusMessage = match[4];\n            // Implied zero length.\n            if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n                this.body_bytes = 0;\n            }\n            this.state = \"HEADER\";\n        };\n        HTTPParser.prototype.shouldKeepAlive = function() {\n            if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n                if (this.connection.indexOf(\"close\") !== -1) {\n                    return false;\n                }\n            } else if (this.connection.indexOf(\"keep-alive\") === -1) {\n                return false;\n            }\n            if (this.body_bytes !== null || this.isChunked) {\n                return true;\n            }\n            return false;\n        };\n        HTTPParser.prototype.HEADER = function() {\n            var line = this.consumeLine();\n            if (line === undefined) {\n                return;\n            }\n            var info = this.info;\n            if (line) {\n                this.parseHeader(line, info.headers);\n            } else {\n                var headers = info.headers;\n                var hasContentLength = false;\n                var currentContentLengthValue;\n                var hasUpgradeHeader = false;\n                for(var i = 0; i < headers.length; i += 2){\n                    switch(headers[i].toLowerCase()){\n                        case \"transfer-encoding\":\n                            this.isChunked = headers[i + 1].toLowerCase() === \"chunked\";\n                            break;\n                        case \"content-length\":\n                            currentContentLengthValue = +headers[i + 1];\n                            if (hasContentLength) {\n                                // Fix duplicate Content-Length header with same values.\n                                // Throw error only if values are different.\n                                // Known issues:\n                                // https://github.com/request/request/issues/2091#issuecomment-328715113\n                                // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n                                if (currentContentLengthValue !== this.body_bytes) {\n                                    throw parseErrorCode(\"HPE_UNEXPECTED_CONTENT_LENGTH\");\n                                }\n                            } else {\n                                hasContentLength = true;\n                                this.body_bytes = currentContentLengthValue;\n                            }\n                            break;\n                        case \"connection\":\n                            this.connection += headers[i + 1].toLowerCase();\n                            break;\n                        case \"upgrade\":\n                            hasUpgradeHeader = true;\n                            break;\n                    }\n                }\n                // if both isChunked and hasContentLength, isChunked wins\n                // This is required so the body is parsed using the chunked method, and matches\n                // Chrome's behavior.  We could, maybe, ignore them both (would get chunked\n                // encoding into the body), and/or disable shouldKeepAlive to be more\n                // resilient.\n                if (this.isChunked && hasContentLength) {\n                    hasContentLength = false;\n                    this.body_bytes = null;\n                }\n                // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737\n                // \"For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n                //   mandatory only when it is a 101 Switching Protocols response,\n                //   otherwise it is purely informational, to announce support.\n                if (hasUpgradeHeader && this.connection.indexOf(\"upgrade\") != -1) {\n                    info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;\n                } else {\n                    info.upgrade = info.method === method_connect;\n                }\n                if (this.isChunked && info.upgrade) {\n                    this.isChunked = false;\n                }\n                info.shouldKeepAlive = this.shouldKeepAlive();\n                //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n                var skipBody;\n                if (compatMode0_12) {\n                    skipBody = this.userCall()(this[kOnHeadersComplete](info));\n                } else {\n                    skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));\n                }\n                if (skipBody === 2) {\n                    this.nextRequest();\n                    return true;\n                } else if (this.isChunked && !skipBody) {\n                    this.state = \"BODY_CHUNKHEAD\";\n                } else if (skipBody || this.body_bytes === 0) {\n                    this.nextRequest();\n                    // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,\n                    //   need this \"return true;\" if it's an upgrade request.\n                    return info.upgrade;\n                } else if (this.body_bytes === null) {\n                    this.state = \"BODY_RAW\";\n                } else {\n                    this.state = \"BODY_SIZED\";\n                }\n            }\n        };\n        HTTPParser.prototype.BODY_CHUNKHEAD = function() {\n            var line = this.consumeLine();\n            if (line === undefined) {\n                return;\n            }\n            this.body_bytes = parseInt(line, 16);\n            if (!this.body_bytes) {\n                this.state = \"BODY_CHUNKTRAILERS\";\n            } else {\n                this.state = \"BODY_CHUNK\";\n            }\n        };\n        HTTPParser.prototype.BODY_CHUNK = function() {\n            var length = Math.min(this.end - this.offset, this.body_bytes);\n            this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n            this.offset += length;\n            this.body_bytes -= length;\n            if (!this.body_bytes) {\n                this.state = \"BODY_CHUNKEMPTYLINE\";\n            }\n        };\n        HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function() {\n            var line = this.consumeLine();\n            if (line === undefined) {\n                return;\n            }\n            assert.equal(line, \"\");\n            this.state = \"BODY_CHUNKHEAD\";\n        };\n        HTTPParser.prototype.BODY_CHUNKTRAILERS = function() {\n            var line = this.consumeLine();\n            if (line === undefined) {\n                return;\n            }\n            if (line) {\n                this.parseHeader(line, this.trailers);\n            } else {\n                if (this.trailers.length) {\n                    this.userCall()(this[kOnHeaders](this.trailers, \"\"));\n                }\n                this.nextRequest();\n            }\n        };\n        HTTPParser.prototype.BODY_RAW = function() {\n            var length = this.end - this.offset;\n            this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n            this.offset = this.end;\n        };\n        HTTPParser.prototype.BODY_SIZED = function() {\n            var length = Math.min(this.end - this.offset, this.body_bytes);\n            this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n            this.offset += length;\n            this.body_bytes -= length;\n            if (!this.body_bytes) {\n                this.nextRequest();\n            }\n        };\n        // backward compat to node < 0.11.6\n        [\n            \"Headers\",\n            \"HeadersComplete\",\n            \"Body\",\n            \"MessageComplete\"\n        ].forEach(function(name) {\n            var k = HTTPParser[\"kOn\" + name];\n            Object.defineProperty(HTTPParser.prototype, \"on\" + name, {\n                get: function() {\n                    return this[k];\n                },\n                set: function(to) {\n                    // hack for backward compatibility\n                    this._compatMode0_11 = true;\n                    method_connect = \"CONNECT\";\n                    return this[k] = to;\n                }\n            });\n        });\n        function parseErrorCode(code) {\n            var err = new Error(\"Parse Error\");\n            err.code = code;\n            return err;\n        }\n    /***/ },\n    /* 28 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! assert */ \"assert\");\n    /***/ },\n    /* 29 */ /***/ function(module1, exports, __nested_webpack_require_227690__) {\n        \"use strict\";\n        var Parser = __nested_webpack_require_227690__(30), Pipeline = __nested_webpack_require_227690__(31);\n        var Extensions = function() {\n            this._rsv1 = this._rsv2 = this._rsv3 = null;\n            this._byName = {};\n            this._inOrder = [];\n            this._sessions = [];\n            this._index = {};\n        };\n        Extensions.MESSAGE_OPCODES = [\n            1,\n            2\n        ];\n        var instance = {\n            add: function(ext) {\n                if (typeof ext.name !== \"string\") throw new TypeError(\"extension.name must be a string\");\n                if (ext.type !== \"permessage\") throw new TypeError('extension.type must be \"permessage\"');\n                if (typeof ext.rsv1 !== \"boolean\") throw new TypeError(\"extension.rsv1 must be true or false\");\n                if (typeof ext.rsv2 !== \"boolean\") throw new TypeError(\"extension.rsv2 must be true or false\");\n                if (typeof ext.rsv3 !== \"boolean\") throw new TypeError(\"extension.rsv3 must be true or false\");\n                if (this._byName.hasOwnProperty(ext.name)) throw new TypeError('An extension with name \"' + ext.name + '\" is already registered');\n                this._byName[ext.name] = ext;\n                this._inOrder.push(ext);\n            },\n            generateOffer: function() {\n                var sessions = [], offer = [], index = {};\n                this._inOrder.forEach(function(ext) {\n                    var session = ext.createClientSession();\n                    if (!session) return;\n                    var record = [\n                        ext,\n                        session\n                    ];\n                    sessions.push(record);\n                    index[ext.name] = record;\n                    var offers = session.generateOffer();\n                    offers = offers ? [].concat(offers) : [];\n                    offers.forEach(function(off) {\n                        offer.push(Parser.serializeParams(ext.name, off));\n                    }, this);\n                }, this);\n                this._sessions = sessions;\n                this._index = index;\n                return offer.length > 0 ? offer.join(\", \") : null;\n            },\n            activate: function(header) {\n                var responses = Parser.parseHeader(header), sessions = [];\n                responses.eachOffer(function(name, params) {\n                    var record = this._index[name];\n                    if (!record) throw new Error('Server sent an extension response for unknown extension \"' + name + '\"');\n                    var ext = record[0], session = record[1], reserved = this._reserved(ext);\n                    if (reserved) throw new Error(\"Server sent two extension responses that use the RSV\" + reserved[0] + ' bit: \"' + reserved[1] + '\" and \"' + ext.name + '\"');\n                    if (session.activate(params) !== true) throw new Error(\"Server sent unacceptable extension parameters: \" + Parser.serializeParams(name, params));\n                    this._reserve(ext);\n                    sessions.push(record);\n                }, this);\n                this._sessions = sessions;\n                this._pipeline = new Pipeline(sessions);\n            },\n            generateResponse: function(header) {\n                var sessions = [], response = [], offers = Parser.parseHeader(header);\n                this._inOrder.forEach(function(ext) {\n                    var offer = offers.byName(ext.name);\n                    if (offer.length === 0 || this._reserved(ext)) return;\n                    var session = ext.createServerSession(offer);\n                    if (!session) return;\n                    this._reserve(ext);\n                    sessions.push([\n                        ext,\n                        session\n                    ]);\n                    response.push(Parser.serializeParams(ext.name, session.generateResponse()));\n                }, this);\n                this._sessions = sessions;\n                this._pipeline = new Pipeline(sessions);\n                return response.length > 0 ? response.join(\", \") : null;\n            },\n            validFrameRsv: function(frame) {\n                var allowed = {\n                    rsv1: false,\n                    rsv2: false,\n                    rsv3: false\n                }, ext;\n                if (Extensions.MESSAGE_OPCODES.indexOf(frame.opcode) >= 0) {\n                    for(var i = 0, n = this._sessions.length; i < n; i++){\n                        ext = this._sessions[i][0];\n                        allowed.rsv1 = allowed.rsv1 || ext.rsv1;\n                        allowed.rsv2 = allowed.rsv2 || ext.rsv2;\n                        allowed.rsv3 = allowed.rsv3 || ext.rsv3;\n                    }\n                }\n                return (allowed.rsv1 || !frame.rsv1) && (allowed.rsv2 || !frame.rsv2) && (allowed.rsv3 || !frame.rsv3);\n            },\n            processIncomingMessage: function(message, callback, context) {\n                this._pipeline.processIncomingMessage(message, callback, context);\n            },\n            processOutgoingMessage: function(message, callback, context) {\n                this._pipeline.processOutgoingMessage(message, callback, context);\n            },\n            close: function(callback, context) {\n                if (!this._pipeline) return callback.call(context);\n                this._pipeline.close(callback, context);\n            },\n            _reserve: function(ext) {\n                this._rsv1 = this._rsv1 || ext.rsv1 && ext.name;\n                this._rsv2 = this._rsv2 || ext.rsv2 && ext.name;\n                this._rsv3 = this._rsv3 || ext.rsv3 && ext.name;\n            },\n            _reserved: function(ext) {\n                if (this._rsv1 && ext.rsv1) return [\n                    1,\n                    this._rsv1\n                ];\n                if (this._rsv2 && ext.rsv2) return [\n                    2,\n                    this._rsv2\n                ];\n                if (this._rsv3 && ext.rsv3) return [\n                    3,\n                    this._rsv3\n                ];\n                return false;\n            }\n        };\n        for(var key in instance)Extensions.prototype[key] = instance[key];\n        module1.exports = Extensions;\n    /***/ },\n    /* 30 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var TOKEN = /([!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+)/, NOTOKEN = /([^!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z])/g, QUOTED = /\"((?:\\\\[\\x00-\\x7f]|[^\\x00-\\x08\\x0a-\\x1f\\x7f\"\\\\])*)\"/, PARAM = new RegExp(TOKEN.source + \"(?:=(?:\" + TOKEN.source + \"|\" + QUOTED.source + \"))?\"), EXT = new RegExp(TOKEN.source + \"(?: *; *\" + PARAM.source + \")*\", \"g\"), EXT_LIST = new RegExp(\"^\" + EXT.source + \"(?: *, *\" + EXT.source + \")*$\"), NUMBER = /^-?(0|[1-9][0-9]*)(\\.[0-9]+)?$/;\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var Parser = {\n            parseHeader: function(header) {\n                var offers = new Offers();\n                if (header === \"\" || header === undefined) return offers;\n                if (!EXT_LIST.test(header)) throw new SyntaxError(\"Invalid Sec-WebSocket-Extensions header: \" + header);\n                var values = header.match(EXT);\n                values.forEach(function(value) {\n                    var params = value.match(new RegExp(PARAM.source, \"g\")), name = params.shift(), offer = {};\n                    params.forEach(function(param) {\n                        var args = param.match(PARAM), key = args[1], data;\n                        if (args[2] !== undefined) {\n                            data = args[2];\n                        } else if (args[3] !== undefined) {\n                            data = args[3].replace(/\\\\/g, \"\");\n                        } else {\n                            data = true;\n                        }\n                        if (NUMBER.test(data)) data = parseFloat(data);\n                        if (hasOwnProperty.call(offer, key)) {\n                            offer[key] = [].concat(offer[key]);\n                            offer[key].push(data);\n                        } else {\n                            offer[key] = data;\n                        }\n                    }, this);\n                    offers.push(name, offer);\n                }, this);\n                return offers;\n            },\n            serializeParams: function(name, params) {\n                var values = [];\n                var print = function(key, value) {\n                    if (value instanceof Array) {\n                        value.forEach(function(v) {\n                            print(key, v);\n                        });\n                    } else if (value === true) {\n                        values.push(key);\n                    } else if (typeof value === \"number\") {\n                        values.push(key + \"=\" + value);\n                    } else if (NOTOKEN.test(value)) {\n                        values.push(key + '=\"' + value.replace(/\"/g, '\\\\\"') + '\"');\n                    } else {\n                        values.push(key + \"=\" + value);\n                    }\n                };\n                for(var key in params)print(key, params[key]);\n                return [\n                    name\n                ].concat(values).join(\"; \");\n            }\n        };\n        var Offers = function() {\n            this._byName = {};\n            this._inOrder = [];\n        };\n        Offers.prototype.push = function(name, params) {\n            if (!hasOwnProperty.call(this._byName, name)) this._byName[name] = [];\n            this._byName[name].push(params);\n            this._inOrder.push({\n                name: name,\n                params: params\n            });\n        };\n        Offers.prototype.eachOffer = function(callback, context) {\n            var list = this._inOrder;\n            for(var i = 0, n = list.length; i < n; i++)callback.call(context, list[i].name, list[i].params);\n        };\n        Offers.prototype.byName = function(name) {\n            return this._byName[name] || [];\n        };\n        Offers.prototype.toArray = function() {\n            return this._inOrder.slice();\n        };\n        module1.exports = Parser;\n    /***/ },\n    /* 31 */ /***/ function(module1, exports, __nested_webpack_require_237960__) {\n        \"use strict\";\n        var Cell = __nested_webpack_require_237960__(32), Pledge = __nested_webpack_require_237960__(14);\n        var Pipeline = function(sessions) {\n            this._cells = sessions.map(function(session) {\n                return new Cell(session);\n            });\n            this._stopped = {\n                incoming: false,\n                outgoing: false\n            };\n        };\n        Pipeline.prototype.processIncomingMessage = function(message, callback, context) {\n            if (this._stopped.incoming) return;\n            this._loop(\"incoming\", this._cells.length - 1, -1, -1, message, callback, context);\n        };\n        Pipeline.prototype.processOutgoingMessage = function(message, callback, context) {\n            if (this._stopped.outgoing) return;\n            this._loop(\"outgoing\", 0, this._cells.length, 1, message, callback, context);\n        };\n        Pipeline.prototype.close = function(callback, context) {\n            this._stopped = {\n                incoming: true,\n                outgoing: true\n            };\n            var closed = this._cells.map(function(a) {\n                return a.close();\n            });\n            if (callback) Pledge.all(closed).then(function() {\n                callback.call(context);\n            });\n        };\n        Pipeline.prototype._loop = function(direction, start, end, step, message, callback, context) {\n            var cells = this._cells, n = cells.length, self1 = this;\n            while(n--)cells[n].pending(direction);\n            var pipe = function(index, error, msg) {\n                if (index === end) return callback.call(context, error, msg);\n                cells[index][direction](error, msg, function(err, m) {\n                    if (err) self1._stopped[direction] = true;\n                    pipe(index + step, err, m);\n                });\n            };\n            pipe(start, null, message);\n        };\n        module1.exports = Pipeline;\n    /***/ },\n    /* 32 */ /***/ function(module1, exports, __nested_webpack_require_239976__) {\n        \"use strict\";\n        var Functor = __nested_webpack_require_239976__(33), Pledge = __nested_webpack_require_239976__(14);\n        var Cell = function(tuple) {\n            this._ext = tuple[0];\n            this._session = tuple[1];\n            this._functors = {\n                incoming: new Functor(this._session, \"processIncomingMessage\"),\n                outgoing: new Functor(this._session, \"processOutgoingMessage\")\n            };\n        };\n        Cell.prototype.pending = function(direction) {\n            var functor = this._functors[direction];\n            if (!functor._stopped) functor.pending += 1;\n        };\n        Cell.prototype.incoming = function(error, message, callback, context) {\n            this._exec(\"incoming\", error, message, callback, context);\n        };\n        Cell.prototype.outgoing = function(error, message, callback, context) {\n            this._exec(\"outgoing\", error, message, callback, context);\n        };\n        Cell.prototype.close = function() {\n            this._closed = this._closed || new Pledge();\n            this._doClose();\n            return this._closed;\n        };\n        Cell.prototype._exec = function(direction, error, message, callback, context) {\n            this._functors[direction].call(error, message, function(err, msg) {\n                if (err) err.message = this._ext.name + \": \" + err.message;\n                callback.call(context, err, msg);\n                this._doClose();\n            }, this);\n        };\n        Cell.prototype._doClose = function() {\n            var fin = this._functors.incoming, fout = this._functors.outgoing;\n            if (!this._closed || fin.pending + fout.pending !== 0) return;\n            if (this._session) this._session.close();\n            this._session = null;\n            this._closed.done();\n        };\n        module1.exports = Cell;\n    /***/ },\n    /* 33 */ /***/ function(module1, exports, __nested_webpack_require_241885__) {\n        \"use strict\";\n        var RingBuffer = __nested_webpack_require_241885__(13);\n        var Functor = function(session, method) {\n            this._session = session;\n            this._method = method;\n            this._queue = new RingBuffer(Functor.QUEUE_SIZE);\n            this._stopped = false;\n            this.pending = 0;\n        };\n        Functor.QUEUE_SIZE = 8;\n        Functor.prototype.call = function(error, message, callback, context) {\n            if (this._stopped) return;\n            var record = {\n                error: error,\n                message: message,\n                callback: callback,\n                context: context,\n                done: false\n            }, called = false, self1 = this;\n            this._queue.push(record);\n            if (record.error) {\n                record.done = true;\n                this._stop();\n                return this._flushQueue();\n            }\n            var handler = function(err, msg) {\n                if (!(called ^ (called = true))) return;\n                if (err) {\n                    self1._stop();\n                    record.error = err;\n                    record.message = null;\n                } else {\n                    record.message = msg;\n                }\n                record.done = true;\n                self1._flushQueue();\n            };\n            try {\n                this._session[this._method](message, handler);\n            } catch (err) {\n                handler(err);\n            }\n        };\n        Functor.prototype._stop = function() {\n            this.pending = this._queue.length;\n            this._stopped = true;\n        };\n        Functor.prototype._flushQueue = function() {\n            var queue = this._queue, record;\n            while(queue.length > 0 && queue.peek().done){\n                record = queue.shift();\n                if (record.error) {\n                    this.pending = 0;\n                    queue.clear();\n                } else {\n                    this.pending -= 1;\n                }\n                record.callback.call(record.context, record.error, record.message);\n            }\n        };\n        module1.exports = Functor;\n    /***/ },\n    /* 34 */ /***/ function(module1, exports, __webpack_require__) {\n        \"use strict\";\n        var Frame = function() {};\n        var instance = {\n            final: false,\n            rsv1: false,\n            rsv2: false,\n            rsv3: false,\n            opcode: null,\n            masked: false,\n            maskingKey: null,\n            lengthBytes: 1,\n            length: 0,\n            payload: null\n        };\n        for(var key in instance)Frame.prototype[key] = instance[key];\n        module1.exports = Frame;\n    /***/ },\n    /* 35 */ /***/ function(module1, exports, __nested_webpack_require_244671__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_244671__(1).Buffer;\n        var Message = function() {\n            this.rsv1 = false;\n            this.rsv2 = false;\n            this.rsv3 = false;\n            this.opcode = null;\n            this.length = 0;\n            this._chunks = [];\n        };\n        var instance = {\n            read: function() {\n                return this.data = this.data || Buffer1.concat(this._chunks, this.length);\n            },\n            pushFrame: function(frame) {\n                this.rsv1 = this.rsv1 || frame.rsv1;\n                this.rsv2 = this.rsv2 || frame.rsv2;\n                this.rsv3 = this.rsv3 || frame.rsv3;\n                if (this.opcode === null) this.opcode = frame.opcode;\n                this._chunks.push(frame.payload);\n                this.length += frame.length;\n            }\n        };\n        for(var key in instance)Message.prototype[key] = instance[key];\n        module1.exports = Message;\n    /***/ },\n    /* 36 */ /***/ function(module1, exports, __nested_webpack_require_245718__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_245718__(1).Buffer, Stream = __nested_webpack_require_245718__(5).Stream, url = __nested_webpack_require_245718__(6), util = __nested_webpack_require_245718__(0), Base = __nested_webpack_require_245718__(2), Headers = __nested_webpack_require_245718__(9), HttpParser = __nested_webpack_require_245718__(10);\n        var PORTS = {\n            \"ws:\": 80,\n            \"wss:\": 443\n        };\n        var Proxy = function(client, origin, options) {\n            this._client = client;\n            this._http = new HttpParser(\"response\");\n            this._origin = typeof client.url === \"object\" ? client.url : url.parse(client.url);\n            this._url = typeof origin === \"object\" ? origin : url.parse(origin);\n            this._options = options || {};\n            this._state = 0;\n            this.readable = this.writable = true;\n            this._paused = false;\n            this._headers = new Headers();\n            this._headers.set(\"Host\", this._origin.host);\n            this._headers.set(\"Connection\", \"keep-alive\");\n            this._headers.set(\"Proxy-Connection\", \"keep-alive\");\n            var auth = this._url.auth && Buffer1.from(this._url.auth, \"utf8\").toString(\"base64\");\n            if (auth) this._headers.set(\"Proxy-Authorization\", \"Basic \" + auth);\n        };\n        util.inherits(Proxy, Stream);\n        var instance = {\n            setHeader: function(name, value) {\n                if (this._state !== 0) return false;\n                this._headers.set(name, value);\n                return true;\n            },\n            start: function() {\n                if (this._state !== 0) return false;\n                this._state = 1;\n                var origin = this._origin, port = origin.port || PORTS[origin.protocol], start = \"CONNECT \" + origin.hostname + \":\" + port + \" HTTP/1.1\";\n                var headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                this.emit(\"data\", Buffer1.from(headers.join(\"\\r\\n\"), \"utf8\"));\n                return true;\n            },\n            pause: function() {\n                this._paused = true;\n            },\n            resume: function() {\n                this._paused = false;\n                this.emit(\"drain\");\n            },\n            write: function(chunk) {\n                if (!this.writable) return false;\n                this._http.parse(chunk);\n                if (!this._http.isComplete()) return !this._paused;\n                this.statusCode = this._http.statusCode;\n                this.headers = this._http.headers;\n                if (this.statusCode === 200) {\n                    this.emit(\"connect\", new Base.ConnectEvent());\n                } else {\n                    var message = \"Can't establish a connection to the server at \" + this._origin.href;\n                    this.emit(\"error\", new Error(message));\n                }\n                this.end();\n                return !this._paused;\n            },\n            end: function(chunk) {\n                if (!this.writable) return;\n                if (chunk !== undefined) this.write(chunk);\n                this.readable = this.writable = false;\n                this.emit(\"close\");\n                this.emit(\"end\");\n            },\n            destroy: function() {\n                this.end();\n            }\n        };\n        for(var key in instance)Proxy.prototype[key] = instance[key];\n        module1.exports = Proxy;\n    /***/ },\n    /* 37 */ /***/ function(module1, exports, __nested_webpack_require_249229__) {\n        \"use strict\";\n        var util = __nested_webpack_require_249229__(0), HttpParser = __nested_webpack_require_249229__(10), Base = __nested_webpack_require_249229__(2), Draft75 = __nested_webpack_require_249229__(15), Draft76 = __nested_webpack_require_249229__(38), Hybi = __nested_webpack_require_249229__(12);\n        var Server = function(options) {\n            Base.call(this, null, null, options);\n            this._http = new HttpParser(\"request\");\n        };\n        util.inherits(Server, Base);\n        var instance = {\n            EVENTS: [\n                \"open\",\n                \"message\",\n                \"error\",\n                \"close\",\n                \"ping\",\n                \"pong\"\n            ],\n            _bindEventListeners: function() {\n                this.messages.on(\"error\", function() {});\n                this.on(\"error\", function() {});\n            },\n            parse: function(chunk) {\n                if (this._delegate) return this._delegate.parse(chunk);\n                this._http.parse(chunk);\n                if (!this._http.isComplete()) return;\n                this.method = this._http.method;\n                this.url = this._http.url;\n                this.headers = this._http.headers;\n                this.body = this._http.body;\n                var self1 = this;\n                this._delegate = Server.http(this, this._options);\n                this._delegate.messages = this.messages;\n                this._delegate.io = this.io;\n                this._open();\n                this.EVENTS.forEach(function(event) {\n                    this._delegate.on(event, function(e) {\n                        self1.emit(event, e);\n                    });\n                }, this);\n                this.protocol = this._delegate.protocol;\n                this.version = this._delegate.version;\n                this.parse(this._http.body);\n                this.emit(\"connect\", new Base.ConnectEvent());\n            },\n            _open: function() {\n                this.__queue.forEach(function(msg) {\n                    this._delegate[msg[0]].apply(this._delegate, msg[1]);\n                }, this);\n                this.__queue = [];\n            }\n        };\n        [\n            \"addExtension\",\n            \"setHeader\",\n            \"start\",\n            \"frame\",\n            \"text\",\n            \"binary\",\n            \"ping\",\n            \"close\"\n        ].forEach(function(method) {\n            instance[method] = function() {\n                if (this._delegate) {\n                    return this._delegate[method].apply(this._delegate, arguments);\n                } else {\n                    this.__queue.push([\n                        method,\n                        arguments\n                    ]);\n                    return true;\n                }\n            };\n        });\n        for(var key in instance)Server.prototype[key] = instance[key];\n        Server.isSecureRequest = function(request) {\n            if (request.connection && request.connection.authorized !== undefined) return true;\n            if (request.socket && request.socket.secure) return true;\n            var headers = request.headers;\n            if (!headers) return false;\n            if (headers[\"https\"] === \"on\") return true;\n            if (headers[\"x-forwarded-ssl\"] === \"on\") return true;\n            if (headers[\"x-forwarded-scheme\"] === \"https\") return true;\n            if (headers[\"x-forwarded-proto\"] === \"https\") return true;\n            return false;\n        };\n        Server.determineUrl = function(request) {\n            var scheme = this.isSecureRequest(request) ? \"wss:\" : \"ws:\";\n            return scheme + \"//\" + request.headers.host + request.url;\n        };\n        Server.http = function(request, options) {\n            options = options || {};\n            if (options.requireMasking === undefined) options.requireMasking = true;\n            var headers = request.headers, version = headers[\"sec-websocket-version\"], key = headers[\"sec-websocket-key\"], key1 = headers[\"sec-websocket-key1\"], key2 = headers[\"sec-websocket-key2\"], url = this.determineUrl(request);\n            if (version || key) return new Hybi(request, url, options);\n            else if (key1 || key2) return new Draft76(request, url, options);\n            else return new Draft75(request, url, options);\n        };\n        module1.exports = Server;\n    /***/ },\n    /* 38 */ /***/ function(module1, exports, __nested_webpack_require_253594__) {\n        \"use strict\";\n        var Buffer1 = __nested_webpack_require_253594__(1).Buffer, Base = __nested_webpack_require_253594__(2), Draft75 = __nested_webpack_require_253594__(15), crypto = __nested_webpack_require_253594__(3), util = __nested_webpack_require_253594__(0);\n        var numberFromKey = function(key) {\n            return parseInt((key.match(/[0-9]/g) || []).join(\"\"), 10);\n        };\n        var spacesInKey = function(key) {\n            return (key.match(/ /g) || []).length;\n        };\n        var Draft76 = function(request, url, options) {\n            Draft75.apply(this, arguments);\n            this._stage = -1;\n            this._body = [];\n            this.version = \"hixie-76\";\n            this._headers.clear();\n            this._headers.set(\"Upgrade\", \"WebSocket\");\n            this._headers.set(\"Connection\", \"Upgrade\");\n            this._headers.set(\"Sec-WebSocket-Origin\", this._request.headers.origin);\n            this._headers.set(\"Sec-WebSocket-Location\", this.url);\n        };\n        util.inherits(Draft76, Draft75);\n        var instance = {\n            BODY_SIZE: 8,\n            start: function() {\n                if (!Draft75.prototype.start.call(this)) return false;\n                this._started = true;\n                this._sendHandshakeBody();\n                return true;\n            },\n            close: function() {\n                if (this.readyState === 3) return false;\n                if (this.readyState === 1) this._write(Buffer1.from([\n                    0xFF,\n                    0x00\n                ]));\n                this.readyState = 3;\n                this.emit(\"close\", new Base.CloseEvent(null, null));\n                return true;\n            },\n            _handshakeResponse: function() {\n                var headers = this._request.headers, key1 = headers[\"sec-websocket-key1\"], key2 = headers[\"sec-websocket-key2\"];\n                if (!key1) throw new Error(\"Missing required header: Sec-WebSocket-Key1\");\n                if (!key2) throw new Error(\"Missing required header: Sec-WebSocket-Key2\");\n                var number1 = numberFromKey(key1), spaces1 = spacesInKey(key1), number2 = numberFromKey(key2), spaces2 = spacesInKey(key2);\n                if (number1 % spaces1 !== 0 || number2 % spaces2 !== 0) throw new Error(\"Client sent invalid Sec-WebSocket-Key headers\");\n                this._keyValues = [\n                    number1 / spaces1,\n                    number2 / spaces2\n                ];\n                var start = \"HTTP/1.1 101 WebSocket Protocol Handshake\", headers = [\n                    start,\n                    this._headers.toString(),\n                    \"\"\n                ];\n                return Buffer1.from(headers.join(\"\\r\\n\"), \"binary\");\n            },\n            _handshakeSignature: function() {\n                if (this._body.length < this.BODY_SIZE) return null;\n                var md5 = crypto.createHash(\"md5\"), buffer = Buffer1.allocUnsafe(8 + this.BODY_SIZE);\n                buffer.writeUInt32BE(this._keyValues[0], 0);\n                buffer.writeUInt32BE(this._keyValues[1], 4);\n                Buffer1.from(this._body).copy(buffer, 8, 0, this.BODY_SIZE);\n                md5.update(buffer);\n                return Buffer1.from(md5.digest(\"binary\"), \"binary\");\n            },\n            _sendHandshakeBody: function() {\n                if (!this._started) return;\n                var signature = this._handshakeSignature();\n                if (!signature) return;\n                this._write(signature);\n                this._stage = 0;\n                this._open();\n                if (this._body.length > this.BODY_SIZE) this.parse(this._body.slice(this.BODY_SIZE));\n            },\n            _parseLeadingByte: function(octet) {\n                if (octet !== 0xFF) return Draft75.prototype._parseLeadingByte.call(this, octet);\n                this._closing = true;\n                this._length = 0;\n                this._stage = 1;\n            }\n        };\n        for(var key in instance)Draft76.prototype[key] = instance[key];\n        module1.exports = Draft76;\n    /***/ },\n    /* 39 */ /***/ function(module1, exports, __nested_webpack_require_257698__) {\n        \"use strict\";\n        var util = __nested_webpack_require_257698__(0), net = __nested_webpack_require_257698__(40), tls = __nested_webpack_require_257698__(41), url = __nested_webpack_require_257698__(6), driver = __nested_webpack_require_257698__(4), API = __nested_webpack_require_257698__(11), Event = __nested_webpack_require_257698__(7);\n        var DEFAULT_PORTS = {\n            \"http:\": 80,\n            \"https:\": 443,\n            \"ws:\": 80,\n            \"wss:\": 443\n        }, SECURE_PROTOCOLS = [\n            \"https:\",\n            \"wss:\"\n        ];\n        var Client = function(_url, protocols, options) {\n            options = options || {};\n            this.url = _url;\n            this._driver = driver.client(this.url, {\n                maxLength: options.maxLength,\n                protocols: protocols\n            });\n            [\n                \"open\",\n                \"error\"\n            ].forEach(function(event) {\n                this._driver.on(event, function() {\n                    self1.headers = self1._driver.headers;\n                    self1.statusCode = self1._driver.statusCode;\n                });\n            }, this);\n            var proxy = options.proxy || {}, endpoint = url.parse(proxy.origin || this.url), port = endpoint.port || DEFAULT_PORTS[endpoint.protocol], secure = SECURE_PROTOCOLS.indexOf(endpoint.protocol) >= 0, onConnect = function() {\n                self1._onConnect();\n            }, netOptions = options.net || {}, originTLS = options.tls || {}, socketTLS = proxy.origin ? proxy.tls || {} : originTLS, self1 = this;\n            netOptions.host = socketTLS.host = endpoint.hostname;\n            netOptions.port = socketTLS.port = port;\n            originTLS.ca = originTLS.ca || options.ca;\n            socketTLS.servername = socketTLS.servername || endpoint.hostname;\n            this._stream = secure ? tls.connect(socketTLS, onConnect) : net.connect(netOptions, onConnect);\n            if (proxy.origin) this._configureProxy(proxy, originTLS);\n            API.call(this, options);\n        };\n        util.inherits(Client, API);\n        Client.prototype._onConnect = function() {\n            var worker = this._proxy || this._driver;\n            worker.start();\n        };\n        Client.prototype._configureProxy = function(proxy, originTLS) {\n            var uri = url.parse(this.url), secure = SECURE_PROTOCOLS.indexOf(uri.protocol) >= 0, self1 = this, name;\n            this._proxy = this._driver.proxy(proxy.origin);\n            if (proxy.headers) {\n                for(name in proxy.headers)this._proxy.setHeader(name, proxy.headers[name]);\n            }\n            this._proxy.pipe(this._stream, {\n                end: false\n            });\n            this._stream.pipe(this._proxy);\n            this._proxy.on(\"connect\", function() {\n                if (secure) {\n                    var options = {\n                        socket: self1._stream,\n                        servername: uri.hostname\n                    };\n                    for(name in originTLS)options[name] = originTLS[name];\n                    self1._stream = tls.connect(options);\n                    self1._configureStream();\n                }\n                self1._driver.io.pipe(self1._stream);\n                self1._stream.pipe(self1._driver.io);\n                self1._driver.start();\n            });\n            this._proxy.on(\"error\", function(error) {\n                self1._driver.emit(\"error\", error);\n            });\n        };\n        module1.exports = Client;\n    /***/ },\n    /* 40 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! net */ \"net\");\n    /***/ },\n    /* 41 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! tls */ \"tls\");\n    /***/ },\n    /* 42 */ /***/ function(module1, exports, __nested_webpack_require_261408__) {\n        \"use strict\";\n        var Stream = __nested_webpack_require_261408__(5).Stream, util = __nested_webpack_require_261408__(0), driver = __nested_webpack_require_261408__(4), Headers = __nested_webpack_require_261408__(9), API = __nested_webpack_require_261408__(11), EventTarget = __nested_webpack_require_261408__(16), Event = __nested_webpack_require_261408__(7);\n        var EventSource = function(request, response, options) {\n            this.writable = true;\n            options = options || {};\n            this._stream = response.socket;\n            this._ping = options.ping || this.DEFAULT_PING;\n            this._retry = options.retry || this.DEFAULT_RETRY;\n            var scheme = driver.isSecureRequest(request) ? \"https:\" : \"http:\";\n            this.url = scheme + \"//\" + request.headers.host + request.url;\n            this.lastEventId = request.headers[\"last-event-id\"] || \"\";\n            this.readyState = API.CONNECTING;\n            var headers = new Headers(), self1 = this;\n            if (options.headers) {\n                for(var key in options.headers)headers.set(key, options.headers[key]);\n            }\n            if (!this._stream || !this._stream.writable) return;\n            process.nextTick(function() {\n                self1._open();\n            });\n            this._stream.setTimeout(0);\n            this._stream.setNoDelay(true);\n            var handshake = \"HTTP/1.1 200 OK\\r\\n\" + \"Content-Type: text/event-stream\\r\\n\" + \"Cache-Control: no-cache, no-store\\r\\n\" + \"Connection: close\\r\\n\" + headers.toString() + \"\\r\\n\" + \"retry: \" + Math.floor(this._retry * 1000) + \"\\r\\n\\r\\n\";\n            this._write(handshake);\n            this._stream.on(\"drain\", function() {\n                self1.emit(\"drain\");\n            });\n            if (this._ping) this._pingTimer = setInterval(function() {\n                self1.ping();\n            }, this._ping * 1000);\n            [\n                \"error\",\n                \"end\"\n            ].forEach(function(event) {\n                self1._stream.on(event, function() {\n                    self1.close();\n                });\n            });\n        };\n        util.inherits(EventSource, Stream);\n        EventSource.isEventSource = function(request) {\n            if (request.method !== \"GET\") return false;\n            var accept = (request.headers.accept || \"\").split(/\\s*,\\s*/);\n            return accept.indexOf(\"text/event-stream\") >= 0;\n        };\n        var instance = {\n            DEFAULT_PING: 10,\n            DEFAULT_RETRY: 5,\n            _write: function(chunk) {\n                if (!this.writable) return false;\n                try {\n                    return this._stream.write(chunk, \"utf8\");\n                } catch (e) {\n                    return false;\n                }\n            },\n            _open: function() {\n                if (this.readyState !== API.CONNECTING) return;\n                this.readyState = API.OPEN;\n                var event = new Event(\"open\");\n                event.initEvent(\"open\", false, false);\n                this.dispatchEvent(event);\n            },\n            write: function(message) {\n                return this.send(message);\n            },\n            end: function(message) {\n                if (message !== undefined) this.write(message);\n                this.close();\n            },\n            send: function(message, options) {\n                if (this.readyState > API.OPEN) return false;\n                message = String(message).replace(/(\\r\\n|\\r|\\n)/g, \"$1data: \");\n                options = options || {};\n                var frame = \"\";\n                if (options.event) frame += \"event: \" + options.event + \"\\r\\n\";\n                if (options.id) frame += \"id: \" + options.id + \"\\r\\n\";\n                frame += \"data: \" + message + \"\\r\\n\\r\\n\";\n                return this._write(frame);\n            },\n            ping: function() {\n                return this._write(\":\\r\\n\\r\\n\");\n            },\n            close: function() {\n                if (this.readyState > API.OPEN) return false;\n                this.readyState = API.CLOSED;\n                this.writable = false;\n                if (this._pingTimer) clearInterval(this._pingTimer);\n                if (this._stream) this._stream.end();\n                var event = new Event(\"close\");\n                event.initEvent(\"close\", false, false);\n                this.dispatchEvent(event);\n                return true;\n            }\n        };\n        for(var method in instance)EventSource.prototype[method] = instance[method];\n        for(var key in EventTarget)EventSource.prototype[key] = EventTarget[key];\n        module1.exports = EventSource;\n    /***/ },\n    /* 43 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! child_process */ \"child_process\");\n    /***/ },\n    /* 44 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! fs */ \"fs\");\n    /***/ },\n    /* 45 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! http */ \"http\");\n    /***/ },\n    /* 46 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! https */ \"https\");\n    /***/ },\n    /* 47 */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_266492__) {\n        \"use strict\";\n        // ESM COMPAT FLAG\n        __nested_webpack_require_266492__.r(__nested_webpack_exports__);\n        // EXPORTS\n        __nested_webpack_require_266492__.d(__nested_webpack_exports__, \"default\", function() {\n            return /* binding */ pusher_with_encryption_PusherWithEncryption;\n        });\n        // CONCATENATED MODULE: ./src/core/base64.ts\n        function encode(s) {\n            return btoa(utob(s));\n        }\n        var fromCharCode = String.fromCharCode;\n        var b64chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        var b64tab = {};\n        for(var base64_i = 0, l = b64chars.length; base64_i < l; base64_i++){\n            b64tab[b64chars.charAt(base64_i)] = base64_i;\n        }\n        var cb_utob = function(c) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);\n        };\n        var utob = function(u) {\n            return u.replace(/[^\\x00-\\x7F]/g, cb_utob);\n        };\n        var cb_encode = function(ccc) {\n            var padlen = [\n                0,\n                2,\n                1\n            ][ccc.length % 3];\n            var ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);\n            var chars = [\n                b64chars.charAt(ord >>> 18),\n                b64chars.charAt(ord >>> 12 & 63),\n                padlen >= 2 ? \"=\" : b64chars.charAt(ord >>> 6 & 63),\n                padlen >= 1 ? \"=\" : b64chars.charAt(ord & 63)\n            ];\n            return chars.join(\"\");\n        };\n        var btoa = global.btoa || function(b) {\n            return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n        };\n        // CONCATENATED MODULE: ./src/core/utils/timers/abstract_timer.ts\n        class Timer {\n            constructor(set, clear, delay, callback){\n                this.clear = clear;\n                this.timer = set(()=>{\n                    if (this.timer) {\n                        this.timer = callback(this.timer);\n                    }\n                }, delay);\n            }\n            isRunning() {\n                return this.timer !== null;\n            }\n            ensureAborted() {\n                if (this.timer) {\n                    this.clear(this.timer);\n                    this.timer = null;\n                }\n            }\n        }\n        /* harmony default export */ var abstract_timer = Timer;\n        // CONCATENATED MODULE: ./src/core/utils/timers/index.ts\n        function timers_clearTimeout(timer) {\n            global.clearTimeout(timer);\n        }\n        function timers_clearInterval(timer) {\n            global.clearInterval(timer);\n        }\n        class timers_OneOffTimer extends abstract_timer {\n            constructor(delay, callback){\n                super(setTimeout, timers_clearTimeout, delay, function(timer) {\n                    callback();\n                    return null;\n                });\n            }\n        }\n        class timers_PeriodicTimer extends abstract_timer {\n            constructor(delay, callback){\n                super(setInterval, timers_clearInterval, delay, function(timer) {\n                    callback();\n                    return timer;\n                });\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/util.ts\n        var Util = {\n            now () {\n                if (Date.now) {\n                    return Date.now();\n                } else {\n                    return new Date().valueOf();\n                }\n            },\n            defer (callback) {\n                return new timers_OneOffTimer(0, callback);\n            },\n            method (name, ...args) {\n                var boundArguments = Array.prototype.slice.call(arguments, 1);\n                return function(object) {\n                    return object[name].apply(object, boundArguments.concat(arguments));\n                };\n            }\n        };\n        /* harmony default export */ var util = Util;\n        // CONCATENATED MODULE: ./src/core/utils/collections.ts\n        function extend(target, ...sources) {\n            for(var i = 0; i < sources.length; i++){\n                var extensions = sources[i];\n                for(var property in extensions){\n                    if (extensions[property] && extensions[property].constructor && extensions[property].constructor === Object) {\n                        target[property] = extend(target[property] || {}, extensions[property]);\n                    } else {\n                        target[property] = extensions[property];\n                    }\n                }\n            }\n            return target;\n        }\n        function stringify() {\n            var m = [\n                \"Pusher\"\n            ];\n            for(var i = 0; i < arguments.length; i++){\n                if (typeof arguments[i] === \"string\") {\n                    m.push(arguments[i]);\n                } else {\n                    m.push(safeJSONStringify(arguments[i]));\n                }\n            }\n            return m.join(\" : \");\n        }\n        function arrayIndexOf(array, item) {\n            var nativeIndexOf = Array.prototype.indexOf;\n            if (array === null) {\n                return -1;\n            }\n            if (nativeIndexOf && array.indexOf === nativeIndexOf) {\n                return array.indexOf(item);\n            }\n            for(var i = 0, l = array.length; i < l; i++){\n                if (array[i] === item) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        function objectApply(object, f) {\n            for(var key in object){\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    f(object[key], key, object);\n                }\n            }\n        }\n        function keys(object) {\n            var keys = [];\n            objectApply(object, function(_, key) {\n                keys.push(key);\n            });\n            return keys;\n        }\n        function values(object) {\n            var values = [];\n            objectApply(object, function(value) {\n                values.push(value);\n            });\n            return values;\n        }\n        function apply(array, f, context) {\n            for(var i = 0; i < array.length; i++){\n                f.call(context || global, array[i], i, array);\n            }\n        }\n        function map(array, f) {\n            var result = [];\n            for(var i = 0; i < array.length; i++){\n                result.push(f(array[i], i, array, result));\n            }\n            return result;\n        }\n        function mapObject(object, f) {\n            var result = {};\n            objectApply(object, function(value, key) {\n                result[key] = f(value);\n            });\n            return result;\n        }\n        function filter(array, test) {\n            test = test || function(value) {\n                return !!value;\n            };\n            var result = [];\n            for(var i = 0; i < array.length; i++){\n                if (test(array[i], i, array, result)) {\n                    result.push(array[i]);\n                }\n            }\n            return result;\n        }\n        function filterObject(object, test) {\n            var result = {};\n            objectApply(object, function(value, key) {\n                if (test && test(value, key, object, result) || Boolean(value)) {\n                    result[key] = value;\n                }\n            });\n            return result;\n        }\n        function flatten(object) {\n            var result = [];\n            objectApply(object, function(value, key) {\n                result.push([\n                    key,\n                    value\n                ]);\n            });\n            return result;\n        }\n        function any(array, test) {\n            for(var i = 0; i < array.length; i++){\n                if (test(array[i], i, array)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function collections_all(array, test) {\n            for(var i = 0; i < array.length; i++){\n                if (!test(array[i], i, array)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function encodeParamsObject(data) {\n            return mapObject(data, function(value) {\n                if (typeof value === \"object\") {\n                    value = safeJSONStringify(value);\n                }\n                return encodeURIComponent(encode(value.toString()));\n            });\n        }\n        function buildQueryString(data) {\n            var params = filterObject(data, function(value) {\n                return value !== undefined;\n            });\n            var query = map(flatten(encodeParamsObject(params)), util.method(\"join\", \"=\")).join(\"&\");\n            return query;\n        }\n        function decycleObject(object) {\n            var objects = [], paths = [];\n            return function derez(value, path) {\n                var i, name, nu;\n                switch(typeof value){\n                    case \"object\":\n                        if (!value) {\n                            return null;\n                        }\n                        for(i = 0; i < objects.length; i += 1){\n                            if (objects[i] === value) {\n                                return {\n                                    $ref: paths[i]\n                                };\n                            }\n                        }\n                        objects.push(value);\n                        paths.push(path);\n                        if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n                            nu = [];\n                            for(i = 0; i < value.length; i += 1){\n                                nu[i] = derez(value[i], path + \"[\" + i + \"]\");\n                            }\n                        } else {\n                            nu = {};\n                            for(name in value){\n                                if (Object.prototype.hasOwnProperty.call(value, name)) {\n                                    nu[name] = derez(value[name], path + \"[\" + JSON.stringify(name) + \"]\");\n                                }\n                            }\n                        }\n                        return nu;\n                    case \"number\":\n                    case \"string\":\n                    case \"boolean\":\n                        return value;\n                }\n            }(object, \"$\");\n        }\n        function safeJSONStringify(source) {\n            try {\n                return JSON.stringify(source);\n            } catch (e) {\n                return JSON.stringify(decycleObject(source));\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/defaults.ts\n        var Defaults = {\n            VERSION: \"8.3.0\",\n            PROTOCOL: 7,\n            wsPort: 80,\n            wssPort: 443,\n            wsPath: \"\",\n            httpHost: \"sockjs.pusher.com\",\n            httpPort: 80,\n            httpsPort: 443,\n            httpPath: \"/pusher\",\n            stats_host: \"stats.pusher.com\",\n            authEndpoint: \"/pusher/auth\",\n            authTransport: \"ajax\",\n            activityTimeout: 120000,\n            pongTimeout: 30000,\n            unavailableTimeout: 10000,\n            userAuthentication: {\n                endpoint: \"/pusher/user-auth\",\n                transport: \"ajax\"\n            },\n            channelAuthorization: {\n                endpoint: \"/pusher/auth\",\n                transport: \"ajax\"\n            },\n            cdn_http: \"http://js.pusher.com\",\n            cdn_https: \"https://js.pusher.com\",\n            dependency_suffix: \"\"\n        };\n        /* harmony default export */ var defaults = Defaults;\n        // CONCATENATED MODULE: ./src/core/transports/url_schemes.ts\n        function getGenericURL(baseScheme, params, path) {\n            var scheme = baseScheme + (params.useTLS ? \"s\" : \"\");\n            var host = params.useTLS ? params.hostTLS : params.hostNonTLS;\n            return scheme + \"://\" + host + path;\n        }\n        function getGenericPath(key, queryString) {\n            var path = \"/app/\" + key;\n            var query = \"?protocol=\" + defaults.PROTOCOL + \"&client=js\" + \"&version=\" + defaults.VERSION + (queryString ? \"&\" + queryString : \"\");\n            return path + query;\n        }\n        var ws = {\n            getInitial: function(key, params) {\n                var path = (params.httpPath || \"\") + getGenericPath(key, \"flash=false\");\n                return getGenericURL(\"ws\", params, path);\n            }\n        };\n        var http = {\n            getInitial: function(key, params) {\n                var path = (params.httpPath || \"/pusher\") + getGenericPath(key);\n                return getGenericURL(\"http\", params, path);\n            }\n        };\n        var sockjs = {\n            getInitial: function(key, params) {\n                return getGenericURL(\"http\", params, params.httpPath || \"/pusher\");\n            },\n            getPath: function(key, params) {\n                return getGenericPath(key);\n            }\n        };\n        // CONCATENATED MODULE: ./src/core/events/callback_registry.ts\n        class callback_registry_CallbackRegistry {\n            constructor(){\n                this._callbacks = {};\n            }\n            get(name) {\n                return this._callbacks[prefix(name)];\n            }\n            add(name, callback, context) {\n                var prefixedEventName = prefix(name);\n                this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];\n                this._callbacks[prefixedEventName].push({\n                    fn: callback,\n                    context: context\n                });\n            }\n            remove(name, callback, context) {\n                if (!name && !callback && !context) {\n                    this._callbacks = {};\n                    return;\n                }\n                var names = name ? [\n                    prefix(name)\n                ] : keys(this._callbacks);\n                if (callback || context) {\n                    this.removeCallback(names, callback, context);\n                } else {\n                    this.removeAllCallbacks(names);\n                }\n            }\n            removeCallback(names, callback, context) {\n                apply(names, function(name) {\n                    this._callbacks[name] = filter(this._callbacks[name] || [], function(binding) {\n                        return callback && callback !== binding.fn || context && context !== binding.context;\n                    });\n                    if (this._callbacks[name].length === 0) {\n                        delete this._callbacks[name];\n                    }\n                }, this);\n            }\n            removeAllCallbacks(names) {\n                apply(names, function(name) {\n                    delete this._callbacks[name];\n                }, this);\n            }\n        }\n        function prefix(name) {\n            return \"_\" + name;\n        }\n        // CONCATENATED MODULE: ./src/core/events/dispatcher.ts\n        class dispatcher_Dispatcher {\n            constructor(failThrough){\n                this.callbacks = new callback_registry_CallbackRegistry();\n                this.global_callbacks = [];\n                this.failThrough = failThrough;\n            }\n            bind(eventName, callback, context) {\n                this.callbacks.add(eventName, callback, context);\n                return this;\n            }\n            bind_global(callback) {\n                this.global_callbacks.push(callback);\n                return this;\n            }\n            unbind(eventName, callback, context) {\n                this.callbacks.remove(eventName, callback, context);\n                return this;\n            }\n            unbind_global(callback) {\n                if (!callback) {\n                    this.global_callbacks = [];\n                    return this;\n                }\n                this.global_callbacks = filter(this.global_callbacks || [], (c)=>c !== callback);\n                return this;\n            }\n            unbind_all() {\n                this.unbind();\n                this.unbind_global();\n                return this;\n            }\n            emit(eventName, data, metadata) {\n                for(var i = 0; i < this.global_callbacks.length; i++){\n                    this.global_callbacks[i](eventName, data);\n                }\n                var callbacks = this.callbacks.get(eventName);\n                var args = [];\n                if (metadata) {\n                    args.push(data, metadata);\n                } else if (data) {\n                    args.push(data);\n                }\n                if (callbacks && callbacks.length > 0) {\n                    for(var i = 0; i < callbacks.length; i++){\n                        callbacks[i].fn.apply(callbacks[i].context || global, args);\n                    }\n                } else if (this.failThrough) {\n                    this.failThrough(eventName, data);\n                }\n                return this;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/logger.ts\n        class logger_Logger {\n            constructor(){\n                this.globalLog = (message)=>{\n                    if (global.console && global.console.log) {\n                        global.console.log(message);\n                    }\n                };\n            }\n            debug(...args) {\n                this.log(this.globalLog, args);\n            }\n            warn(...args) {\n                this.log(this.globalLogWarn, args);\n            }\n            error(...args) {\n                this.log(this.globalLogError, args);\n            }\n            globalLogWarn(message) {\n                if (global.console && global.console.warn) {\n                    global.console.warn(message);\n                } else {\n                    this.globalLog(message);\n                }\n            }\n            globalLogError(message) {\n                if (global.console && global.console.error) {\n                    global.console.error(message);\n                } else {\n                    this.globalLogWarn(message);\n                }\n            }\n            log(defaultLoggingFunction, ...args) {\n                var message = stringify.apply(this, arguments);\n                if (core_pusher.log) {\n                    core_pusher.log(message);\n                } else if (core_pusher.logToConsole) {\n                    const log = defaultLoggingFunction.bind(this);\n                    log(message);\n                }\n            }\n        }\n        /* harmony default export */ var logger = new logger_Logger();\n        // CONCATENATED MODULE: ./src/core/transports/transport_connection.ts\n        class transport_connection_TransportConnection extends dispatcher_Dispatcher {\n            constructor(hooks, name, priority, key, options){\n                super();\n                this.initialize = node_runtime.transportConnectionInitializer;\n                this.hooks = hooks;\n                this.name = name;\n                this.priority = priority;\n                this.key = key;\n                this.options = options;\n                this.state = \"new\";\n                this.timeline = options.timeline;\n                this.activityTimeout = options.activityTimeout;\n                this.id = this.timeline.generateUniqueID();\n            }\n            handlesActivityChecks() {\n                return Boolean(this.hooks.handlesActivityChecks);\n            }\n            supportsPing() {\n                return Boolean(this.hooks.supportsPing);\n            }\n            connect() {\n                if (this.socket || this.state !== \"initialized\") {\n                    return false;\n                }\n                var url = this.hooks.urls.getInitial(this.key, this.options);\n                try {\n                    this.socket = this.hooks.getSocket(url, this.options);\n                } catch (e) {\n                    util.defer(()=>{\n                        this.onError(e);\n                        this.changeState(\"closed\");\n                    });\n                    return false;\n                }\n                this.bindListeners();\n                logger.debug(\"Connecting\", {\n                    transport: this.name,\n                    url\n                });\n                this.changeState(\"connecting\");\n                return true;\n            }\n            close() {\n                if (this.socket) {\n                    this.socket.close();\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            send(data) {\n                if (this.state === \"open\") {\n                    util.defer(()=>{\n                        if (this.socket) {\n                            this.socket.send(data);\n                        }\n                    });\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            ping() {\n                if (this.state === \"open\" && this.supportsPing()) {\n                    this.socket.ping();\n                }\n            }\n            onOpen() {\n                if (this.hooks.beforeOpen) {\n                    this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));\n                }\n                this.changeState(\"open\");\n                this.socket.onopen = undefined;\n            }\n            onError(error) {\n                this.emit(\"error\", {\n                    type: \"WebSocketError\",\n                    error: error\n                });\n                this.timeline.error(this.buildTimelineMessage({\n                    error: error.toString()\n                }));\n            }\n            onClose(closeEvent) {\n                if (closeEvent) {\n                    this.changeState(\"closed\", {\n                        code: closeEvent.code,\n                        reason: closeEvent.reason,\n                        wasClean: closeEvent.wasClean\n                    });\n                } else {\n                    this.changeState(\"closed\");\n                }\n                this.unbindListeners();\n                this.socket = undefined;\n            }\n            onMessage(message) {\n                this.emit(\"message\", message);\n            }\n            onActivity() {\n                this.emit(\"activity\");\n            }\n            bindListeners() {\n                this.socket.onopen = ()=>{\n                    this.onOpen();\n                };\n                this.socket.onerror = (error)=>{\n                    this.onError(error);\n                };\n                this.socket.onclose = (closeEvent)=>{\n                    this.onClose(closeEvent);\n                };\n                this.socket.onmessage = (message)=>{\n                    this.onMessage(message);\n                };\n                if (this.supportsPing()) {\n                    this.socket.onactivity = ()=>{\n                        this.onActivity();\n                    };\n                }\n            }\n            unbindListeners() {\n                if (this.socket) {\n                    this.socket.onopen = undefined;\n                    this.socket.onerror = undefined;\n                    this.socket.onclose = undefined;\n                    this.socket.onmessage = undefined;\n                    if (this.supportsPing()) {\n                        this.socket.onactivity = undefined;\n                    }\n                }\n            }\n            changeState(state, params) {\n                this.state = state;\n                this.timeline.info(this.buildTimelineMessage({\n                    state: state,\n                    params: params\n                }));\n                this.emit(state, params);\n            }\n            buildTimelineMessage(message) {\n                return extend({\n                    cid: this.id\n                }, message);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/transports/transport.ts\n        class transport_Transport {\n            constructor(hooks){\n                this.hooks = hooks;\n            }\n            isSupported(environment) {\n                return this.hooks.isSupported(environment);\n            }\n            createConnection(name, priority, key, options) {\n                return new transport_connection_TransportConnection(this.hooks, name, priority, key, options);\n            }\n        }\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transports.ts\n        var WSTransport = new transport_Transport({\n            urls: ws,\n            handlesActivityChecks: false,\n            supportsPing: false,\n            isInitialized: function() {\n                return Boolean(node_runtime.getWebSocketAPI());\n            },\n            isSupported: function() {\n                return Boolean(node_runtime.getWebSocketAPI());\n            },\n            getSocket: function(url) {\n                return node_runtime.createWebSocket(url);\n            }\n        });\n        var httpConfiguration = {\n            urls: http,\n            handlesActivityChecks: false,\n            supportsPing: true,\n            isInitialized: function() {\n                return true;\n            }\n        };\n        var streamingConfiguration = extend({\n            getSocket: function(url) {\n                return node_runtime.HTTPFactory.createStreamingSocket(url);\n            }\n        }, httpConfiguration);\n        var pollingConfiguration = extend({\n            getSocket: function(url) {\n                return node_runtime.HTTPFactory.createPollingSocket(url);\n            }\n        }, httpConfiguration);\n        var xhrConfiguration = {\n            isSupported: function() {\n                return node_runtime.isXHRSupported();\n            }\n        };\n        var XHRStreamingTransport = new transport_Transport(extend({}, streamingConfiguration, xhrConfiguration));\n        var XHRPollingTransport = new transport_Transport(extend({}, pollingConfiguration, xhrConfiguration));\n        var Transports = {\n            ws: WSTransport,\n            xhr_streaming: XHRStreamingTransport,\n            xhr_polling: XHRPollingTransport\n        };\n        /* harmony default export */ var transports = Transports;\n        // CONCATENATED MODULE: ./src/core/transports/assistant_to_the_transport_manager.ts\n        class assistant_to_the_transport_manager_AssistantToTheTransportManager {\n            constructor(manager, transport, options){\n                this.manager = manager;\n                this.transport = transport;\n                this.minPingDelay = options.minPingDelay;\n                this.maxPingDelay = options.maxPingDelay;\n                this.pingDelay = undefined;\n            }\n            createConnection(name, priority, key, options) {\n                options = extend({}, options, {\n                    activityTimeout: this.pingDelay\n                });\n                var connection = this.transport.createConnection(name, priority, key, options);\n                var openTimestamp = null;\n                var onOpen = function() {\n                    connection.unbind(\"open\", onOpen);\n                    connection.bind(\"closed\", onClosed);\n                    openTimestamp = util.now();\n                };\n                var onClosed = (closeEvent)=>{\n                    connection.unbind(\"closed\", onClosed);\n                    if (closeEvent.code === 1002 || closeEvent.code === 1003) {\n                        this.manager.reportDeath();\n                    } else if (!closeEvent.wasClean && openTimestamp) {\n                        var lifespan = util.now() - openTimestamp;\n                        if (lifespan < 2 * this.maxPingDelay) {\n                            this.manager.reportDeath();\n                            this.pingDelay = Math.max(lifespan / 2, this.minPingDelay);\n                        }\n                    }\n                };\n                connection.bind(\"open\", onOpen);\n                return connection;\n            }\n            isSupported(environment) {\n                return this.manager.isAlive() && this.transport.isSupported(environment);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/connection/protocol/protocol.ts\n        const Protocol = {\n            decodeMessage: function(messageEvent) {\n                try {\n                    var messageData = JSON.parse(messageEvent.data);\n                    var pusherEventData = messageData.data;\n                    if (typeof pusherEventData === \"string\") {\n                        try {\n                            pusherEventData = JSON.parse(messageData.data);\n                        } catch (e) {}\n                    }\n                    var pusherEvent = {\n                        event: messageData.event,\n                        channel: messageData.channel,\n                        data: pusherEventData\n                    };\n                    if (messageData.user_id) {\n                        pusherEvent.user_id = messageData.user_id;\n                    }\n                    return pusherEvent;\n                } catch (e) {\n                    throw {\n                        type: \"MessageParseError\",\n                        error: e,\n                        data: messageEvent.data\n                    };\n                }\n            },\n            encodeMessage: function(event) {\n                return JSON.stringify(event);\n            },\n            processHandshake: function(messageEvent) {\n                var message = Protocol.decodeMessage(messageEvent);\n                if (message.event === \"pusher:connection_established\") {\n                    if (!message.data.activity_timeout) {\n                        throw \"No activity timeout specified in handshake\";\n                    }\n                    return {\n                        action: \"connected\",\n                        id: message.data.socket_id,\n                        activityTimeout: message.data.activity_timeout * 1000\n                    };\n                } else if (message.event === \"pusher:error\") {\n                    return {\n                        action: this.getCloseAction(message.data),\n                        error: this.getCloseError(message.data)\n                    };\n                } else {\n                    throw \"Invalid handshake\";\n                }\n            },\n            getCloseAction: function(closeEvent) {\n                if (closeEvent.code < 4000) {\n                    if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {\n                        return \"backoff\";\n                    } else {\n                        return null;\n                    }\n                } else if (closeEvent.code === 4000) {\n                    return \"tls_only\";\n                } else if (closeEvent.code < 4100) {\n                    return \"refused\";\n                } else if (closeEvent.code < 4200) {\n                    return \"backoff\";\n                } else if (closeEvent.code < 4300) {\n                    return \"retry\";\n                } else {\n                    return \"refused\";\n                }\n            },\n            getCloseError: function(closeEvent) {\n                if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {\n                    return {\n                        type: \"PusherError\",\n                        data: {\n                            code: closeEvent.code,\n                            message: closeEvent.reason || closeEvent.message\n                        }\n                    };\n                } else {\n                    return null;\n                }\n            }\n        };\n        /* harmony default export */ var protocol = Protocol;\n        // CONCATENATED MODULE: ./src/core/connection/connection.ts\n        class connection_Connection extends dispatcher_Dispatcher {\n            constructor(id, transport){\n                super();\n                this.id = id;\n                this.transport = transport;\n                this.activityTimeout = transport.activityTimeout;\n                this.bindListeners();\n            }\n            handlesActivityChecks() {\n                return this.transport.handlesActivityChecks();\n            }\n            send(data) {\n                return this.transport.send(data);\n            }\n            send_event(name, data, channel) {\n                var event = {\n                    event: name,\n                    data: data\n                };\n                if (channel) {\n                    event.channel = channel;\n                }\n                logger.debug(\"Event sent\", event);\n                return this.send(protocol.encodeMessage(event));\n            }\n            ping() {\n                if (this.transport.supportsPing()) {\n                    this.transport.ping();\n                } else {\n                    this.send_event(\"pusher:ping\", {});\n                }\n            }\n            close() {\n                this.transport.close();\n            }\n            bindListeners() {\n                var listeners = {\n                    message: (messageEvent)=>{\n                        var pusherEvent;\n                        try {\n                            pusherEvent = protocol.decodeMessage(messageEvent);\n                        } catch (e) {\n                            this.emit(\"error\", {\n                                type: \"MessageParseError\",\n                                error: e,\n                                data: messageEvent.data\n                            });\n                        }\n                        if (pusherEvent !== undefined) {\n                            logger.debug(\"Event recd\", pusherEvent);\n                            switch(pusherEvent.event){\n                                case \"pusher:error\":\n                                    this.emit(\"error\", {\n                                        type: \"PusherError\",\n                                        data: pusherEvent.data\n                                    });\n                                    break;\n                                case \"pusher:ping\":\n                                    this.emit(\"ping\");\n                                    break;\n                                case \"pusher:pong\":\n                                    this.emit(\"pong\");\n                                    break;\n                            }\n                            this.emit(\"message\", pusherEvent);\n                        }\n                    },\n                    activity: ()=>{\n                        this.emit(\"activity\");\n                    },\n                    error: (error)=>{\n                        this.emit(\"error\", error);\n                    },\n                    closed: (closeEvent)=>{\n                        unbindListeners();\n                        if (closeEvent && closeEvent.code) {\n                            this.handleCloseEvent(closeEvent);\n                        }\n                        this.transport = null;\n                        this.emit(\"closed\");\n                    }\n                };\n                var unbindListeners = ()=>{\n                    objectApply(listeners, (listener, event)=>{\n                        this.transport.unbind(event, listener);\n                    });\n                };\n                objectApply(listeners, (listener, event)=>{\n                    this.transport.bind(event, listener);\n                });\n            }\n            handleCloseEvent(closeEvent) {\n                var action = protocol.getCloseAction(closeEvent);\n                var error = protocol.getCloseError(closeEvent);\n                if (error) {\n                    this.emit(\"error\", error);\n                }\n                if (action) {\n                    this.emit(action, {\n                        action: action,\n                        error: error\n                    });\n                }\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/connection/handshake/index.ts\n        class handshake_Handshake {\n            constructor(transport, callback){\n                this.transport = transport;\n                this.callback = callback;\n                this.bindListeners();\n            }\n            close() {\n                this.unbindListeners();\n                this.transport.close();\n            }\n            bindListeners() {\n                this.onMessage = (m)=>{\n                    this.unbindListeners();\n                    var result;\n                    try {\n                        result = protocol.processHandshake(m);\n                    } catch (e) {\n                        this.finish(\"error\", {\n                            error: e\n                        });\n                        this.transport.close();\n                        return;\n                    }\n                    if (result.action === \"connected\") {\n                        this.finish(\"connected\", {\n                            connection: new connection_Connection(result.id, this.transport),\n                            activityTimeout: result.activityTimeout\n                        });\n                    } else {\n                        this.finish(result.action, {\n                            error: result.error\n                        });\n                        this.transport.close();\n                    }\n                };\n                this.onClosed = (closeEvent)=>{\n                    this.unbindListeners();\n                    var action = protocol.getCloseAction(closeEvent) || \"backoff\";\n                    var error = protocol.getCloseError(closeEvent);\n                    this.finish(action, {\n                        error: error\n                    });\n                };\n                this.transport.bind(\"message\", this.onMessage);\n                this.transport.bind(\"closed\", this.onClosed);\n            }\n            unbindListeners() {\n                this.transport.unbind(\"message\", this.onMessage);\n                this.transport.unbind(\"closed\", this.onClosed);\n            }\n            finish(action, params) {\n                this.callback(extend({\n                    transport: this.transport,\n                    action: action\n                }, params));\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/timeline/timeline_sender.ts\n        class timeline_sender_TimelineSender {\n            constructor(timeline, options){\n                this.timeline = timeline;\n                this.options = options || {};\n            }\n            send(useTLS, callback) {\n                if (this.timeline.isEmpty()) {\n                    return;\n                }\n                this.timeline.send(node_runtime.TimelineTransport.getAgent(this, useTLS), callback);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/errors.ts\n        class BadEventName extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class BadChannelName extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class RequestTimedOut extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class TransportPriorityTooLow extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class TransportClosed extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class UnsupportedFeature extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class UnsupportedTransport extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class UnsupportedStrategy extends Error {\n            constructor(msg){\n                super(msg);\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        class HTTPAuthError extends Error {\n            constructor(status, msg){\n                super(msg);\n                this.status = status;\n                Object.setPrototypeOf(this, new.target.prototype);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/utils/url_store.ts\n        const urlStore = {\n            baseUrl: \"https://pusher.com\",\n            urls: {\n                authenticationEndpoint: {\n                    path: \"/docs/channels/server_api/authenticating_users\"\n                },\n                authorizationEndpoint: {\n                    path: \"/docs/channels/server_api/authorizing-users/\"\n                },\n                javascriptQuickStart: {\n                    path: \"/docs/javascript_quick_start\"\n                },\n                triggeringClientEvents: {\n                    path: \"/docs/client_api_guide/client_events#trigger-events\"\n                },\n                encryptedChannelSupport: {\n                    fullUrl: \"https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support\"\n                }\n            }\n        };\n        const buildLogSuffix = function(key) {\n            const urlPrefix = \"See:\";\n            const urlObj = urlStore.urls[key];\n            if (!urlObj) return \"\";\n            let url;\n            if (urlObj.fullUrl) {\n                url = urlObj.fullUrl;\n            } else if (urlObj.path) {\n                url = urlStore.baseUrl + urlObj.path;\n            }\n            if (!url) return \"\";\n            return `${urlPrefix} ${url}`;\n        };\n        /* harmony default export */ var url_store = {\n            buildLogSuffix\n        };\n        // CONCATENATED MODULE: ./src/core/channels/channel.ts\n        class channel_Channel extends dispatcher_Dispatcher {\n            constructor(name, pusher){\n                super(function(event, data) {\n                    logger.debug(\"No callbacks on \" + name + \" for \" + event);\n                });\n                this.name = name;\n                this.pusher = pusher;\n                this.subscribed = false;\n                this.subscriptionPending = false;\n                this.subscriptionCancelled = false;\n            }\n            authorize(socketId, callback) {\n                return callback(null, {\n                    auth: \"\"\n                });\n            }\n            trigger(event, data) {\n                if (event.indexOf(\"client-\") !== 0) {\n                    throw new BadEventName(\"Event '\" + event + \"' does not start with 'client-'\");\n                }\n                if (!this.subscribed) {\n                    var suffix = url_store.buildLogSuffix(\"triggeringClientEvents\");\n                    logger.warn(`Client event triggered before channel 'subscription_succeeded' event . ${suffix}`);\n                }\n                return this.pusher.send_event(event, data, this.name);\n            }\n            disconnect() {\n                this.subscribed = false;\n                this.subscriptionPending = false;\n            }\n            handleEvent(event) {\n                var eventName = event.event;\n                var data = event.data;\n                if (eventName === \"pusher_internal:subscription_succeeded\") {\n                    this.handleSubscriptionSucceededEvent(event);\n                } else if (eventName === \"pusher_internal:subscription_count\") {\n                    this.handleSubscriptionCountEvent(event);\n                } else if (eventName.indexOf(\"pusher_internal:\") !== 0) {\n                    var metadata = {};\n                    this.emit(eventName, data, metadata);\n                }\n            }\n            handleSubscriptionSucceededEvent(event) {\n                this.subscriptionPending = false;\n                this.subscribed = true;\n                if (this.subscriptionCancelled) {\n                    this.pusher.unsubscribe(this.name);\n                } else {\n                    this.emit(\"pusher:subscription_succeeded\", event.data);\n                }\n            }\n            handleSubscriptionCountEvent(event) {\n                if (event.data.subscription_count) {\n                    this.subscriptionCount = event.data.subscription_count;\n                }\n                this.emit(\"pusher:subscription_count\", event.data);\n            }\n            subscribe() {\n                if (this.subscribed) {\n                    return;\n                }\n                this.subscriptionPending = true;\n                this.subscriptionCancelled = false;\n                this.authorize(this.pusher.connection.socket_id, (error, data)=>{\n                    if (error) {\n                        this.subscriptionPending = false;\n                        logger.error(error.toString());\n                        this.emit(\"pusher:subscription_error\", Object.assign({}, {\n                            type: \"AuthError\",\n                            error: error.message\n                        }, error instanceof HTTPAuthError ? {\n                            status: error.status\n                        } : {}));\n                    } else {\n                        this.pusher.send_event(\"pusher:subscribe\", {\n                            auth: data.auth,\n                            channel_data: data.channel_data,\n                            channel: this.name\n                        });\n                    }\n                });\n            }\n            unsubscribe() {\n                this.subscribed = false;\n                this.pusher.send_event(\"pusher:unsubscribe\", {\n                    channel: this.name\n                });\n            }\n            cancelSubscription() {\n                this.subscriptionCancelled = true;\n            }\n            reinstateSubscription() {\n                this.subscriptionCancelled = false;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/channels/private_channel.ts\n        class private_channel_PrivateChannel extends channel_Channel {\n            authorize(socketId, callback) {\n                return this.pusher.config.channelAuthorizer({\n                    channelName: this.name,\n                    socketId: socketId\n                }, callback);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/channels/members.ts\n        class members_Members {\n            constructor(){\n                this.reset();\n            }\n            get(id) {\n                if (Object.prototype.hasOwnProperty.call(this.members, id)) {\n                    return {\n                        id: id,\n                        info: this.members[id]\n                    };\n                } else {\n                    return null;\n                }\n            }\n            each(callback) {\n                objectApply(this.members, (member, id)=>{\n                    callback(this.get(id));\n                });\n            }\n            setMyID(id) {\n                this.myID = id;\n            }\n            onSubscription(subscriptionData) {\n                this.members = subscriptionData.presence.hash;\n                this.count = subscriptionData.presence.count;\n                this.me = this.get(this.myID);\n            }\n            addMember(memberData) {\n                if (this.get(memberData.user_id) === null) {\n                    this.count++;\n                }\n                this.members[memberData.user_id] = memberData.user_info;\n                return this.get(memberData.user_id);\n            }\n            removeMember(memberData) {\n                var member = this.get(memberData.user_id);\n                if (member) {\n                    delete this.members[memberData.user_id];\n                    this.count--;\n                }\n                return member;\n            }\n            reset() {\n                this.members = {};\n                this.count = 0;\n                this.myID = null;\n                this.me = null;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/channels/presence_channel.ts\n        var __awaiter =  false || function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n                return value instanceof P ? value : new P(function(resolve) {\n                    resolve(value);\n                });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n                function fulfilled(value) {\n                    try {\n                        step(generator.next(value));\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                function rejected(value) {\n                    try {\n                        step(generator[\"throw\"](value));\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                function step(result) {\n                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n                }\n                step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n        };\n        class presence_channel_PresenceChannel extends private_channel_PrivateChannel {\n            constructor(name, pusher){\n                super(name, pusher);\n                this.members = new members_Members();\n            }\n            authorize(socketId, callback) {\n                super.authorize(socketId, (error, authData)=>__awaiter(this, void 0, void 0, function*() {\n                        if (!error) {\n                            authData = authData;\n                            if (authData.channel_data != null) {\n                                var channelData = JSON.parse(authData.channel_data);\n                                this.members.setMyID(channelData.user_id);\n                            } else {\n                                yield this.pusher.user.signinDonePromise;\n                                if (this.pusher.user.user_data != null) {\n                                    this.members.setMyID(this.pusher.user.user_data.id);\n                                } else {\n                                    let suffix = url_store.buildLogSuffix(\"authorizationEndpoint\");\n                                    logger.error(`Invalid auth response for channel '${this.name}', ` + `expected 'channel_data' field. ${suffix}, ` + `or the user should be signed in.`);\n                                    callback(\"Invalid auth response\");\n                                    return;\n                                }\n                            }\n                        }\n                        callback(error, authData);\n                    }));\n            }\n            handleEvent(event) {\n                var eventName = event.event;\n                if (eventName.indexOf(\"pusher_internal:\") === 0) {\n                    this.handleInternalEvent(event);\n                } else {\n                    var data = event.data;\n                    var metadata = {};\n                    if (event.user_id) {\n                        metadata.user_id = event.user_id;\n                    }\n                    this.emit(eventName, data, metadata);\n                }\n            }\n            handleInternalEvent(event) {\n                var eventName = event.event;\n                var data = event.data;\n                switch(eventName){\n                    case \"pusher_internal:subscription_succeeded\":\n                        this.handleSubscriptionSucceededEvent(event);\n                        break;\n                    case \"pusher_internal:subscription_count\":\n                        this.handleSubscriptionCountEvent(event);\n                        break;\n                    case \"pusher_internal:member_added\":\n                        var addedMember = this.members.addMember(data);\n                        this.emit(\"pusher:member_added\", addedMember);\n                        break;\n                    case \"pusher_internal:member_removed\":\n                        var removedMember = this.members.removeMember(data);\n                        if (removedMember) {\n                            this.emit(\"pusher:member_removed\", removedMember);\n                        }\n                        break;\n                }\n            }\n            handleSubscriptionSucceededEvent(event) {\n                this.subscriptionPending = false;\n                this.subscribed = true;\n                if (this.subscriptionCancelled) {\n                    this.pusher.unsubscribe(this.name);\n                } else {\n                    this.members.onSubscription(event.data);\n                    this.emit(\"pusher:subscription_succeeded\", this.members);\n                }\n            }\n            disconnect() {\n                this.members.reset();\n                super.disconnect();\n            }\n        }\n        // EXTERNAL MODULE: ./node_modules/@stablelib/utf8/lib/utf8.js\n        var utf8 = __nested_webpack_require_266492__(17);\n        // EXTERNAL MODULE: ./node_modules/@stablelib/base64/lib/base64.js\n        var base64 = __nested_webpack_require_266492__(8);\n        // CONCATENATED MODULE: ./src/core/channels/encrypted_channel.ts\n        class encrypted_channel_EncryptedChannel extends private_channel_PrivateChannel {\n            constructor(name, pusher, nacl){\n                super(name, pusher);\n                this.key = null;\n                this.nacl = nacl;\n            }\n            authorize(socketId, callback) {\n                super.authorize(socketId, (error, authData)=>{\n                    if (error) {\n                        callback(error, authData);\n                        return;\n                    }\n                    let sharedSecret = authData[\"shared_secret\"];\n                    if (!sharedSecret) {\n                        callback(new Error(`No shared_secret key in auth payload for encrypted channel: ${this.name}`), null);\n                        return;\n                    }\n                    this.key = Object(base64[\"decode\"])(sharedSecret);\n                    delete authData[\"shared_secret\"];\n                    callback(null, authData);\n                });\n            }\n            trigger(event, data) {\n                throw new UnsupportedFeature(\"Client events are not currently supported for encrypted channels\");\n            }\n            handleEvent(event) {\n                var eventName = event.event;\n                var data = event.data;\n                if (eventName.indexOf(\"pusher_internal:\") === 0 || eventName.indexOf(\"pusher:\") === 0) {\n                    super.handleEvent(event);\n                    return;\n                }\n                this.handleEncryptedEvent(eventName, data);\n            }\n            handleEncryptedEvent(event, data) {\n                if (!this.key) {\n                    logger.debug(\"Received encrypted event before key has been retrieved from the authEndpoint\");\n                    return;\n                }\n                if (!data.ciphertext || !data.nonce) {\n                    logger.error(\"Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: \" + data);\n                    return;\n                }\n                let cipherText = Object(base64[\"decode\"])(data.ciphertext);\n                if (cipherText.length < this.nacl.secretbox.overheadLength) {\n                    logger.error(`Expected encrypted event ciphertext length to be ${this.nacl.secretbox.overheadLength}, got: ${cipherText.length}`);\n                    return;\n                }\n                let nonce = Object(base64[\"decode\"])(data.nonce);\n                if (nonce.length < this.nacl.secretbox.nonceLength) {\n                    logger.error(`Expected encrypted event nonce length to be ${this.nacl.secretbox.nonceLength}, got: ${nonce.length}`);\n                    return;\n                }\n                let bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n                if (bytes === null) {\n                    logger.debug(\"Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...\");\n                    this.authorize(this.pusher.connection.socket_id, (error, authData)=>{\n                        if (error) {\n                            logger.error(`Failed to make a request to the authEndpoint: ${authData}. Unable to fetch new key, so dropping encrypted event`);\n                            return;\n                        }\n                        bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n                        if (bytes === null) {\n                            logger.error(`Failed to decrypt event with new key. Dropping encrypted event`);\n                            return;\n                        }\n                        this.emit(event, this.getDataToEmit(bytes));\n                        return;\n                    });\n                    return;\n                }\n                this.emit(event, this.getDataToEmit(bytes));\n            }\n            getDataToEmit(bytes) {\n                let raw = Object(utf8[\"decode\"])(bytes);\n                try {\n                    return JSON.parse(raw);\n                } catch (_a) {\n                    return raw;\n                }\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/connection/connection_manager.ts\n        class connection_manager_ConnectionManager extends dispatcher_Dispatcher {\n            constructor(key, options){\n                super();\n                this.state = \"initialized\";\n                this.connection = null;\n                this.key = key;\n                this.options = options;\n                this.timeline = this.options.timeline;\n                this.usingTLS = this.options.useTLS;\n                this.errorCallbacks = this.buildErrorCallbacks();\n                this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);\n                this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);\n                var Network = node_runtime.getNetwork();\n                Network.bind(\"online\", ()=>{\n                    this.timeline.info({\n                        netinfo: \"online\"\n                    });\n                    if (this.state === \"connecting\" || this.state === \"unavailable\") {\n                        this.retryIn(0);\n                    }\n                });\n                Network.bind(\"offline\", ()=>{\n                    this.timeline.info({\n                        netinfo: \"offline\"\n                    });\n                    if (this.connection) {\n                        this.sendActivityCheck();\n                    }\n                });\n                this.updateStrategy();\n            }\n            connect() {\n                if (this.connection || this.runner) {\n                    return;\n                }\n                if (!this.strategy.isSupported()) {\n                    this.updateState(\"failed\");\n                    return;\n                }\n                this.updateState(\"connecting\");\n                this.startConnecting();\n                this.setUnavailableTimer();\n            }\n            send(data) {\n                if (this.connection) {\n                    return this.connection.send(data);\n                } else {\n                    return false;\n                }\n            }\n            send_event(name, data, channel) {\n                if (this.connection) {\n                    return this.connection.send_event(name, data, channel);\n                } else {\n                    return false;\n                }\n            }\n            disconnect() {\n                this.disconnectInternally();\n                this.updateState(\"disconnected\");\n            }\n            isUsingTLS() {\n                return this.usingTLS;\n            }\n            startConnecting() {\n                var callback = (error, handshake)=>{\n                    if (error) {\n                        this.runner = this.strategy.connect(0, callback);\n                    } else {\n                        if (handshake.action === \"error\") {\n                            this.emit(\"error\", {\n                                type: \"HandshakeError\",\n                                error: handshake.error\n                            });\n                            this.timeline.error({\n                                handshakeError: handshake.error\n                            });\n                        } else {\n                            this.abortConnecting();\n                            this.handshakeCallbacks[handshake.action](handshake);\n                        }\n                    }\n                };\n                this.runner = this.strategy.connect(0, callback);\n            }\n            abortConnecting() {\n                if (this.runner) {\n                    this.runner.abort();\n                    this.runner = null;\n                }\n            }\n            disconnectInternally() {\n                this.abortConnecting();\n                this.clearRetryTimer();\n                this.clearUnavailableTimer();\n                if (this.connection) {\n                    var connection = this.abandonConnection();\n                    connection.close();\n                }\n            }\n            updateStrategy() {\n                this.strategy = this.options.getStrategy({\n                    key: this.key,\n                    timeline: this.timeline,\n                    useTLS: this.usingTLS\n                });\n            }\n            retryIn(delay) {\n                this.timeline.info({\n                    action: \"retry\",\n                    delay: delay\n                });\n                if (delay > 0) {\n                    this.emit(\"connecting_in\", Math.round(delay / 1000));\n                }\n                this.retryTimer = new timers_OneOffTimer(delay || 0, ()=>{\n                    this.disconnectInternally();\n                    this.connect();\n                });\n            }\n            clearRetryTimer() {\n                if (this.retryTimer) {\n                    this.retryTimer.ensureAborted();\n                    this.retryTimer = null;\n                }\n            }\n            setUnavailableTimer() {\n                this.unavailableTimer = new timers_OneOffTimer(this.options.unavailableTimeout, ()=>{\n                    this.updateState(\"unavailable\");\n                });\n            }\n            clearUnavailableTimer() {\n                if (this.unavailableTimer) {\n                    this.unavailableTimer.ensureAborted();\n                }\n            }\n            sendActivityCheck() {\n                this.stopActivityCheck();\n                this.connection.ping();\n                this.activityTimer = new timers_OneOffTimer(this.options.pongTimeout, ()=>{\n                    this.timeline.error({\n                        pong_timed_out: this.options.pongTimeout\n                    });\n                    this.retryIn(0);\n                });\n            }\n            resetActivityCheck() {\n                this.stopActivityCheck();\n                if (this.connection && !this.connection.handlesActivityChecks()) {\n                    this.activityTimer = new timers_OneOffTimer(this.activityTimeout, ()=>{\n                        this.sendActivityCheck();\n                    });\n                }\n            }\n            stopActivityCheck() {\n                if (this.activityTimer) {\n                    this.activityTimer.ensureAborted();\n                }\n            }\n            buildConnectionCallbacks(errorCallbacks) {\n                return extend({}, errorCallbacks, {\n                    message: (message)=>{\n                        this.resetActivityCheck();\n                        this.emit(\"message\", message);\n                    },\n                    ping: ()=>{\n                        this.send_event(\"pusher:pong\", {});\n                    },\n                    activity: ()=>{\n                        this.resetActivityCheck();\n                    },\n                    error: (error)=>{\n                        this.emit(\"error\", error);\n                    },\n                    closed: ()=>{\n                        this.abandonConnection();\n                        if (this.shouldRetry()) {\n                            this.retryIn(1000);\n                        }\n                    }\n                });\n            }\n            buildHandshakeCallbacks(errorCallbacks) {\n                return extend({}, errorCallbacks, {\n                    connected: (handshake)=>{\n                        this.activityTimeout = Math.min(this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);\n                        this.clearUnavailableTimer();\n                        this.setConnection(handshake.connection);\n                        this.socket_id = this.connection.id;\n                        this.updateState(\"connected\", {\n                            socket_id: this.socket_id\n                        });\n                    }\n                });\n            }\n            buildErrorCallbacks() {\n                let withErrorEmitted = (callback)=>{\n                    return (result)=>{\n                        if (result.error) {\n                            this.emit(\"error\", {\n                                type: \"WebSocketError\",\n                                error: result.error\n                            });\n                        }\n                        callback(result);\n                    };\n                };\n                return {\n                    tls_only: withErrorEmitted(()=>{\n                        this.usingTLS = true;\n                        this.updateStrategy();\n                        this.retryIn(0);\n                    }),\n                    refused: withErrorEmitted(()=>{\n                        this.disconnect();\n                    }),\n                    backoff: withErrorEmitted(()=>{\n                        this.retryIn(1000);\n                    }),\n                    retry: withErrorEmitted(()=>{\n                        this.retryIn(0);\n                    })\n                };\n            }\n            setConnection(connection) {\n                this.connection = connection;\n                for(var event in this.connectionCallbacks){\n                    this.connection.bind(event, this.connectionCallbacks[event]);\n                }\n                this.resetActivityCheck();\n            }\n            abandonConnection() {\n                if (!this.connection) {\n                    return;\n                }\n                this.stopActivityCheck();\n                for(var event in this.connectionCallbacks){\n                    this.connection.unbind(event, this.connectionCallbacks[event]);\n                }\n                var connection = this.connection;\n                this.connection = null;\n                return connection;\n            }\n            updateState(newState, data) {\n                var previousState = this.state;\n                this.state = newState;\n                if (previousState !== newState) {\n                    var newStateDescription = newState;\n                    if (newStateDescription === \"connected\") {\n                        newStateDescription += \" with new socket ID \" + data.socket_id;\n                    }\n                    logger.debug(\"State changed\", previousState + \" -> \" + newStateDescription);\n                    this.timeline.info({\n                        state: newState,\n                        params: data\n                    });\n                    this.emit(\"state_change\", {\n                        previous: previousState,\n                        current: newState\n                    });\n                    this.emit(newState, data);\n                }\n            }\n            shouldRetry() {\n                return this.state === \"connecting\" || this.state === \"connected\";\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/channels/channels.ts\n        class channels_Channels {\n            constructor(){\n                this.channels = {};\n            }\n            add(name, pusher) {\n                if (!this.channels[name]) {\n                    this.channels[name] = createChannel(name, pusher);\n                }\n                return this.channels[name];\n            }\n            all() {\n                return values(this.channels);\n            }\n            find(name) {\n                return this.channels[name];\n            }\n            remove(name) {\n                var channel = this.channels[name];\n                delete this.channels[name];\n                return channel;\n            }\n            disconnect() {\n                objectApply(this.channels, function(channel) {\n                    channel.disconnect();\n                });\n            }\n        }\n        function createChannel(name, pusher) {\n            if (name.indexOf(\"private-encrypted-\") === 0) {\n                if (pusher.config.nacl) {\n                    return factory.createEncryptedChannel(name, pusher, pusher.config.nacl);\n                }\n                let errMsg = \"Tried to subscribe to a private-encrypted- channel but no nacl implementation available\";\n                let suffix = url_store.buildLogSuffix(\"encryptedChannelSupport\");\n                throw new UnsupportedFeature(`${errMsg}. ${suffix}`);\n            } else if (name.indexOf(\"private-\") === 0) {\n                return factory.createPrivateChannel(name, pusher);\n            } else if (name.indexOf(\"presence-\") === 0) {\n                return factory.createPresenceChannel(name, pusher);\n            } else if (name.indexOf(\"#\") === 0) {\n                throw new BadChannelName('Cannot create a channel with name \"' + name + '\".');\n            } else {\n                return factory.createChannel(name, pusher);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/utils/factory.ts\n        var Factory = {\n            createChannels () {\n                return new channels_Channels();\n            },\n            createConnectionManager (key, options) {\n                return new connection_manager_ConnectionManager(key, options);\n            },\n            createChannel (name, pusher) {\n                return new channel_Channel(name, pusher);\n            },\n            createPrivateChannel (name, pusher) {\n                return new private_channel_PrivateChannel(name, pusher);\n            },\n            createPresenceChannel (name, pusher) {\n                return new presence_channel_PresenceChannel(name, pusher);\n            },\n            createEncryptedChannel (name, pusher, nacl) {\n                return new encrypted_channel_EncryptedChannel(name, pusher, nacl);\n            },\n            createTimelineSender (timeline, options) {\n                return new timeline_sender_TimelineSender(timeline, options);\n            },\n            createHandshake (transport, callback) {\n                return new handshake_Handshake(transport, callback);\n            },\n            createAssistantToTheTransportManager (manager, transport, options) {\n                return new assistant_to_the_transport_manager_AssistantToTheTransportManager(manager, transport, options);\n            }\n        };\n        /* harmony default export */ var factory = Factory;\n        // CONCATENATED MODULE: ./src/core/transports/transport_manager.ts\n        class transport_manager_TransportManager {\n            constructor(options){\n                this.options = options || {};\n                this.livesLeft = this.options.lives || Infinity;\n            }\n            getAssistant(transport) {\n                return factory.createAssistantToTheTransportManager(this, transport, {\n                    minPingDelay: this.options.minPingDelay,\n                    maxPingDelay: this.options.maxPingDelay\n                });\n            }\n            isAlive() {\n                return this.livesLeft > 0;\n            }\n            reportDeath() {\n                this.livesLeft -= 1;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/sequential_strategy.ts\n        class sequential_strategy_SequentialStrategy {\n            constructor(strategies, options){\n                this.strategies = strategies;\n                this.loop = Boolean(options.loop);\n                this.failFast = Boolean(options.failFast);\n                this.timeout = options.timeout;\n                this.timeoutLimit = options.timeoutLimit;\n            }\n            isSupported() {\n                return any(this.strategies, util.method(\"isSupported\"));\n            }\n            connect(minPriority, callback) {\n                var strategies = this.strategies;\n                var current = 0;\n                var timeout = this.timeout;\n                var runner = null;\n                var tryNextStrategy = (error, handshake)=>{\n                    if (handshake) {\n                        callback(null, handshake);\n                    } else {\n                        current = current + 1;\n                        if (this.loop) {\n                            current = current % strategies.length;\n                        }\n                        if (current < strategies.length) {\n                            if (timeout) {\n                                timeout = timeout * 2;\n                                if (this.timeoutLimit) {\n                                    timeout = Math.min(timeout, this.timeoutLimit);\n                                }\n                            }\n                            runner = this.tryStrategy(strategies[current], minPriority, {\n                                timeout,\n                                failFast: this.failFast\n                            }, tryNextStrategy);\n                        } else {\n                            callback(true);\n                        }\n                    }\n                };\n                runner = this.tryStrategy(strategies[current], minPriority, {\n                    timeout: timeout,\n                    failFast: this.failFast\n                }, tryNextStrategy);\n                return {\n                    abort: function() {\n                        runner.abort();\n                    },\n                    forceMinPriority: function(p) {\n                        minPriority = p;\n                        if (runner) {\n                            runner.forceMinPriority(p);\n                        }\n                    }\n                };\n            }\n            tryStrategy(strategy, minPriority, options, callback) {\n                var timer = null;\n                var runner = null;\n                if (options.timeout > 0) {\n                    timer = new timers_OneOffTimer(options.timeout, function() {\n                        runner.abort();\n                        callback(true);\n                    });\n                }\n                runner = strategy.connect(minPriority, function(error, handshake) {\n                    if (error && timer && timer.isRunning() && !options.failFast) {\n                        return;\n                    }\n                    if (timer) {\n                        timer.ensureAborted();\n                    }\n                    callback(error, handshake);\n                });\n                return {\n                    abort: function() {\n                        if (timer) {\n                            timer.ensureAborted();\n                        }\n                        runner.abort();\n                    },\n                    forceMinPriority: function(p) {\n                        runner.forceMinPriority(p);\n                    }\n                };\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/best_connected_ever_strategy.ts\n        class best_connected_ever_strategy_BestConnectedEverStrategy {\n            constructor(strategies){\n                this.strategies = strategies;\n            }\n            isSupported() {\n                return any(this.strategies, util.method(\"isSupported\"));\n            }\n            connect(minPriority, callback) {\n                return connect(this.strategies, minPriority, function(i, runners) {\n                    return function(error, handshake) {\n                        runners[i].error = error;\n                        if (error) {\n                            if (allRunnersFailed(runners)) {\n                                callback(true);\n                            }\n                            return;\n                        }\n                        apply(runners, function(runner) {\n                            runner.forceMinPriority(handshake.transport.priority);\n                        });\n                        callback(null, handshake);\n                    };\n                });\n            }\n        }\n        function connect(strategies, minPriority, callbackBuilder) {\n            var runners = map(strategies, function(strategy, i, _, rs) {\n                return strategy.connect(minPriority, callbackBuilder(i, rs));\n            });\n            return {\n                abort: function() {\n                    apply(runners, abortRunner);\n                },\n                forceMinPriority: function(p) {\n                    apply(runners, function(runner) {\n                        runner.forceMinPriority(p);\n                    });\n                }\n            };\n        }\n        function allRunnersFailed(runners) {\n            return collections_all(runners, function(runner) {\n                return Boolean(runner.error);\n            });\n        }\n        function abortRunner(runner) {\n            if (!runner.error && !runner.aborted) {\n                runner.abort();\n                runner.aborted = true;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/websocket_prioritized_cached_strategy.ts\n        class websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy {\n            constructor(strategy, transports, options){\n                this.strategy = strategy;\n                this.transports = transports;\n                this.ttl = options.ttl || 1800 * 1000;\n                this.usingTLS = options.useTLS;\n                this.timeline = options.timeline;\n            }\n            isSupported() {\n                return this.strategy.isSupported();\n            }\n            connect(minPriority, callback) {\n                var usingTLS = this.usingTLS;\n                var info = fetchTransportCache(usingTLS);\n                var cacheSkipCount = info && info.cacheSkipCount ? info.cacheSkipCount : 0;\n                var strategies = [\n                    this.strategy\n                ];\n                if (info && info.timestamp + this.ttl >= util.now()) {\n                    var transport = this.transports[info.transport];\n                    if (transport) {\n                        if ([\n                            \"ws\",\n                            \"wss\"\n                        ].includes(info.transport) || cacheSkipCount > 3) {\n                            this.timeline.info({\n                                cached: true,\n                                transport: info.transport,\n                                latency: info.latency\n                            });\n                            strategies.push(new sequential_strategy_SequentialStrategy([\n                                transport\n                            ], {\n                                timeout: info.latency * 2 + 1000,\n                                failFast: true\n                            }));\n                        } else {\n                            cacheSkipCount++;\n                        }\n                    }\n                }\n                var startTimestamp = util.now();\n                var runner = strategies.pop().connect(minPriority, function cb(error, handshake) {\n                    if (error) {\n                        flushTransportCache(usingTLS);\n                        if (strategies.length > 0) {\n                            startTimestamp = util.now();\n                            runner = strategies.pop().connect(minPriority, cb);\n                        } else {\n                            callback(error);\n                        }\n                    } else {\n                        storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp, cacheSkipCount);\n                        callback(null, handshake);\n                    }\n                });\n                return {\n                    abort: function() {\n                        runner.abort();\n                    },\n                    forceMinPriority: function(p) {\n                        minPriority = p;\n                        if (runner) {\n                            runner.forceMinPriority(p);\n                        }\n                    }\n                };\n            }\n        }\n        function getTransportCacheKey(usingTLS) {\n            return \"pusherTransport\" + (usingTLS ? \"TLS\" : \"NonTLS\");\n        }\n        function fetchTransportCache(usingTLS) {\n            var storage = node_runtime.getLocalStorage();\n            if (storage) {\n                try {\n                    var serializedCache = storage[getTransportCacheKey(usingTLS)];\n                    if (serializedCache) {\n                        return JSON.parse(serializedCache);\n                    }\n                } catch (e) {\n                    flushTransportCache(usingTLS);\n                }\n            }\n            return null;\n        }\n        function storeTransportCache(usingTLS, transport, latency, cacheSkipCount) {\n            var storage = node_runtime.getLocalStorage();\n            if (storage) {\n                try {\n                    storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({\n                        timestamp: util.now(),\n                        transport: transport,\n                        latency: latency,\n                        cacheSkipCount: cacheSkipCount\n                    });\n                } catch (e) {}\n            }\n        }\n        function flushTransportCache(usingTLS) {\n            var storage = node_runtime.getLocalStorage();\n            if (storage) {\n                try {\n                    delete storage[getTransportCacheKey(usingTLS)];\n                } catch (e) {}\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/delayed_strategy.ts\n        class delayed_strategy_DelayedStrategy {\n            constructor(strategy, { delay: number }){\n                this.strategy = strategy;\n                this.options = {\n                    delay: number\n                };\n            }\n            isSupported() {\n                return this.strategy.isSupported();\n            }\n            connect(minPriority, callback) {\n                var strategy = this.strategy;\n                var runner;\n                var timer = new timers_OneOffTimer(this.options.delay, function() {\n                    runner = strategy.connect(minPriority, callback);\n                });\n                return {\n                    abort: function() {\n                        timer.ensureAborted();\n                        if (runner) {\n                            runner.abort();\n                        }\n                    },\n                    forceMinPriority: function(p) {\n                        minPriority = p;\n                        if (runner) {\n                            runner.forceMinPriority(p);\n                        }\n                    }\n                };\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/if_strategy.ts\n        class IfStrategy {\n            constructor(test, trueBranch, falseBranch){\n                this.test = test;\n                this.trueBranch = trueBranch;\n                this.falseBranch = falseBranch;\n            }\n            isSupported() {\n                var branch = this.test() ? this.trueBranch : this.falseBranch;\n                return branch.isSupported();\n            }\n            connect(minPriority, callback) {\n                var branch = this.test() ? this.trueBranch : this.falseBranch;\n                return branch.connect(minPriority, callback);\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/first_connected_strategy.ts\n        class FirstConnectedStrategy {\n            constructor(strategy){\n                this.strategy = strategy;\n            }\n            isSupported() {\n                return this.strategy.isSupported();\n            }\n            connect(minPriority, callback) {\n                var runner = this.strategy.connect(minPriority, function(error, handshake) {\n                    if (handshake) {\n                        runner.abort();\n                    }\n                    callback(error, handshake);\n                });\n                return runner;\n            }\n        }\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/default_strategy.ts\n        function testSupportsStrategy(strategy) {\n            return function() {\n                return strategy.isSupported();\n            };\n        }\n        var getDefaultStrategy = function(config, baseOptions, defineTransport) {\n            var definedTransports = {};\n            function defineTransportStrategy(name, type, priority, options, manager) {\n                var transport = defineTransport(config, name, type, priority, options, manager);\n                definedTransports[name] = transport;\n                return transport;\n            }\n            var ws_options = Object.assign({}, baseOptions, {\n                hostNonTLS: config.wsHost + \":\" + config.wsPort,\n                hostTLS: config.wsHost + \":\" + config.wssPort,\n                httpPath: config.wsPath\n            });\n            var wss_options = extend({}, ws_options, {\n                useTLS: true\n            });\n            var http_options = Object.assign({}, baseOptions, {\n                hostNonTLS: config.httpHost + \":\" + config.httpPort,\n                hostTLS: config.httpHost + \":\" + config.httpsPort,\n                httpPath: config.httpPath\n            });\n            var timeouts = {\n                loop: true,\n                timeout: 15000,\n                timeoutLimit: 60000\n            };\n            var ws_manager = new transport_manager_TransportManager({\n                minPingDelay: 10000,\n                maxPingDelay: config.activityTimeout\n            });\n            var streaming_manager = new transport_manager_TransportManager({\n                lives: 2,\n                minPingDelay: 10000,\n                maxPingDelay: config.activityTimeout\n            });\n            var ws_transport = defineTransportStrategy(\"ws\", \"ws\", 3, ws_options, ws_manager);\n            var wss_transport = defineTransportStrategy(\"wss\", \"ws\", 3, wss_options, ws_manager);\n            var xhr_streaming_transport = defineTransportStrategy(\"xhr_streaming\", \"xhr_streaming\", 1, http_options, streaming_manager);\n            var xhr_polling_transport = defineTransportStrategy(\"xhr_polling\", \"xhr_polling\", 1, http_options);\n            var ws_loop = new sequential_strategy_SequentialStrategy([\n                ws_transport\n            ], timeouts);\n            var wss_loop = new sequential_strategy_SequentialStrategy([\n                wss_transport\n            ], timeouts);\n            var streaming_loop = new sequential_strategy_SequentialStrategy([\n                xhr_streaming_transport\n            ], timeouts);\n            var polling_loop = new sequential_strategy_SequentialStrategy([\n                xhr_polling_transport\n            ], timeouts);\n            var http_loop = new sequential_strategy_SequentialStrategy([\n                new IfStrategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy_BestConnectedEverStrategy([\n                    streaming_loop,\n                    new delayed_strategy_DelayedStrategy(polling_loop, {\n                        delay: 4000\n                    })\n                ]), polling_loop)\n            ], timeouts);\n            var wsStrategy;\n            if (baseOptions.useTLS) {\n                wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n                    ws_loop,\n                    new delayed_strategy_DelayedStrategy(http_loop, {\n                        delay: 2000\n                    })\n                ]);\n            } else {\n                wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n                    ws_loop,\n                    new delayed_strategy_DelayedStrategy(wss_loop, {\n                        delay: 2000\n                    }),\n                    new delayed_strategy_DelayedStrategy(http_loop, {\n                        delay: 5000\n                    })\n                ]);\n            }\n            return new websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy(new FirstConnectedStrategy(new IfStrategy(testSupportsStrategy(ws_transport), wsStrategy, http_loop)), definedTransports, {\n                ttl: 1800000,\n                timeline: baseOptions.timeline,\n                useTLS: baseOptions.useTLS\n            });\n        };\n        /* harmony default export */ var default_strategy = getDefaultStrategy;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transport_connection_initializer.ts\n        /* harmony default export */ var transport_connection_initializer = function() {\n            var self1 = this;\n            self1.timeline.info(self1.buildTimelineMessage({\n                transport: self1.name + (self1.options.useTLS ? \"s\" : \"\")\n            }));\n            if (self1.hooks.isInitialized()) {\n                self1.changeState(\"initialized\");\n            } else {\n                self1.onClose();\n            }\n        };\n        // CONCATENATED MODULE: ./src/core/http/http_request.ts\n        const MAX_BUFFER_LENGTH = 256 * 1024;\n        class http_request_HTTPRequest extends dispatcher_Dispatcher {\n            constructor(hooks, method, url){\n                super();\n                this.hooks = hooks;\n                this.method = method;\n                this.url = url;\n            }\n            start(payload) {\n                this.position = 0;\n                this.xhr = this.hooks.getRequest(this);\n                this.unloader = ()=>{\n                    this.close();\n                };\n                node_runtime.addUnloadListener(this.unloader);\n                this.xhr.open(this.method, this.url, true);\n                if (this.xhr.setRequestHeader) {\n                    this.xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n                }\n                this.xhr.send(payload);\n            }\n            close() {\n                if (this.unloader) {\n                    node_runtime.removeUnloadListener(this.unloader);\n                    this.unloader = null;\n                }\n                if (this.xhr) {\n                    this.hooks.abortRequest(this.xhr);\n                    this.xhr = null;\n                }\n            }\n            onChunk(status, data) {\n                while(true){\n                    var chunk = this.advanceBuffer(data);\n                    if (chunk) {\n                        this.emit(\"chunk\", {\n                            status: status,\n                            data: chunk\n                        });\n                    } else {\n                        break;\n                    }\n                }\n                if (this.isBufferTooLong(data)) {\n                    this.emit(\"buffer_too_long\");\n                }\n            }\n            advanceBuffer(buffer) {\n                var unreadData = buffer.slice(this.position);\n                var endOfLinePosition = unreadData.indexOf(\"\\n\");\n                if (endOfLinePosition !== -1) {\n                    this.position += endOfLinePosition + 1;\n                    return unreadData.slice(0, endOfLinePosition);\n                } else {\n                    return null;\n                }\n            }\n            isBufferTooLong(buffer) {\n                return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/http/state.ts\n        var State;\n        (function(State) {\n            State[State[\"CONNECTING\"] = 0] = \"CONNECTING\";\n            State[State[\"OPEN\"] = 1] = \"OPEN\";\n            State[State[\"CLOSED\"] = 3] = \"CLOSED\";\n        })(State || (State = {}));\n        /* harmony default export */ var state = State;\n        // CONCATENATED MODULE: ./src/core/http/http_socket.ts\n        var autoIncrement = 1;\n        class http_socket_HTTPSocket {\n            constructor(hooks, url){\n                this.hooks = hooks;\n                this.session = randomNumber(1000) + \"/\" + randomString(8);\n                this.location = getLocation(url);\n                this.readyState = state.CONNECTING;\n                this.openStream();\n            }\n            send(payload) {\n                return this.sendRaw(JSON.stringify([\n                    payload\n                ]));\n            }\n            ping() {\n                this.hooks.sendHeartbeat(this);\n            }\n            close(code, reason) {\n                this.onClose(code, reason, true);\n            }\n            sendRaw(payload) {\n                if (this.readyState === state.OPEN) {\n                    try {\n                        node_runtime.createSocketRequest(\"POST\", getUniqueURL(getSendURL(this.location, this.session))).start(payload);\n                        return true;\n                    } catch (e) {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n            reconnect() {\n                this.closeStream();\n                this.openStream();\n            }\n            onClose(code, reason, wasClean) {\n                this.closeStream();\n                this.readyState = state.CLOSED;\n                if (this.onclose) {\n                    this.onclose({\n                        code: code,\n                        reason: reason,\n                        wasClean: wasClean\n                    });\n                }\n            }\n            onChunk(chunk) {\n                if (chunk.status !== 200) {\n                    return;\n                }\n                if (this.readyState === state.OPEN) {\n                    this.onActivity();\n                }\n                var payload;\n                var type = chunk.data.slice(0, 1);\n                switch(type){\n                    case \"o\":\n                        payload = JSON.parse(chunk.data.slice(1) || \"{}\");\n                        this.onOpen(payload);\n                        break;\n                    case \"a\":\n                        payload = JSON.parse(chunk.data.slice(1) || \"[]\");\n                        for(var i = 0; i < payload.length; i++){\n                            this.onEvent(payload[i]);\n                        }\n                        break;\n                    case \"m\":\n                        payload = JSON.parse(chunk.data.slice(1) || \"null\");\n                        this.onEvent(payload);\n                        break;\n                    case \"h\":\n                        this.hooks.onHeartbeat(this);\n                        break;\n                    case \"c\":\n                        payload = JSON.parse(chunk.data.slice(1) || \"[]\");\n                        this.onClose(payload[0], payload[1], true);\n                        break;\n                }\n            }\n            onOpen(options) {\n                if (this.readyState === state.CONNECTING) {\n                    if (options && options.hostname) {\n                        this.location.base = replaceHost(this.location.base, options.hostname);\n                    }\n                    this.readyState = state.OPEN;\n                    if (this.onopen) {\n                        this.onopen();\n                    }\n                } else {\n                    this.onClose(1006, \"Server lost session\", true);\n                }\n            }\n            onEvent(event) {\n                if (this.readyState === state.OPEN && this.onmessage) {\n                    this.onmessage({\n                        data: event\n                    });\n                }\n            }\n            onActivity() {\n                if (this.onactivity) {\n                    this.onactivity();\n                }\n            }\n            onError(error) {\n                if (this.onerror) {\n                    this.onerror(error);\n                }\n            }\n            openStream() {\n                this.stream = node_runtime.createSocketRequest(\"POST\", getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));\n                this.stream.bind(\"chunk\", (chunk)=>{\n                    this.onChunk(chunk);\n                });\n                this.stream.bind(\"finished\", (status)=>{\n                    this.hooks.onFinished(this, status);\n                });\n                this.stream.bind(\"buffer_too_long\", ()=>{\n                    this.reconnect();\n                });\n                try {\n                    this.stream.start();\n                } catch (error) {\n                    util.defer(()=>{\n                        this.onError(error);\n                        this.onClose(1006, \"Could not start streaming\", false);\n                    });\n                }\n            }\n            closeStream() {\n                if (this.stream) {\n                    this.stream.unbind_all();\n                    this.stream.close();\n                    this.stream = null;\n                }\n            }\n        }\n        function getLocation(url) {\n            var parts = /([^\\?]*)\\/*(\\??.*)/.exec(url);\n            return {\n                base: parts[1],\n                queryString: parts[2]\n            };\n        }\n        function getSendURL(url, session) {\n            return url.base + \"/\" + session + \"/xhr_send\";\n        }\n        function getUniqueURL(url) {\n            var separator = url.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n            return url + separator + \"t=\" + +new Date() + \"&n=\" + autoIncrement++;\n        }\n        function replaceHost(url, hostname) {\n            var urlParts = /(https?:\\/\\/)([^\\/:]+)((\\/|:)?.*)/.exec(url);\n            return urlParts[1] + hostname + urlParts[3];\n        }\n        function randomNumber(max) {\n            return node_runtime.randomInt(max);\n        }\n        function randomString(length) {\n            var result = [];\n            for(var i = 0; i < length; i++){\n                result.push(randomNumber(32).toString(32));\n            }\n            return result.join(\"\");\n        }\n        /* harmony default export */ var http_socket = http_socket_HTTPSocket;\n        // CONCATENATED MODULE: ./src/core/http/http_streaming_socket.ts\n        var http_streaming_socket_hooks = {\n            getReceiveURL: function(url, session) {\n                return url.base + \"/\" + session + \"/xhr_streaming\" + url.queryString;\n            },\n            onHeartbeat: function(socket) {\n                socket.sendRaw(\"[]\");\n            },\n            sendHeartbeat: function(socket) {\n                socket.sendRaw(\"[]\");\n            },\n            onFinished: function(socket, status) {\n                socket.onClose(1006, \"Connection interrupted (\" + status + \")\", false);\n            }\n        };\n        /* harmony default export */ var http_streaming_socket = http_streaming_socket_hooks;\n        // CONCATENATED MODULE: ./src/core/http/http_polling_socket.ts\n        var http_polling_socket_hooks = {\n            getReceiveURL: function(url, session) {\n                return url.base + \"/\" + session + \"/xhr\" + url.queryString;\n            },\n            onHeartbeat: function() {},\n            sendHeartbeat: function(socket) {\n                socket.sendRaw(\"[]\");\n            },\n            onFinished: function(socket, status) {\n                if (status === 200) {\n                    socket.reconnect();\n                } else {\n                    socket.onClose(1006, \"Connection interrupted (\" + status + \")\", false);\n                }\n            }\n        };\n        /* harmony default export */ var http_polling_socket = http_polling_socket_hooks;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http_xhr_request.ts\n        var http_xhr_request_hooks = {\n            getRequest: function(socket) {\n                var Constructor = node_runtime.getXHRAPI();\n                var xhr = new Constructor();\n                xhr.onreadystatechange = xhr.onprogress = function() {\n                    switch(xhr.readyState){\n                        case 3:\n                            if (xhr.responseText && xhr.responseText.length > 0) {\n                                socket.onChunk(xhr.status, xhr.responseText);\n                            }\n                            break;\n                        case 4:\n                            if (xhr.responseText && xhr.responseText.length > 0) {\n                                socket.onChunk(xhr.status, xhr.responseText);\n                            }\n                            socket.emit(\"finished\", xhr.status);\n                            socket.close();\n                            break;\n                    }\n                };\n                return xhr;\n            },\n            abortRequest: function(xhr) {\n                xhr.onreadystatechange = null;\n                xhr.abort();\n            }\n        };\n        /* harmony default export */ var http_xhr_request = http_xhr_request_hooks;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http.ts\n        var HTTP = {\n            createStreamingSocket (url) {\n                return this.createSocket(http_streaming_socket, url);\n            },\n            createPollingSocket (url) {\n                return this.createSocket(http_polling_socket, url);\n            },\n            createSocket (hooks, url) {\n                return new http_socket(hooks, url);\n            },\n            createXHR (method, url) {\n                return this.createRequest(http_xhr_request, method, url);\n            },\n            createRequest (hooks, method, url) {\n                return new http_request_HTTPRequest(hooks, method, url);\n            }\n        };\n        /* harmony default export */ var http_http = HTTP;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/runtime.ts\n        var Isomorphic = {\n            getDefaultStrategy: default_strategy,\n            Transports: transports,\n            transportConnectionInitializer: transport_connection_initializer,\n            HTTPFactory: http_http,\n            setup (PusherClass) {\n                PusherClass.ready();\n            },\n            getLocalStorage () {\n                return undefined;\n            },\n            getClientFeatures () {\n                return keys(filterObject({\n                    ws: transports.ws\n                }, function(t) {\n                    return t.isSupported({});\n                }));\n            },\n            getProtocol () {\n                return \"http:\";\n            },\n            isXHRSupported () {\n                return true;\n            },\n            createSocketRequest (method, url) {\n                if (this.isXHRSupported()) {\n                    return this.HTTPFactory.createXHR(method, url);\n                } else {\n                    throw \"Cross-origin HTTP requests are not supported\";\n                }\n            },\n            createXHR () {\n                var Constructor = this.getXHRAPI();\n                return new Constructor();\n            },\n            createWebSocket (url) {\n                var Constructor = this.getWebSocketAPI();\n                return new Constructor(url);\n            },\n            addUnloadListener (listener) {},\n            removeUnloadListener (listener) {}\n        };\n        /* harmony default export */ var runtime = Isomorphic;\n        // EXTERNAL MODULE: ./node_modules/faye-websocket/lib/faye/websocket.js\n        var websocket = __nested_webpack_require_266492__(18);\n        // EXTERNAL MODULE: ./node_modules/xmlhttprequest/lib/XMLHttpRequest.js\n        var XMLHttpRequest = __nested_webpack_require_266492__(19);\n        // CONCATENATED MODULE: ./src/runtimes/node/net_info.ts\n        class net_info_NetInfo extends dispatcher_Dispatcher {\n            isOnline() {\n                return true;\n            }\n        }\n        var net_info_Network = new net_info_NetInfo();\n        // CONCATENATED MODULE: ./src/core/auth/options.ts\n        var AuthRequestType;\n        (function(AuthRequestType) {\n            AuthRequestType[\"UserAuthentication\"] = \"user-authentication\";\n            AuthRequestType[\"ChannelAuthorization\"] = \"channel-authorization\";\n        })(AuthRequestType || (AuthRequestType = {}));\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/auth/xhr_auth.ts\n        const ajax = function(context, query, authOptions, authRequestType, callback) {\n            const xhr = node_runtime.createXHR();\n            xhr.open(\"POST\", authOptions.endpoint, true);\n            xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            for(var headerName in authOptions.headers){\n                xhr.setRequestHeader(headerName, authOptions.headers[headerName]);\n            }\n            if (authOptions.headersProvider != null) {\n                let dynamicHeaders = authOptions.headersProvider();\n                for(var headerName in dynamicHeaders){\n                    xhr.setRequestHeader(headerName, dynamicHeaders[headerName]);\n                }\n            }\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                        let data;\n                        let parsed = false;\n                        try {\n                            data = JSON.parse(xhr.responseText);\n                            parsed = true;\n                        } catch (e) {\n                            callback(new HTTPAuthError(200, `JSON returned from ${authRequestType.toString()} endpoint was invalid, yet status code was 200. Data was: ${xhr.responseText}`), null);\n                        }\n                        if (parsed) {\n                            callback(null, data);\n                        }\n                    } else {\n                        let suffix = \"\";\n                        switch(authRequestType){\n                            case AuthRequestType.UserAuthentication:\n                                suffix = url_store.buildLogSuffix(\"authenticationEndpoint\");\n                                break;\n                            case AuthRequestType.ChannelAuthorization:\n                                suffix = `Clients must be authorized to join private or presence channels. ${url_store.buildLogSuffix(\"authorizationEndpoint\")}`;\n                                break;\n                        }\n                        callback(new HTTPAuthError(xhr.status, `Unable to retrieve auth string from ${authRequestType.toString()} endpoint - ` + `received status: ${xhr.status} from ${authOptions.endpoint}. ${suffix}`), null);\n                    }\n                }\n            };\n            xhr.send(query);\n            return xhr;\n        };\n        /* harmony default export */ var xhr_auth = ajax;\n        // CONCATENATED MODULE: ./src/runtimes/isomorphic/timeline/xhr_timeline.ts\n        var getAgent = function(sender, useTLS) {\n            return function(data, callback) {\n                var scheme = \"http\" + (useTLS ? \"s\" : \"\") + \"://\";\n                var url = scheme + (sender.host || sender.options.host) + sender.options.path;\n                var query = buildQueryString(data);\n                url += \"/\" + 2 + \"?\" + query;\n                var xhr = node_runtime.createXHR();\n                xhr.open(\"GET\", url, true);\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4) {\n                        let { status, responseText } = xhr;\n                        if (status !== 200) {\n                            logger.debug(`TimelineSender Error: received ${status} from stats.pusher.com`);\n                            return;\n                        }\n                        try {\n                            var { host } = JSON.parse(responseText);\n                        } catch (e) {\n                            logger.debug(`TimelineSenderError: invalid response ${responseText}`);\n                        }\n                        if (host) {\n                            sender.host = host;\n                        }\n                    }\n                };\n                xhr.send();\n            };\n        };\n        var xhr_timeline_xhr = {\n            name: \"xhr\",\n            getAgent\n        };\n        /* harmony default export */ var xhr_timeline = xhr_timeline_xhr;\n        // EXTERNAL MODULE: external \"crypto\"\n        var external_crypto_ = __nested_webpack_require_266492__(3);\n        // CONCATENATED MODULE: ./src/runtimes/node/runtime.ts\n        const { getDefaultStrategy: runtime_getDefaultStrategy, Transports: runtime_Transports, setup, getProtocol, isXHRSupported, getLocalStorage, createXHR, createWebSocket, addUnloadListener, removeUnloadListener, transportConnectionInitializer, createSocketRequest, HTTPFactory } = runtime;\n        const NodeJS = {\n            getDefaultStrategy: runtime_getDefaultStrategy,\n            Transports: runtime_Transports,\n            setup,\n            getProtocol,\n            isXHRSupported,\n            createSocketRequest,\n            getLocalStorage,\n            createXHR,\n            createWebSocket,\n            addUnloadListener,\n            removeUnloadListener,\n            transportConnectionInitializer,\n            HTTPFactory,\n            TimelineTransport: xhr_timeline,\n            getAuthorizers () {\n                return {\n                    ajax: xhr_auth\n                };\n            },\n            getWebSocketAPI () {\n                return websocket[\"Client\"];\n            },\n            getXHRAPI () {\n                return XMLHttpRequest[\"XMLHttpRequest\"];\n            },\n            getNetwork () {\n                return net_info_Network;\n            },\n            randomInt (max) {\n                return Object(external_crypto_[\"randomInt\"])(max);\n            }\n        };\n        /* harmony default export */ var node_runtime = NodeJS;\n        // CONCATENATED MODULE: ./src/core/timeline/level.ts\n        var TimelineLevel;\n        (function(TimelineLevel) {\n            TimelineLevel[TimelineLevel[\"ERROR\"] = 3] = \"ERROR\";\n            TimelineLevel[TimelineLevel[\"INFO\"] = 6] = \"INFO\";\n            TimelineLevel[TimelineLevel[\"DEBUG\"] = 7] = \"DEBUG\";\n        })(TimelineLevel || (TimelineLevel = {}));\n        /* harmony default export */ var timeline_level = TimelineLevel;\n        // CONCATENATED MODULE: ./src/core/timeline/timeline.ts\n        class timeline_Timeline {\n            constructor(key, session, options){\n                this.key = key;\n                this.session = session;\n                this.events = [];\n                this.options = options || {};\n                this.sent = 0;\n                this.uniqueID = 0;\n            }\n            log(level, event) {\n                if (level <= this.options.level) {\n                    this.events.push(extend({}, event, {\n                        timestamp: util.now()\n                    }));\n                    if (this.options.limit && this.events.length > this.options.limit) {\n                        this.events.shift();\n                    }\n                }\n            }\n            error(event) {\n                this.log(timeline_level.ERROR, event);\n            }\n            info(event) {\n                this.log(timeline_level.INFO, event);\n            }\n            debug(event) {\n                this.log(timeline_level.DEBUG, event);\n            }\n            isEmpty() {\n                return this.events.length === 0;\n            }\n            send(sendfn, callback) {\n                var data = extend({\n                    session: this.session,\n                    bundle: this.sent + 1,\n                    key: this.key,\n                    lib: \"js\",\n                    version: this.options.version,\n                    cluster: this.options.cluster,\n                    features: this.options.features,\n                    timeline: this.events\n                }, this.options.params);\n                this.events = [];\n                sendfn(data, (error, result)=>{\n                    if (!error) {\n                        this.sent++;\n                    }\n                    if (callback) {\n                        callback(error, result);\n                    }\n                });\n                return true;\n            }\n            generateUniqueID() {\n                this.uniqueID++;\n                return this.uniqueID;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/transport_strategy.ts\n        class transport_strategy_TransportStrategy {\n            constructor(name, priority, transport, options){\n                this.name = name;\n                this.priority = priority;\n                this.transport = transport;\n                this.options = options || {};\n            }\n            isSupported() {\n                return this.transport.isSupported({\n                    useTLS: this.options.useTLS\n                });\n            }\n            connect(minPriority, callback) {\n                if (!this.isSupported()) {\n                    return failAttempt(new UnsupportedStrategy(), callback);\n                } else if (this.priority < minPriority) {\n                    return failAttempt(new TransportPriorityTooLow(), callback);\n                }\n                var connected = false;\n                var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);\n                var handshake = null;\n                var onInitialized = function() {\n                    transport.unbind(\"initialized\", onInitialized);\n                    transport.connect();\n                };\n                var onOpen = function() {\n                    handshake = factory.createHandshake(transport, function(result) {\n                        connected = true;\n                        unbindListeners();\n                        callback(null, result);\n                    });\n                };\n                var onError = function(error) {\n                    unbindListeners();\n                    callback(error);\n                };\n                var onClosed = function() {\n                    unbindListeners();\n                    var serializedTransport;\n                    serializedTransport = safeJSONStringify(transport);\n                    callback(new TransportClosed(serializedTransport));\n                };\n                var unbindListeners = function() {\n                    transport.unbind(\"initialized\", onInitialized);\n                    transport.unbind(\"open\", onOpen);\n                    transport.unbind(\"error\", onError);\n                    transport.unbind(\"closed\", onClosed);\n                };\n                transport.bind(\"initialized\", onInitialized);\n                transport.bind(\"open\", onOpen);\n                transport.bind(\"error\", onError);\n                transport.bind(\"closed\", onClosed);\n                transport.initialize();\n                return {\n                    abort: ()=>{\n                        if (connected) {\n                            return;\n                        }\n                        unbindListeners();\n                        if (handshake) {\n                            handshake.close();\n                        } else {\n                            transport.close();\n                        }\n                    },\n                    forceMinPriority: (p)=>{\n                        if (connected) {\n                            return;\n                        }\n                        if (this.priority < p) {\n                            if (handshake) {\n                                handshake.close();\n                            } else {\n                                transport.close();\n                            }\n                        }\n                    }\n                };\n            }\n        }\n        function failAttempt(error, callback) {\n            util.defer(function() {\n                callback(error);\n            });\n            return {\n                abort: function() {},\n                forceMinPriority: function() {}\n            };\n        }\n        // CONCATENATED MODULE: ./src/core/strategies/strategy_builder.ts\n        const { Transports: strategy_builder_Transports } = node_runtime;\n        var strategy_builder_defineTransport = function(config, name, type, priority, options, manager) {\n            var transportClass = strategy_builder_Transports[type];\n            if (!transportClass) {\n                throw new UnsupportedTransport(type);\n            }\n            var enabled = (!config.enabledTransports || arrayIndexOf(config.enabledTransports, name) !== -1) && (!config.disabledTransports || arrayIndexOf(config.disabledTransports, name) === -1);\n            var transport;\n            if (enabled) {\n                options = Object.assign({\n                    ignoreNullOrigin: config.ignoreNullOrigin\n                }, options);\n                transport = new transport_strategy_TransportStrategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, options);\n            } else {\n                transport = strategy_builder_UnsupportedStrategy;\n            }\n            return transport;\n        };\n        var strategy_builder_UnsupportedStrategy = {\n            isSupported: function() {\n                return false;\n            },\n            connect: function(_, callback) {\n                var deferred = util.defer(function() {\n                    callback(new UnsupportedStrategy());\n                });\n                return {\n                    abort: function() {\n                        deferred.ensureAborted();\n                    },\n                    forceMinPriority: function() {}\n                };\n            }\n        };\n        // CONCATENATED MODULE: ./src/core/options.ts\n        function validateOptions(options) {\n            if (options == null) {\n                throw \"You must pass an options object\";\n            }\n            if (options.cluster == null) {\n                throw \"Options object must provide a cluster\";\n            }\n            if (\"disableStats\" in options) {\n                logger.warn(\"The disableStats option is deprecated in favor of enableStats\");\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/auth/user_authenticator.ts\n        const composeChannelQuery = (params, authOptions)=>{\n            var query = \"socket_id=\" + encodeURIComponent(params.socketId);\n            for(var key in authOptions.params){\n                query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(authOptions.params[key]);\n            }\n            if (authOptions.paramsProvider != null) {\n                let dynamicParams = authOptions.paramsProvider();\n                for(var key in dynamicParams){\n                    query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(dynamicParams[key]);\n                }\n            }\n            return query;\n        };\n        const UserAuthenticator = (authOptions)=>{\n            if (typeof node_runtime.getAuthorizers()[authOptions.transport] === \"undefined\") {\n                throw `'${authOptions.transport}' is not a recognized auth transport`;\n            }\n            return (params, callback)=>{\n                const query = composeChannelQuery(params, authOptions);\n                node_runtime.getAuthorizers()[authOptions.transport](node_runtime, query, authOptions, AuthRequestType.UserAuthentication, callback);\n            };\n        };\n        /* harmony default export */ var user_authenticator = UserAuthenticator;\n        // CONCATENATED MODULE: ./src/core/auth/channel_authorizer.ts\n        const channel_authorizer_composeChannelQuery = (params, authOptions)=>{\n            var query = \"socket_id=\" + encodeURIComponent(params.socketId);\n            query += \"&channel_name=\" + encodeURIComponent(params.channelName);\n            for(var key in authOptions.params){\n                query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(authOptions.params[key]);\n            }\n            if (authOptions.paramsProvider != null) {\n                let dynamicParams = authOptions.paramsProvider();\n                for(var key in dynamicParams){\n                    query += \"&\" + encodeURIComponent(key) + \"=\" + encodeURIComponent(dynamicParams[key]);\n                }\n            }\n            return query;\n        };\n        const ChannelAuthorizer = (authOptions)=>{\n            if (typeof node_runtime.getAuthorizers()[authOptions.transport] === \"undefined\") {\n                throw `'${authOptions.transport}' is not a recognized auth transport`;\n            }\n            return (params, callback)=>{\n                const query = channel_authorizer_composeChannelQuery(params, authOptions);\n                node_runtime.getAuthorizers()[authOptions.transport](node_runtime, query, authOptions, AuthRequestType.ChannelAuthorization, callback);\n            };\n        };\n        /* harmony default export */ var channel_authorizer = ChannelAuthorizer;\n        // CONCATENATED MODULE: ./src/core/auth/deprecated_channel_authorizer.ts\n        const ChannelAuthorizerProxy = (pusher, authOptions, channelAuthorizerGenerator)=>{\n            const deprecatedAuthorizerOptions = {\n                authTransport: authOptions.transport,\n                authEndpoint: authOptions.endpoint,\n                auth: {\n                    params: authOptions.params,\n                    headers: authOptions.headers\n                }\n            };\n            return (params, callback)=>{\n                const channel = pusher.channel(params.channelName);\n                const channelAuthorizer = channelAuthorizerGenerator(channel, deprecatedAuthorizerOptions);\n                channelAuthorizer.authorize(params.socketId, callback);\n            };\n        };\n        // CONCATENATED MODULE: ./src/core/config.ts\n        function getConfig(opts, pusher) {\n            let config = {\n                activityTimeout: opts.activityTimeout || defaults.activityTimeout,\n                cluster: opts.cluster,\n                httpPath: opts.httpPath || defaults.httpPath,\n                httpPort: opts.httpPort || defaults.httpPort,\n                httpsPort: opts.httpsPort || defaults.httpsPort,\n                pongTimeout: opts.pongTimeout || defaults.pongTimeout,\n                statsHost: opts.statsHost || defaults.stats_host,\n                unavailableTimeout: opts.unavailableTimeout || defaults.unavailableTimeout,\n                wsPath: opts.wsPath || defaults.wsPath,\n                wsPort: opts.wsPort || defaults.wsPort,\n                wssPort: opts.wssPort || defaults.wssPort,\n                enableStats: getEnableStatsConfig(opts),\n                httpHost: getHttpHost(opts),\n                useTLS: shouldUseTLS(opts),\n                wsHost: getWebsocketHost(opts),\n                userAuthenticator: buildUserAuthenticator(opts),\n                channelAuthorizer: buildChannelAuthorizer(opts, pusher)\n            };\n            if (\"disabledTransports\" in opts) config.disabledTransports = opts.disabledTransports;\n            if (\"enabledTransports\" in opts) config.enabledTransports = opts.enabledTransports;\n            if (\"ignoreNullOrigin\" in opts) config.ignoreNullOrigin = opts.ignoreNullOrigin;\n            if (\"timelineParams\" in opts) config.timelineParams = opts.timelineParams;\n            if (\"nacl\" in opts) {\n                config.nacl = opts.nacl;\n            }\n            return config;\n        }\n        function getHttpHost(opts) {\n            if (opts.httpHost) {\n                return opts.httpHost;\n            }\n            if (opts.cluster) {\n                return `sockjs-${opts.cluster}.pusher.com`;\n            }\n            return defaults.httpHost;\n        }\n        function getWebsocketHost(opts) {\n            if (opts.wsHost) {\n                return opts.wsHost;\n            }\n            return getWebsocketHostFromCluster(opts.cluster);\n        }\n        function getWebsocketHostFromCluster(cluster) {\n            return `ws-${cluster}.pusher.com`;\n        }\n        function shouldUseTLS(opts) {\n            if (node_runtime.getProtocol() === \"https:\") {\n                return true;\n            } else if (opts.forceTLS === false) {\n                return false;\n            }\n            return true;\n        }\n        function getEnableStatsConfig(opts) {\n            if (\"enableStats\" in opts) {\n                return opts.enableStats;\n            }\n            if (\"disableStats\" in opts) {\n                return !opts.disableStats;\n            }\n            return false;\n        }\n        function buildUserAuthenticator(opts) {\n            const userAuthentication = Object.assign(Object.assign({}, defaults.userAuthentication), opts.userAuthentication);\n            if (\"customHandler\" in userAuthentication && userAuthentication[\"customHandler\"] != null) {\n                return userAuthentication[\"customHandler\"];\n            }\n            return user_authenticator(userAuthentication);\n        }\n        function buildChannelAuth(opts, pusher) {\n            let channelAuthorization;\n            if (\"channelAuthorization\" in opts) {\n                channelAuthorization = Object.assign(Object.assign({}, defaults.channelAuthorization), opts.channelAuthorization);\n            } else {\n                channelAuthorization = {\n                    transport: opts.authTransport || defaults.authTransport,\n                    endpoint: opts.authEndpoint || defaults.authEndpoint\n                };\n                if (\"auth\" in opts) {\n                    if (\"params\" in opts.auth) channelAuthorization.params = opts.auth.params;\n                    if (\"headers\" in opts.auth) channelAuthorization.headers = opts.auth.headers;\n                }\n                if (\"authorizer\" in opts) channelAuthorization.customHandler = ChannelAuthorizerProxy(pusher, channelAuthorization, opts.authorizer);\n            }\n            return channelAuthorization;\n        }\n        function buildChannelAuthorizer(opts, pusher) {\n            const channelAuthorization = buildChannelAuth(opts, pusher);\n            if (\"customHandler\" in channelAuthorization && channelAuthorization[\"customHandler\"] != null) {\n                return channelAuthorization[\"customHandler\"];\n            }\n            return channel_authorizer(channelAuthorization);\n        }\n        // CONCATENATED MODULE: ./src/core/watchlist.ts\n        class watchlist_WatchlistFacade extends dispatcher_Dispatcher {\n            constructor(pusher){\n                super(function(eventName, data) {\n                    logger.debug(`No callbacks on watchlist events for ${eventName}`);\n                });\n                this.pusher = pusher;\n                this.bindWatchlistInternalEvent();\n            }\n            handleEvent(pusherEvent) {\n                pusherEvent.data.events.forEach((watchlistEvent)=>{\n                    this.emit(watchlistEvent.name, watchlistEvent);\n                });\n            }\n            bindWatchlistInternalEvent() {\n                this.pusher.connection.bind(\"message\", (pusherEvent)=>{\n                    var eventName = pusherEvent.event;\n                    if (eventName === \"pusher_internal:watchlist_events\") {\n                        this.handleEvent(pusherEvent);\n                    }\n                });\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/utils/flat_promise.ts\n        function flatPromise() {\n            let resolve, reject;\n            const promise = new Promise((res, rej)=>{\n                resolve = res;\n                reject = rej;\n            });\n            return {\n                promise,\n                resolve,\n                reject\n            };\n        }\n        /* harmony default export */ var flat_promise = flatPromise;\n        // CONCATENATED MODULE: ./src/core/user.ts\n        class user_UserFacade extends dispatcher_Dispatcher {\n            constructor(pusher){\n                super(function(eventName, data) {\n                    logger.debug(\"No callbacks on user for \" + eventName);\n                });\n                this.signin_requested = false;\n                this.user_data = null;\n                this.serverToUserChannel = null;\n                this.signinDonePromise = null;\n                this._signinDoneResolve = null;\n                this._onAuthorize = (err, authData)=>{\n                    if (err) {\n                        logger.warn(`Error during signin: ${err}`);\n                        this._cleanup();\n                        return;\n                    }\n                    this.pusher.send_event(\"pusher:signin\", {\n                        auth: authData.auth,\n                        user_data: authData.user_data\n                    });\n                };\n                this.pusher = pusher;\n                this.pusher.connection.bind(\"state_change\", ({ previous, current })=>{\n                    if (previous !== \"connected\" && current === \"connected\") {\n                        this._signin();\n                    }\n                    if (previous === \"connected\" && current !== \"connected\") {\n                        this._cleanup();\n                        this._newSigninPromiseIfNeeded();\n                    }\n                });\n                this.watchlist = new watchlist_WatchlistFacade(pusher);\n                this.pusher.connection.bind(\"message\", (event)=>{\n                    var eventName = event.event;\n                    if (eventName === \"pusher:signin_success\") {\n                        this._onSigninSuccess(event.data);\n                    }\n                    if (this.serverToUserChannel && this.serverToUserChannel.name === event.channel) {\n                        this.serverToUserChannel.handleEvent(event);\n                    }\n                });\n            }\n            signin() {\n                if (this.signin_requested) {\n                    return;\n                }\n                this.signin_requested = true;\n                this._signin();\n            }\n            _signin() {\n                if (!this.signin_requested) {\n                    return;\n                }\n                this._newSigninPromiseIfNeeded();\n                if (this.pusher.connection.state !== \"connected\") {\n                    return;\n                }\n                this.pusher.config.userAuthenticator({\n                    socketId: this.pusher.connection.socket_id\n                }, this._onAuthorize);\n            }\n            _onSigninSuccess(data) {\n                try {\n                    this.user_data = JSON.parse(data.user_data);\n                } catch (e) {\n                    logger.error(`Failed parsing user data after signin: ${data.user_data}`);\n                    this._cleanup();\n                    return;\n                }\n                if (typeof this.user_data.id !== \"string\" || this.user_data.id === \"\") {\n                    logger.error(`user_data doesn't contain an id. user_data: ${this.user_data}`);\n                    this._cleanup();\n                    return;\n                }\n                this._signinDoneResolve();\n                this._subscribeChannels();\n            }\n            _subscribeChannels() {\n                const ensure_subscribed = (channel)=>{\n                    if (channel.subscriptionPending && channel.subscriptionCancelled) {\n                        channel.reinstateSubscription();\n                    } else if (!channel.subscriptionPending && this.pusher.connection.state === \"connected\") {\n                        channel.subscribe();\n                    }\n                };\n                this.serverToUserChannel = new channel_Channel(`#server-to-user-${this.user_data.id}`, this.pusher);\n                this.serverToUserChannel.bind_global((eventName, data)=>{\n                    if (eventName.indexOf(\"pusher_internal:\") === 0 || eventName.indexOf(\"pusher:\") === 0) {\n                        return;\n                    }\n                    this.emit(eventName, data);\n                });\n                ensure_subscribed(this.serverToUserChannel);\n            }\n            _cleanup() {\n                this.user_data = null;\n                if (this.serverToUserChannel) {\n                    this.serverToUserChannel.unbind_all();\n                    this.serverToUserChannel.disconnect();\n                    this.serverToUserChannel = null;\n                }\n                if (this.signin_requested) {\n                    this._signinDoneResolve();\n                }\n            }\n            _newSigninPromiseIfNeeded() {\n                if (!this.signin_requested) {\n                    return;\n                }\n                if (this.signinDonePromise && !this.signinDonePromise.done) {\n                    return;\n                }\n                const { promise, resolve, reject: _ } = flat_promise();\n                promise.done = false;\n                const setDone = ()=>{\n                    promise.done = true;\n                };\n                promise.then(setDone).catch(setDone);\n                this.signinDonePromise = promise;\n                this._signinDoneResolve = resolve;\n            }\n        }\n        // CONCATENATED MODULE: ./src/core/pusher.ts\n        class pusher_Pusher {\n            static ready() {\n                pusher_Pusher.isReady = true;\n                for(var i = 0, l = pusher_Pusher.instances.length; i < l; i++){\n                    pusher_Pusher.instances[i].connect();\n                }\n            }\n            static getClientFeatures() {\n                return keys(filterObject({\n                    ws: node_runtime.Transports.ws\n                }, function(t) {\n                    return t.isSupported({});\n                }));\n            }\n            constructor(app_key, options){\n                checkAppKey(app_key);\n                validateOptions(options);\n                this.key = app_key;\n                this.config = getConfig(options, this);\n                this.channels = factory.createChannels();\n                this.global_emitter = new dispatcher_Dispatcher();\n                this.sessionID = node_runtime.randomInt(1000000000);\n                this.timeline = new timeline_Timeline(this.key, this.sessionID, {\n                    cluster: this.config.cluster,\n                    features: pusher_Pusher.getClientFeatures(),\n                    params: this.config.timelineParams || {},\n                    limit: 50,\n                    level: timeline_level.INFO,\n                    version: defaults.VERSION\n                });\n                if (this.config.enableStats) {\n                    this.timelineSender = factory.createTimelineSender(this.timeline, {\n                        host: this.config.statsHost,\n                        path: \"/timeline/v2/\" + node_runtime.TimelineTransport.name\n                    });\n                }\n                var getStrategy = (options)=>{\n                    return node_runtime.getDefaultStrategy(this.config, options, strategy_builder_defineTransport);\n                };\n                this.connection = factory.createConnectionManager(this.key, {\n                    getStrategy: getStrategy,\n                    timeline: this.timeline,\n                    activityTimeout: this.config.activityTimeout,\n                    pongTimeout: this.config.pongTimeout,\n                    unavailableTimeout: this.config.unavailableTimeout,\n                    useTLS: Boolean(this.config.useTLS)\n                });\n                this.connection.bind(\"connected\", ()=>{\n                    this.subscribeAll();\n                    if (this.timelineSender) {\n                        this.timelineSender.send(this.connection.isUsingTLS());\n                    }\n                });\n                this.connection.bind(\"message\", (event)=>{\n                    var eventName = event.event;\n                    var internal = eventName.indexOf(\"pusher_internal:\") === 0;\n                    if (event.channel) {\n                        var channel = this.channel(event.channel);\n                        if (channel) {\n                            channel.handleEvent(event);\n                        }\n                    }\n                    if (!internal) {\n                        this.global_emitter.emit(event.event, event.data);\n                    }\n                });\n                this.connection.bind(\"connecting\", ()=>{\n                    this.channels.disconnect();\n                });\n                this.connection.bind(\"disconnected\", ()=>{\n                    this.channels.disconnect();\n                });\n                this.connection.bind(\"error\", (err)=>{\n                    logger.warn(err);\n                });\n                pusher_Pusher.instances.push(this);\n                this.timeline.info({\n                    instances: pusher_Pusher.instances.length\n                });\n                this.user = new user_UserFacade(this);\n                if (pusher_Pusher.isReady) {\n                    this.connect();\n                }\n            }\n            channel(name) {\n                return this.channels.find(name);\n            }\n            allChannels() {\n                return this.channels.all();\n            }\n            connect() {\n                this.connection.connect();\n                if (this.timelineSender) {\n                    if (!this.timelineSenderTimer) {\n                        var usingTLS = this.connection.isUsingTLS();\n                        var timelineSender = this.timelineSender;\n                        this.timelineSenderTimer = new timers_PeriodicTimer(60000, function() {\n                            timelineSender.send(usingTLS);\n                        });\n                    }\n                }\n            }\n            disconnect() {\n                this.connection.disconnect();\n                if (this.timelineSenderTimer) {\n                    this.timelineSenderTimer.ensureAborted();\n                    this.timelineSenderTimer = null;\n                }\n            }\n            bind(event_name, callback, context) {\n                this.global_emitter.bind(event_name, callback, context);\n                return this;\n            }\n            unbind(event_name, callback, context) {\n                this.global_emitter.unbind(event_name, callback, context);\n                return this;\n            }\n            bind_global(callback) {\n                this.global_emitter.bind_global(callback);\n                return this;\n            }\n            unbind_global(callback) {\n                this.global_emitter.unbind_global(callback);\n                return this;\n            }\n            unbind_all(callback) {\n                this.global_emitter.unbind_all();\n                return this;\n            }\n            subscribeAll() {\n                var channelName;\n                for(channelName in this.channels.channels){\n                    if (this.channels.channels.hasOwnProperty(channelName)) {\n                        this.subscribe(channelName);\n                    }\n                }\n            }\n            subscribe(channel_name) {\n                var channel = this.channels.add(channel_name, this);\n                if (channel.subscriptionPending && channel.subscriptionCancelled) {\n                    channel.reinstateSubscription();\n                } else if (!channel.subscriptionPending && this.connection.state === \"connected\") {\n                    channel.subscribe();\n                }\n                return channel;\n            }\n            unsubscribe(channel_name) {\n                var channel = this.channels.find(channel_name);\n                if (channel && channel.subscriptionPending) {\n                    channel.cancelSubscription();\n                } else {\n                    channel = this.channels.remove(channel_name);\n                    if (channel && channel.subscribed) {\n                        channel.unsubscribe();\n                    }\n                }\n            }\n            send_event(event_name, data, channel) {\n                return this.connection.send_event(event_name, data, channel);\n            }\n            shouldUseTLS() {\n                return this.config.useTLS;\n            }\n            signin() {\n                this.user.signin();\n            }\n        }\n        pusher_Pusher.instances = [];\n        pusher_Pusher.isReady = false;\n        pusher_Pusher.logToConsole = false;\n        pusher_Pusher.Runtime = node_runtime;\n        pusher_Pusher.ScriptReceivers = node_runtime.ScriptReceivers;\n        pusher_Pusher.DependenciesReceivers = node_runtime.DependenciesReceivers;\n        pusher_Pusher.auth_callbacks = node_runtime.auth_callbacks;\n        /* harmony default export */ var core_pusher = pusher_Pusher;\n        function checkAppKey(key) {\n            if (key === null || key === undefined) {\n                throw \"You must pass your app key when you instantiate Pusher.\";\n            }\n        }\n        node_runtime.setup(pusher_Pusher);\n        // EXTERNAL MODULE: ./node_modules/tweetnacl/nacl-fast.js\n        var nacl_fast = __nested_webpack_require_266492__(20);\n        // CONCATENATED MODULE: ./src/core/pusher-with-encryption.ts\n        class pusher_with_encryption_PusherWithEncryption extends core_pusher {\n            constructor(app_key, options){\n                core_pusher.logToConsole = pusher_with_encryption_PusherWithEncryption.logToConsole;\n                core_pusher.log = pusher_with_encryption_PusherWithEncryption.log;\n                validateOptions(options);\n                options.nacl = nacl_fast;\n                super(app_key, options);\n            }\n        }\n    /***/ }\n]); //# sourceMappingURL=pusher.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcHVzaGVyLWpzL2Rpc3Qvbm9kZS9wdXNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBRURBLE9BQU9DLE9BQU8sR0FDTCxNQUFILEdBQUksU0FBU0MsT0FBTztJQUMxQixNQUFNLEdBQUksbUJBQW1CO0lBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztJQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtJQUNqQyxNQUFNLEdBQUksU0FBU0MsOEJBQW1CQSxDQUFDQyxRQUFRO1FBQy9DLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1FBQ3pDLE1BQU0sR0FBSyxJQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBUyxFQUFFO1lBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDSixPQUFPO1FBQ3JELE1BQU0sR0FBSztRQUNYLE1BQU0sR0FBSyxrREFBa0Q7UUFDN0QsTUFBTSxHQUFLLElBQUlELFVBQVNHLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7WUFDckQsTUFBTSxHQUFNQyxHQUFHRDtZQUNmLE1BQU0sR0FBTUUsR0FBRztZQUNmLE1BQU0sR0FBTU4sU0FBUyxDQUFDO1FBQ1g7UUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtRQUN6QyxNQUFNLEdBQUtDLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNSLFFBQU9DLE9BQU8sRUFBRUQsU0FBUUEsUUFBT0MsT0FBTyxFQUFFRyw4QkFBbUJBO1FBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1FBQ3ZDLE1BQU0sR0FBS0osUUFBT08sQ0FBQyxHQUFHO1FBQ3RCLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1FBQzlDLE1BQU0sR0FBSyxPQUFPUCxRQUFPQyxPQUFPO0lBQ2hDLE1BQU0sR0FBSTtJQUNWLE1BQU0sR0FDTixNQUFNLEdBQ04sTUFBTSxHQUFJLGtEQUFrRDtJQUM1RCxNQUFNLEdB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bkIsSUFBSTtnQkFDbEI7Z0JBRUFILEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBUSxFQUFFLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBTyxHQUFHLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FBTyxHQUFHLEdBQUcsSUFBSyxDQUFDdkcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFLO2dCQUNyQ3NHLEdBQUcsQ0FBQ0MsU0FB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QUNBa1gsZUFBZTtnQkFDWCxPQUFPLElBQUksQ0FBQ3JULE1BQU0sQ0FBQ2pLLE1BQU07WUFDN0I7WUFDQW9mLFNBQVM7Z0JBQ0wsSUFBSSxDQUFDMW9DLElBQUksQ0FBQzBvQyxNQUFNO1lBQ3BCO1FBQ0o7UUFDQUssY0FBY0UsU0FBUyxHQUFHLEVBQUU7UUFDNUJGLGNBQWNDLE9BQU8sR0FBRztRQUN4QkQsY0FBY3ZkLFlBQVksR0FBRztRQUM3QnVkLGNBQWNjLE9BQU8sR0FBR2hlO1FBQ3hCa2QsY0FBY2UsZUFBZSxHQUFHamUsYUFBYWllLGVBQWU7UUFDNURmLGNBQWNnQixxQkFBcUIsR0FBR2xlLGFBQWFrZSxxQkFBcUI7UUFDeEVoQixjQUFjaUIsY0FBYyxHQUFHbmUsYUFBYW1lLGNBQWM7UUFDMUQsMEJBQTBCLEdBQUcsSUFBSXplLGNBQWV3ZDtRQUNoRCxTQUFTSSxZQUFZeGtELEdBQUc7WUFDcEIsSUFBSUEsUUFBUSxRQUFRQSxRQUFROEIsV0FBVztnQkFDbkMsTUFBTTtZQUNWO1FBQ0o7UUFDQW9sQyxhQUFhb1csS0FBSyxDQUFDOEc7UUFFbkIseURBQXlEO1FBQ3pELElBQUlrQixZQUFZOW1ELGlDQUFtQkEsQ0FBQztRQUVwQyw0REFBNEQ7UUFJNUQsTUFBTW9oQyxvREFBb0RnSDtZQUN0RDU5QixZQUFZdTdDLE9BQU8sRUFBRTloRCxPQUFPLENBQUU7Z0JBQzFCbWtDLFlBQVlDLFlBQVksR0FBR2pILDRDQUE0Q2lILFlBQVk7Z0JBQ25GRCxZQUFZTCxHQUFHLEdBQUczRyw0Q0FBNEMyRyxHQUFHO2dCQUNqRTdqQyxnQkFBZ0JEO2dCQUNoQkEsUUFBUWdjLElBQUksR0FBRzZtQztnQkFDZixLQUFLLENBQUNmLFNBQVM5aEQ7WUFDbkI7UUFDSjtJQUdBLEdBQUcsR0FBRztDQUNJLEdBQ1Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVzc2VuZ2VyLy4vbm9kZV9tb2R1bGVzL3B1c2hlci1qcy9kaXN0L25vZGUvcHVzaGVyLmpzP2FkNTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBQdXNoZXIgSmF2YVNjcmlwdCBMaWJyYXJ5IHY4LjMuMFxuICogaHR0cHM6Ly9wdXNoZXIuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDIwLCBQdXNoZXJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5jZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIxKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBCdWZmZXIgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXIsXG4gICAgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpLkV2ZW50RW1pdHRlcixcbiAgICB1dGlsICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBzdHJlYW1zID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCksXG4gICAgSGVhZGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oOSksXG4gICAgUmVhZGVyICA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIHVybCwgb3B0aW9ucykge1xuICBFbWl0dGVyLmNhbGwodGhpcyk7XG4gIEJhc2UudmFsaWRhdGVPcHRpb25zKG9wdGlvbnMgfHwge30sIFsnbWF4TGVuZ3RoJywgJ21hc2tpbmcnLCAncmVxdWlyZU1hc2tpbmcnLCAncHJvdG9jb2xzJ10pO1xuXG4gIHRoaXMuX3JlcXVlc3QgICA9IHJlcXVlc3Q7XG4gIHRoaXMuX3JlYWRlciAgICA9IG5ldyBSZWFkZXIoKTtcbiAgdGhpcy5fb3B0aW9ucyAgID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5fb3B0aW9ucy5tYXhMZW5ndGggfHwgdGhpcy5NQVhfTEVOR1RIO1xuICB0aGlzLl9oZWFkZXJzICAgPSBuZXcgSGVhZGVycygpO1xuICB0aGlzLl9fcXVldWUgICAgPSBbXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gMDtcbiAgdGhpcy51cmwgICAgICAgID0gdXJsO1xuXG4gIHRoaXMuaW8gPSBuZXcgc3RyZWFtcy5JTyh0aGlzKTtcbiAgdGhpcy5tZXNzYWdlcyA9IG5ldyBzdHJlYW1zLk1lc3NhZ2VzKHRoaXMpO1xuICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG51dGlsLmluaGVyaXRzKEJhc2UsIEVtaXR0ZXIpO1xuXG5CYXNlLmlzV2ViU29ja2V0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICB2YXIgY29ubmVjdGlvbiA9IHJlcXVlc3QuaGVhZGVycy5jb25uZWN0aW9uIHx8ICcnLFxuICAgICAgdXBncmFkZSAgICA9IHJlcXVlc3QuaGVhZGVycy51cGdyYWRlIHx8ICcnO1xuXG4gIHJldHVybiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcgJiZcbiAgICAgICAgIGNvbm5lY3Rpb24udG9Mb3dlckNhc2UoKS5zcGxpdCgvICosICovKS5pbmRleE9mKCd1cGdyYWRlJykgPj0gMCAmJlxuICAgICAgICAgdXBncmFkZS50b0xvd2VyQ2FzZSgpID09PSAnd2Vic29ja2V0Jztcbn07XG5cbkJhc2UudmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucywgdmFsaWRLZXlzKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKHZhbGlkS2V5cy5pbmRleE9mKGtleSkgPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uOiAnICsga2V5KTtcbiAgfVxufTtcblxudmFyIGluc3RhbmNlID0ge1xuICAvLyBUaGlzIGlzIDY0TUIsIHNtYWxsIGVub3VnaCBmb3IgYW4gYXZlcmFnZSBWUFMgdG8gaGFuZGxlIHdpdGhvdXRcbiAgLy8gY3Jhc2hpbmcgZnJvbSBwcm9jZXNzIG91dCBvZiBtZW1vcnlcbiAgTUFYX0xFTkdUSDogMHgzZmZmZmZmLFxuXG4gIFNUQVRFUzogWydjb25uZWN0aW5nJywgJ29wZW4nLCAnY2xvc2luZycsICdjbG9zZWQnXSxcblxuICBfYmluZEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBQcm90b2NvbCBlcnJvcnMgYXJlIGluZm9ybWF0aW9uYWwgYW5kIGRvIG5vdCBoYXZlIHRvIGJlIGhhbmRsZWRcbiAgICB0aGlzLm1lc3NhZ2VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge30pO1xuXG4gICAgdGhpcy5vbignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgbWVzc2FnZXMgPSBzZWxmLm1lc3NhZ2VzO1xuICAgICAgaWYgKG1lc3NhZ2VzLnJlYWRhYmxlKSBtZXNzYWdlcy5lbWl0KCdkYXRhJywgZXZlbnQuZGF0YSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICB2YXIgbWVzc2FnZXMgPSBzZWxmLm1lc3NhZ2VzO1xuICAgICAgaWYgKG1lc3NhZ2VzLnJlYWRhYmxlKSBtZXNzYWdlcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWVzc2FnZXMgPSBzZWxmLm1lc3NhZ2VzO1xuICAgICAgaWYgKCFtZXNzYWdlcy5yZWFkYWJsZSkgcmV0dXJuO1xuICAgICAgbWVzc2FnZXMucmVhZGFibGUgPSBtZXNzYWdlcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgbWVzc2FnZXMuZW1pdCgnZW5kJyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLlNUQVRFU1t0aGlzLnJlYWR5U3RhdGVdIHx8IG51bGw7XG4gIH0sXG5cbiAgYWRkRXh0ZW5zaW9uOiBmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgc2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5faGVhZGVycy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIUJhc2UuaXNXZWJTb2NrZXQodGhpcy5fcmVxdWVzdCkpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZShuZXcgRXJyb3IoJ05vdCBhIFdlYlNvY2tldCByZXF1ZXN0JykpO1xuXG4gICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gdGhpcy5faGFuZHNoYWtlUmVzcG9uc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoZXJyb3IpO1xuICAgIH1cblxuICAgIHRoaXMuX3dyaXRlKHJlc3BvbnNlKTtcbiAgICBpZiAodGhpcy5fc3RhZ2UgIT09IC0xKSB0aGlzLl9vcGVuKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX2ZhaWxIYW5kc2hha2U6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpO1xuICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LUxlbmd0aCcsIEJ1ZmZlci5ieXRlTGVuZ3RoKGVycm9yLm1lc3NhZ2UsICd1dGY4JykpO1xuXG4gICAgaGVhZGVycyA9IFsnSFRUUC8xLjEgNDAwIEJhZCBSZXF1ZXN0JywgaGVhZGVycy50b1N0cmluZygpLCBlcnJvci5tZXNzYWdlXTtcbiAgICB0aGlzLl93cml0ZShCdWZmZXIuZnJvbShoZWFkZXJzLmpvaW4oJ1xcclxcbicpLCAndXRmOCcpKTtcbiAgICB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHRleHQ6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFtZShtZXNzYWdlKTtcbiAgfSxcblxuICBiaW5hcnk6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgcGluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHBvbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbihyZWFzb24sIGNvZGUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMztcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbmV3IEJhc2UuQ2xvc2VFdmVudChudWxsLCBudWxsKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX29wZW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDE7XG4gICAgdGhpcy5fX3F1ZXVlLmZvckVhY2goZnVuY3Rpb24oYXJncykgeyB0aGlzLmZyYW1lLmFwcGx5KHRoaXMsIGFyZ3MpIH0sIHRoaXMpO1xuICAgIHRoaXMuX19xdWV1ZSA9IFtdO1xuICAgIHRoaXMuZW1pdCgnb3BlbicsIG5ldyBCYXNlLk9wZW5FdmVudCgpKTtcbiAgfSxcblxuICBfcXVldWU6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9fcXVldWUucHVzaChtZXNzYWdlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfd3JpdGU6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgdmFyIGlvID0gdGhpcy5pbztcbiAgICBpZiAoaW8ucmVhZGFibGUpIGlvLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0sXG5cbiAgX2ZhaWw6IGZ1bmN0aW9uKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAyO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxufTtcblxuZm9yICh2YXIga2V5IGluIGluc3RhbmNlKVxuICBCYXNlLnByb3RvdHlwZVtrZXldID0gaW5zdGFuY2Vba2V5XTtcblxuXG5CYXNlLkNvbm5lY3RFdmVudCA9IGZ1bmN0aW9uKCkge307XG5cbkJhc2UuT3BlbkV2ZW50ID0gZnVuY3Rpb24oKSB7fTtcblxuQmFzZS5DbG9zZUV2ZW50ID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIHRoaXMuY29kZSAgID0gY29kZTtcbiAgdGhpcy5yZWFzb24gPSByZWFzb247XG59O1xuXG5CYXNlLk1lc3NhZ2VFdmVudCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn07XG5cbkJhc2UuUGluZ0V2ZW50ID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufTtcblxuQmFzZS5Qb25nRXZlbnQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIFByb3RvY29sIHJlZmVyZW5jZXM6XG4vL1xuLy8gKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1oaXhpZS10aGV3ZWJzb2NrZXRwcm90b2NvbC03NVxuLy8gKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1oaXhpZS10aGV3ZWJzb2NrZXRwcm90b2NvbC03NlxuLy8gKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLWh5YmktdGhld2Vic29ja2V0cHJvdG9jb2wtMTdcblxudmFyIEJhc2UgICA9IF9fd2VicGFja19yZXF1aXJlX18oMiksXG4gICAgQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNiksXG4gICAgU2VydmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbnZhciBEcml2ZXIgPSB7XG4gIGNsaWVudDogZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMubWFza2luZyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zLm1hc2tpbmcgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgQ2xpZW50KHVybCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc2VydmVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMucmVxdWlyZU1hc2tpbmcgPT09IHVuZGVmaW5lZCkgb3B0aW9ucy5yZXF1aXJlTWFza2luZyA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXIob3B0aW9ucyk7XG4gIH0sXG5cbiAgaHR0cDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFNlcnZlci5odHRwLmFwcGx5KFNlcnZlciwgYXJndW1lbnRzKTtcbiAgfSxcblxuICBpc1NlY3VyZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gU2VydmVyLmlzU2VjdXJlUmVxdWVzdChyZXF1ZXN0KTtcbiAgfSxcblxuICBpc1dlYlNvY2tldDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHJldHVybiBCYXNlLmlzV2ViU29ja2V0KHJlcXVlc3QpO1xuICB9LFxuXG4gIHZhbGlkYXRlT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucywgdmFsaWRLZXlzKSB7XG4gICAgQmFzZS52YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgdmFsaWRLZXlzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcml2ZXI7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmVhbVwiKTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgb3B0aW9ucykge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKVxuICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgICAgICAgPSBldmVudFR5cGU7XG4gIHRoaXMuYnViYmxlcyAgICA9IGNhbkJ1YmJsZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ICA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgICAgICAgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgID0gMztcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENvcHlyaWdodCAoQykgMjAxNiBEbWl0cnkgQ2hlc3RueWtoXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIGJhc2U2NCBpbXBsZW1lbnRzIEJhc2U2NCBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKi9cbi8vIEludmFsaWQgY2hhcmFjdGVyIHVzZWQgaW4gZGVjb2RpbmcgdG8gaW5kaWNhdGVcbi8vIHRoYXQgdGhlIGNoYXJhY3RlciB0byBkZWNvZGUgaXMgb3V0IG9mIHJhbmdlIG9mXG4vLyBhbHBoYWJldCBhbmQgY2Fubm90IGJlIGRlY29kZWQuXG52YXIgSU5WQUxJRF9CWVRFID0gMjU2O1xuLyoqXG4gKiBJbXBsZW1lbnRzIHN0YW5kYXJkIEJhc2U2NCBlbmNvZGluZy5cbiAqXG4gKiBPcGVyYXRlcyBpbiBjb25zdGFudCB0aW1lLlxuICovXG52YXIgQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETyhkY2hlc3QpOiBtZXRob2RzIHRvIGVuY29kZSBjaHVuay1ieS1jaHVuay5cbiAgICBmdW5jdGlvbiBDb2RlcihfcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICBpZiAoX3BhZGRpbmdDaGFyYWN0ZXIgPT09IHZvaWQgMCkgeyBfcGFkZGluZ0NoYXJhY3RlciA9IFwiPVwiOyB9XG4gICAgICAgIHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgPSBfcGFkZGluZ0NoYXJhY3RlcjtcbiAgICB9XG4gICAgQ29kZXIucHJvdG90eXBlLmVuY29kZWRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIChsZW5ndGggKiA4ICsgNSkgLyA2IHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGxlbmd0aCArIDIpIC8gMyAqIDQgfCAwO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBvdXQgPSBcIlwiO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgZGF0YS5sZW5ndGggLSAyOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHZhciBjID0gKGRhdGFbaV0gPDwgMTYpIHwgKGRhdGFbaSArIDFdIDw8IDgpIHwgKGRhdGFbaSArIDJdKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAzICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMiAqIDYpICYgNjMpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDEgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAwICogNikgJiA2Myk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSBkYXRhLmxlbmd0aCAtIGk7XG4gICAgICAgIGlmIChsZWZ0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGMgPSAoZGF0YVtpXSA8PCAxNikgfCAobGVmdCA9PT0gMiA/IGRhdGFbaSArIDFdIDw8IDggOiAwKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAzICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMiAqIDYpICYgNjMpO1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMSAqIDYpICYgNjMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgfHwgXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5tYXhEZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAobGVuZ3RoICogNiArIDcpIC8gOCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aCAvIDQgKiAzIHwgMDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5kZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RGVjb2RlZExlbmd0aChzLmxlbmd0aCAtIHRoaXMuX2dldFBhZGRpbmdMZW5ndGgocykpO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWRkaW5nTGVuZ3RoID0gdGhpcy5fZ2V0UGFkZGluZ0xlbmd0aChzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoIC0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4RGVjb2RlZExlbmd0aChsZW5ndGgpKTtcbiAgICAgICAgdmFyIG9wID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgaGF2ZUJhZCA9IDA7XG4gICAgICAgIHZhciB2MCA9IDAsIHYxID0gMCwgdjIgPSAwLCB2MyA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoIC0gNDsgaSArPSA0KSB7XG4gICAgICAgICAgICB2MCA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAwKSk7XG4gICAgICAgICAgICB2MSA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICB2MiA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAyKSk7XG4gICAgICAgICAgICB2MyA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjAgPDwgMikgfCAodjEgPj4+IDQpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYxIDw8IDQpIHwgKHYyID4+PiAyKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MiA8PCA2KSB8IHYzO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MCAmIElOVkFMSURfQllURTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjEgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYyICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MyAmIElOVkFMSURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHYwID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgdjEgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYwIDw8IDIpIHwgKHYxID4+PiA0KTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjAgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYxICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgdjIgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMikpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYxIDw8IDQpIHwgKHYyID4+PiAyKTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjIgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAzKSB7XG4gICAgICAgICAgICB2MyA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjIgPDwgNikgfCB2MztcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjMgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhdmVCYWQgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NENvZGVyOiBpbmNvcnJlY3QgY2hhcmFjdGVycyBmb3IgZGVjb2RpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8vIFN0YW5kYXJkIGVuY29kaW5nIGhhdmUgdGhlIGZvbGxvd2luZyBlbmNvZGVkL2RlY29kZWQgcmFuZ2VzLFxuICAgIC8vIHdoaWNoIHdlIG5lZWQgdG8gY29udmVydCBiZXR3ZWVuLlxuICAgIC8vXG4gICAgLy8gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogMDEyMzQ1Njc4OSAgKyAgIC9cbiAgICAvLyBJbmRleDogICAwIC0gMjUgICAgICAgICAgICAgICAgICAgIDI2IC0gNTEgICAgICAgICAgICAgIDUyIC0gNjEgICA2MiAgNjNcbiAgICAvLyBBU0NJSTogIDY1IC0gOTAgICAgICAgICAgICAgICAgICAgIDk3IC0gMTIyICAgICAgICAgICAgIDQ4IC0gNTcgICA0MyAgNDdcbiAgICAvL1xuICAgIC8vIEVuY29kZSA2IGJpdHMgaW4gYiBpbnRvIGEgbmV3IGNoYXJhY3Rlci5cbiAgICBDb2Rlci5wcm90b3R5cGUuX2VuY29kZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAvLyBFbmNvZGluZyB1c2VzIGNvbnN0YW50IHRpbWUgb3BlcmF0aW9ucyBhcyBmb2xsb3dzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBEZWZpbmUgY29tcGFyaXNvbiBvZiBBIHdpdGggQiB1c2luZyAoQSAtIEIpID4+PiA4OlxuICAgICAgICAvLyAgICAgICAgICBpZiBBID4gQiwgdGhlbiByZXN1bHQgaXMgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAvLyAgICAgICAgICBpZiBBIDw9IEIsIHRoZW4gcmVzdWx0IGlzIDBcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMi4gRGVmaW5lIHNlbGVjdGlvbiBvZiBDIG9yIDAgdXNpbmcgYml0d2lzZSBBTkQ6IFggJiBDOlxuICAgICAgICAvLyAgICAgICAgICBpZiBYID09IDAsIHRoZW4gcmVzdWx0IGlzIDBcbiAgICAgICAgLy8gICAgICAgICAgaWYgWCAhPSAwLCB0aGVuIHJlc3VsdCBpcyBDXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDMuIFN0YXJ0IHdpdGggdGhlIHNtYWxsZXN0IGNvbXBhcmlzb24gKGIgPj0gMCksIHdoaWNoIGlzIGFsd2F5c1xuICAgICAgICAvLyAgICB0cnVlLCBzbyBzZXQgdGhlIHJlc3VsdCB0byB0aGUgc3RhcnRpbmcgQVNDSUkgdmFsdWUgKDY1KS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gNC4gQ29udGludWUgY29tcGFyaW5nIGIgdG8gaGlnaGVyIEFTQ0lJIHZhbHVlcywgYW5kIHNlbGVjdGluZ1xuICAgICAgICAvLyAgICB6ZXJvIGlmIGNvbXBhcmlzb24gaXNuJ3QgdHJ1ZSwgb3RoZXJ3aXNlIHNlbGVjdGluZyBhIHZhbHVlXG4gICAgICAgIC8vICAgIHRvIGFkZCB0byByZXN1bHQsIHdoaWNoOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgICBhKSB1bmRvZXMgdGhlIHByZXZpb3VzIGFkZGl0aW9uXG4gICAgICAgIC8vICAgICAgICAgIGIpIHByb3ZpZGVzIG5ldyB2YWx1ZSB0byBhZGRcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHJlc3VsdCA9IGI7XG4gICAgICAgIC8vIGIgPj0gMFxuICAgICAgICByZXN1bHQgKz0gNjU7XG4gICAgICAgIC8vIGIgPiAyNVxuICAgICAgICByZXN1bHQgKz0gKCgyNSAtIGIpID4+PiA4KSAmICgoMCAtIDY1KSAtIDI2ICsgOTcpO1xuICAgICAgICAvLyBiID4gNTFcbiAgICAgICAgcmVzdWx0ICs9ICgoNTEgLSBiKSA+Pj4gOCkgJiAoKDI2IC0gOTcpIC0gNTIgKyA0OCk7XG4gICAgICAgIC8vIGIgPiA2MVxuICAgICAgICByZXN1bHQgKz0gKCg2MSAtIGIpID4+PiA4KSAmICgoNTIgLSA0OCkgLSA2MiArIDQzKTtcbiAgICAgICAgLy8gYiA+IDYyXG4gICAgICAgIHJlc3VsdCArPSAoKDYyIC0gYikgPj4+IDgpICYgKCg2MiAtIDQzKSAtIDYzICsgNDcpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShyZXN1bHQpO1xuICAgIH07XG4gICAgLy8gRGVjb2RlIGEgY2hhcmFjdGVyIGNvZGUgaW50byBhIGJ5dGUuXG4gICAgLy8gTXVzdCByZXR1cm4gMjU2IGlmIGNoYXJhY3RlciBpcyBvdXQgb2YgYWxwaGFiZXQgcmFuZ2UuXG4gICAgQ29kZXIucHJvdG90eXBlLl9kZWNvZGVDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gRGVjb2Rpbmcgd29ya3Mgc2ltaWxhciB0byBlbmNvZGluZzogdXNpbmcgdGhlIHNhbWUgY29tcGFyaXNvblxuICAgICAgICAvLyBmdW5jdGlvbiwgYnV0IG5vdyBpdCB3b3JrcyBvbiByYW5nZXM6IHJlc3VsdCBpcyBhbHdheXMgaW5jcmVtZW50ZWRcbiAgICAgICAgLy8gYnkgdmFsdWUsIGJ1dCB0aGlzIHZhbHVlIGJlY29tZXMgemVybyBpZiB0aGUgcmFuZ2UgaXMgbm90XG4gICAgICAgIC8vIHNhdGlzZmllZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVjb2Rpbmcgc3RhcnRzIHdpdGggaW52YWxpZCB2YWx1ZSwgMjU2LCB3aGljaCBpcyB0aGVuXG4gICAgICAgIC8vIHN1YnRyYWN0ZWQgd2hlbiB0aGUgcmFuZ2UgaXMgc2F0aXNmaWVkLiBJZiBub25lIG9mIHRoZSByYW5nZXNcbiAgICAgICAgLy8gYXBwbHksIHRoZSBmdW5jdGlvbiByZXR1cm5zIDI1Niwgd2hpY2ggaXMgdGhlbiBjaGVja2VkIGJ5XG4gICAgICAgIC8vIHRoZSBjYWxsZXIgdG8gdGhyb3cgZXJyb3IuXG4gICAgICAgIHZhciByZXN1bHQgPSBJTlZBTElEX0JZVEU7IC8vIHN0YXJ0IHdpdGggaW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgICAgLy8gYyA9PSA0MyAoYyA+IDQyIGFuZCBjIDwgNDQpXG4gICAgICAgIHJlc3VsdCArPSAoKCg0MiAtIGMpICYgKGMgLSA0NCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQzICsgNjIpO1xuICAgICAgICAvLyBjID09IDQ3IChjID4gNDYgYW5kIGMgPCA0OClcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ2IC0gYykgJiAoYyAtIDQ4KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDcgKyA2Myk7XG4gICAgICAgIC8vIGMgPiA0NyBhbmQgYyA8IDU4XG4gICAgICAgIHJlc3VsdCArPSAoKCg0NyAtIGMpICYgKGMgLSA1OCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ4ICsgNTIpO1xuICAgICAgICAvLyBjID4gNjQgYW5kIGMgPCA5MVxuICAgICAgICByZXN1bHQgKz0gKCgoNjQgLSBjKSAmIChjIC0gOTEpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA2NSArIDApO1xuICAgICAgICAvLyBjID4gOTYgYW5kIGMgPCAxMjNcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk2IC0gYykgJiAoYyAtIDEyMykpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDk3ICsgMjYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLl9nZXRQYWRkaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHBhZGRpbmdMZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPT0gdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMubGVuZ3RoIDwgNCB8fCBwYWRkaW5nTGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NENvZGVyOiBpbmNvcnJlY3QgcGFkZGluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZ0xlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBDb2Rlcjtcbn0oKSk7XG5leHBvcnRzLkNvZGVyID0gQ29kZXI7XG52YXIgc3RkQ29kZXIgPSBuZXcgQ29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmVuY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZnVuY3Rpb24gZGVjb2RlKHMpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZGVjb2RlKHMpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIEltcGxlbWVudHMgVVJMLXNhZmUgQmFzZTY0IGVuY29kaW5nLlxuICogKFNhbWUgYXMgQmFzZTY0LCBidXQgJysnIGlzIHJlcGxhY2VkIHdpdGggJy0nLCBhbmQgJy8nIHdpdGggJ18nKS5cbiAqXG4gKiBPcGVyYXRlcyBpbiBjb25zdGFudCB0aW1lLlxuICovXG52YXIgVVJMU2FmZUNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVUkxTYWZlQ29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVVJMU2FmZUNvZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIFVSTC1zYWZlIGVuY29kaW5nIGhhdmUgdGhlIGZvbGxvd2luZyBlbmNvZGVkL2RlY29kZWQgcmFuZ2VzOlxuICAgIC8vXG4gICAgLy8gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogMDEyMzQ1Njc4OSAgLSAgIF9cbiAgICAvLyBJbmRleDogICAwIC0gMjUgICAgICAgICAgICAgICAgICAgIDI2IC0gNTEgICAgICAgICAgICAgIDUyIC0gNjEgICA2MiAgNjNcbiAgICAvLyBBU0NJSTogIDY1IC0gOTAgICAgICAgICAgICAgICAgICAgIDk3IC0gMTIyICAgICAgICAgICAgIDQ4IC0gNTcgICA0NSAgOTVcbiAgICAvL1xuICAgIFVSTFNhZmVDb2Rlci5wcm90b3R5cGUuX2VuY29kZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYjtcbiAgICAgICAgLy8gYiA+PSAwXG4gICAgICAgIHJlc3VsdCArPSA2NTtcbiAgICAgICAgLy8gYiA+IDI1XG4gICAgICAgIHJlc3VsdCArPSAoKDI1IC0gYikgPj4+IDgpICYgKCgwIC0gNjUpIC0gMjYgKyA5Nyk7XG4gICAgICAgIC8vIGIgPiA1MVxuICAgICAgICByZXN1bHQgKz0gKCg1MSAtIGIpID4+PiA4KSAmICgoMjYgLSA5NykgLSA1MiArIDQ4KTtcbiAgICAgICAgLy8gYiA+IDYxXG4gICAgICAgIHJlc3VsdCArPSAoKDYxIC0gYikgPj4+IDgpICYgKCg1MiAtIDQ4KSAtIDYyICsgNDUpO1xuICAgICAgICAvLyBiID4gNjJcbiAgICAgICAgcmVzdWx0ICs9ICgoNjIgLSBiKSA+Pj4gOCkgJiAoKDYyIC0gNDUpIC0gNjMgKyA5NSk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlc3VsdCk7XG4gICAgfTtcbiAgICBVUkxTYWZlQ29kZXIucHJvdG90eXBlLl9kZWNvZGVDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IElOVkFMSURfQllURTtcbiAgICAgICAgLy8gYyA9PSA0NSAoYyA+IDQ0IGFuZCBjIDwgNDYpXG4gICAgICAgIHJlc3VsdCArPSAoKCg0NCAtIGMpICYgKGMgLSA0NikpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ1ICsgNjIpO1xuICAgICAgICAvLyBjID09IDk1IChjID4gOTQgYW5kIGMgPCA5NilcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk0IC0gYykgJiAoYyAtIDk2KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gOTUgKyA2Myk7XG4gICAgICAgIC8vIGMgPiA0NyBhbmQgYyA8IDU4XG4gICAgICAgIHJlc3VsdCArPSAoKCg0NyAtIGMpICYgKGMgLSA1OCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ4ICsgNTIpO1xuICAgICAgICAvLyBjID4gNjQgYW5kIGMgPCA5MVxuICAgICAgICByZXN1bHQgKz0gKCgoNjQgLSBjKSAmIChjIC0gOTEpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA2NSArIDApO1xuICAgICAgICAvLyBjID4gOTYgYW5kIGMgPCAxMjNcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk2IC0gYykgJiAoYyAtIDEyMykpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDk3ICsgMjYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFVSTFNhZmVDb2Rlcjtcbn0oQ29kZXIpKTtcbmV4cG9ydHMuVVJMU2FmZUNvZGVyID0gVVJMU2FmZUNvZGVyO1xudmFyIHVybFNhZmVDb2RlciA9IG5ldyBVUkxTYWZlQ29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZVVSTFNhZmUoZGF0YSkge1xuICAgIHJldHVybiB1cmxTYWZlQ29kZXIuZW5jb2RlKGRhdGEpO1xufVxuZXhwb3J0cy5lbmNvZGVVUkxTYWZlID0gZW5jb2RlVVJMU2FmZTtcbmZ1bmN0aW9uIGRlY29kZVVSTFNhZmUocykge1xuICAgIHJldHVybiB1cmxTYWZlQ29kZXIuZGVjb2RlKHMpO1xufVxuZXhwb3J0cy5kZWNvZGVVUkxTYWZlID0gZGVjb2RlVVJMU2FmZTtcbmV4cG9ydHMuZW5jb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZW5jb2RlZExlbmd0aChsZW5ndGgpO1xufTtcbmV4cG9ydHMubWF4RGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIubWF4RGVjb2RlZExlbmd0aChsZW5ndGgpO1xufTtcbmV4cG9ydHMuZGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmRlY29kZWRMZW5ndGgocyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgSGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNsZWFyKCk7XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS5BTExPV0VEX0RVUExJQ0FURVMgPSBbJ3NldC1jb29raWUnLCAnc2V0LWNvb2tpZTInLCAnd2FybmluZycsICd3d3ctYXV0aGVudGljYXRlJ107XG5cbkhlYWRlcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3NlbnQgID0ge307XG4gIHRoaXMuX2xpbmVzID0gW107XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIG5hbWUgPSB0aGlzLl9zdHJpcChuYW1lKTtcbiAgdmFsdWUgPSB0aGlzLl9zdHJpcCh2YWx1ZSk7XG5cbiAgdmFyIGtleSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCF0aGlzLl9zZW50Lmhhc093blByb3BlcnR5KGtleSkgfHwgdGhpcy5BTExPV0VEX0RVUExJQ0FURVMuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICB0aGlzLl9zZW50W2tleV0gPSB0cnVlO1xuICAgIHRoaXMuX2xpbmVzLnB1c2gobmFtZSArICc6ICcgKyB2YWx1ZSArICdcXHJcXG4nKTtcbiAgfVxufTtcblxuSGVhZGVycy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpbmVzLmpvaW4oJycpO1xufTtcblxuSGVhZGVycy5wcm90b3R5cGUuX3N0cmlwID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudG9TdHJpbmcoKS5yZXBsYWNlKC9eICovLCAnJykucmVwbGFjZSgvICokLywgJycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXJzO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIE5vZGVIVFRQUGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNykuSFRUUFBhcnNlcixcbiAgICBCdWZmZXIgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyO1xuXG52YXIgVFlQRVMgPSB7XG4gIHJlcXVlc3Q6ICBOb2RlSFRUUFBhcnNlci5SRVFVRVNUICB8fCAncmVxdWVzdCcsXG4gIHJlc3BvbnNlOiBOb2RlSFRUUFBhcnNlci5SRVNQT05TRSB8fCAncmVzcG9uc2UnXG59O1xuXG52YXIgSHR0cFBhcnNlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdGhpcy5fdHlwZSAgICAgPSB0eXBlO1xuICB0aGlzLl9wYXJzZXIgICA9IG5ldyBOb2RlSFRUUFBhcnNlcihUWVBFU1t0eXBlXSk7XG4gIHRoaXMuX2NvbXBsZXRlID0gZmFsc2U7XG4gIHRoaXMuaGVhZGVycyAgID0ge307XG5cbiAgdmFyIGN1cnJlbnQgPSBudWxsLFxuICAgICAgc2VsZiAgICA9IHRoaXM7XG5cbiAgdGhpcy5fcGFyc2VyLm9uSGVhZGVyRmllbGQgPSBmdW5jdGlvbihiLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgY3VycmVudCA9IGIudG9TdHJpbmcoJ3V0ZjgnLCBzdGFydCwgc3RhcnQgKyBsZW5ndGgpLnRvTG93ZXJDYXNlKCk7XG4gIH07XG5cbiAgdGhpcy5fcGFyc2VyLm9uSGVhZGVyVmFsdWUgPSBmdW5jdGlvbihiLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYi50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBzdGFydCArIGxlbmd0aCk7XG5cbiAgICBpZiAoc2VsZi5oZWFkZXJzLmhhc093blByb3BlcnR5KGN1cnJlbnQpKVxuICAgICAgc2VsZi5oZWFkZXJzW2N1cnJlbnRdICs9ICcsICcgKyB2YWx1ZTtcbiAgICBlbHNlXG4gICAgICBzZWxmLmhlYWRlcnNbY3VycmVudF0gPSB2YWx1ZTtcbiAgfTtcblxuICB0aGlzLl9wYXJzZXIub25IZWFkZXJzQ29tcGxldGUgPSB0aGlzLl9wYXJzZXJbTm9kZUhUVFBQYXJzZXIua09uSGVhZGVyc0NvbXBsZXRlXSA9XG4gIGZ1bmN0aW9uKG1ham9yVmVyc2lvbiwgbWlub3JWZXJzaW9uLCBoZWFkZXJzLCBtZXRob2QsIHBhdGhuYW1lLCBzdGF0dXNDb2RlKSB7XG4gICAgdmFyIGluZm8gPSBhcmd1bWVudHNbMF07XG5cbiAgICBpZiAodHlwZW9mIGluZm8gPT09ICdvYmplY3QnKSB7XG4gICAgICBtZXRob2QgICAgID0gaW5mby5tZXRob2Q7XG4gICAgICBwYXRobmFtZSAgID0gaW5mby51cmw7XG4gICAgICBzdGF0dXNDb2RlID0gaW5mby5zdGF0dXNDb2RlO1xuICAgICAgaGVhZGVycyAgICA9IGluZm8uaGVhZGVycztcbiAgICB9XG5cbiAgICBzZWxmLm1ldGhvZCAgICAgPSAodHlwZW9mIG1ldGhvZCA9PT0gJ251bWJlcicpID8gSHR0cFBhcnNlci5NRVRIT0RTW21ldGhvZF0gOiBtZXRob2Q7XG4gICAgc2VsZi5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICBzZWxmLnVybCAgICAgICAgPSBwYXRobmFtZTtcblxuICAgIGlmICghaGVhZGVycykgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBoZWFkZXJzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IG47IGkgKz0gMikge1xuICAgICAga2V5ICAgPSBoZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9IGhlYWRlcnNbaSsxXTtcbiAgICAgIGlmIChzZWxmLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgc2VsZi5oZWFkZXJzW2tleV0gKz0gJywgJyArIHZhbHVlO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHNlbGYuX2NvbXBsZXRlID0gdHJ1ZTtcbiAgfTtcbn07XG5cbkh0dHBQYXJzZXIuTUVUSE9EUyA9IHtcbiAgMDogICdERUxFVEUnLFxuICAxOiAgJ0dFVCcsXG4gIDI6ICAnSEVBRCcsXG4gIDM6ICAnUE9TVCcsXG4gIDQ6ICAnUFVUJyxcbiAgNTogICdDT05ORUNUJyxcbiAgNjogICdPUFRJT05TJyxcbiAgNzogICdUUkFDRScsXG4gIDg6ICAnQ09QWScsXG4gIDk6ICAnTE9DSycsXG4gIDEwOiAnTUtDT0wnLFxuICAxMTogJ01PVkUnLFxuICAxMjogJ1BST1BGSU5EJyxcbiAgMTM6ICdQUk9QUEFUQ0gnLFxuICAxNDogJ1NFQVJDSCcsXG4gIDE1OiAnVU5MT0NLJyxcbiAgMTY6ICdCSU5EJyxcbiAgMTc6ICdSRUJJTkQnLFxuICAxODogJ1VOQklORCcsXG4gIDE5OiAnQUNMJyxcbiAgMjA6ICdSRVBPUlQnLFxuICAyMTogJ01LQUNUSVZJVFknLFxuICAyMjogJ0NIRUNLT1VUJyxcbiAgMjM6ICdNRVJHRScsXG4gIDI0OiAnTS1TRUFSQ0gnLFxuICAyNTogJ05PVElGWScsXG4gIDI2OiAnU1VCU0NSSUJFJyxcbiAgMjc6ICdVTlNVQlNDUklCRScsXG4gIDI4OiAnUEFUQ0gnLFxuICAyOTogJ1BVUkdFJyxcbiAgMzA6ICdNS0NBTEVOREFSJyxcbiAgMzE6ICdMSU5LJyxcbiAgMzI6ICdVTkxJTksnXG59O1xuXG52YXIgVkVSU0lPTiA9IHByb2Nlc3MudmVyc2lvblxuICA/IHByb2Nlc3MudmVyc2lvbi5tYXRjaCgvWzAtOV0rL2cpLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBwYXJzZUludChuLCAxMCkgfSlcbiAgOiBbXTtcblxuaWYgKFZFUlNJT05bMF0gPT09IDAgJiYgVkVSU0lPTlsxXSA9PT0gMTIpIHtcbiAgSHR0cFBhcnNlci5NRVRIT0RTWzE2XSA9ICdSRVBPUlQnO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMTddID0gJ01LQUNUSVZJVFknO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMThdID0gJ0NIRUNLT1VUJztcbiAgSHR0cFBhcnNlci5NRVRIT0RTWzE5XSA9ICdNRVJHRSc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1syMF0gPSAnTS1TRUFSQ0gnO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMjFdID0gJ05PVElGWSc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1syMl0gPSAnU1VCU0NSSUJFJztcbiAgSHR0cFBhcnNlci5NRVRIT0RTWzIzXSA9ICdVTlNVQlNDUklCRSc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1syNF0gPSAnUEFUQ0gnO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMjVdID0gJ1BVUkdFJztcbn1cblxuSHR0cFBhcnNlci5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29tcGxldGU7XG59O1xuXG5IdHRwUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBjb25zdW1lZCA9IHRoaXMuX3BhcnNlci5leGVjdXRlKGNodW5rLCAwLCBjaHVuay5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgY29uc3VtZWQgIT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5lcnJvciAgICAgPSBjb25zdW1lZDtcbiAgICB0aGlzLl9jb21wbGV0ZSA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2NvbXBsZXRlKVxuICAgIHRoaXMuYm9keSA9IChjb25zdW1lZCA8IGNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgPyBjaHVuay5zbGljZShjb25zdW1lZClcbiAgICAgICAgICAgICAgOiBCdWZmZXIuYWxsb2MoMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0dHBQYXJzZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgU3RyZWFtICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLlN0cmVhbSxcbiAgICB1dGlsICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgZHJpdmVyICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLFxuICAgIEV2ZW50VGFyZ2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG4gICAgRXZlbnQgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgQVBJID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZHJpdmVyLnZhbGlkYXRlT3B0aW9ucyhvcHRpb25zLCBbJ2hlYWRlcnMnLCAnZXh0ZW5zaW9ucycsICdtYXhMZW5ndGgnLCAncGluZycsICdwcm94eScsICd0bHMnLCAnY2EnXSk7XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICBpZiAoaGVhZGVycykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykgdGhpcy5fZHJpdmVyLnNldEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgfVxuXG4gIHZhciBleHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zO1xuICBpZiAoZXh0ZW5zaW9ucykge1xuICAgIFtdLmNvbmNhdChleHRlbnNpb25zKS5mb3JFYWNoKHRoaXMuX2RyaXZlci5hZGRFeHRlbnNpb24sIHRoaXMuX2RyaXZlcik7XG4gIH1cblxuICB0aGlzLl9waW5nICAgICAgICAgID0gb3B0aW9ucy5waW5nO1xuICB0aGlzLl9waW5nSWQgICAgICAgID0gMDtcbiAgdGhpcy5yZWFkeVN0YXRlICAgICA9IEFQSS5DT05ORUNUSU5HO1xuICB0aGlzLmJ1ZmZlcmVkQW1vdW50ID0gMDtcbiAgdGhpcy5wcm90b2NvbCAgICAgICA9ICcnO1xuICB0aGlzLnVybCAgICAgICAgICAgID0gdGhpcy5fZHJpdmVyLnVybDtcbiAgdGhpcy52ZXJzaW9uICAgICAgICA9IHRoaXMuX2RyaXZlci52ZXJzaW9uO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLl9kcml2ZXIub24oJ29wZW4nLCAgICBmdW5jdGlvbihlKSB7IHNlbGYuX29wZW4oKSB9KTtcbiAgdGhpcy5fZHJpdmVyLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkgeyBzZWxmLl9yZWNlaXZlTWVzc2FnZShlLmRhdGEpIH0pO1xuICB0aGlzLl9kcml2ZXIub24oJ2Nsb3NlJywgICBmdW5jdGlvbihlKSB7IHNlbGYuX2JlZ2luQ2xvc2UoZS5yZWFzb24sIGUuY29kZSkgfSk7XG5cbiAgdGhpcy5fZHJpdmVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgc2VsZi5fZW1pdEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICB9KTtcbiAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbigpIHt9KTtcblxuICB0aGlzLl9kcml2ZXIubWVzc2FnZXMub24oJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9KTtcblxuICBpZiAodGhpcy5fcGluZylcbiAgICB0aGlzLl9waW5nVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX3BpbmdJZCArPSAxO1xuICAgICAgc2VsZi5waW5nKHNlbGYuX3BpbmdJZC50b1N0cmluZygpKTtcbiAgICB9LCB0aGlzLl9waW5nICogMTAwMCk7XG5cbiAgdGhpcy5fY29uZmlndXJlU3RyZWFtKCk7XG5cbiAgaWYgKCF0aGlzLl9wcm94eSkge1xuICAgIHRoaXMuX3N0cmVhbS5waXBlKHRoaXMuX2RyaXZlci5pbyk7XG4gICAgdGhpcy5fZHJpdmVyLmlvLnBpcGUodGhpcy5fc3RyZWFtKTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoQVBJLCBTdHJlYW0pO1xuXG5BUEkuQ09OTkVDVElORyA9IDA7XG5BUEkuT1BFTiAgICAgICA9IDE7XG5BUEkuQ0xPU0lORyAgICA9IDI7XG5BUEkuQ0xPU0VEICAgICA9IDM7XG5cbkFQSS5DTE9TRV9USU1FT1VUID0gMzAwMDA7XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgd3JpdGU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kKGRhdGEpO1xuICB9LFxuXG4gIGVuZDogZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHRoaXMuc2VuZChkYXRhKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH0sXG5cbiAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kcml2ZXIubWVzc2FnZXMucGF1c2UoKTtcbiAgfSxcblxuICByZXN1bWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kcml2ZXIubWVzc2FnZXMucmVzdW1lKCk7XG4gIH0sXG5cbiAgc2VuZDogZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiBBUEkuT1BFTikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBCdWZmZXIpKSBkYXRhID0gU3RyaW5nKGRhdGEpO1xuICAgIHJldHVybiB0aGlzLl9kcml2ZXIubWVzc2FnZXMud3JpdGUoZGF0YSk7XG4gIH0sXG5cbiAgcGluZzogZnVuY3Rpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gQVBJLk9QRU4pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5fZHJpdmVyLnBpbmcobWVzc2FnZSwgY2FsbGJhY2spO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSBjb2RlID0gMTAwMDtcbiAgICBpZiAocmVhc29uID09PSB1bmRlZmluZWQpIHJlYXNvbiA9ICcnO1xuXG4gICAgaWYgKGNvZGUgIT09IDEwMDAgJiYgKGNvZGUgPCAzMDAwIHx8IGNvZGUgPiA0OTk5KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdjbG9zZScgb24gV2ViU29ja2V0OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaGUgY29kZSBtdXN0IGJlIGVpdGhlciAxMDAwLCBvciBiZXR3ZWVuIDMwMDAgYW5kIDQ5OTkuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBjb2RlICsgXCIgaXMgbmVpdGhlci5cIik7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBBUEkuQ0xPU0VEKSB0aGlzLnJlYWR5U3RhdGUgPSBBUEkuQ0xPU0lORztcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX2JlZ2luQ2xvc2UoJycsIDEwMDYpO1xuICAgIH0sIEFQSS5DTE9TRV9USU1FT1VUKTtcblxuICAgIHRoaXMuX2RyaXZlci5jbG9zZShyZWFzb24sIGNvZGUpO1xuICB9LFxuXG4gIF9jb25maWd1cmVTdHJlYW06IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX3N0cmVhbS5zZXRUaW1lb3V0KDApO1xuICAgIHRoaXMuX3N0cmVhbS5zZXROb0RlbGF5KHRydWUpO1xuXG4gICAgWydjbG9zZScsICdlbmQnXS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB0aGlzLl9zdHJlYW0ub24oZXZlbnQsIGZ1bmN0aW9uKCkgeyBzZWxmLl9maW5hbGl6ZUNsb3NlKCkgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9zdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHNlbGYuX2VtaXRFcnJvcignTmV0d29yayBlcnJvcjogJyArIHNlbGYudXJsICsgJzogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgc2VsZi5fZmluYWxpemVDbG9zZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIF9vcGVuOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBBUEkuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gQVBJLk9QRU47XG4gICAgdGhpcy5wcm90b2NvbCA9IHRoaXMuX2RyaXZlci5wcm90b2NvbCB8fCAnJztcblxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnb3BlbicpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnb3BlbicsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSxcblxuICBfcmVjZWl2ZU1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gQVBJLk9QRU4pIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh0aGlzLnJlYWRhYmxlKSB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcblxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnbWVzc2FnZScsIHtkYXRhOiBkYXRhfSk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9LFxuXG4gIF9lbWl0RXJyb3I6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID49IEFQSS5DTE9TSU5HKSByZXR1cm47XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2Vycm9yJywge21lc3NhZ2U6IG1lc3NhZ2V9KTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2Vycm9yJywgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9LFxuXG4gIF9iZWdpbkNsb3NlOiBmdW5jdGlvbihyZWFzb24sIGNvZGUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBBUEkuQ0xPU0VEKSByZXR1cm47XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gQVBJLkNMT1NJTkc7XG4gICAgdGhpcy5fY2xvc2VQYXJhbXMgPSBbcmVhc29uLCBjb2RlXTtcblxuICAgIGlmICh0aGlzLl9zdHJlYW0pIHtcbiAgICAgIHRoaXMuX3N0cmVhbS5kZXN0cm95KCk7XG4gICAgICBpZiAoIXRoaXMuX3N0cmVhbS5yZWFkYWJsZSkgdGhpcy5fZmluYWxpemVDbG9zZSgpO1xuICAgIH1cbiAgfSxcblxuICBfZmluYWxpemVDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gQVBJLkNMT1NFRCkgcmV0dXJuO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IEFQSS5DTE9TRUQ7XG5cbiAgICBpZiAodGhpcy5fY2xvc2VUaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuX2Nsb3NlVGltZXIpO1xuICAgIGlmICh0aGlzLl9waW5nVGltZXIpIGNsZWFySW50ZXJ2YWwodGhpcy5fcGluZ1RpbWVyKTtcbiAgICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9zdHJlYW0uZW5kKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkYWJsZSkgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlYXNvbiA9IHRoaXMuX2Nsb3NlUGFyYW1zID8gdGhpcy5fY2xvc2VQYXJhbXNbMF0gOiAnJyxcbiAgICAgICAgY29kZSAgID0gdGhpcy5fY2xvc2VQYXJhbXMgPyB0aGlzLl9jbG9zZVBhcmFtc1sxXSA6IDEwMDY7XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2Nsb3NlJywge2NvZGU6IGNvZGUsIHJlYXNvbjogcmVhc29ufSk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdjbG9zZScsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufTtcblxuZm9yICh2YXIgbWV0aG9kIGluIGluc3RhbmNlKSBBUEkucHJvdG90eXBlW21ldGhvZF0gPSBpbnN0YW5jZVttZXRob2RdO1xuZm9yICh2YXIga2V5IGluIEV2ZW50VGFyZ2V0KSBBUEkucHJvdG90eXBlW2tleV0gPSBFdmVudFRhcmdldFtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFQSTtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBCdWZmZXIgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXIsXG4gICAgY3J5cHRvICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMyksXG4gICAgdXRpbCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgRXh0ZW5zaW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpLFxuICAgIEJhc2UgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuICAgIEZyYW1lICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSxcbiAgICBNZXNzYWdlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBIeWJpID0gZnVuY3Rpb24ocmVxdWVzdCwgdXJsLCBvcHRpb25zKSB7XG4gIEJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLl9leHRlbnNpb25zICAgICA9IG5ldyBFeHRlbnNpb25zKCk7XG4gIHRoaXMuX3N0YWdlICAgICAgICAgID0gMDtcbiAgdGhpcy5fbWFza2luZyAgICAgICAgPSB0aGlzLl9vcHRpb25zLm1hc2tpbmc7XG4gIHRoaXMuX3Byb3RvY29scyAgICAgID0gdGhpcy5fb3B0aW9ucy5wcm90b2NvbHMgfHwgW107XG4gIHRoaXMuX3JlcXVpcmVNYXNraW5nID0gdGhpcy5fb3B0aW9ucy5yZXF1aXJlTWFza2luZztcbiAgdGhpcy5fcGluZ0NhbGxiYWNrcyAgPSB7fTtcblxuICBpZiAodHlwZW9mIHRoaXMuX3Byb3RvY29scyA9PT0gJ3N0cmluZycpXG4gICAgdGhpcy5fcHJvdG9jb2xzID0gdGhpcy5fcHJvdG9jb2xzLnNwbGl0KC8gKiwgKi8pO1xuXG4gIGlmICghdGhpcy5fcmVxdWVzdCkgcmV0dXJuO1xuXG4gIHZhciBwcm90b3MgICAgPSB0aGlzLl9yZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXSxcbiAgICAgIHN1cHBvcnRlZCA9IHRoaXMuX3Byb3RvY29scztcblxuICBpZiAocHJvdG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHByb3RvcyA9PT0gJ3N0cmluZycpIHByb3RvcyA9IHByb3Rvcy5zcGxpdCgvICosICovKTtcbiAgICB0aGlzLnByb3RvY29sID0gcHJvdG9zLmZpbHRlcihmdW5jdGlvbihwKSB7IHJldHVybiBzdXBwb3J0ZWQuaW5kZXhPZihwKSA+PSAwIH0pWzBdO1xuICB9XG5cbiAgdGhpcy52ZXJzaW9uID0gJ2h5YmktJyArIEh5YmkuVkVSU0lPTjtcbn07XG51dGlsLmluaGVyaXRzKEh5YmksIEJhc2UpO1xuXG5IeWJpLlZFUlNJT04gPSAnMTMnO1xuXG5IeWJpLm1hc2sgPSBmdW5jdGlvbihwYXlsb2FkLCBtYXNrLCBvZmZzZXQpIHtcbiAgaWYgKCFtYXNrIHx8IG1hc2subGVuZ3RoID09PSAwKSByZXR1cm4gcGF5bG9hZDtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBwYXlsb2FkLmxlbmd0aCAtIG9mZnNldDsgaSA8IG47IGkrKykge1xuICAgIHBheWxvYWRbb2Zmc2V0ICsgaV0gPSBwYXlsb2FkW29mZnNldCArIGldIF4gbWFza1tpICUgNF07XG4gIH1cbiAgcmV0dXJuIHBheWxvYWQ7XG59O1xuXG5IeWJpLmdlbmVyYXRlQWNjZXB0ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBzaGExID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgc2hhMS51cGRhdGUoa2V5ICsgSHliaS5HVUlEKTtcbiAgcmV0dXJuIHNoYTEuZGlnZXN0KCdiYXNlNjQnKTtcbn07XG5cbkh5YmkuR1VJRCA9ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnO1xuXG52YXIgaW5zdGFuY2UgPSB7XG4gIEZJTjogICAgMHg4MCxcbiAgTUFTSzogICAweDgwLFxuICBSU1YxOiAgIDB4NDAsXG4gIFJTVjI6ICAgMHgyMCxcbiAgUlNWMzogICAweDEwLFxuICBPUENPREU6IDB4MEYsXG4gIExFTkdUSDogMHg3RixcblxuICBPUENPREVTOiB7XG4gICAgY29udGludWF0aW9uOiAwLFxuICAgIHRleHQ6ICAgICAgICAgMSxcbiAgICBiaW5hcnk6ICAgICAgIDIsXG4gICAgY2xvc2U6ICAgICAgICA4LFxuICAgIHBpbmc6ICAgICAgICAgOSxcbiAgICBwb25nOiAgICAgICAgIDEwXG4gIH0sXG5cbiAgT1BDT0RFX0NPREVTOiAgICBbMCwgMSwgMiwgOCwgOSwgMTBdLFxuICBNRVNTQUdFX09QQ09ERVM6IFswLCAxLCAyXSxcbiAgT1BFTklOR19PUENPREVTOiBbMSwgMl0sXG5cbiAgRVJST1JTOiB7XG4gICAgbm9ybWFsX2Nsb3N1cmU6ICAgICAgIDEwMDAsXG4gICAgZ29pbmdfYXdheTogICAgICAgICAgIDEwMDEsXG4gICAgcHJvdG9jb2xfZXJyb3I6ICAgICAgIDEwMDIsXG4gICAgdW5hY2NlcHRhYmxlOiAgICAgICAgIDEwMDMsXG4gICAgZW5jb2RpbmdfZXJyb3I6ICAgICAgIDEwMDcsXG4gICAgcG9saWN5X3Zpb2xhdGlvbjogICAgIDEwMDgsXG4gICAgdG9vX2xhcmdlOiAgICAgICAgICAgIDEwMDksXG4gICAgZXh0ZW5zaW9uX2Vycm9yOiAgICAgIDEwMTAsXG4gICAgdW5leHBlY3RlZF9jb25kaXRpb246IDEwMTFcbiAgfSxcblxuICBFUlJPUl9DT0RFUzogICAgICAgIFsxMDAwLCAxMDAxLCAxMDAyLCAxMDAzLCAxMDA3LCAxMDA4LCAxMDA5LCAxMDEwLCAxMDExXSxcbiAgREVGQVVMVF9FUlJPUl9DT0RFOiAxMDAwLFxuICBNSU5fUkVTRVJWRURfRVJST1I6IDMwMDAsXG4gIE1BWF9SRVNFUlZFRF9FUlJPUjogNDk5OSxcblxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL3F1ZXN0aW9ucy9xYS1mb3Jtcy11dGYtOC5lbi5waHBcbiAgVVRGOF9NQVRDSDogL14oW1xceDAwLVxceDdGXXxbXFx4QzItXFx4REZdW1xceDgwLVxceEJGXXxcXHhFMFtcXHhBMC1cXHhCRl1bXFx4ODAtXFx4QkZdfFtcXHhFMS1cXHhFQ1xceEVFXFx4RUZdW1xceDgwLVxceEJGXXsyfXxcXHhFRFtcXHg4MC1cXHg5Rl1bXFx4ODAtXFx4QkZdfFxceEYwW1xceDkwLVxceEJGXVtcXHg4MC1cXHhCRl17Mn18W1xceEYxLVxceEYzXVtcXHg4MC1cXHhCRl17M318XFx4RjRbXFx4ODAtXFx4OEZdW1xceDgwLVxceEJGXXsyfSkqJC8sXG5cbiAgYWRkRXh0ZW5zaW9uOiBmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICB0aGlzLl9leHRlbnNpb25zLmFkZChleHRlbnNpb24pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihjaHVuaykge1xuICAgIHRoaXMuX3JlYWRlci5wdXQoY2h1bmspO1xuICAgIHZhciBidWZmZXIgPSB0cnVlO1xuICAgIHdoaWxlIChidWZmZXIpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhZ2UpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3JlYWRlci5yZWFkKDEpO1xuICAgICAgICAgIGlmIChidWZmZXIpIHRoaXMuX3BhcnNlT3Bjb2RlKGJ1ZmZlclswXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3JlYWRlci5yZWFkKDEpO1xuICAgICAgICAgIGlmIChidWZmZXIpIHRoaXMuX3BhcnNlTGVuZ3RoKGJ1ZmZlclswXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3JlYWRlci5yZWFkKHRoaXMuX2ZyYW1lLmxlbmd0aEJ5dGVzKTtcbiAgICAgICAgICBpZiAoYnVmZmVyKSB0aGlzLl9wYXJzZUV4dGVuZGVkTGVuZ3RoKGJ1ZmZlcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3JlYWRlci5yZWFkKDQpO1xuICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWdlID0gNDtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lLm1hc2tpbmdLZXkgPSBidWZmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBidWZmZXIgPSB0aGlzLl9yZWFkZXIucmVhZCh0aGlzLl9mcmFtZS5sZW5ndGgpO1xuICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWdlID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRGcmFtZShidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRleHQ6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmZyYW1lKG1lc3NhZ2UsICd0ZXh0Jyk7XG4gIH0sXG5cbiAgYmluYXJ5OiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5mcmFtZShtZXNzYWdlLCAnYmluYXJ5Jyk7XG4gIH0sXG5cbiAgcGluZzogZnVuY3Rpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuICAgIGlmIChjYWxsYmFjaykgdGhpcy5fcGluZ0NhbGxiYWNrc1ttZXNzYWdlXSA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzLmZyYW1lKG1lc3NhZ2UsICdwaW5nJyk7XG4gIH0sXG5cbiAgcG9uZzogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDEpIHJldHVybiBmYWxzZTtcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8Jyc7XG4gICAgICByZXR1cm4gdGhpcy5mcmFtZShtZXNzYWdlLCAncG9uZycpO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbihyZWFzb24sIGNvZGUpIHtcbiAgICByZWFzb24gPSByZWFzb24gfHwgJyc7XG4gICAgY29kZSAgID0gY29kZSAgIHx8IHRoaXMuRVJST1JTLm5vcm1hbF9jbG9zdXJlO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA8PSAwKSB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSAzO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIG5ldyBCYXNlLkNsb3NlRXZlbnQoY29kZSwgcmVhc29uKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gMjtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMuY2xvc2UoZnVuY3Rpb24oKSB7IHRoaXMuZnJhbWUocmVhc29uLCAnY2xvc2UnLCBjb2RlKSB9LCB0aGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGZyYW1lOiBmdW5jdGlvbihidWZmZXIsIHR5cGUsIGNvZGUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDw9IDApIHJldHVybiB0aGlzLl9xdWV1ZShbYnVmZmVyLCB0eXBlLCBjb2RlXSk7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDIpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheSkgICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ251bWJlcicpIGJ1ZmZlciA9IGJ1ZmZlci50b1N0cmluZygpO1xuXG4gICAgdmFyIG1lc3NhZ2UgPSBuZXcgTWVzc2FnZSgpLFxuICAgICAgICBpc1RleHQgID0gKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSxcbiAgICAgICAgcGF5bG9hZCwgY29weTtcblxuICAgIG1lc3NhZ2UucnN2MSAgID0gbWVzc2FnZS5yc3YyID0gbWVzc2FnZS5yc3YzID0gZmFsc2U7XG4gICAgbWVzc2FnZS5vcGNvZGUgPSB0aGlzLk9QQ09ERVNbdHlwZSB8fCAoaXNUZXh0ID8gJ3RleHQnIDogJ2JpbmFyeScpXTtcblxuICAgIHBheWxvYWQgPSBpc1RleHQgPyBCdWZmZXIuZnJvbShidWZmZXIsICd1dGY4JykgOiBidWZmZXI7XG5cbiAgICBpZiAoY29kZSkge1xuICAgICAgY29weSA9IHBheWxvYWQ7XG4gICAgICBwYXlsb2FkID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBjb3B5Lmxlbmd0aCk7XG4gICAgICBwYXlsb2FkLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgICBjb3B5LmNvcHkocGF5bG9hZCwgMik7XG4gICAgfVxuICAgIG1lc3NhZ2UuZGF0YSA9IHBheWxvYWQ7XG5cbiAgICB2YXIgb25NZXNzYWdlUmVhZHkgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICB2YXIgZnJhbWUgPSBuZXcgRnJhbWUoKTtcblxuICAgICAgZnJhbWUuZmluYWwgICA9IHRydWU7XG4gICAgICBmcmFtZS5yc3YxICAgID0gbWVzc2FnZS5yc3YxO1xuICAgICAgZnJhbWUucnN2MiAgICA9IG1lc3NhZ2UucnN2MjtcbiAgICAgIGZyYW1lLnJzdjMgICAgPSBtZXNzYWdlLnJzdjM7XG4gICAgICBmcmFtZS5vcGNvZGUgID0gbWVzc2FnZS5vcGNvZGU7XG4gICAgICBmcmFtZS5tYXNrZWQgID0gISF0aGlzLl9tYXNraW5nO1xuICAgICAgZnJhbWUubGVuZ3RoICA9IG1lc3NhZ2UuZGF0YS5sZW5ndGg7XG4gICAgICBmcmFtZS5wYXlsb2FkID0gbWVzc2FnZS5kYXRhO1xuXG4gICAgICBpZiAoZnJhbWUubWFza2VkKSBmcmFtZS5tYXNraW5nS2V5ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpO1xuXG4gICAgICB0aGlzLl9zZW5kRnJhbWUoZnJhbWUpO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5NRVNTQUdFX09QQ09ERVMuaW5kZXhPZihtZXNzYWdlLm9wY29kZSkgPj0gMClcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMucHJvY2Vzc091dGdvaW5nTWVzc2FnZShtZXNzYWdlLCBmdW5jdGlvbihlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiB0aGlzLl9mYWlsKCdleHRlbnNpb25fZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgb25NZXNzYWdlUmVhZHkuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIG9uTWVzc2FnZVJlYWR5LmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfc2VuZEZyYW1lOiBmdW5jdGlvbihmcmFtZSkge1xuICAgIHZhciBsZW5ndGggPSBmcmFtZS5sZW5ndGgsXG4gICAgICAgIGhlYWRlciA9IChsZW5ndGggPD0gMTI1KSA/IDIgOiAobGVuZ3RoIDw9IDY1NTM1ID8gNCA6IDEwKSxcbiAgICAgICAgb2Zmc2V0ID0gaGVhZGVyICsgKGZyYW1lLm1hc2tlZCA/IDQgOiAwKSxcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG9mZnNldCArIGxlbmd0aCksXG4gICAgICAgIG1hc2tlZCA9IGZyYW1lLm1hc2tlZCA/IHRoaXMuTUFTSyA6IDA7XG5cbiAgICBidWZmZXJbMF0gPSAoZnJhbWUuZmluYWwgPyB0aGlzLkZJTiA6IDApIHxcbiAgICAgICAgICAgICAgICAoZnJhbWUucnN2MSA/IHRoaXMuUlNWMSA6IDApIHxcbiAgICAgICAgICAgICAgICAoZnJhbWUucnN2MiA/IHRoaXMuUlNWMiA6IDApIHxcbiAgICAgICAgICAgICAgICAoZnJhbWUucnN2MyA/IHRoaXMuUlNWMyA6IDApIHxcbiAgICAgICAgICAgICAgICBmcmFtZS5vcGNvZGU7XG5cbiAgICBpZiAobGVuZ3RoIDw9IDEyNSkge1xuICAgICAgYnVmZmVyWzFdID0gbWFza2VkIHwgbGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDY1NTM1KSB7XG4gICAgICBidWZmZXJbMV0gPSBtYXNrZWQgfCAxMjY7XG4gICAgICBidWZmZXIud3JpdGVVSW50MTZCRShsZW5ndGgsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJbMV0gPSBtYXNrZWQgfCAxMjc7XG4gICAgICBidWZmZXIud3JpdGVVSW50MzJCRShNYXRoLmZsb29yKGxlbmd0aCAvIDB4MTAwMDAwMDAwKSwgMik7XG4gICAgICBidWZmZXIud3JpdGVVSW50MzJCRShsZW5ndGggJSAweDEwMDAwMDAwMCwgNik7XG4gICAgfVxuXG4gICAgZnJhbWUucGF5bG9hZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcblxuICAgIGlmIChmcmFtZS5tYXNrZWQpIHtcbiAgICAgIGZyYW1lLm1hc2tpbmdLZXkuY29weShidWZmZXIsIGhlYWRlcik7XG4gICAgICBIeWJpLm1hc2soYnVmZmVyLCBmcmFtZS5tYXNraW5nS2V5LCBvZmZzZXQpO1xuICAgIH1cblxuICAgIHRoaXMuX3dyaXRlKGJ1ZmZlcik7XG4gIH0sXG5cbiAgX2hhbmRzaGFrZVJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VjS2V5ICA9IHRoaXMuX3JlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSxcbiAgICAgICAgdmVyc2lvbiA9IHRoaXMuX3JlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG5cbiAgICBpZiAodmVyc2lvbiAhPT0gSHliaS5WRVJTSU9OKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBXZWJTb2NrZXQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuXG4gICAgaWYgKHR5cGVvZiBzZWNLZXkgIT09ICdzdHJpbmcnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGhhbmRzaGFrZSByZXF1ZXN0IGhlYWRlcjogU2VjLVdlYlNvY2tldC1LZXknKTtcblxuICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdVcGdyYWRlJywgJ3dlYnNvY2tldCcpO1xuICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdDb25uZWN0aW9uJywgJ1VwZ3JhZGUnKTtcbiAgICB0aGlzLl9oZWFkZXJzLnNldCgnU2VjLVdlYlNvY2tldC1BY2NlcHQnLCBIeWJpLmdlbmVyYXRlQWNjZXB0KHNlY0tleSkpO1xuXG4gICAgaWYgKHRoaXMucHJvdG9jb2wpIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJywgdGhpcy5wcm90b2NvbCk7XG5cbiAgICB2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuX2V4dGVuc2lvbnMuZ2VuZXJhdGVSZXNwb25zZSh0aGlzLl9yZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddKTtcbiAgICBpZiAoZXh0ZW5zaW9ucykgdGhpcy5faGVhZGVycy5zZXQoJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucycsIGV4dGVuc2lvbnMpO1xuXG4gICAgdmFyIHN0YXJ0ICAgPSAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgICBoZWFkZXJzID0gW3N0YXJ0LCB0aGlzLl9oZWFkZXJzLnRvU3RyaW5nKCksICcnXTtcblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShoZWFkZXJzLmpvaW4oJ1xcclxcbicpLCAndXRmOCcpO1xuICB9LFxuXG4gIF9zaHV0ZG93bjogZnVuY3Rpb24oY29kZSwgcmVhc29uLCBlcnJvcikge1xuICAgIGRlbGV0ZSB0aGlzLl9mcmFtZTtcbiAgICBkZWxldGUgdGhpcy5fbWVzc2FnZTtcbiAgICB0aGlzLl9zdGFnZSA9IDU7XG5cbiAgICB2YXIgc2VuZENsb3NlRnJhbWUgPSAodGhpcy5yZWFkeVN0YXRlID09PSAxKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAyO1xuXG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5jbG9zZShmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZW5kQ2xvc2VGcmFtZSkgdGhpcy5mcmFtZShyZWFzb24sICdjbG9zZScsIGNvZGUpO1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gMztcbiAgICAgIGlmIChlcnJvcikgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBuZXcgQmFzZS5DbG9zZUV2ZW50KGNvZGUsIHJlYXNvbikpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIF9mYWlsOiBmdW5jdGlvbih0eXBlLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDEpIHJldHVybjtcbiAgICB0aGlzLl9zaHV0ZG93bih0aGlzLkVSUk9SU1t0eXBlXSwgbWVzc2FnZSwgdHJ1ZSk7XG4gIH0sXG5cbiAgX3BhcnNlT3Bjb2RlOiBmdW5jdGlvbihvY3RldCkge1xuICAgIHZhciByc3ZzID0gW3RoaXMuUlNWMSwgdGhpcy5SU1YyLCB0aGlzLlJTVjNdLm1hcChmdW5jdGlvbihyc3YpIHtcbiAgICAgIHJldHVybiAob2N0ZXQgJiByc3YpID09PSByc3Y7XG4gICAgfSk7XG5cbiAgICB2YXIgZnJhbWUgPSB0aGlzLl9mcmFtZSA9IG5ldyBGcmFtZSgpO1xuXG4gICAgZnJhbWUuZmluYWwgID0gKG9jdGV0ICYgdGhpcy5GSU4pID09PSB0aGlzLkZJTjtcbiAgICBmcmFtZS5yc3YxICAgPSByc3ZzWzBdO1xuICAgIGZyYW1lLnJzdjIgICA9IHJzdnNbMV07XG4gICAgZnJhbWUucnN2MyAgID0gcnN2c1syXTtcbiAgICBmcmFtZS5vcGNvZGUgPSAob2N0ZXQgJiB0aGlzLk9QQ09ERSk7XG5cbiAgICB0aGlzLl9zdGFnZSA9IDE7XG5cbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnMudmFsaWRGcmFtZVJzdihmcmFtZSkpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbCgncHJvdG9jb2xfZXJyb3InLFxuICAgICAgICAgICdPbmUgb3IgbW9yZSByZXNlcnZlZCBiaXRzIGFyZSBvbjogcmVzZXJ2ZWQxID0gJyArIChmcmFtZS5yc3YxID8gMSA6IDApICtcbiAgICAgICAgICAnLCByZXNlcnZlZDIgPSAnICsgKGZyYW1lLnJzdjIgPyAxIDogMCkgK1xuICAgICAgICAgICcsIHJlc2VydmVkMyA9ICcgKyAoZnJhbWUucnN2MyA/IDEgOiAwKSk7XG5cbiAgICBpZiAodGhpcy5PUENPREVfQ09ERVMuaW5kZXhPZihmcmFtZS5vcGNvZGUpIDwgMClcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsICdVbnJlY29nbml6ZWQgZnJhbWUgb3Bjb2RlOiAnICsgZnJhbWUub3Bjb2RlKTtcblxuICAgIGlmICh0aGlzLk1FU1NBR0VfT1BDT0RFUy5pbmRleE9mKGZyYW1lLm9wY29kZSkgPCAwICYmICFmcmFtZS5maW5hbClcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsICdSZWNlaXZlZCBmcmFnbWVudGVkIGNvbnRyb2wgZnJhbWU6IG9wY29kZSA9ICcgKyBmcmFtZS5vcGNvZGUpO1xuXG4gICAgaWYgKHRoaXMuX21lc3NhZ2UgJiYgdGhpcy5PUEVOSU5HX09QQ09ERVMuaW5kZXhPZihmcmFtZS5vcGNvZGUpID49IDApXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbCgncHJvdG9jb2xfZXJyb3InLCAnUmVjZWl2ZWQgbmV3IGRhdGEgZnJhbWUgYnV0IHByZXZpb3VzIGNvbnRpbnVvdXMgZnJhbWUgaXMgdW5maW5pc2hlZCcpO1xuICB9LFxuXG4gIF9wYXJzZUxlbmd0aDogZnVuY3Rpb24ob2N0ZXQpIHtcbiAgICB2YXIgZnJhbWUgPSB0aGlzLl9mcmFtZTtcbiAgICBmcmFtZS5tYXNrZWQgPSAob2N0ZXQgJiB0aGlzLk1BU0spID09PSB0aGlzLk1BU0s7XG4gICAgZnJhbWUubGVuZ3RoID0gKG9jdGV0ICYgdGhpcy5MRU5HVEgpO1xuXG4gICAgaWYgKGZyYW1lLmxlbmd0aCA+PSAwICYmIGZyYW1lLmxlbmd0aCA8PSAxMjUpIHtcbiAgICAgIHRoaXMuX3N0YWdlID0gZnJhbWUubWFza2VkID8gMyA6IDQ7XG4gICAgICBpZiAoIXRoaXMuX2NoZWNrRnJhbWVMZW5ndGgoKSkgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGFnZSA9IDI7XG4gICAgICBmcmFtZS5sZW5ndGhCeXRlcyA9IChmcmFtZS5sZW5ndGggPT09IDEyNiA/IDIgOiA4KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVxdWlyZU1hc2tpbmcgJiYgIWZyYW1lLm1hc2tlZClcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsKCd1bmFjY2VwdGFibGUnLCAnUmVjZWl2ZWQgdW5tYXNrZWQgZnJhbWUgYnV0IG1hc2tpbmcgaXMgcmVxdWlyZWQnKTtcbiAgfSxcblxuICBfcGFyc2VFeHRlbmRlZExlbmd0aDogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgdmFyIGZyYW1lID0gdGhpcy5fZnJhbWU7XG4gICAgZnJhbWUubGVuZ3RoID0gdGhpcy5fcmVhZFVJbnQoYnVmZmVyKTtcblxuICAgIHRoaXMuX3N0YWdlID0gZnJhbWUubWFza2VkID8gMyA6IDQ7XG5cbiAgICBpZiAodGhpcy5NRVNTQUdFX09QQ09ERVMuaW5kZXhPZihmcmFtZS5vcGNvZGUpIDwgMCAmJiBmcmFtZS5sZW5ndGggPiAxMjUpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbCgncHJvdG9jb2xfZXJyb3InLCAnUmVjZWl2ZWQgY29udHJvbCBmcmFtZSBoYXZpbmcgdG9vIGxvbmcgcGF5bG9hZDogJyArIGZyYW1lLmxlbmd0aCk7XG5cbiAgICBpZiAoIXRoaXMuX2NoZWNrRnJhbWVMZW5ndGgoKSkgcmV0dXJuO1xuICB9LFxuXG4gIF9jaGVja0ZyYW1lTGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbWVzc2FnZSA/IHRoaXMuX21lc3NhZ2UubGVuZ3RoIDogMDtcblxuICAgIGlmIChsZW5ndGggKyB0aGlzLl9mcmFtZS5sZW5ndGggPiB0aGlzLl9tYXhMZW5ndGgpIHtcbiAgICAgIHRoaXMuX2ZhaWwoJ3Rvb19sYXJnZScsICdXZWJTb2NrZXQgZnJhbWUgbGVuZ3RoIHRvbyBsYXJnZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgX2VtaXRGcmFtZTogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgdmFyIGZyYW1lICAgPSB0aGlzLl9mcmFtZSxcbiAgICAgICAgcGF5bG9hZCA9IGZyYW1lLnBheWxvYWQgPSBIeWJpLm1hc2soYnVmZmVyLCBmcmFtZS5tYXNraW5nS2V5KSxcbiAgICAgICAgb3Bjb2RlICA9IGZyYW1lLm9wY29kZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgY29kZSwgcmVhc29uLFxuICAgICAgICBjYWxsYmFja3MsIGNhbGxiYWNrO1xuXG4gICAgZGVsZXRlIHRoaXMuX2ZyYW1lO1xuXG4gICAgaWYgKG9wY29kZSA9PT0gdGhpcy5PUENPREVTLmNvbnRpbnVhdGlvbikge1xuICAgICAgaWYgKCF0aGlzLl9tZXNzYWdlKSByZXR1cm4gdGhpcy5fZmFpbCgncHJvdG9jb2xfZXJyb3InLCAnUmVjZWl2ZWQgdW5leHBlY3RlZCBjb250aW51YXRpb24gZnJhbWUnKTtcbiAgICAgIHRoaXMuX21lc3NhZ2UucHVzaEZyYW1lKGZyYW1lKTtcbiAgICB9XG5cbiAgICBpZiAob3Bjb2RlID09PSB0aGlzLk9QQ09ERVMudGV4dCB8fCBvcGNvZGUgPT09IHRoaXMuT1BDT0RFUy5iaW5hcnkpIHtcbiAgICAgIHRoaXMuX21lc3NhZ2UgPSBuZXcgTWVzc2FnZSgpO1xuICAgICAgdGhpcy5fbWVzc2FnZS5wdXNoRnJhbWUoZnJhbWUpO1xuICAgIH1cblxuICAgIGlmIChmcmFtZS5maW5hbCAmJiB0aGlzLk1FU1NBR0VfT1BDT0RFUy5pbmRleE9mKG9wY29kZSkgPj0gMClcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0TWVzc2FnZSh0aGlzLl9tZXNzYWdlKTtcblxuICAgIGlmIChvcGNvZGUgPT09IHRoaXMuT1BDT0RFUy5jbG9zZSkge1xuICAgICAgY29kZSAgID0gKHBheWxvYWQubGVuZ3RoID49IDIpID8gcGF5bG9hZC5yZWFkVUludDE2QkUoMCkgOiBudWxsO1xuICAgICAgcmVhc29uID0gKHBheWxvYWQubGVuZ3RoID4gMikgPyB0aGlzLl9lbmNvZGUocGF5bG9hZC5zbGljZSgyKSkgOiBudWxsO1xuXG4gICAgICBpZiAoIShwYXlsb2FkLmxlbmd0aCA9PT0gMCkgJiZcbiAgICAgICAgICAhKGNvZGUgIT09IG51bGwgJiYgY29kZSA+PSB0aGlzLk1JTl9SRVNFUlZFRF9FUlJPUiAmJiBjb2RlIDw9IHRoaXMuTUFYX1JFU0VSVkVEX0VSUk9SKSAmJlxuICAgICAgICAgIHRoaXMuRVJST1JfQ09ERVMuaW5kZXhPZihjb2RlKSA8IDApXG4gICAgICAgIGNvZGUgPSB0aGlzLkVSUk9SUy5wcm90b2NvbF9lcnJvcjtcblxuICAgICAgaWYgKHBheWxvYWQubGVuZ3RoID4gMTI1IHx8IChwYXlsb2FkLmxlbmd0aCA+IDIgJiYgIXJlYXNvbikpXG4gICAgICAgIGNvZGUgPSB0aGlzLkVSUk9SUy5wcm90b2NvbF9lcnJvcjtcblxuICAgICAgdGhpcy5fc2h1dGRvd24oY29kZSB8fCB0aGlzLkRFRkFVTFRfRVJST1JfQ09ERSwgcmVhc29uIHx8ICcnKTtcbiAgICB9XG5cbiAgICBpZiAob3Bjb2RlID09PSB0aGlzLk9QQ09ERVMucGluZykge1xuICAgICAgdGhpcy5mcmFtZShwYXlsb2FkLCAncG9uZycpO1xuICAgICAgdGhpcy5lbWl0KCdwaW5nJywgbmV3IEJhc2UuUGluZ0V2ZW50KHBheWxvYWQudG9TdHJpbmcoKSkpXG4gICAgfVxuXG4gICAgaWYgKG9wY29kZSA9PT0gdGhpcy5PUENPREVTLnBvbmcpIHtcbiAgICAgIGNhbGxiYWNrcyA9IHRoaXMuX3BpbmdDYWxsYmFja3M7XG4gICAgICBtZXNzYWdlICAgPSB0aGlzLl9lbmNvZGUocGF5bG9hZCk7XG4gICAgICBjYWxsYmFjayAgPSBjYWxsYmFja3NbbWVzc2FnZV07XG5cbiAgICAgIGRlbGV0ZSBjYWxsYmFja3NbbWVzc2FnZV07XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcblxuICAgICAgdGhpcy5lbWl0KCdwb25nJywgbmV3IEJhc2UuUG9uZ0V2ZW50KHBheWxvYWQudG9TdHJpbmcoKSkpXG4gICAgfVxuICB9LFxuXG4gIF9lbWl0TWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHZhciBtZXNzYWdlID0gdGhpcy5fbWVzc2FnZTtcbiAgICBtZXNzYWdlLnJlYWQoKTtcblxuICAgIGRlbGV0ZSB0aGlzLl9tZXNzYWdlO1xuXG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5wcm9jZXNzSW5jb21pbmdNZXNzYWdlKG1lc3NhZ2UsIGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlKSB7XG4gICAgICBpZiAoZXJyb3IpIHJldHVybiB0aGlzLl9mYWlsKCdleHRlbnNpb25fZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcblxuICAgICAgdmFyIHBheWxvYWQgPSBtZXNzYWdlLmRhdGE7XG4gICAgICBpZiAobWVzc2FnZS5vcGNvZGUgPT09IHRoaXMuT1BDT0RFUy50ZXh0KSBwYXlsb2FkID0gdGhpcy5fZW5jb2RlKHBheWxvYWQpO1xuXG4gICAgICBpZiAocGF5bG9hZCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoJ2VuY29kaW5nX2Vycm9yJywgJ0NvdWxkIG5vdCBkZWNvZGUgYSB0ZXh0IGZyYW1lIGFzIFVURi04Jyk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG5ldyBCYXNlLk1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX2VuY29kZTogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBzdHJpbmcgPSBidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScsIDAsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgaWYgKCF0aGlzLlVURjhfTUFUQ0gudGVzdChzdHJpbmcpKSByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ3V0ZjgnLCAwLCBidWZmZXIubGVuZ3RoKTtcbiAgfSxcblxuICBfcmVhZFVJbnQ6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAyKSByZXR1cm4gYnVmZmVyLnJlYWRVSW50MTZCRSgwKTtcblxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkJFKDApICogMHgxMDAwMDAwMDAgK1xuICAgICAgICAgICBidWZmZXIucmVhZFVJbnQzMkJFKDQpO1xuICB9XG59O1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIEh5YmkucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh5Ymk7XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgUmluZ0J1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlclNpemUpIHtcbiAgdGhpcy5fYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XG4gIHRoaXMuY2xlYXIoKTtcbn07XG5cblJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2J1ZmZlciAgICAgPSBuZXcgQXJyYXkodGhpcy5fYnVmZmVyU2l6ZSk7XG4gIHRoaXMuX3JpbmdPZmZzZXQgPSAwO1xuICB0aGlzLl9yaW5nU2l6ZSAgID0gdGhpcy5fYnVmZmVyU2l6ZTtcbiAgdGhpcy5faGVhZCAgICAgICA9IDA7XG4gIHRoaXMuX3RhaWwgICAgICAgPSAwO1xuICB0aGlzLmxlbmd0aCAgICAgID0gMDtcbn07XG5cblJpbmdCdWZmZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgZXhwYW5kQnVmZmVyID0gZmFsc2UsXG4gICAgICBleHBhbmRSaW5nICAgPSBmYWxzZTtcblxuICBpZiAodGhpcy5fcmluZ1NpemUgPCB0aGlzLl9idWZmZXJTaXplKSB7XG4gICAgZXhwYW5kQnVmZmVyID0gKHRoaXMuX3RhaWwgPT09IDApO1xuICB9IGVsc2UgaWYgKHRoaXMuX3JpbmdPZmZzZXQgPT09IHRoaXMuX3JpbmdTaXplKSB7XG4gICAgZXhwYW5kQnVmZmVyID0gdHJ1ZTtcbiAgICBleHBhbmRSaW5nICAgPSAodGhpcy5fdGFpbCA9PT0gMCk7XG4gIH1cblxuICBpZiAoZXhwYW5kQnVmZmVyKSB7XG4gICAgdGhpcy5fdGFpbCAgICAgICA9IHRoaXMuX2J1ZmZlclNpemU7XG4gICAgdGhpcy5fYnVmZmVyICAgICA9IHRoaXMuX2J1ZmZlci5jb25jYXQobmV3IEFycmF5KHRoaXMuX2J1ZmZlclNpemUpKTtcbiAgICB0aGlzLl9idWZmZXJTaXplID0gdGhpcy5fYnVmZmVyLmxlbmd0aDtcblxuICAgIGlmIChleHBhbmRSaW5nKVxuICAgICAgdGhpcy5fcmluZ1NpemUgPSB0aGlzLl9idWZmZXJTaXplO1xuICB9XG5cbiAgdGhpcy5fYnVmZmVyW3RoaXMuX3RhaWxdID0gdmFsdWU7XG4gIHRoaXMubGVuZ3RoICs9IDE7XG4gIGlmICh0aGlzLl90YWlsIDwgdGhpcy5fcmluZ1NpemUpIHRoaXMuX3JpbmdPZmZzZXQgKz0gMTtcbiAgdGhpcy5fdGFpbCA9ICh0aGlzLl90YWlsICsgMSkgJSB0aGlzLl9idWZmZXJTaXplO1xufTtcblxuUmluZ0J1ZmZlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiB0aGlzLl9idWZmZXJbdGhpcy5faGVhZF07XG59O1xuXG5SaW5nQnVmZmVyLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG5cbiAgdmFyIHZhbHVlID0gdGhpcy5fYnVmZmVyW3RoaXMuX2hlYWRdO1xuICB0aGlzLl9idWZmZXJbdGhpcy5faGVhZF0gPSB2b2lkIDA7XG4gIHRoaXMubGVuZ3RoIC09IDE7XG4gIHRoaXMuX3JpbmdPZmZzZXQgLT0gMTtcblxuICBpZiAodGhpcy5fcmluZ09mZnNldCA9PT0gMCAmJiB0aGlzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9oZWFkICAgICAgID0gdGhpcy5fcmluZ1NpemU7XG4gICAgdGhpcy5fcmluZ09mZnNldCA9IHRoaXMubGVuZ3RoO1xuICAgIHRoaXMuX3JpbmdTaXplICAgPSB0aGlzLl9idWZmZXJTaXplO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2hlYWQgPSAodGhpcy5faGVhZCArIDEpICUgdGhpcy5fcmluZ1NpemU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSaW5nQnVmZmVyO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFJpbmdCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIFBsZWRnZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jb21wbGV0ZSAgPSBmYWxzZTtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IFJpbmdCdWZmZXIoUGxlZGdlLlFVRVVFX1NJWkUpO1xufTtcblxuUGxlZGdlLlFVRVVFX1NJWkUgPSA0O1xuXG5QbGVkZ2UuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuICB2YXIgcGxlZGdlICA9IG5ldyBQbGVkZ2UoKSxcbiAgICAgIHBlbmRpbmcgPSBsaXN0Lmxlbmd0aCxcbiAgICAgIG4gICAgICAgPSBwZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nID09PSAwKSBwbGVkZ2UuZG9uZSgpO1xuXG4gIHdoaWxlIChuLS0pIGxpc3Rbbl0udGhlbihmdW5jdGlvbigpIHtcbiAgICBwZW5kaW5nIC09IDE7XG4gICAgaWYgKHBlbmRpbmcgPT09IDApIHBsZWRnZS5kb25lKCk7XG4gIH0pO1xuICByZXR1cm4gcGxlZGdlO1xufTtcblxuUGxlZGdlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuX2NvbXBsZXRlKSBjYWxsYmFjaygpO1xuICBlbHNlIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbn07XG5cblBsZWRnZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jb21wbGV0ZSA9IHRydWU7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MsIGNhbGxiYWNrO1xuICB3aGlsZSAoY2FsbGJhY2sgPSBjYWxsYmFja3Muc2hpZnQoKSkgY2FsbGJhY2soKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGxlZGdlO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyLFxuICAgIEJhc2UgICA9IF9fd2VicGFja19yZXF1aXJlX18oMiksXG4gICAgdXRpbCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIERyYWZ0NzUgPSBmdW5jdGlvbihyZXF1ZXN0LCB1cmwsIG9wdGlvbnMpIHtcbiAgQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLl9zdGFnZSAgPSAwO1xuICB0aGlzLnZlcnNpb24gPSAnaGl4aWUtNzUnO1xuXG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdVcGdyYWRlJywgJ1dlYlNvY2tldCcpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnQ29ubmVjdGlvbicsICdVcGdyYWRlJyk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdXZWJTb2NrZXQtT3JpZ2luJywgdGhpcy5fcmVxdWVzdC5oZWFkZXJzLm9yaWdpbik7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdXZWJTb2NrZXQtTG9jYXRpb24nLCB0aGlzLnVybCk7XG59O1xudXRpbC5pbmhlcml0cyhEcmFmdDc1LCBCYXNlKTtcblxudmFyIGluc3RhbmNlID0ge1xuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gMykgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDM7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG5ldyBCYXNlLkNsb3NlRXZlbnQobnVsbCwgbnVsbCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiAxKSByZXR1cm47XG5cbiAgICB0aGlzLl9yZWFkZXIucHV0KGNodW5rKTtcblxuICAgIHRoaXMuX3JlYWRlci5lYWNoQnl0ZShmdW5jdGlvbihvY3RldCkge1xuICAgICAgdmFyIG1lc3NhZ2U7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhZ2UpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICB0aGlzLl9ib2R5LnB1c2gob2N0ZXQpO1xuICAgICAgICAgIHRoaXMuX3NlbmRIYW5kc2hha2VCb2R5KCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHRoaXMuX3BhcnNlTGVhZGluZ0J5dGUob2N0ZXQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLl9sZW5ndGggPSAob2N0ZXQgJiAweDdGKSArIDEyOCAqIHRoaXMuX2xlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLl9jbG9zaW5nICYmIHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9jdGV0ICYgMHg4MCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3RhZ2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NraXBwZWQgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl9zdGFnZSAgID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmIChvY3RldCA9PT0gMHhGRikge1xuICAgICAgICAgICAgdGhpcy5fc3RhZ2UgPSAwO1xuICAgICAgICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKHRoaXMuX2J1ZmZlcikudG9TdHJpbmcoJ3V0ZjgnLCAwLCB0aGlzLl9idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG5ldyBCYXNlLk1lc3NhZ2VFdmVudChtZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICAgICAgICB0aGlzLl9za2lwcGVkICs9IDE7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9za2lwcGVkID09PSB0aGlzLl9sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhZ2UgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnB1c2gob2N0ZXQpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA+IHRoaXMuX21heExlbmd0aCkgcmV0dXJuIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgZnJhbWU6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDApIHJldHVybiB0aGlzLl9xdWV1ZShbYnVmZmVyXSk7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDEpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgYnVmZmVyICE9PSAnc3RyaW5nJykgYnVmZmVyID0gYnVmZmVyLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoYnVmZmVyKSxcbiAgICAgICAgZnJhbWUgID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCArIDIpO1xuXG4gICAgZnJhbWVbMF0gPSAweDAwO1xuICAgIGZyYW1lLndyaXRlKGJ1ZmZlciwgMSk7XG4gICAgZnJhbWVbZnJhbWUubGVuZ3RoIC0gMV0gPSAweEZGO1xuXG4gICAgdGhpcy5fd3JpdGUoZnJhbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIF9oYW5kc2hha2VSZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0ICAgPSAnSFRUUC8xLjEgMTAxIFdlYiBTb2NrZXQgUHJvdG9jb2wgSGFuZHNoYWtlJyxcbiAgICAgICAgaGVhZGVycyA9IFtzdGFydCwgdGhpcy5faGVhZGVycy50b1N0cmluZygpLCAnJ107XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGVhZGVycy5qb2luKCdcXHJcXG4nKSwgJ3V0ZjgnKTtcbiAgfSxcblxuICBfcGFyc2VMZWFkaW5nQnl0ZTogZnVuY3Rpb24ob2N0ZXQpIHtcbiAgICBpZiAoKG9jdGV0ICYgMHg4MCkgPT09IDB4ODApIHtcbiAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9zdGFnZSAgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGVuZ3RoO1xuICAgICAgZGVsZXRlIHRoaXMuX3NraXBwZWQ7XG4gICAgICB0aGlzLl9idWZmZXIgPSBbXTtcbiAgICAgIHRoaXMuX3N0YWdlICA9IDI7XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIERyYWZ0NzUucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0NzU7XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgRXZlbnRUYXJnZXQgPSB7XG4gIG9ub3BlbjogICAgIG51bGwsXG4gIG9ubWVzc2FnZTogIG51bGwsXG4gIG9uZXJyb3I6ICAgIG51bGwsXG4gIG9uY2xvc2U6ICAgIG51bGwsXG5cbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgIHRoaXMub24oZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudC50YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcbiAgICBldmVudC5ldmVudFBoYXNlID0gRXZlbnQuQVRfVEFSR0VUO1xuXG4gICAgaWYgKHRoaXNbJ29uJyArIGV2ZW50LnR5cGVdKVxuICAgICAgdGhpc1snb24nICsgZXZlbnQudHlwZV0oZXZlbnQpO1xuXG4gICAgdGhpcy5lbWl0KGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFBhY2thZ2UgdXRmOCBpbXBsZW1lbnRzIFVURi04IGVuY29kaW5nIGFuZCBkZWNvZGluZy5cbiAqL1xudmFyIElOVkFMSURfVVRGMTYgPSBcInV0Zjg6IGludmFsaWQgc3RyaW5nXCI7XG52YXIgSU5WQUxJRF9VVEY4ID0gXCJ1dGY4OiBpbnZhbGlkIHNvdXJjZSBlbmNvZGluZ1wiO1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgaW50byBVVEYtOCBieXRlIGFycmF5LlxuICogVGhyb3dzIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGhhcyBpbnZhbGlkIFVURi0xNiBlbmNvZGluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHMpIHtcbiAgICAvLyBDYWxjdWxhdGUgcmVzdWx0IGxlbmd0aCBhbmQgYWxsb2NhdGUgb3V0cHV0IGFycmF5LlxuICAgIC8vIGVuY29kZWRMZW5ndGgoKSBhbHNvIHZhbGlkYXRlcyBzdHJpbmcgYW5kIHRocm93cyBlcnJvcnMsXG4gICAgLy8gc28gd2UgZG9uJ3QgbmVlZCByZXBlYXQgdmFsaWRhdGlvbiBoZXJlLlxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShlbmNvZGVkTGVuZ3RoKHMpKTtcbiAgICB2YXIgcG9zID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHhjMCB8IGMgPj4gNjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCkge1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ZTAgfCBjID4+IDEyO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCAoYyA+PiA2KSAmIDB4M2Y7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSsrOyAvLyBnZXQgb25lIG1vcmUgY2hhcmFjdGVyXG4gICAgICAgICAgICBjID0gKGMgJiAweDNmZikgPDwgMTA7XG4gICAgICAgICAgICBjIHw9IHMuY2hhckNvZGVBdChpKSAmIDB4M2ZmO1xuICAgICAgICAgICAgYyArPSAweDEwMDAwO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ZjAgfCBjID4+IDE4O1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCAoYyA+PiAxMikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCAoYyA+PiA2KSAmIDB4M2Y7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIGVuY29kZSB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gVVRGLTguXG4gKiBUaHJvd3MgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaGFzIGludmFsaWQgVVRGLTE2IGVuY29kaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGVkTGVuZ3RoKHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgaWYgKGkgPj0gcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrOyAvLyBcImVhdFwiIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICByZXN1bHQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5lbmNvZGVkTGVuZ3RoID0gZW5jb2RlZExlbmd0aDtcbi8qKlxuICogRGVjb2RlcyB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSBmcm9tIFVURi04IGludG8gYSBzdHJpbmcuXG4gKiBUaHJvd3MgaWYgZW5jb2RpbmcgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGFycikge1xuICAgIHZhciBjaGFycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBiID0gYXJyW2ldO1xuICAgICAgICBpZiAoYiAmIDB4ODApIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoYiA8IDB4ZTApIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIDEgbW9yZSBieXRlLlxuICAgICAgICAgICAgICAgIGlmIChpID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuMSA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIGlmICgobjEgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IChiICYgMHgxZikgPDwgNiB8IChuMSAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIG1pbiA9IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiIDwgMHhmMCkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgMiBtb3JlIGJ5dGVzLlxuICAgICAgICAgICAgICAgIGlmIChpID49IGFyci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbjEgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICB2YXIgbjIgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG4xICYgMHhjMCkgIT09IDB4ODAgfHwgKG4yICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSAoYiAmIDB4MGYpIDw8IDEyIHwgKG4xICYgMHgzZikgPDwgNiB8IChuMiAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIG1pbiA9IDB4ODAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA8IDB4ZjgpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIDMgbW9yZSBieXRlcy5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG4xID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgdmFyIG4yID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgdmFyIG4zID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgaWYgKChuMSAmIDB4YzApICE9PSAweDgwIHx8IChuMiAmIDB4YzApICE9PSAweDgwIHx8IChuMyAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gKGIgJiAweDBmKSA8PCAxOCB8IChuMSAmIDB4M2YpIDw8IDEyIHwgKG4yICYgMHgzZikgPDwgNiB8IChuMyAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIG1pbiA9IDB4MTAwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiIDwgbWluIHx8IChiID49IDB4ZDgwMCAmJiBiIDw9IDB4ZGZmZikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiID49IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICAvLyBTdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICAgICAgICBpZiAoYiA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiIC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgY2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCB8IChiID4+IDEwKSkpO1xuICAgICAgICAgICAgICAgIGIgPSAweGRjMDAgfCAoYiAmIDB4M2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYikpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbihcIlwiKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBBUEkgcmVmZXJlbmNlczpcbi8vXG4vLyAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjbmV0d29ya1xuLy8gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1ldmVudHRhcmdldFxuLy8gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1ldmVudFxuXG5cblxudmFyIHV0aWwgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgZHJpdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KSxcbiAgICBBUEkgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIFdlYlNvY2tldCA9IGZ1bmN0aW9uKHJlcXVlc3QsIHNvY2tldCwgYm9keSwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuX3N0cmVhbSA9IHNvY2tldDtcbiAgdGhpcy5fZHJpdmVyID0gZHJpdmVyLmh0dHAocmVxdWVzdCwge21heExlbmd0aDogb3B0aW9ucy5tYXhMZW5ndGgsIHByb3RvY29sczogcHJvdG9jb2xzfSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoIXRoaXMuX3N0cmVhbSB8fCAhdGhpcy5fc3RyZWFtLndyaXRhYmxlKSByZXR1cm47XG4gIGlmICghdGhpcy5fc3RyZWFtLnJlYWRhYmxlKSByZXR1cm4gdGhpcy5fc3RyZWFtLmVuZCgpO1xuXG4gIHZhciBjYXRjaHVwID0gZnVuY3Rpb24oKSB7IHNlbGYuX3N0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGNhdGNodXApIH07XG4gIHRoaXMuX3N0cmVhbS5vbignZGF0YScsIGNhdGNodXApO1xuXG4gIEFQSS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZHJpdmVyLnN0YXJ0KCk7XG4gICAgc2VsZi5fZHJpdmVyLmlvLndyaXRlKGJvZHkpO1xuICB9KTtcbn07XG51dGlsLmluaGVyaXRzKFdlYlNvY2tldCwgQVBJKTtcblxuV2ViU29ja2V0LmlzV2ViU29ja2V0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICByZXR1cm4gZHJpdmVyLmlzV2ViU29ja2V0KHJlcXVlc3QpO1xufTtcblxuV2ViU29ja2V0LnZhbGlkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIHZhbGlkS2V5cykge1xuICBkcml2ZXIudmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIHZhbGlkS2V5cyk7XG59O1xuXG5XZWJTb2NrZXQuV2ViU29ja2V0ICAgPSBXZWJTb2NrZXQ7XG5XZWJTb2NrZXQuQ2xpZW50ICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbldlYlNvY2tldC5FdmVudFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuXG5tb2R1bGUuZXhwb3J0cyAgICAgICAgPSBXZWJTb2NrZXQ7XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIGJ1aWx0LWluIGh0dHAuanMgdG8gZW11bGF0ZSB0aGUgYnJvd3NlciBYTUxIdHRwUmVxdWVzdCBvYmplY3QuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aXRoIEpTIGRlc2lnbmVkIGZvciBicm93c2VycyB0byBpbXByb3ZlIHJldXNlIG9mIGNvZGUgYW5kXG4gKiBhbGxvdyB0aGUgdXNlIG9mIGV4aXN0aW5nIGxpYnJhcmllcy5cbiAqXG4gKiBVc2FnZTogaW5jbHVkZShcIlhNTEh0dHBSZXF1ZXN0LmpzXCIpIGFuZCB1c2UgWE1MSHR0cFJlcXVlc3QgcGVyIFczQyBzcGVjcy5cbiAqXG4gKiBAYXV0aG9yIERhbiBEZUZlbGlwcGkgPGRhbkBkcml2ZXJkYW4uY29tPlxuICogQGNvbnRyaWJ1dG9yIERhdmlkIEVsbGlzIDxkLmYuZWxsaXNAaWVlZS5vcmc+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG52YXIgVXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBzcGF3biA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpLnNwYXduO1xudmFyIGZzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG5cbmV4cG9ydHMuWE1MSHR0cFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgdmFyaWFibGVzXG4gICAqL1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBodHRwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG4gIHZhciBodHRwcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuXG4gIC8vIEhvbGRzIGh0dHAuanMgb2JqZWN0c1xuICB2YXIgcmVxdWVzdDtcbiAgdmFyIHJlc3BvbnNlO1xuXG4gIC8vIFJlcXVlc3Qgc2V0dGluZ3NcbiAgdmFyIHNldHRpbmdzID0ge307XG5cbiAgLy8gRGlzYWJsZSBoZWFkZXIgYmxhY2tsaXN0LlxuICAvLyBOb3QgcGFydCBvZiBYSFIgc3BlY3MuXG4gIHZhciBkaXNhYmxlSGVhZGVyQ2hlY2sgPSBmYWxzZTtcblxuICAvLyBTZXQgc29tZSBkZWZhdWx0IGhlYWRlcnNcbiAgdmFyIGRlZmF1bHRIZWFkZXJzID0ge1xuICAgIFwiVXNlci1BZ2VudFwiOiBcIm5vZGUtWE1MSHR0cFJlcXVlc3RcIixcbiAgICBcIkFjY2VwdFwiOiBcIiovKlwiLFxuICB9O1xuXG4gIHZhciBoZWFkZXJzID0ge307XG4gIHZhciBoZWFkZXJzQ2FzZSA9IHt9O1xuXG4gIC8vIFRoZXNlIGhlYWRlcnMgYXJlIG5vdCB1c2VyIHNldGFibGUuXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXJlIGFsbG93ZWQgYnV0IGJhbm5lZCBpbiB0aGUgc3BlYzpcbiAgLy8gKiB1c2VyLWFnZW50XG4gIHZhciBmb3JiaWRkZW5SZXF1ZXN0SGVhZGVycyA9IFtcbiAgICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcImNvbm5lY3Rpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImNvb2tpZTJcIixcbiAgICBcImRhdGVcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgIFwib3JpZ2luXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidHJhaWxlclwiLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInZpYVwiXG4gIF07XG5cbiAgLy8gVGhlc2UgcmVxdWVzdCBtZXRob2RzIGFyZSBub3QgYWxsb3dlZFxuICB2YXIgZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMgPSBbXG4gICAgXCJUUkFDRVwiLFxuICAgIFwiVFJBQ0tcIixcbiAgICBcIkNPTk5FQ1RcIlxuICBdO1xuXG4gIC8vIFNlbmQgZmxhZ1xuICB2YXIgc2VuZEZsYWcgPSBmYWxzZTtcbiAgLy8gRXJyb3IgZmxhZywgdXNlZCB3aGVuIGVycm9ycyBvY2N1ciBvciBhYm9ydCBpcyBjYWxsZWRcbiAgdmFyIGVycm9yRmxhZyA9IGZhbHNlO1xuXG4gIC8vIEV2ZW50IGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0ge307XG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICB0aGlzLlVOU0VOVCA9IDA7XG4gIHRoaXMuT1BFTkVEID0gMTtcbiAgdGhpcy5IRUFERVJTX1JFQ0VJVkVEID0gMjtcbiAgdGhpcy5MT0FESU5HID0gMztcbiAgdGhpcy5ET05FID0gNDtcblxuICAvKipcbiAgICogUHVibGljIHZhcnNcbiAgICovXG5cbiAgLy8gQ3VycmVudCBzdGF0ZVxuICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLlVOU0VOVDtcblxuICAvLyBkZWZhdWx0IHJlYWR5IHN0YXRlIGNoYW5nZSBoYW5kbGVyIGluIGNhc2Ugb25lIGlzIG5vdCBzZXQgb3IgaXMgc2V0IGxhdGVcbiAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG4gIC8vIFJlc3VsdCAmIHJlc3BvbnNlXG4gIHRoaXMucmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XG4gIHRoaXMuc3RhdHVzID0gbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gbnVsbDtcbiAgXG4gIC8vIFdoZXRoZXIgY3Jvc3Mtc2l0ZSBBY2Nlc3MtQ29udHJvbCByZXF1ZXN0cyBzaG91bGQgYmUgbWFkZSB1c2luZ1xuICAvLyBjcmVkZW50aWFscyBzdWNoIGFzIGNvb2tpZXMgb3IgYXV0aG9yaXphdGlvbiBoZWFkZXJzXG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbWV0aG9kc1xuICAgKi9cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHNwZWNpZmllZCBoZWFkZXIgaXMgYWxsb3dlZC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgSGVhZGVyIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm4gYm9vbGVhbiBGYWxzZSBpZiBub3QgYWxsb3dlZCwgb3RoZXJ3aXNlIHRydWVcbiAgICovXG4gIHZhciBpc0FsbG93ZWRIdHRwSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgcmV0dXJuIGRpc2FibGVIZWFkZXJDaGVjayB8fCAoaGVhZGVyICYmIGZvcmJpZGRlblJlcXVlc3RIZWFkZXJzLmluZGV4T2YoaGVhZGVyLnRvTG93ZXJDYXNlKCkpID09PSAtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgbWV0aG9kIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgbWV0aG9kIFJlcXVlc3QgbWV0aG9kIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm4gYm9vbGVhbiBGYWxzZSBpZiBub3QgYWxsb3dlZCwgb3RoZXJ3aXNlIHRydWVcbiAgICovXG4gIHZhciBpc0FsbG93ZWRIdHRwTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgcmV0dXJuIChtZXRob2QgJiYgZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMuaW5kZXhPZihtZXRob2QpID09PSAtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2RzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcGVuIHRoZSBjb25uZWN0aW9uLiBDdXJyZW50bHkgc3VwcG9ydHMgbG9jYWwgc2VydmVyIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIG1ldGhvZCBDb25uZWN0aW9uIG1ldGhvZCAoZWcgR0VULCBQT1NUKVxuICAgKiBAcGFyYW0gc3RyaW5nIHVybCBVUkwgZm9yIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0gYm9vbGVhbiBhc3luYyBBc3luY2hyb25vdXMgY29ubmVjdGlvbi4gRGVmYXVsdCBpcyB0cnVlLlxuICAgKiBAcGFyYW0gc3RyaW5nIHVzZXIgVXNlcm5hbWUgZm9yIGJhc2ljIGF1dGhlbnRpY2F0aW9uIChvcHRpb25hbClcbiAgICogQHBhcmFtIHN0cmluZyBwYXNzd29yZCBQYXNzd29yZCBmb3IgYmFzaWMgYXV0aGVudGljYXRpb24gKG9wdGlvbmFsKVxuICAgKi9cbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCkge1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgICBlcnJvckZsYWcgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGZvciB2YWxpZCByZXF1ZXN0IG1ldGhvZFxuICAgIGlmICghaXNBbGxvd2VkSHR0cE1ldGhvZChtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWN1cml0eUVycm9yOiBSZXF1ZXN0IG1ldGhvZCBub3QgYWxsb3dlZFwiKTtcbiAgICB9XG5cbiAgICBzZXR0aW5ncyA9IHtcbiAgICAgIFwibWV0aG9kXCI6IG1ldGhvZCxcbiAgICAgIFwidXJsXCI6IHVybC50b1N0cmluZygpLFxuICAgICAgXCJhc3luY1wiOiAodHlwZW9mIGFzeW5jICE9PSBcImJvb2xlYW5cIiA/IHRydWUgOiBhc3luYyksXG4gICAgICBcInVzZXJcIjogdXNlciB8fCBudWxsLFxuICAgICAgXCJwYXNzd29yZFwiOiBwYXNzd29yZCB8fCBudWxsXG4gICAgfTtcblxuICAgIHNldFN0YXRlKHRoaXMuT1BFTkVEKTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZXMgb3IgZW5hYmxlcyBpc0FsbG93ZWRIdHRwSGVhZGVyKCkgY2hlY2sgdGhlIHJlcXVlc3QuIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICogVGhpcyBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBXM0Mgc3BlYy5cbiAgICpcbiAgICogQHBhcmFtIGJvb2xlYW4gc3RhdGUgRW5hYmxlIG9yIGRpc2FibGUgaGVhZGVyIGNoZWNraW5nLlxuICAgKi9cbiAgdGhpcy5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGRpc2FibGVIZWFkZXJDaGVjayA9IHN0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgaGVhZGVyIGZvciB0aGUgcmVxdWVzdCBvciBhcHBlbmRzIHRoZSB2YWx1ZSBpZiBvbmUgaXMgYWxyZWFkeSBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIEhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSBzdHJpbmcgdmFsdWUgSGVhZGVyIHZhbHVlXG4gICAqL1xuICB0aGlzLnNldFJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5PUEVORUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBzZXRSZXF1ZXN0SGVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIHN0YXRlIGlzIE9QRU5cIik7XG4gICAgfVxuICAgIGlmICghaXNBbGxvd2VkSHR0cEhlYWRlcihoZWFkZXIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJSZWZ1c2VkIHRvIHNldCB1bnNhZmUgaGVhZGVyIFxcXCJcIiArIGhlYWRlciArIFwiXFxcIlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogc2VuZCBmbGFnIGlzIHRydWVcIik7XG4gICAgfVxuICAgIGhlYWRlciA9IGhlYWRlcnNDYXNlW2hlYWRlci50b0xvd2VyQ2FzZSgpXSB8fCBoZWFkZXI7XG4gICAgaGVhZGVyc0Nhc2VbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyO1xuICAgIGhlYWRlcnNbaGVhZGVyXSA9IGhlYWRlcnNbaGVhZGVyXSA/IGhlYWRlcnNbaGVhZGVyXSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgaGVhZGVyIGZyb20gdGhlIHNlcnZlciByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgTmFtZSBvZiBoZWFkZXIgdG8gZ2V0LlxuICAgKiBAcmV0dXJuIHN0cmluZyBUZXh0IG9mIHRoZSBoZWFkZXIgb3IgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgdGhpcy5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIGlmICh0eXBlb2YgaGVhZGVyID09PSBcInN0cmluZ1wiXG4gICAgICAmJiB0aGlzLnJlYWR5U3RhdGUgPiB0aGlzLk9QRU5FRFxuICAgICAgJiYgcmVzcG9uc2VcbiAgICAgICYmIHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICYmIHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldXG4gICAgICAmJiAhZXJyb3JGbGFnXG4gICAgKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgKlxuICAgKiBAcmV0dXJuIHN0cmluZyBBIHN0cmluZyB3aXRoIGFsbCByZXNwb25zZSBoZWFkZXJzIHNlcGFyYXRlZCBieSBDUitMRlxuICAgKi9cbiAgdGhpcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDwgdGhpcy5IRUFERVJTX1JFQ0VJVkVEIHx8IGVycm9yRmxhZykge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAvLyBDb29raWUgaGVhZGVycyBhcmUgZXhjbHVkZWRcbiAgICAgIGlmIChpICE9PSBcInNldC1jb29raWVcIiAmJiBpICE9PSBcInNldC1jb29raWUyXCIpIHtcbiAgICAgICAgcmVzdWx0ICs9IGkgKyBcIjogXCIgKyByZXNwb25zZS5oZWFkZXJzW2ldICsgXCJcXHJcXG5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zdWJzdHIoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVxdWVzdCBoZWFkZXJcbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBuYW1lIE5hbWUgb2YgaGVhZGVyIHRvIGdldFxuICAgKiBAcmV0dXJuIHN0cmluZyBSZXR1cm5zIHRoZSByZXF1ZXN0IGhlYWRlciBvciBlbXB0eSBzdHJpbmcgaWYgbm90IHNldFxuICAgKi9cbiAgdGhpcy5nZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBoZWFkZXJzQ2FzZVtuYW1lLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICByZXR1cm4gaGVhZGVyc1toZWFkZXJzQ2FzZVtuYW1lLnRvTG93ZXJDYXNlKCldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIjtcbiAgfTtcblxuICAvKipcbiAgICogU2VuZHMgdGhlIHJlcXVlc3QgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBkYXRhIE9wdGlvbmFsIGRhdGEgdG8gc2VuZCBhcyByZXF1ZXN0IGJvZHkuXG4gICAqL1xuICB0aGlzLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5PUEVORUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBjb25uZWN0aW9uIG11c3QgYmUgb3BlbmVkIGJlZm9yZSBzZW5kKCkgaXMgY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlI6IHNlbmQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgdmFyIHNzbCA9IGZhbHNlLCBsb2NhbCA9IGZhbHNlO1xuICAgIHZhciB1cmwgPSBVcmwucGFyc2Uoc2V0dGluZ3MudXJsKTtcbiAgICB2YXIgaG9zdDtcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHNlcnZlclxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgICAgIHNzbCA9IHRydWU7XG4gICAgICAgIC8vIFNTTCAmIG5vbi1TU0wgYm90aCBuZWVkIGhvc3QsIG5vIGJyZWFrIGhlcmUuXG4gICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJmaWxlOlwiOlxuICAgICAgICBsb2NhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgaG9zdCA9IFwibG9jYWxob3N0XCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm90b2NvbCBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG5cbiAgICAvLyBMb2FkIGZpbGVzIG9mZiB0aGUgbG9jYWwgZmlsZXN5c3RlbSAoZmlsZTovLylcbiAgICBpZiAobG9jYWwpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3Q6IE9ubHkgR0VUIG1ldGhvZCBpcyBzdXBwb3J0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXR0aW5ncy5hc3luYykge1xuICAgICAgICBmcy5yZWFkRmlsZSh1cmwucGF0aG5hbWUsIFwidXRmOFwiLCBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBkYXRhO1xuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IGZzLnJlYWRGaWxlU3luYyh1cmwucGF0aG5hbWUsIFwidXRmOFwiKTtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IDIwMDtcbiAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHBvcnQgODAuIElmIGFjY2Vzc2luZyBsb2NhbGhvc3Qgb24gYW5vdGhlciBwb3J0IGJlIHN1cmVcbiAgICAvLyB0byB1c2UgaHR0cDovL2xvY2FsaG9zdDpwb3J0L3BhdGhcbiAgICB2YXIgcG9ydCA9IHVybC5wb3J0IHx8IChzc2wgPyA0NDMgOiA4MCk7XG4gICAgLy8gQWRkIHF1ZXJ5IHN0cmluZyBpZiBvbmUgaXMgdXNlZFxuICAgIHZhciB1cmkgPSB1cmwucGF0aG5hbWUgKyAodXJsLnNlYXJjaCA/IHVybC5zZWFyY2ggOiBcIlwiKTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgaWYgdGhleSBoYXZlbid0IGJlZW4gc2V0XG4gICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0SGVhZGVycykge1xuICAgICAgaWYgKCFoZWFkZXJzQ2FzZVtuYW1lLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIGhlYWRlcnNbbmFtZV0gPSBkZWZhdWx0SGVhZGVyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIEhvc3QgaGVhZGVyIG9yIHRoZSBzZXJ2ZXIgbWF5IHJlamVjdCB0aGUgcmVxdWVzdFxuICAgIGhlYWRlcnMuSG9zdCA9IGhvc3Q7XG4gICAgaWYgKCEoKHNzbCAmJiBwb3J0ID09PSA0NDMpIHx8IHBvcnQgPT09IDgwKSkge1xuICAgICAgaGVhZGVycy5Ib3N0ICs9IFwiOlwiICsgdXJsLnBvcnQ7XG4gICAgfVxuXG4gICAgLy8gU2V0IEJhc2ljIEF1dGggaWYgbmVjZXNzYXJ5XG4gICAgaWYgKHNldHRpbmdzLnVzZXIpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MucGFzc3dvcmQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2V0dGluZ3MucGFzc3dvcmQgPSBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIGF1dGhCdWYgPSBuZXcgQnVmZmVyKHNldHRpbmdzLnVzZXIgKyBcIjpcIiArIHNldHRpbmdzLnBhc3N3b3JkKTtcbiAgICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IFwiQmFzaWMgXCIgKyBhdXRoQnVmLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cblxuICAgIC8vIFNldCBjb250ZW50IGxlbmd0aCBoZWFkZXJcbiAgICBpZiAoc2V0dGluZ3MubWV0aG9kID09PSBcIkdFVFwiIHx8IHNldHRpbmdzLm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgIGRhdGEgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gQnVmZmVyLmlzQnVmZmVyKGRhdGEpID8gZGF0YS5sZW5ndGggOiBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKCFoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKSB7XG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgLy8gRm9yIGEgcG9zdCB3aXRoIG5vIGRhdGEgc2V0IENvbnRlbnQtTGVuZ3RoOiAwLlxuICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBieSBidWdneSBzZXJ2ZXJzIHRoYXQgZG9uJ3QgbWVldCB0aGUgc3BlY3MuXG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSAwO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgaG9zdDogaG9zdCxcbiAgICAgIHBvcnQ6IHBvcnQsXG4gICAgICBwYXRoOiB1cmksXG4gICAgICBtZXRob2Q6IHNldHRpbmdzLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBhZ2VudDogZmFsc2UsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYud2l0aENyZWRlbnRpYWxzXG4gICAgfTtcblxuICAgIC8vIFJlc2V0IGVycm9yIGZsYWdcbiAgICBlcnJvckZsYWcgPSBmYWxzZTtcblxuICAgIC8vIEhhbmRsZSBhc3luYyByZXF1ZXN0c1xuICAgIGlmIChzZXR0aW5ncy5hc3luYykge1xuICAgICAgLy8gVXNlIHRoZSBwcm9wZXIgcHJvdG9jb2xcbiAgICAgIHZhciBkb1JlcXVlc3QgPSBzc2wgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0O1xuXG4gICAgICAvLyBSZXF1ZXN0IGlzIGJlaW5nIHNlbnQsIHNldCBzZW5kIGZsYWdcbiAgICAgIHNlbmRGbGFnID0gdHJ1ZTtcblxuICAgICAgLy8gQXMgcGVyIHNwZWMsIHRoaXMgaXMgY2FsbGVkIGhlcmUgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIik7XG5cbiAgICAgIC8vIEhhbmRsZXIgZm9yIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGFuZGxlciA9IGZ1bmN0aW9uIHJlc3BvbnNlSGFuZGxlcihyZXNwKSB7XG4gICAgICAgIC8vIFNldCByZXNwb25zZSB2YXIgdG8gdGhlIHJlc3BvbnNlIHdlIGdvdCBiYWNrXG4gICAgICAgIC8vIFRoaXMgaXMgc28gaXQgcmVtYWlucyBhY2Nlc3NhYmxlIG91dHNpZGUgdGhpcyBzY29wZVxuICAgICAgICByZXNwb25zZSA9IHJlc3A7XG4gICAgICAgIC8vIENoZWNrIGZvciByZWRpcmVjdFxuICAgICAgICAvLyBAVE9ETyBQcmV2ZW50IGxvb3BlZCByZWRpcmVjdHNcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAzIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNykge1xuICAgICAgICAgIC8vIENoYW5nZSBVUkwgdG8gdGhlIHJlZGlyZWN0IGxvY2F0aW9uXG4gICAgICAgICAgc2V0dGluZ3MudXJsID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbjtcbiAgICAgICAgICB2YXIgdXJsID0gVXJsLnBhcnNlKHNldHRpbmdzLnVybCk7XG4gICAgICAgICAgLy8gU2V0IGhvc3QgdmFyIGluIGNhc2UgaXQncyB1c2VkIGxhdGVyXG4gICAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgICAvLyBPcHRpb25zIGZvciB0aGUgbmV3IHJlcXVlc3RcbiAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUsXG4gICAgICAgICAgICBwb3J0OiB1cmwucG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHVybC5wYXRoLFxuICAgICAgICAgICAgbWV0aG9kOiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDMgPyBcIkdFVFwiIDogc2V0dGluZ3MubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi53aXRoQ3JlZGVudGlhbHNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gSXNzdWUgdGhlIG5ldyByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdCA9IGRvUmVxdWVzdChuZXdPcHRpb25zLCByZXNwb25zZUhhbmRsZXIpLm9uKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICAgIC8vIEBUT0RPIENoZWNrIGlmIGFuIFhIUiBldmVudCBuZWVkcyB0byBiZSBmaXJlZCBoZXJlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuXG4gICAgICAgIHNldFN0YXRlKHNlbGYuSEVBREVSU19SRUNFSVZFRCk7XG4gICAgICAgIHNlbGYuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcblxuICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUncyBzb21lIGRhdGFcbiAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ICs9IGNodW5rO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEb24ndCBlbWl0IHN0YXRlIGNoYW5nZXMgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHNlbGYuTE9BRElORyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXNwb25zZS5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgICAgICAgIC8vIERpc2NhcmQgdGhlIGVuZCBldmVudCBpZiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBhYm9ydGVkXG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICAgICAgc2VuZEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBFcnJvciBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdFxuICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIGVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IGRvUmVxdWVzdChvcHRpb25zLCByZXNwb25zZUhhbmRsZXIpLm9uKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcblxuICAgICAgLy8gTm9kZSAwLjQgYW5kIGxhdGVyIHdvbid0IGFjY2VwdCBlbXB0eSBkYXRhLiBNYWtlIHN1cmUgaXQncyBuZWVkZWQuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXF1ZXN0LndyaXRlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmVuZCgpO1xuXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG4gICAgfSBlbHNlIHsgLy8gU3luY2hyb25vdXNcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBmaWxlIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIG90aGVyIE5vZGUgcHJvY2Vzc1xuICAgICAgdmFyIGNvbnRlbnRGaWxlID0gXCIubm9kZS14bWxodHRwcmVxdWVzdC1jb250ZW50LVwiICsgcHJvY2Vzcy5waWQ7XG4gICAgICB2YXIgc3luY0ZpbGUgPSBcIi5ub2RlLXhtbGh0dHByZXF1ZXN0LXN5bmMtXCIgKyBwcm9jZXNzLnBpZDtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoc3luY0ZpbGUsIFwiXCIsIFwidXRmOFwiKTtcbiAgICAgIC8vIFRoZSBhc3luYyByZXF1ZXN0IHRoZSBvdGhlciBOb2RlIHByb2Nlc3MgZXhlY3V0ZXNcbiAgICAgIHZhciBleGVjU3RyaW5nID0gXCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKSwgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpLCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XCJcbiAgICAgICAgKyBcInZhciBkb1JlcXVlc3QgPSBodHRwXCIgKyAoc3NsID8gXCJzXCIgOiBcIlwiKSArIFwiLnJlcXVlc3Q7XCJcbiAgICAgICAgKyBcInZhciBvcHRpb25zID0gXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSArIFwiO1wiXG4gICAgICAgICsgXCJ2YXIgcmVzcG9uc2VUZXh0ID0gJyc7XCJcbiAgICAgICAgKyBcInZhciByZXEgPSBkb1JlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcIlxuICAgICAgICArIFwicmVzcG9uc2Uuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcIlxuICAgICAgICArIFwicmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1wiXG4gICAgICAgICsgXCIgIHJlc3BvbnNlVGV4dCArPSBjaHVuaztcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcIlxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgSlNPTi5zdHJpbmdpZnkoe2VycjogbnVsbCwgZGF0YToge3N0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsIHRleHQ6IHJlc3BvbnNlVGV4dH19KSwgJ3V0ZjgnKTtcIlxuICAgICAgICArIFwiZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcbiAgICAgICAgKyBcIn0pO1wiXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1wiXG4gICAgICAgICsgXCJmcy53cml0ZUZpbGVTeW5jKCdcIiArIGNvbnRlbnRGaWxlICsgXCInLCBKU09OLnN0cmluZ2lmeSh7ZXJyOiBlcnJvcn0pLCAndXRmOCcpO1wiXG4gICAgICAgICsgXCJmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcIn0pLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XCJcbiAgICAgICAgKyBcImZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsIEpTT04uc3RyaW5naWZ5KHtlcnI6IGVycm9yfSksICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcImZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXG4gICAgICAgICsgXCJ9KTtcIlxuICAgICAgICArIChkYXRhID8gXCJyZXEud3JpdGUoJ1wiICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkuc2xpY2UoMSwtMSkucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpICsgXCInKTtcIjpcIlwiKVxuICAgICAgICArIFwicmVxLmVuZCgpO1wiO1xuICAgICAgLy8gU3RhcnQgdGhlIG90aGVyIE5vZGUgUHJvY2VzcywgZXhlY3V0aW5nIHRoaXMgc3RyaW5nXG4gICAgICB2YXIgc3luY1Byb2MgPSBzcGF3bihwcm9jZXNzLmFyZ3ZbMF0sIFtcIi1lXCIsIGV4ZWNTdHJpbmddKTtcbiAgICAgIHdoaWxlKGZzLmV4aXN0c1N5bmMoc3luY0ZpbGUpKSB7XG4gICAgICAgIC8vIFdhaXQgd2hpbGUgdGhlIHN5bmMgZmlsZSBpcyBlbXB0eVxuICAgICAgfVxuICAgICAgdmFyIHJlc3AgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhjb250ZW50RmlsZSwgJ3V0ZjgnKSk7XG4gICAgICAvLyBLaWxsIHRoZSBjaGlsZCBwcm9jZXNzIG9uY2UgdGhlIGZpbGUgaGFzIGRhdGFcbiAgICAgIHN5bmNQcm9jLnN0ZGluLmVuZCgpO1xuICAgICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgZmlsZVxuICAgICAgZnMudW5saW5rU3luYyhjb250ZW50RmlsZSk7XG5cbiAgICAgIGlmIChyZXNwLmVycikge1xuICAgICAgICBzZWxmLmhhbmRsZUVycm9yKHJlc3AuZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNlID0gcmVzcC5kYXRhO1xuICAgICAgICBzZWxmLnN0YXR1cyA9IHJlc3AuZGF0YS5zdGF0dXNDb2RlO1xuICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IHJlc3AuZGF0YS50ZXh0O1xuICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgdG8gZGVhbCB3aXRoIGl0LlxuICAgKi9cbiAgdGhpcy5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgdGhpcy5zdGF0dXMgPSAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGVycm9yO1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gZXJyb3Iuc3RhY2s7XG4gICAgZXJyb3JGbGFnID0gdHJ1ZTtcbiAgICBzZXRTdGF0ZSh0aGlzLkRPTkUpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZXJyb3InKTtcbiAgfTtcblxuICAvKipcbiAgICogQWJvcnRzIGEgcmVxdWVzdC5cbiAgICovXG4gIHRoaXMuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaGVhZGVycyA9IGRlZmF1bHRIZWFkZXJzO1xuICAgIHRoaXMuc3RhdHVzID0gMDtcbiAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gICAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XG5cbiAgICBlcnJvckZsYWcgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5VTlNFTlRcbiAgICAgICAgJiYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5PUEVORUQgfHwgc2VuZEZsYWcpXG4gICAgICAgICYmIHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5ET05FKSB7XG4gICAgICBzZW5kRmxhZyA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUodGhpcy5ET05FKTtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlQ7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdhYm9ydCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyLiBQcmVmZXJyZWQgbWV0aG9kIG9mIGJpbmRpbmcgdG8gZXZlbnRzLlxuICAgKi9cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoZXZlbnQgaW4gbGlzdGVuZXJzKSkge1xuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICAvLyBDdXJyZW50bHkgYWxsb3dzIGR1cGxpY2F0ZSBjYWxsYmFja3MuIFNob3VsZCBpdD9cbiAgICBsaXN0ZW5lcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgY2FsbGJhY2sgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kLlxuICAgKiBPbmx5IHdvcmtzIG9uIHRoZSBtYXRjaGluZyBmdW5jaXRvbiwgY2Fubm90IGJlIGEgY29weS5cbiAgICovXG4gIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmIChldmVudCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIC8vIEZpbHRlciB3aWxsIHJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZSBjYWxsYmFjayByZW1vdmVkXG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXJzW2V2ZW50XS5maWx0ZXIoZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgcmV0dXJuIGV2ICE9PSBjYWxsYmFjaztcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2ggYW55IGV2ZW50cywgaW5jbHVkaW5nIGJvdGggXCJvblwiIG1ldGhvZHMgYW5kIGV2ZW50cyBhdHRhY2hlZCB1c2luZyBhZGRFdmVudExpc3RlbmVyLlxuICAgKi9cbiAgdGhpcy5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIHNlbGZbXCJvblwiICsgZXZlbnRdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHNlbGZbXCJvblwiICsgZXZlbnRdKCk7XG4gICAgfVxuICAgIGlmIChldmVudCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnNbZXZlbnRdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tldmVudF1baV0uY2FsbChzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgcmVhZHlTdGF0ZSBhbmQgY2FsbHMgb25yZWFkeXN0YXRlY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0gaW50IHN0YXRlIE5ldyBzdGF0ZVxuICAgKi9cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT0gc2VsZi5MT0FESU5HIHx8IHNlbGYucmVhZHlTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IHN0YXRlO1xuXG4gICAgICBpZiAoc2V0dGluZ3MuYXN5bmMgfHwgc2VsZi5yZWFkeVN0YXRlIDwgc2VsZi5PUEVORUQgfHwgc2VsZi5yZWFkeVN0YXRlID09PSBzZWxmLkRPTkUpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5ET05FICYmICFlcnJvckZsYWcpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZFwiKTtcbiAgICAgICAgLy8gQFRPRE8gZmlndXJlIG91dCBJbnNwZWN0b3JJbnN0cnVtZW50YXRpb246OmRpZExvYWRYSFIoY29va2llKVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2FkZW5kXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4oZnVuY3Rpb24obmFjbCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQb3J0ZWQgaW4gMjAxNCBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuLy9cbi8vIEltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBUd2VldE5hQ2wgdmVyc2lvbiAyMDE0MDQyNy5cbi8vIFNlZSBmb3IgZGV0YWlsczogaHR0cDovL3R3ZWV0bmFjbC5jci55cC50by9cblxudmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBpZiAoaW5pdCkgZm9yIChpID0gMDsgaSA8IGluaXQubGVuZ3RoOyBpKyspIHJbaV0gPSBpbml0W2ldO1xuICByZXR1cm4gcjtcbn07XG5cbi8vICBQbHVnZ2FibGUsIGluaXRpYWxpemVkIGluIGhpZ2gtbGV2ZWwgQVBJIGJlbG93LlxudmFyIHJhbmRvbWJ5dGVzID0gZnVuY3Rpb24oLyogeCwgbiAqLykgeyB0aHJvdyBuZXcgRXJyb3IoJ25vIFBSTkcnKTsgfTtcblxudmFyIF8wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xudmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyBfOVswXSA9IDk7XG5cbnZhciBnZjAgPSBnZigpLFxuICAgIGdmMSA9IGdmKFsxXSksXG4gICAgXzEyMTY2NSA9IGdmKFsweGRiNDEsIDFdKSxcbiAgICBEID0gZ2YoWzB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLCAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pLFxuICAgIEQyID0gZ2YoWzB4ZjE1OSwgMHgyNmIyLCAweDliOTQsIDB4ZWJkNiwgMHhiMTU2LCAweDgyODMsIDB4MTQ5YSwgMHgwMGUwLCAweGQxMzAsIDB4ZWVmMywgMHg4MGYyLCAweDE5OGUsIDB4ZmNlNywgMHg1NmRmLCAweGQ5ZGMsIDB4MjQwNl0pLFxuICAgIFggPSBnZihbMHhkNTFhLCAweDhmMjUsIDB4MmQ2MCwgMHhjOTU2LCAweGE3YjIsIDB4OTUyNSwgMHhjNzYwLCAweDY5MmMsIDB4ZGM1YywgMHhmZGQ2LCAweGUyMzEsIDB4YzBhNCwgMHg1M2ZlLCAweGNkNmUsIDB4MzZkMywgMHgyMTY5XSksXG4gICAgWSA9IGdmKFsweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKSxcbiAgICBJID0gZ2YoWzB4YTBiMCwgMHg0YTBlLCAweDFiMjcsIDB4YzRlZSwgMHhlNDc4LCAweGFkMmYsIDB4MTgwNiwgMHgyZjQzLCAweGQ3YTcsIDB4M2RmYiwgMHgwMDk5LCAweDJiNGQsIDB4ZGYwYiwgMHg0ZmMxLCAweDI0ODAsIDB4MmI4M10pO1xuXG5mdW5jdGlvbiB0czY0KHgsIGksIGgsIGwpIHtcbiAgeFtpXSAgID0gKGggPj4gMjQpICYgMHhmZjtcbiAgeFtpKzFdID0gKGggPj4gMTYpICYgMHhmZjtcbiAgeFtpKzJdID0gKGggPj4gIDgpICYgMHhmZjtcbiAgeFtpKzNdID0gaCAmIDB4ZmY7XG4gIHhbaSs0XSA9IChsID4+IDI0KSAgJiAweGZmO1xuICB4W2krNV0gPSAobCA+PiAxNikgICYgMHhmZjtcbiAgeFtpKzZdID0gKGwgPj4gIDgpICAmIDB4ZmY7XG4gIHhbaSs3XSA9IGwgJiAweGZmO1xufVxuXG5mdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgdmFyIGksZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGQgfD0geFt4aStpXV55W3lpK2ldO1xuICByZXR1cm4gKDEgJiAoKGQgLSAxKSA+Pj4gOCkpIC0gMTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8xNih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwxNik7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMzIpO1xufVxuXG5mdW5jdGlvbiBjb3JlX3NhbHNhMjAobywgcCwgaywgYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZik8PDggfCAoY1sgMl0gJiAweGZmKTw8MTYgfCAoY1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKTw8OCB8IChrWyAyXSAmIDB4ZmYpPDwxNiB8IChrWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpPDw4IHwgKGtbIDZdICYgMHhmZik8PDE2IHwgKGtbIDddICYgMHhmZik8PDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZik8PDggfCAoa1sxMF0gJiAweGZmKTw8MTYgfCAoa1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKTw8OCB8IChrWzE0XSAmIDB4ZmYpPDwxNiB8IChrWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpPDw4IHwgKGNbIDZdICYgMHhmZik8PDE2IHwgKGNbIDddICYgMHhmZik8PDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZik8PDggfCAocFsgMl0gJiAweGZmKTw8MTYgfCAocFsgM10gJiAweGZmKTw8MjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKTw8OCB8IChwWyA2XSAmIDB4ZmYpPDwxNiB8IChwWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpPDw4IHwgKHBbMTBdICYgMHhmZik8PDE2IHwgKHBbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZik8PDggfCAocFsxNF0gJiAweGZmKTw8MTYgfCAocFsxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKTw8OCB8IChjWzEwXSAmIDB4ZmYpPDwxNiB8IChjWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpPDw4IHwgKGtbMThdICYgMHhmZik8PDE2IHwgKGtbMTldICYgMHhmZik8PDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZik8PDggfCAoa1syMl0gJiAweGZmKTw8MTYgfCAoa1syM10gJiAweGZmKTw8MjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKTw8OCB8IChrWzI2XSAmIDB4ZmYpPDwxNiB8IChrWzI3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpPDw4IHwgKGtbMzBdICYgMHhmZik8PDE2IHwgKGtbMzFdICYgMHhmZik8PDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZik8PDggfCAoY1sxNF0gJiAweGZmKTw8MTYgfCAoY1sxNV0gJiAweGZmKTw8MjQ7XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwO1xuICAgIHg0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NCArIHgwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4NCB8IDA7XG4gICAgeDEyIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMiArIHg4IHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDEgfCAwO1xuICAgIHg5IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4OSArIHg1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHg5IHwgMDtcbiAgICB4MSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MSArIHgxMyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4NiB8IDA7XG4gICAgeDE0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTQgKyB4MTAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxNCB8IDA7XG4gICAgeDYgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDYgKyB4MiB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMDtcbiAgICB4MyBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDMgKyB4MTUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHgzIHwgMDtcbiAgICB4MTEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDExICsgeDcgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgwICsgeDMgfCAwO1xuICAgIHgxIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MSArIHgwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MSB8IDA7XG4gICAgeDMgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDMgKyB4MiB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHg0IHwgMDtcbiAgICB4NiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDYgKyB4NSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDYgfCAwO1xuICAgIHg0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg0ICsgeDcgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDkgfCAwO1xuICAgIHgxMSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDExICsgeDEwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4MTEgfCAwO1xuICAgIHg5IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg5ICsgeDggfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxNCB8IDA7XG4gICAgeDEyIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTIgKyB4MTUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDEyIHwgMDtcbiAgICB4MTQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDE0ICsgeDEzIHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcbiAgfVxuICAgeDAgPSAgeDAgKyAgajAgfCAwO1xuICAgeDEgPSAgeDEgKyAgajEgfCAwO1xuICAgeDIgPSAgeDIgKyAgajIgfCAwO1xuICAgeDMgPSAgeDMgKyAgajMgfCAwO1xuICAgeDQgPSAgeDQgKyAgajQgfCAwO1xuICAgeDUgPSAgeDUgKyAgajUgfCAwO1xuICAgeDYgPSAgeDYgKyAgajYgfCAwO1xuICAgeDcgPSAgeDcgKyAgajcgfCAwO1xuICAgeDggPSAgeDggKyAgajggfCAwO1xuICAgeDkgPSAgeDkgKyAgajkgfCAwO1xuICB4MTAgPSB4MTAgKyBqMTAgfCAwO1xuICB4MTEgPSB4MTEgKyBqMTEgfCAwO1xuICB4MTIgPSB4MTIgKyBqMTIgfCAwO1xuICB4MTMgPSB4MTMgKyBqMTMgfCAwO1xuICB4MTQgPSB4MTQgKyBqMTQgfCAwO1xuICB4MTUgPSB4MTUgKyBqMTUgfCAwO1xuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZjtcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmO1xuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA0XSA9IHgxID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDVdID0geDEgPj4+ICA4ICYgMHhmZjtcbiAgb1sgNl0gPSB4MSA+Pj4gMTYgJiAweGZmO1xuICBvWyA3XSA9IHgxID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgOF0gPSB4MiA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgyID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDIgPj4+IDE2ICYgMHhmZjtcbiAgb1sxMV0gPSB4MiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDMgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MyA+Pj4gIDggJiAweGZmO1xuICBvWzE0XSA9IHgzID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDMgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDQgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NCA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDYgPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4NiA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg2ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDYgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg3ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDcgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4NyA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg3ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szMl0gPSB4OCA+Pj4gIDAgJiAweGZmO1xuICBvWzMzXSA9IHg4ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzRdID0geDggPj4+IDE2ICYgMHhmZjtcbiAgb1szNV0gPSB4OCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMzZdID0geDkgPj4+ICAwICYgMHhmZjtcbiAgb1szN10gPSB4OSA+Pj4gIDggJiAweGZmO1xuICBvWzM4XSA9IHg5ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzldID0geDkgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQwXSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWzQxXSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzQyXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzQzXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDRdID0geDExID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDVdID0geDExID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDZdID0geDExID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDddID0geDExID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0OF0gPSB4MTIgPj4+ICAwICYgMHhmZjtcbiAgb1s0OV0gPSB4MTIgPj4+ICA4ICYgMHhmZjtcbiAgb1s1MF0gPSB4MTIgPj4+IDE2ICYgMHhmZjtcbiAgb1s1MV0gPSB4MTIgPj4+IDI0ICYgMHhmZjtcblxuICBvWzUyXSA9IHgxMyA+Pj4gIDAgJiAweGZmO1xuICBvWzUzXSA9IHgxMyA+Pj4gIDggJiAweGZmO1xuICBvWzU0XSA9IHgxMyA+Pj4gMTYgJiAweGZmO1xuICBvWzU1XSA9IHgxMyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTZdID0geDE0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTddID0geDE0ID4+PiAgOCAmIDB4ZmY7XG4gIG9bNThdID0geDE0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTldID0geDE0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s2MF0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1s2MV0gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1s2Ml0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1s2M10gPSB4MTUgPj4+IDI0ICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gY29yZV9oc2Fsc2EyMChvLHAsayxjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDUgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4NSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHg1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDUgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzEwXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDE1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTNdID0geDE1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDE1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDE1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxNl0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzE3XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMThdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1sxOV0gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjBdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syMV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzIyXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjNdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI0XSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjVdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1syNl0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzI3XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syOF0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzI5XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzBdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szMV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX2hzYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpO1xufVxuXG52YXIgc2lnbWEgPSBuZXcgVWludDhBcnJheShbMTAxLCAxMjAsIDExMiwgOTcsIDExMCwgMTAwLCAzMiwgNTEsIDUwLCA0NSwgOTgsIDEyMSwgMTE2LCAxMDEsIDMyLCAxMDddKTtcbiAgICAgICAgICAgIC8vIFwiZXhwYW5kIDMyLWJ5dGUga1wiXG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYyxjcG9zLG0sbXBvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IG1bbXBvcytpXSBeIHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICAgIG1wb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiOyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW0oYyxjcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxkLHNuLHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3hvcihjLGNwb3MsbSxtcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGQsc24scyk7XG59XG5cbi8qXG4qIFBvcnQgb2YgQW5kcmV3IE1vb24ncyBQb2x5MTMwNS1kb25uYS0xNi4gUHVibGljIGRvbWFpbi5cbiogaHR0cHM6Ly9naXRodWIuY29tL2Zsb29keWJlcnJ5L3BvbHkxMzA1LWRvbm5hXG4qL1xuXG52YXIgcG9seTEzMDUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgdGhpcy5maW4gPSAwO1xuXG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDc7XG5cbiAgdDAgPSBrZXlbIDBdICYgMHhmZiB8IChrZXlbIDFdICYgMHhmZikgPDwgODsgdGhpcy5yWzBdID0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gIHQxID0ga2V5WyAyXSAmIDB4ZmYgfCAoa2V5WyAzXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICB0MiA9IGtleVsgNF0gJiAweGZmIHwgKGtleVsgNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWYwMztcbiAgdDMgPSBrZXlbIDZdICYgMHhmZiB8IChrZXlbIDddICYgMHhmZikgPDwgODsgdGhpcy5yWzNdID0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gIHQ0ID0ga2V5WyA4XSAmIDB4ZmYgfCAoa2V5WyA5XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls0XSA9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuICB0aGlzLnJbNV0gPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZlO1xuICB0NSA9IGtleVsxMF0gJiAweGZmIHwgKGtleVsxMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgdDYgPSBrZXlbMTJdICYgMHhmZiB8IChrZXlbMTNdICYgMHhmZikgPDwgODsgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmODE7XG4gIHQ3ID0ga2V5WzE0XSAmIDB4ZmYgfCAoa2V5WzE1XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls4XSA9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICB0aGlzLnJbOV0gPSAoKHQ3ID4+PiAgNSkpICYgMHgwMDdmO1xuXG4gIHRoaXMucGFkWzBdID0ga2V5WzE2XSAmIDB4ZmYgfCAoa2V5WzE3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzFdID0ga2V5WzE4XSAmIDB4ZmYgfCAoa2V5WzE5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzJdID0ga2V5WzIwXSAmIDB4ZmYgfCAoa2V5WzIxXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzNdID0ga2V5WzIyXSAmIDB4ZmYgfCAoa2V5WzIzXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzRdID0ga2V5WzI0XSAmIDB4ZmYgfCAoa2V5WzI1XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzVdID0ga2V5WzI2XSAmIDB4ZmYgfCAoa2V5WzI3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzZdID0ga2V5WzI4XSAmIDB4ZmYgfCAoa2V5WzI5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzddID0ga2V5WzMwXSAmIDB4ZmYgfCAoa2V5WzMxXSAmIDB4ZmYpIDw8IDg7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGhpYml0ID0gdGhpcy5maW4gPyAwIDogKDEgPDwgMTEpO1xuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3LCBjO1xuICB2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDk7XG5cbiAgdmFyIGgwID0gdGhpcy5oWzBdLFxuICAgICAgaDEgPSB0aGlzLmhbMV0sXG4gICAgICBoMiA9IHRoaXMuaFsyXSxcbiAgICAgIGgzID0gdGhpcy5oWzNdLFxuICAgICAgaDQgPSB0aGlzLmhbNF0sXG4gICAgICBoNSA9IHRoaXMuaFs1XSxcbiAgICAgIGg2ID0gdGhpcy5oWzZdLFxuICAgICAgaDcgPSB0aGlzLmhbN10sXG4gICAgICBoOCA9IHRoaXMuaFs4XSxcbiAgICAgIGg5ID0gdGhpcy5oWzldO1xuXG4gIHZhciByMCA9IHRoaXMuclswXSxcbiAgICAgIHIxID0gdGhpcy5yWzFdLFxuICAgICAgcjIgPSB0aGlzLnJbMl0sXG4gICAgICByMyA9IHRoaXMuclszXSxcbiAgICAgIHI0ID0gdGhpcy5yWzRdLFxuICAgICAgcjUgPSB0aGlzLnJbNV0sXG4gICAgICByNiA9IHRoaXMucls2XSxcbiAgICAgIHI3ID0gdGhpcy5yWzddLFxuICAgICAgcjggPSB0aGlzLnJbOF0sXG4gICAgICByOSA9IHRoaXMucls5XTtcblxuICB3aGlsZSAoYnl0ZXMgPj0gMTYpIHtcbiAgICB0MCA9IG1bbXBvcysgMF0gJiAweGZmIHwgKG1bbXBvcysgMV0gJiAweGZmKSA8PCA4OyBoMCArPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgICB0MSA9IG1bbXBvcysgMl0gJiAweGZmIHwgKG1bbXBvcysgM10gJiAweGZmKSA8PCA4OyBoMSArPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgICB0MiA9IG1bbXBvcysgNF0gJiAweGZmIHwgKG1bbXBvcysgNV0gJiAweGZmKSA8PCA4OyBoMiArPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWZmZjtcbiAgICB0MyA9IG1bbXBvcysgNl0gJiAweGZmIHwgKG1bbXBvcysgN10gJiAweGZmKSA8PCA4OyBoMyArPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgICB0NCA9IG1bbXBvcysgOF0gJiAweGZmIHwgKG1bbXBvcysgOV0gJiAweGZmKSA8PCA4OyBoNCArPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZjtcbiAgICBoNSArPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZmO1xuICAgIHQ1ID0gbVttcG9zKzEwXSAmIDB4ZmYgfCAobVttcG9zKzExXSAmIDB4ZmYpIDw8IDg7IGg2ICs9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICAgIHQ2ID0gbVttcG9zKzEyXSAmIDB4ZmYgfCAobVttcG9zKzEzXSAmIDB4ZmYpIDw8IDg7IGg3ICs9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZmZmO1xuICAgIHQ3ID0gbVttcG9zKzE0XSAmIDB4ZmYgfCAobVttcG9zKzE1XSAmIDB4ZmYpIDw8IDg7IGg4ICs9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICAgIGg5ICs9ICgodDcgPj4+IDUpKSB8IGhpYml0O1xuXG4gICAgYyA9IDA7XG5cbiAgICBkMCA9IGM7XG4gICAgZDAgKz0gaDAgKiByMDtcbiAgICBkMCArPSBoMSAqICg1ICogcjkpO1xuICAgIGQwICs9IGgyICogKDUgKiByOCk7XG4gICAgZDAgKz0gaDMgKiAoNSAqIHI3KTtcbiAgICBkMCArPSBoNCAqICg1ICogcjYpO1xuICAgIGMgPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuICAgIGQwICs9IGg1ICogKDUgKiByNSk7XG4gICAgZDAgKz0gaDYgKiAoNSAqIHI0KTtcbiAgICBkMCArPSBoNyAqICg1ICogcjMpO1xuICAgIGQwICs9IGg4ICogKDUgKiByMik7XG4gICAgZDAgKz0gaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG5cbiAgICBkMSA9IGM7XG4gICAgZDEgKz0gaDAgKiByMTtcbiAgICBkMSArPSBoMSAqIHIwO1xuICAgIGQxICs9IGgyICogKDUgKiByOSk7XG4gICAgZDEgKz0gaDMgKiAoNSAqIHI4KTtcbiAgICBkMSArPSBoNCAqICg1ICogcjcpO1xuICAgIGMgPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuICAgIGQxICs9IGg1ICogKDUgKiByNik7XG4gICAgZDEgKz0gaDYgKiAoNSAqIHI1KTtcbiAgICBkMSArPSBoNyAqICg1ICogcjQpO1xuICAgIGQxICs9IGg4ICogKDUgKiByMyk7XG4gICAgZDEgKz0gaDkgKiAoNSAqIHIyKTtcbiAgICBjICs9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG5cbiAgICBkMiA9IGM7XG4gICAgZDIgKz0gaDAgKiByMjtcbiAgICBkMiArPSBoMSAqIHIxO1xuICAgIGQyICs9IGgyICogcjA7XG4gICAgZDIgKz0gaDMgKiAoNSAqIHI5KTtcbiAgICBkMiArPSBoNCAqICg1ICogcjgpO1xuICAgIGMgPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNyk7XG4gICAgZDIgKz0gaDYgKiAoNSAqIHI2KTtcbiAgICBkMiArPSBoNyAqICg1ICogcjUpO1xuICAgIGQyICs9IGg4ICogKDUgKiByNCk7XG4gICAgZDIgKz0gaDkgKiAoNSAqIHIzKTtcbiAgICBjICs9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG5cbiAgICBkMyA9IGM7XG4gICAgZDMgKz0gaDAgKiByMztcbiAgICBkMyArPSBoMSAqIHIyO1xuICAgIGQzICs9IGgyICogcjE7XG4gICAgZDMgKz0gaDMgKiByMDtcbiAgICBkMyArPSBoNCAqICg1ICogcjkpO1xuICAgIGMgPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuICAgIGQzICs9IGg1ICogKDUgKiByOCk7XG4gICAgZDMgKz0gaDYgKiAoNSAqIHI3KTtcbiAgICBkMyArPSBoNyAqICg1ICogcjYpO1xuICAgIGQzICs9IGg4ICogKDUgKiByNSk7XG4gICAgZDMgKz0gaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG5cbiAgICBkNCA9IGM7XG4gICAgZDQgKz0gaDAgKiByNDtcbiAgICBkNCArPSBoMSAqIHIzO1xuICAgIGQ0ICs9IGgyICogcjI7XG4gICAgZDQgKz0gaDMgKiByMTtcbiAgICBkNCArPSBoNCAqIHIwO1xuICAgIGMgPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuICAgIGQ0ICs9IGg1ICogKDUgKiByOSk7XG4gICAgZDQgKz0gaDYgKiAoNSAqIHI4KTtcbiAgICBkNCArPSBoNyAqICg1ICogcjcpO1xuICAgIGQ0ICs9IGg4ICogKDUgKiByNik7XG4gICAgZDQgKz0gaDkgKiAoNSAqIHI1KTtcbiAgICBjICs9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG5cbiAgICBkNSA9IGM7XG4gICAgZDUgKz0gaDAgKiByNTtcbiAgICBkNSArPSBoMSAqIHI0O1xuICAgIGQ1ICs9IGgyICogcjM7XG4gICAgZDUgKz0gaDMgKiByMjtcbiAgICBkNSArPSBoNCAqIHIxO1xuICAgIGMgPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjA7XG4gICAgZDUgKz0gaDYgKiAoNSAqIHI5KTtcbiAgICBkNSArPSBoNyAqICg1ICogcjgpO1xuICAgIGQ1ICs9IGg4ICogKDUgKiByNyk7XG4gICAgZDUgKz0gaDkgKiAoNSAqIHI2KTtcbiAgICBjICs9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG5cbiAgICBkNiA9IGM7XG4gICAgZDYgKz0gaDAgKiByNjtcbiAgICBkNiArPSBoMSAqIHI1O1xuICAgIGQ2ICs9IGgyICogcjQ7XG4gICAgZDYgKz0gaDMgKiByMztcbiAgICBkNiArPSBoNCAqIHIyO1xuICAgIGMgPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuICAgIGQ2ICs9IGg1ICogcjE7XG4gICAgZDYgKz0gaDYgKiByMDtcbiAgICBkNiArPSBoNyAqICg1ICogcjkpO1xuICAgIGQ2ICs9IGg4ICogKDUgKiByOCk7XG4gICAgZDYgKz0gaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG5cbiAgICBkNyA9IGM7XG4gICAgZDcgKz0gaDAgKiByNztcbiAgICBkNyArPSBoMSAqIHI2O1xuICAgIGQ3ICs9IGgyICogcjU7XG4gICAgZDcgKz0gaDMgKiByNDtcbiAgICBkNyArPSBoNCAqIHIzO1xuICAgIGMgPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuICAgIGQ3ICs9IGg1ICogcjI7XG4gICAgZDcgKz0gaDYgKiByMTtcbiAgICBkNyArPSBoNyAqIHIwO1xuICAgIGQ3ICs9IGg4ICogKDUgKiByOSk7XG4gICAgZDcgKz0gaDkgKiAoNSAqIHI4KTtcbiAgICBjICs9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG5cbiAgICBkOCA9IGM7XG4gICAgZDggKz0gaDAgKiByODtcbiAgICBkOCArPSBoMSAqIHI3O1xuICAgIGQ4ICs9IGgyICogcjY7XG4gICAgZDggKz0gaDMgKiByNTtcbiAgICBkOCArPSBoNCAqIHI0O1xuICAgIGMgPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjM7XG4gICAgZDggKz0gaDYgKiByMjtcbiAgICBkOCArPSBoNyAqIHIxO1xuICAgIGQ4ICs9IGg4ICogcjA7XG4gICAgZDggKz0gaDkgKiAoNSAqIHI5KTtcbiAgICBjICs9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG5cbiAgICBkOSA9IGM7XG4gICAgZDkgKz0gaDAgKiByOTtcbiAgICBkOSArPSBoMSAqIHI4O1xuICAgIGQ5ICs9IGgyICogcjc7XG4gICAgZDkgKz0gaDMgKiByNjtcbiAgICBkOSArPSBoNCAqIHI1O1xuICAgIGMgPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuICAgIGQ5ICs9IGg1ICogcjQ7XG4gICAgZDkgKz0gaDYgKiByMztcbiAgICBkOSArPSBoNyAqIHIyO1xuICAgIGQ5ICs9IGg4ICogcjE7XG4gICAgZDkgKz0gaDkgKiByMDtcbiAgICBjICs9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKCgoYyA8PCAyKSArIGMpKSB8IDA7XG4gICAgYyA9IChjICsgZDApIHwgMDtcbiAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgYyA9IChjID4+PiAxMyk7XG4gICAgZDEgKz0gYztcblxuICAgIGgwID0gZDA7XG4gICAgaDEgPSBkMTtcbiAgICBoMiA9IGQyO1xuICAgIGgzID0gZDM7XG4gICAgaDQgPSBkNDtcbiAgICBoNSA9IGQ1O1xuICAgIGg2ID0gZDY7XG4gICAgaDcgPSBkNztcbiAgICBoOCA9IGQ4O1xuICAgIGg5ID0gZDk7XG5cbiAgICBtcG9zICs9IDE2O1xuICAgIGJ5dGVzIC09IDE2O1xuICB9XG4gIHRoaXMuaFswXSA9IGgwO1xuICB0aGlzLmhbMV0gPSBoMTtcbiAgdGhpcy5oWzJdID0gaDI7XG4gIHRoaXMuaFszXSA9IGgzO1xuICB0aGlzLmhbNF0gPSBoNDtcbiAgdGhpcy5oWzVdID0gaDU7XG4gIHRoaXMuaFs2XSA9IGg2O1xuICB0aGlzLmhbN10gPSBoNztcbiAgdGhpcy5oWzhdID0gaDg7XG4gIHRoaXMuaFs5XSA9IGg5O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKG1hYywgbWFjcG9zKSB7XG4gIHZhciBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdmFyIGMsIG1hc2ssIGYsIGk7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICBpID0gdGhpcy5sZWZ0b3ZlcjtcbiAgICB0aGlzLmJ1ZmZlcltpKytdID0gMTtcbiAgICBmb3IgKDsgaSA8IDE2OyBpKyspIHRoaXMuYnVmZmVyW2ldID0gMDtcbiAgICB0aGlzLmZpbiA9IDE7XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgfVxuXG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgIHRoaXMuaFtpXSArPSBjO1xuICAgIGMgPSB0aGlzLmhbaV0gPj4+IDEzO1xuICAgIHRoaXMuaFtpXSAmPSAweDFmZmY7XG4gIH1cbiAgdGhpcy5oWzBdICs9IChjICogNSk7XG4gIGMgPSB0aGlzLmhbMF0gPj4+IDEzO1xuICB0aGlzLmhbMF0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMV0gKz0gYztcbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsyXSArPSBjO1xuXG4gIGdbMF0gPSB0aGlzLmhbMF0gKyA1O1xuICBjID0gZ1swXSA+Pj4gMTM7XG4gIGdbMF0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgIGdbaV0gPSB0aGlzLmhbaV0gKyBjO1xuICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICBnW2ldICY9IDB4MWZmZjtcbiAgfVxuICBnWzldIC09ICgxIDw8IDEzKTtcblxuICBtYXNrID0gKGMgXiAxKSAtIDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSBnW2ldICY9IG1hc2s7XG4gIG1hc2sgPSB+bWFzaztcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHRoaXMuaFtpXSA9ICh0aGlzLmhbaV0gJiBtYXNrKSB8IGdbaV07XG5cbiAgdGhpcy5oWzBdID0gKCh0aGlzLmhbMF0gICAgICAgKSB8ICh0aGlzLmhbMV0gPDwgMTMpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMV0gPSAoKHRoaXMuaFsxXSA+Pj4gIDMpIHwgKHRoaXMuaFsyXSA8PCAxMCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsyXSA9ICgodGhpcy5oWzJdID4+PiAgNikgfCAodGhpcy5oWzNdIDw8ICA3KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzNdID0gKCh0aGlzLmhbM10gPj4+ICA5KSB8ICh0aGlzLmhbNF0gPDwgIDQpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNF0gPSAoKHRoaXMuaFs0XSA+Pj4gMTIpIHwgKHRoaXMuaFs1XSA8PCAgMSkgfCAodGhpcy5oWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gIHRoaXMuaFs1XSA9ICgodGhpcy5oWzZdID4+PiAgMikgfCAodGhpcy5oWzddIDw8IDExKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzZdID0gKCh0aGlzLmhbN10gPj4+ICA1KSB8ICh0aGlzLmhbOF0gPDwgIDgpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbN10gPSAoKHRoaXMuaFs4XSA+Pj4gIDgpIHwgKHRoaXMuaFs5XSA8PCAgNSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG5cbiAgZiA9IHRoaXMuaFswXSArIHRoaXMucGFkWzBdO1xuICB0aGlzLmhbMF0gPSBmICYgMHhmZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgZiA9ICgoKHRoaXMuaFtpXSArIHRoaXMucGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgIHRoaXMuaFtpXSA9IGYgJiAweGZmZmY7XG4gIH1cblxuICBtYWNbbWFjcG9zKyAwXSA9ICh0aGlzLmhbMF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMV0gPSAodGhpcy5oWzBdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDJdID0gKHRoaXMuaFsxXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAzXSA9ICh0aGlzLmhbMV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNF0gPSAodGhpcy5oWzJdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDVdID0gKHRoaXMuaFsyXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA2XSA9ICh0aGlzLmhbM10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgN10gPSAodGhpcy5oWzNdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDhdID0gKHRoaXMuaFs0XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA5XSA9ICh0aGlzLmhbNF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMF0gPSAodGhpcy5oWzVdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTFdID0gKHRoaXMuaFs1XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEyXSA9ICh0aGlzLmhbNl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxM10gPSAodGhpcy5oWzZdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTRdID0gKHRoaXMuaFs3XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE1XSA9ICh0aGlzLmhbN10gPj4+IDgpICYgMHhmZjtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaSwgd2FudDtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIHdhbnQgPSAoMTYgLSB0aGlzLmxlZnRvdmVyKTtcbiAgICBpZiAod2FudCA+IGJ5dGVzKVxuICAgICAgd2FudCA9IGJ5dGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YW50OyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgdGhpcy5sZWZ0b3ZlciArPSB3YW50O1xuICAgIGlmICh0aGlzLmxlZnRvdmVyIDwgMTYpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgfVxuXG4gIGlmIChieXRlcyA+PSAxNikge1xuICAgIHdhbnQgPSBieXRlcyAtIChieXRlcyAlIDE2KTtcbiAgICB0aGlzLmJsb2NrcyhtLCBtcG9zLCB3YW50KTtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgfVxuXG4gIGlmIChieXRlcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIHRoaXMubGVmdG92ZXIgKz0gYnl0ZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aChvdXQsIG91dHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgcyA9IG5ldyBwb2x5MTMwNShrKTtcbiAgcy51cGRhdGUobSwgbXBvcywgbik7XG4gIHMuZmluaXNoKG91dCwgb3V0cG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoaCwgaHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKHgsMCxtLG1wb3MsbixrKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCxocG9zLHgsMCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYyxtLGQsbixrKSB7XG4gIHZhciBpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKGMsMCxtLDAsZCxuLGspO1xuICBjcnlwdG9fb25ldGltZWF1dGgoYywgMTYsIGMsIDMyLCBkIC0gMzIsIGMpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgY1tpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW4obSxjLGQsbixrKSB7XG4gIHZhciBpO1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtKHgsMCwzMixuLGspO1xuICBpZiAoY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShjLCAxNixjLCAzMixkIC0gMzIseCkgIT09IDApIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IobSwwLGMsMCxkLG4sayk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHNldDI1NTE5KHIsIGEpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSByW2ldID0gYVtpXXwwO1xufVxuXG5mdW5jdGlvbiBjYXIyNTUxOShvKSB7XG4gIHZhciBpLCB2LCBjID0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2ID0gb1tpXSArIGMgKyA2NTUzNTtcbiAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgIG9baV0gPSB2IC0gYyAqIDY1NTM2O1xuICB9XG4gIG9bMF0gKz0gYy0xICsgMzcgKiAoYy0xKTtcbn1cblxuZnVuY3Rpb24gc2VsMjU1MTkocCwgcSwgYikge1xuICB2YXIgdCwgYyA9IH4oYi0xKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgIHBbaV0gXj0gdDtcbiAgICBxW2ldIF49IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGI7XG4gIHZhciBtID0gZ2YoKSwgdCA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB0W2ldID0gbltpXTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgZm9yIChqID0gMDsgaiA8IDI7IGorKykge1xuICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgIGZvciAoaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtICgobVtpLTFdPj4xNikgJiAxKTtcbiAgICAgIG1baS0xXSAmPSAweGZmZmY7XG4gICAgfVxuICAgIG1bMTVdID0gdFsxNV0gLSAweDdmZmYgLSAoKG1bMTRdPj4xNikgJiAxKTtcbiAgICBiID0gKG1bMTVdPj4xNikgJiAxO1xuICAgIG1bMTRdICY9IDB4ZmZmZjtcbiAgICBzZWwyNTUxOSh0LCBtLCAxLWIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgb1syKmldID0gdFtpXSAmIDB4ZmY7XG4gICAgb1syKmkrMV0gPSB0W2ldPj44O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgzMiksIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShjLCBhKTtcbiAgcGFjazI1NTE5KGQsIGIpO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbn1cblxuZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGQsIGEpO1xuICByZXR1cm4gZFswXSAmIDE7XG59XG5cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gblsyKmldICsgKG5bMippKzFdIDw8IDgpO1xuICBvWzE1XSAmPSAweDdmZmY7XG59XG5cbmZ1bmN0aW9uIEEobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldICsgYltpXTtcbn1cblxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gLSBiW2ldO1xufVxuXG5mdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgdmFyIHYsIGMsXG4gICAgIHQwID0gMCwgIHQxID0gMCwgIHQyID0gMCwgIHQzID0gMCwgIHQ0ID0gMCwgIHQ1ID0gMCwgIHQ2ID0gMCwgIHQ3ID0gMCxcbiAgICAgdDggPSAwLCAgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLFxuICAgIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsXG4gICAgdDI0ID0gMCwgdDI1ID0gMCwgdDI2ID0gMCwgdDI3ID0gMCwgdDI4ID0gMCwgdDI5ID0gMCwgdDMwID0gMCxcbiAgICBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM10sXG4gICAgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddLFxuICAgIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV0sXG4gICAgYjEyID0gYlsxMl0sXG4gICAgYjEzID0gYlsxM10sXG4gICAgYjE0ID0gYlsxNF0sXG4gICAgYjE1ID0gYlsxNV07XG5cbiAgdiA9IGFbMF07XG4gIHQwICs9IHYgKiBiMDtcbiAgdDEgKz0gdiAqIGIxO1xuICB0MiArPSB2ICogYjI7XG4gIHQzICs9IHYgKiBiMztcbiAgdDQgKz0gdiAqIGI0O1xuICB0NSArPSB2ICogYjU7XG4gIHQ2ICs9IHYgKiBiNjtcbiAgdDcgKz0gdiAqIGI3O1xuICB0OCArPSB2ICogYjg7XG4gIHQ5ICs9IHYgKiBiOTtcbiAgdDEwICs9IHYgKiBiMTA7XG4gIHQxMSArPSB2ICogYjExO1xuICB0MTIgKz0gdiAqIGIxMjtcbiAgdDEzICs9IHYgKiBiMTM7XG4gIHQxNCArPSB2ICogYjE0O1xuICB0MTUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMV07XG4gIHQxICs9IHYgKiBiMDtcbiAgdDIgKz0gdiAqIGIxO1xuICB0MyArPSB2ICogYjI7XG4gIHQ0ICs9IHYgKiBiMztcbiAgdDUgKz0gdiAqIGI0O1xuICB0NiArPSB2ICogYjU7XG4gIHQ3ICs9IHYgKiBiNjtcbiAgdDggKz0gdiAqIGI3O1xuICB0OSArPSB2ICogYjg7XG4gIHQxMCArPSB2ICogYjk7XG4gIHQxMSArPSB2ICogYjEwO1xuICB0MTIgKz0gdiAqIGIxMTtcbiAgdDEzICs9IHYgKiBiMTI7XG4gIHQxNCArPSB2ICogYjEzO1xuICB0MTUgKz0gdiAqIGIxNDtcbiAgdDE2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzJdO1xuICB0MiArPSB2ICogYjA7XG4gIHQzICs9IHYgKiBiMTtcbiAgdDQgKz0gdiAqIGIyO1xuICB0NSArPSB2ICogYjM7XG4gIHQ2ICs9IHYgKiBiNDtcbiAgdDcgKz0gdiAqIGI1O1xuICB0OCArPSB2ICogYjY7XG4gIHQ5ICs9IHYgKiBiNztcbiAgdDEwICs9IHYgKiBiODtcbiAgdDExICs9IHYgKiBiOTtcbiAgdDEyICs9IHYgKiBiMTA7XG4gIHQxMyArPSB2ICogYjExO1xuICB0MTQgKz0gdiAqIGIxMjtcbiAgdDE1ICs9IHYgKiBiMTM7XG4gIHQxNiArPSB2ICogYjE0O1xuICB0MTcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbM107XG4gIHQzICs9IHYgKiBiMDtcbiAgdDQgKz0gdiAqIGIxO1xuICB0NSArPSB2ICogYjI7XG4gIHQ2ICs9IHYgKiBiMztcbiAgdDcgKz0gdiAqIGI0O1xuICB0OCArPSB2ICogYjU7XG4gIHQ5ICs9IHYgKiBiNjtcbiAgdDEwICs9IHYgKiBiNztcbiAgdDExICs9IHYgKiBiODtcbiAgdDEyICs9IHYgKiBiOTtcbiAgdDEzICs9IHYgKiBiMTA7XG4gIHQxNCArPSB2ICogYjExO1xuICB0MTUgKz0gdiAqIGIxMjtcbiAgdDE2ICs9IHYgKiBiMTM7XG4gIHQxNyArPSB2ICogYjE0O1xuICB0MTggKz0gdiAqIGIxNTtcbiAgdiA9IGFbNF07XG4gIHQ0ICs9IHYgKiBiMDtcbiAgdDUgKz0gdiAqIGIxO1xuICB0NiArPSB2ICogYjI7XG4gIHQ3ICs9IHYgKiBiMztcbiAgdDggKz0gdiAqIGI0O1xuICB0OSArPSB2ICogYjU7XG4gIHQxMCArPSB2ICogYjY7XG4gIHQxMSArPSB2ICogYjc7XG4gIHQxMiArPSB2ICogYjg7XG4gIHQxMyArPSB2ICogYjk7XG4gIHQxNCArPSB2ICogYjEwO1xuICB0MTUgKz0gdiAqIGIxMTtcbiAgdDE2ICs9IHYgKiBiMTI7XG4gIHQxNyArPSB2ICogYjEzO1xuICB0MTggKz0gdiAqIGIxNDtcbiAgdDE5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzVdO1xuICB0NSArPSB2ICogYjA7XG4gIHQ2ICs9IHYgKiBiMTtcbiAgdDcgKz0gdiAqIGIyO1xuICB0OCArPSB2ICogYjM7XG4gIHQ5ICs9IHYgKiBiNDtcbiAgdDEwICs9IHYgKiBiNTtcbiAgdDExICs9IHYgKiBiNjtcbiAgdDEyICs9IHYgKiBiNztcbiAgdDEzICs9IHYgKiBiODtcbiAgdDE0ICs9IHYgKiBiOTtcbiAgdDE1ICs9IHYgKiBiMTA7XG4gIHQxNiArPSB2ICogYjExO1xuICB0MTcgKz0gdiAqIGIxMjtcbiAgdDE4ICs9IHYgKiBiMTM7XG4gIHQxOSArPSB2ICogYjE0O1xuICB0MjAgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNl07XG4gIHQ2ICs9IHYgKiBiMDtcbiAgdDcgKz0gdiAqIGIxO1xuICB0OCArPSB2ICogYjI7XG4gIHQ5ICs9IHYgKiBiMztcbiAgdDEwICs9IHYgKiBiNDtcbiAgdDExICs9IHYgKiBiNTtcbiAgdDEyICs9IHYgKiBiNjtcbiAgdDEzICs9IHYgKiBiNztcbiAgdDE0ICs9IHYgKiBiODtcbiAgdDE1ICs9IHYgKiBiOTtcbiAgdDE2ICs9IHYgKiBiMTA7XG4gIHQxNyArPSB2ICogYjExO1xuICB0MTggKz0gdiAqIGIxMjtcbiAgdDE5ICs9IHYgKiBiMTM7XG4gIHQyMCArPSB2ICogYjE0O1xuICB0MjEgKz0gdiAqIGIxNTtcbiAgdiA9IGFbN107XG4gIHQ3ICs9IHYgKiBiMDtcbiAgdDggKz0gdiAqIGIxO1xuICB0OSArPSB2ICogYjI7XG4gIHQxMCArPSB2ICogYjM7XG4gIHQxMSArPSB2ICogYjQ7XG4gIHQxMiArPSB2ICogYjU7XG4gIHQxMyArPSB2ICogYjY7XG4gIHQxNCArPSB2ICogYjc7XG4gIHQxNSArPSB2ICogYjg7XG4gIHQxNiArPSB2ICogYjk7XG4gIHQxNyArPSB2ICogYjEwO1xuICB0MTggKz0gdiAqIGIxMTtcbiAgdDE5ICs9IHYgKiBiMTI7XG4gIHQyMCArPSB2ICogYjEzO1xuICB0MjEgKz0gdiAqIGIxNDtcbiAgdDIyICs9IHYgKiBiMTU7XG4gIHYgPSBhWzhdO1xuICB0OCArPSB2ICogYjA7XG4gIHQ5ICs9IHYgKiBiMTtcbiAgdDEwICs9IHYgKiBiMjtcbiAgdDExICs9IHYgKiBiMztcbiAgdDEyICs9IHYgKiBiNDtcbiAgdDEzICs9IHYgKiBiNTtcbiAgdDE0ICs9IHYgKiBiNjtcbiAgdDE1ICs9IHYgKiBiNztcbiAgdDE2ICs9IHYgKiBiODtcbiAgdDE3ICs9IHYgKiBiOTtcbiAgdDE4ICs9IHYgKiBiMTA7XG4gIHQxOSArPSB2ICogYjExO1xuICB0MjAgKz0gdiAqIGIxMjtcbiAgdDIxICs9IHYgKiBiMTM7XG4gIHQyMiArPSB2ICogYjE0O1xuICB0MjMgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOV07XG4gIHQ5ICs9IHYgKiBiMDtcbiAgdDEwICs9IHYgKiBiMTtcbiAgdDExICs9IHYgKiBiMjtcbiAgdDEyICs9IHYgKiBiMztcbiAgdDEzICs9IHYgKiBiNDtcbiAgdDE0ICs9IHYgKiBiNTtcbiAgdDE1ICs9IHYgKiBiNjtcbiAgdDE2ICs9IHYgKiBiNztcbiAgdDE3ICs9IHYgKiBiODtcbiAgdDE4ICs9IHYgKiBiOTtcbiAgdDE5ICs9IHYgKiBiMTA7XG4gIHQyMCArPSB2ICogYjExO1xuICB0MjEgKz0gdiAqIGIxMjtcbiAgdDIyICs9IHYgKiBiMTM7XG4gIHQyMyArPSB2ICogYjE0O1xuICB0MjQgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTBdO1xuICB0MTAgKz0gdiAqIGIwO1xuICB0MTEgKz0gdiAqIGIxO1xuICB0MTIgKz0gdiAqIGIyO1xuICB0MTMgKz0gdiAqIGIzO1xuICB0MTQgKz0gdiAqIGI0O1xuICB0MTUgKz0gdiAqIGI1O1xuICB0MTYgKz0gdiAqIGI2O1xuICB0MTcgKz0gdiAqIGI3O1xuICB0MTggKz0gdiAqIGI4O1xuICB0MTkgKz0gdiAqIGI5O1xuICB0MjAgKz0gdiAqIGIxMDtcbiAgdDIxICs9IHYgKiBiMTE7XG4gIHQyMiArPSB2ICogYjEyO1xuICB0MjMgKz0gdiAqIGIxMztcbiAgdDI0ICs9IHYgKiBiMTQ7XG4gIHQyNSArPSB2ICogYjE1O1xuICB2ID0gYVsxMV07XG4gIHQxMSArPSB2ICogYjA7XG4gIHQxMiArPSB2ICogYjE7XG4gIHQxMyArPSB2ICogYjI7XG4gIHQxNCArPSB2ICogYjM7XG4gIHQxNSArPSB2ICogYjQ7XG4gIHQxNiArPSB2ICogYjU7XG4gIHQxNyArPSB2ICogYjY7XG4gIHQxOCArPSB2ICogYjc7XG4gIHQxOSArPSB2ICogYjg7XG4gIHQyMCArPSB2ICogYjk7XG4gIHQyMSArPSB2ICogYjEwO1xuICB0MjIgKz0gdiAqIGIxMTtcbiAgdDIzICs9IHYgKiBiMTI7XG4gIHQyNCArPSB2ICogYjEzO1xuICB0MjUgKz0gdiAqIGIxNDtcbiAgdDI2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEyXTtcbiAgdDEyICs9IHYgKiBiMDtcbiAgdDEzICs9IHYgKiBiMTtcbiAgdDE0ICs9IHYgKiBiMjtcbiAgdDE1ICs9IHYgKiBiMztcbiAgdDE2ICs9IHYgKiBiNDtcbiAgdDE3ICs9IHYgKiBiNTtcbiAgdDE4ICs9IHYgKiBiNjtcbiAgdDE5ICs9IHYgKiBiNztcbiAgdDIwICs9IHYgKiBiODtcbiAgdDIxICs9IHYgKiBiOTtcbiAgdDIyICs9IHYgKiBiMTA7XG4gIHQyMyArPSB2ICogYjExO1xuICB0MjQgKz0gdiAqIGIxMjtcbiAgdDI1ICs9IHYgKiBiMTM7XG4gIHQyNiArPSB2ICogYjE0O1xuICB0MjcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTNdO1xuICB0MTMgKz0gdiAqIGIwO1xuICB0MTQgKz0gdiAqIGIxO1xuICB0MTUgKz0gdiAqIGIyO1xuICB0MTYgKz0gdiAqIGIzO1xuICB0MTcgKz0gdiAqIGI0O1xuICB0MTggKz0gdiAqIGI1O1xuICB0MTkgKz0gdiAqIGI2O1xuICB0MjAgKz0gdiAqIGI3O1xuICB0MjEgKz0gdiAqIGI4O1xuICB0MjIgKz0gdiAqIGI5O1xuICB0MjMgKz0gdiAqIGIxMDtcbiAgdDI0ICs9IHYgKiBiMTE7XG4gIHQyNSArPSB2ICogYjEyO1xuICB0MjYgKz0gdiAqIGIxMztcbiAgdDI3ICs9IHYgKiBiMTQ7XG4gIHQyOCArPSB2ICogYjE1O1xuICB2ID0gYVsxNF07XG4gIHQxNCArPSB2ICogYjA7XG4gIHQxNSArPSB2ICogYjE7XG4gIHQxNiArPSB2ICogYjI7XG4gIHQxNyArPSB2ICogYjM7XG4gIHQxOCArPSB2ICogYjQ7XG4gIHQxOSArPSB2ICogYjU7XG4gIHQyMCArPSB2ICogYjY7XG4gIHQyMSArPSB2ICogYjc7XG4gIHQyMiArPSB2ICogYjg7XG4gIHQyMyArPSB2ICogYjk7XG4gIHQyNCArPSB2ICogYjEwO1xuICB0MjUgKz0gdiAqIGIxMTtcbiAgdDI2ICs9IHYgKiBiMTI7XG4gIHQyNyArPSB2ICogYjEzO1xuICB0MjggKz0gdiAqIGIxNDtcbiAgdDI5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE1XTtcbiAgdDE1ICs9IHYgKiBiMDtcbiAgdDE2ICs9IHYgKiBiMTtcbiAgdDE3ICs9IHYgKiBiMjtcbiAgdDE4ICs9IHYgKiBiMztcbiAgdDE5ICs9IHYgKiBiNDtcbiAgdDIwICs9IHYgKiBiNTtcbiAgdDIxICs9IHYgKiBiNjtcbiAgdDIyICs9IHYgKiBiNztcbiAgdDIzICs9IHYgKiBiODtcbiAgdDI0ICs9IHYgKiBiOTtcbiAgdDI1ICs9IHYgKiBiMTA7XG4gIHQyNiArPSB2ICogYjExO1xuICB0MjcgKz0gdiAqIGIxMjtcbiAgdDI4ICs9IHYgKiBiMTM7XG4gIHQyOSArPSB2ICogYjE0O1xuICB0MzAgKz0gdiAqIGIxNTtcblxuICB0MCAgKz0gMzggKiB0MTY7XG4gIHQxICArPSAzOCAqIHQxNztcbiAgdDIgICs9IDM4ICogdDE4O1xuICB0MyAgKz0gMzggKiB0MTk7XG4gIHQ0ICArPSAzOCAqIHQyMDtcbiAgdDUgICs9IDM4ICogdDIxO1xuICB0NiAgKz0gMzggKiB0MjI7XG4gIHQ3ICArPSAzOCAqIHQyMztcbiAgdDggICs9IDM4ICogdDI0O1xuICB0OSAgKz0gMzggKiB0MjU7XG4gIHQxMCArPSAzOCAqIHQyNjtcbiAgdDExICs9IDM4ICogdDI3O1xuICB0MTIgKz0gMzggKiB0Mjg7XG4gIHQxMyArPSAzOCAqIHQyOTtcbiAgdDE0ICs9IDM4ICogdDMwO1xuICAvLyB0MTUgbGVmdCBhcyBpc1xuXG4gIC8vIGZpcnN0IGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIG9bIDBdID0gdDA7XG4gIG9bIDFdID0gdDE7XG4gIG9bIDJdID0gdDI7XG4gIG9bIDNdID0gdDM7XG4gIG9bIDRdID0gdDQ7XG4gIG9bIDVdID0gdDU7XG4gIG9bIDZdID0gdDY7XG4gIG9bIDddID0gdDc7XG4gIG9bIDhdID0gdDg7XG4gIG9bIDldID0gdDk7XG4gIG9bMTBdID0gdDEwO1xuICBvWzExXSA9IHQxMTtcbiAgb1sxMl0gPSB0MTI7XG4gIG9bMTNdID0gdDEzO1xuICBvWzE0XSA9IHQxNDtcbiAgb1sxNV0gPSB0MTU7XG59XG5cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpO1xufVxuXG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUzOyBhID49IDA7IGEtLSkge1xuICAgIFMoYywgYyk7XG4gICAgaWYoYSAhPT0gMiAmJiBhICE9PSA0KSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUwOyBhID49IDA7IGEtLSkge1xuICAgICAgUyhjLCBjKTtcbiAgICAgIGlmKGEgIT09IDEpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApLCByLCBpO1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMTsgaSsrKSB6W2ldID0gbltpXTtcbiAgelszMV09KG5bMzFdJjEyNyl8NjQ7XG4gIHpbMF0mPTI0ODtcbiAgdW5wYWNrMjU1MTkoeCxwKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBiW2ldPXhbaV07XG4gICAgZFtpXT1hW2ldPWNbaV09MDtcbiAgfVxuICBhWzBdPWRbMF09MTtcbiAgZm9yIChpPTI1NDsgaT49MDsgLS1pKSB7XG4gICAgcj0oeltpPj4+M10+Pj4oaSY3KSkmMTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIEEoYyxiLGQpO1xuICAgIFooYixiLGQpO1xuICAgIFMoZCxlKTtcbiAgICBTKGYsYSk7XG4gICAgTShhLGMsYSk7XG4gICAgTShjLGIsZSk7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgUyhiLGEpO1xuICAgIFooYyxkLGYpO1xuICAgIE0oYSxjLF8xMjE2NjUpO1xuICAgIEEoYSxhLGQpO1xuICAgIE0oYyxjLGEpO1xuICAgIE0oYSxkLGYpO1xuICAgIE0oZCxiLHgpO1xuICAgIFMoYixlKTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgeFtpKzE2XT1hW2ldO1xuICAgIHhbaSszMl09Y1tpXTtcbiAgICB4W2krNDhdPWJbaV07XG4gICAgeFtpKzY0XT1kW2ldO1xuICB9XG4gIHZhciB4MzIgPSB4LnN1YmFycmF5KDMyKTtcbiAgdmFyIHgxNiA9IHguc3ViYXJyYXkoMTYpO1xuICBpbnYyNTUxOSh4MzIseDMyKTtcbiAgTSh4MTYseDE2LHgzMik7XG4gIHBhY2syNTUxOShxLHgxNik7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9rZXlwYWlyKHksIHgpIHtcbiAgcmFuZG9tYnl0ZXMoeCwgMzIpO1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHRfYmFzZSh5LCB4KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fc2NhbGFybXVsdChzLCB4LCB5KTtcbiAgcmV0dXJuIGNyeXB0b19jb3JlX2hzYWxzYTIwKGssIF8wLCBzLCBzaWdtYSk7XG59XG5cbnZhciBjcnlwdG9fYm94X2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94O1xudmFyIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveF9vcGVuO1xuXG5mdW5jdGlvbiBjcnlwdG9fYm94KGMsIG0sIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X2FmdGVybm0oYywgbSwgZCwgbiwgayk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfb3BlbihtLCBjLCBkLCBuLCB5LCB4KSB7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICByZXR1cm4gY3J5cHRvX2JveF9vcGVuX2FmdGVybm0obSwgYywgZCwgbiwgayk7XG59XG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pIHtcbiAgdmFyIHdoID0gbmV3IEludDMyQXJyYXkoMTYpLCB3bCA9IG5ldyBJbnQzMkFycmF5KDE2KSxcbiAgICAgIGJoMCwgYmgxLCBiaDIsIGJoMywgYmg0LCBiaDUsIGJoNiwgYmg3LFxuICAgICAgYmwwLCBibDEsIGJsMiwgYmwzLCBibDQsIGJsNSwgYmw2LCBibDcsXG4gICAgICB0aCwgdGwsIGksIGosIGgsIGwsIGEsIGIsIGMsIGQ7XG5cbiAgdmFyIGFoMCA9IGhoWzBdLFxuICAgICAgYWgxID0gaGhbMV0sXG4gICAgICBhaDIgPSBoaFsyXSxcbiAgICAgIGFoMyA9IGhoWzNdLFxuICAgICAgYWg0ID0gaGhbNF0sXG4gICAgICBhaDUgPSBoaFs1XSxcbiAgICAgIGFoNiA9IGhoWzZdLFxuICAgICAgYWg3ID0gaGhbN10sXG5cbiAgICAgIGFsMCA9IGhsWzBdLFxuICAgICAgYWwxID0gaGxbMV0sXG4gICAgICBhbDIgPSBobFsyXSxcbiAgICAgIGFsMyA9IGhsWzNdLFxuICAgICAgYWw0ID0gaGxbNF0sXG4gICAgICBhbDUgPSBobFs1XSxcbiAgICAgIGFsNiA9IGhsWzZdLFxuICAgICAgYWw3ID0gaGxbN107XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHdoaWxlIChuID49IDEyOCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBqID0gOCAqIGkgKyBwb3M7XG4gICAgICB3aFtpXSA9IChtW2orMF0gPDwgMjQpIHwgKG1baisxXSA8PCAxNikgfCAobVtqKzJdIDw8IDgpIHwgbVtqKzNdO1xuICAgICAgd2xbaV0gPSAobVtqKzRdIDw8IDI0KSB8IChtW2orNV0gPDwgMTYpIHwgKG1bais2XSA8PCA4KSB8IG1bais3XTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGJoMCA9IGFoMDtcbiAgICAgIGJoMSA9IGFoMTtcbiAgICAgIGJoMiA9IGFoMjtcbiAgICAgIGJoMyA9IGFoMztcbiAgICAgIGJoNCA9IGFoNDtcbiAgICAgIGJoNSA9IGFoNTtcbiAgICAgIGJoNiA9IGFoNjtcbiAgICAgIGJoNyA9IGFoNztcblxuICAgICAgYmwwID0gYWwwO1xuICAgICAgYmwxID0gYWwxO1xuICAgICAgYmwyID0gYWwyO1xuICAgICAgYmwzID0gYWwzO1xuICAgICAgYmw0ID0gYWw0O1xuICAgICAgYmw1ID0gYWw1O1xuICAgICAgYmw2ID0gYWw2O1xuICAgICAgYmw3ID0gYWw3O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBhaDc7XG4gICAgICBsID0gYWw3O1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWExXG4gICAgICBoID0gKChhaDQgPj4+IDE0KSB8IChhbDQgPDwgKDMyLTE0KSkpIF4gKChhaDQgPj4+IDE4KSB8IChhbDQgPDwgKDMyLTE4KSkpIF4gKChhbDQgPj4+ICg0MS0zMikpIHwgKGFoNCA8PCAoMzItKDQxLTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsNCA+Pj4gMTQpIHwgKGFoNCA8PCAoMzItMTQpKSkgXiAoKGFsNCA+Pj4gMTgpIHwgKGFoNCA8PCAoMzItMTgpKSkgXiAoKGFoNCA+Pj4gKDQxLTMyKSkgfCAoYWw0IDw8ICgzMi0oNDEtMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIENoXG4gICAgICBoID0gKGFoNCAmIGFoNSkgXiAofmFoNCAmIGFoNik7XG4gICAgICBsID0gKGFsNCAmIGFsNSkgXiAofmFsNCAmIGFsNik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gS1xuICAgICAgaCA9IEtbaSoyXTtcbiAgICAgIGwgPSBLW2kqMisxXTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyB3XG4gICAgICBoID0gd2hbaSUxNl07XG4gICAgICBsID0gd2xbaSUxNl07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICB0aCA9IGMgJiAweGZmZmYgfCBkIDw8IDE2O1xuICAgICAgdGwgPSBhICYgMHhmZmZmIHwgYiA8PCAxNjtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTBcbiAgICAgIGggPSAoKGFoMCA+Pj4gMjgpIHwgKGFsMCA8PCAoMzItMjgpKSkgXiAoKGFsMCA+Pj4gKDM0LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhbDAgPj4+ICgzOS0zMikpIHwgKGFoMCA8PCAoMzItKDM5LTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsMCA+Pj4gMjgpIHwgKGFoMCA8PCAoMzItMjgpKSkgXiAoKGFoMCA+Pj4gKDM0LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhaDAgPj4+ICgzOS0zMikpIHwgKGFsMCA8PCAoMzItKDM5LTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBNYWpcbiAgICAgIGggPSAoYWgwICYgYWgxKSBeIChhaDAgJiBhaDIpIF4gKGFoMSAmIGFoMik7XG4gICAgICBsID0gKGFsMCAmIGFsMSkgXiAoYWwwICYgYWwyKSBeIChhbDEgJiBhbDIpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBiaDM7XG4gICAgICBsID0gYmwzO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICBhaDEgPSBiaDA7XG4gICAgICBhaDIgPSBiaDE7XG4gICAgICBhaDMgPSBiaDI7XG4gICAgICBhaDQgPSBiaDM7XG4gICAgICBhaDUgPSBiaDQ7XG4gICAgICBhaDYgPSBiaDU7XG4gICAgICBhaDcgPSBiaDY7XG4gICAgICBhaDAgPSBiaDc7XG5cbiAgICAgIGFsMSA9IGJsMDtcbiAgICAgIGFsMiA9IGJsMTtcbiAgICAgIGFsMyA9IGJsMjtcbiAgICAgIGFsNCA9IGJsMztcbiAgICAgIGFsNSA9IGJsNDtcbiAgICAgIGFsNiA9IGJsNTtcbiAgICAgIGFsNyA9IGJsNjtcbiAgICAgIGFsMCA9IGJsNztcblxuICAgICAgaWYgKGklMTYgPT09IDE1KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgaCA9IHdoW2pdO1xuICAgICAgICAgIGwgPSB3bFtqXTtcblxuICAgICAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgICAgIGggPSB3aFsoais5KSUxNl07XG4gICAgICAgICAgbCA9IHdsWyhqKzkpJTE2XTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTBcbiAgICAgICAgICB0aCA9IHdoWyhqKzEpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzEpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMSkgfCAodGwgPDwgKDMyLTEpKSkgXiAoKHRoID4+PiA4KSB8ICh0bCA8PCAoMzItOCkpKSBeICh0aCA+Pj4gNyk7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDEpIHwgKHRoIDw8ICgzMi0xKSkpIF4gKCh0bCA+Pj4gOCkgfCAodGggPDwgKDMyLTgpKSkgXiAoKHRsID4+PiA3KSB8ICh0aCA8PCAoMzItNykpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTFcbiAgICAgICAgICB0aCA9IHdoWyhqKzE0KSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxNCklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxOSkgfCAodGwgPDwgKDMyLTE5KSkpIF4gKCh0bCA+Pj4gKDYxLTMyKSkgfCAodGggPDwgKDMyLSg2MS0zMikpKSkgXiAodGggPj4+IDYpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxOSkgfCAodGggPDwgKDMyLTE5KSkpIF4gKCh0aCA+Pj4gKDYxLTMyKSkgfCAodGwgPDwgKDMyLSg2MS0zMikpKSkgXiAoKHRsID4+PiA2KSB8ICh0aCA8PCAoMzItNikpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgICAgIHdoW2pdID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgICAgIHdsW2pdID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkXG4gICAgaCA9IGFoMDtcbiAgICBsID0gYWwwO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzBdO1xuICAgIGwgPSBobFswXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzBdID0gYWgwID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzBdID0gYWwwID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMTtcbiAgICBsID0gYWwxO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzFdO1xuICAgIGwgPSBobFsxXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzFdID0gYWgxID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzFdID0gYWwxID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMjtcbiAgICBsID0gYWwyO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzJdO1xuICAgIGwgPSBobFsyXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzJdID0gYWgyID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzJdID0gYWwyID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMztcbiAgICBsID0gYWwzO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzNdO1xuICAgIGwgPSBobFszXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzNdID0gYWgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzNdID0gYWwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNDtcbiAgICBsID0gYWw0O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzRdO1xuICAgIGwgPSBobFs0XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzRdID0gYWg0ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzRdID0gYWw0ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNTtcbiAgICBsID0gYWw1O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzVdO1xuICAgIGwgPSBobFs1XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzVdID0gYWg1ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzVdID0gYWw1ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNjtcbiAgICBsID0gYWw2O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzZdO1xuICAgIGwgPSBobFs2XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzZdID0gYWg2ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzZdID0gYWw2ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNztcbiAgICBsID0gYWw3O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzddO1xuICAgIGwgPSBobFs3XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzddID0gYWg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzddID0gYWw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgcG9zICs9IDEyODtcbiAgICBuIC09IDEyODtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgdmFyIGhoID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICBobCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgeCA9IG5ldyBVaW50OEFycmF5KDI1NiksXG4gICAgICBpLCBiID0gbjtcblxuICBoaFswXSA9IDB4NmEwOWU2Njc7XG4gIGhoWzFdID0gMHhiYjY3YWU4NTtcbiAgaGhbMl0gPSAweDNjNmVmMzcyO1xuICBoaFszXSA9IDB4YTU0ZmY1M2E7XG4gIGhoWzRdID0gMHg1MTBlNTI3ZjtcbiAgaGhbNV0gPSAweDliMDU2ODhjO1xuICBoaFs2XSA9IDB4MWY4M2Q5YWI7XG4gIGhoWzddID0gMHg1YmUwY2QxOTtcblxuICBobFswXSA9IDB4ZjNiY2M5MDg7XG4gIGhsWzFdID0gMHg4NGNhYTczYjtcbiAgaGxbMl0gPSAweGZlOTRmODJiO1xuICBobFszXSA9IDB4NWYxZDM2ZjE7XG4gIGhsWzRdID0gMHhhZGU2ODJkMTtcbiAgaGxbNV0gPSAweDJiM2U2YzFmO1xuICBobFs2XSA9IDB4ZmI0MWJkNmI7XG4gIGhsWzddID0gMHgxMzdlMjE3OTtcblxuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pO1xuICBuICU9IDEyODtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gbVtiLW4raV07XG4gIHhbbl0gPSAxMjg7XG5cbiAgbiA9IDI1Ni0xMjgqKG48MTEyPzE6MCk7XG4gIHhbbi05XSA9IDA7XG4gIHRzNjQoeCwgbi04LCAgKGIgLyAweDIwMDAwMDAwKSB8IDAsIGIgPDwgMyk7XG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgeCwgbik7XG5cbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgdHM2NChvdXQsIDgqaSwgaGhbaV0sIGhsW2ldKTtcblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWRkKHAsIHEpIHtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLFxuICAgICAgZyA9IGdmKCksIGggPSBnZigpLCB0ID0gZ2YoKTtcblxuICBaKGEsIHBbMV0sIHBbMF0pO1xuICBaKHQsIHFbMV0sIHFbMF0pO1xuICBNKGEsIGEsIHQpO1xuICBBKGIsIHBbMF0sIHBbMV0pO1xuICBBKHQsIHFbMF0sIHFbMV0pO1xuICBNKGIsIGIsIHQpO1xuICBNKGMsIHBbM10sIHFbM10pO1xuICBNKGMsIGMsIEQyKTtcbiAgTShkLCBwWzJdLCBxWzJdKTtcbiAgQShkLCBkLCBkKTtcbiAgWihlLCBiLCBhKTtcbiAgWihmLCBkLCBjKTtcbiAgQShnLCBkLCBjKTtcbiAgQShoLCBiLCBhKTtcblxuICBNKHBbMF0sIGUsIGYpO1xuICBNKHBbMV0sIGgsIGcpO1xuICBNKHBbMl0sIGcsIGYpO1xuICBNKHBbM10sIGUsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gIE0odHgsIHBbMF0sIHppKTtcbiAgTSh0eSwgcFsxXSwgemkpO1xuICBwYWNrMjU1MTkociwgdHkpO1xuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbn1cblxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpO1xuICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICBmb3IgKGkgPSAyNTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgYiA9IChzWyhpLzgpfDBdID4+IChpJjcpKSAmIDE7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gICAgYWRkKHEsIHApO1xuICAgIGFkZChwLCBwKTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHNldDI1NTE5KHFbMF0sIFgpO1xuICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKTtcbiAgTShxWzNdLCBYLCBZKTtcbiAgc2NhbGFybXVsdChwLCBxLCBzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHNlZWRlZCkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHZhciBpO1xuXG4gIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICBzY2FsYXJiYXNlKHAsIGQpO1xuICBwYWNrKHBrLCBwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaSszMl0gPSBwa1tpXTtcbiAgcmV0dXJuIDA7XG59XG5cbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbMHhlZCwgMHhkMywgMHhmNSwgMHg1YywgMHgxYSwgMHg2MywgMHgxMiwgMHg1OCwgMHhkNiwgMHg5YywgMHhmNywgMHhhMiwgMHhkZSwgMHhmOSwgMHhkZSwgMHgxNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgxMF0pO1xuXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrO1xuICBmb3IgKGkgPSA2MzsgaSA+PSAzMjsgLS1pKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsraikge1xuICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcigoeFtqXSArIDEyOCkgLyAyNTYpO1xuICAgICAgeFtqXSAtPSBjYXJyeSAqIDI1NjtcbiAgICB9XG4gICAgeFtqXSArPSBjYXJyeTtcbiAgICB4W2ldID0gMDtcbiAgfVxuICBjYXJyeSA9IDA7XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgeFtqXSArPSBjYXJyeSAtICh4WzMxXSA+PiA0KSAqIExbal07XG4gICAgY2FycnkgPSB4W2pdID4+IDg7XG4gICAgeFtqXSAmPSAyNTU7XG4gIH1cbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHhbal0gLT0gY2FycnkgKiBMW2pdO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHhbaSsxXSArPSB4W2ldID4+IDg7XG4gICAgcltpXSA9IHhbaV0gJiAyNTU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHIpIHtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgcltpXSA9IDA7XG4gIG1vZEwociwgeCk7XG59XG5cbi8vIE5vdGU6IGRpZmZlcmVuY2UgZnJvbSBDIC0gc21sZW4gcmV0dXJuZWQsIG5vdCBwYXNzZWQgYXMgYXJndW1lbnQuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgbiwgc2spIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBpLCBqLCB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHZhciBzbWxlbiA9IG4gKyA2NDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgc21bNjQgKyBpXSA9IG1baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBzbVszMiArIGldID0gZFszMiArIGldO1xuXG4gIGNyeXB0b19oYXNoKHIsIHNtLnN1YmFycmF5KDMyKSwgbiszMik7XG4gIHJlZHVjZShyKTtcbiAgc2NhbGFyYmFzZShwLCByKTtcbiAgcGFjayhzbSwgcCk7XG5cbiAgZm9yIChpID0gMzI7IGkgPCA2NDsgaSsrKSBzbVtpXSA9IHNrW2ldO1xuICBjcnlwdG9faGFzaChoLCBzbSwgbiArIDY0KTtcbiAgcmVkdWNlKGgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgICB4W2kral0gKz0gaFtpXSAqIGRbal07XG4gICAgfVxuICB9XG5cbiAgbW9kTChzbS5zdWJhcnJheSgzMiksIHgpO1xuICByZXR1cm4gc21sZW47XG59XG5cbmZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSxcbiAgICAgIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSxcbiAgICAgIGRlbjYgPSBnZigpO1xuXG4gIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICBTKG51bSwgclsxXSk7XG4gIE0oZGVuLCBudW0sIEQpO1xuICBaKG51bSwgbnVtLCByWzJdKTtcbiAgQShkZW4sIHJbMl0sIGRlbik7XG5cbiAgUyhkZW4yLCBkZW4pO1xuICBTKGRlbjQsIGRlbjIpO1xuICBNKGRlbjYsIGRlbjQsIGRlbjIpO1xuICBNKHQsIGRlbjYsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcblxuICBwb3cyNTIzKHQsIHQpO1xuICBNKHQsIHQsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHJbMF0sIHQsIGRlbik7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSBNKHJbMF0sIHJbMF0sIEkpO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgcmV0dXJuIC0xO1xuXG4gIGlmIChwYXIyNTUxOShyWzBdKSA9PT0gKHBbMzFdPj43KSkgWihyWzBdLCBnZjAsIHJbMF0pO1xuXG4gIE0oclszXSwgclswXSwgclsxXSk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBuLCBwaykge1xuICB2YXIgaTtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldLFxuICAgICAgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG5cbiAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiAtMTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2krMzJdID0gcGtbaV07XG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICByZWR1Y2UoaCk7XG4gIHNjYWxhcm11bHQocCwgcSwgaCk7XG5cbiAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICBhZGQocCwgcSk7XG4gIHBhY2sodCwgcCk7XG5cbiAgbiAtPSA2NDtcbiAgaWYgKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2kgKyA2NF07XG4gIHJldHVybiBuO1xufVxuXG52YXIgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyA9IDI0LFxuICAgIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgPSAxNixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gICAgY3J5cHRvX2JveF9aRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICAgIGNyeXB0b19zaWduX0JZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1NFRURCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19oYXNoX0JZVEVTID0gNjQ7XG5cbm5hY2wubG93bGV2ZWwgPSB7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwOiBjcnlwdG9fY29yZV9oc2Fsc2EyMCxcbiAgY3J5cHRvX3N0cmVhbV94b3I6IGNyeXB0b19zdHJlYW1feG9yLFxuICBjcnlwdG9fc3RyZWFtOiBjcnlwdG9fc3RyZWFtLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjA6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMCxcbiAgY3J5cHRvX29uZXRpbWVhdXRoOiBjcnlwdG9fb25ldGltZWF1dGgsXG4gIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnk6IGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnksXG4gIGNyeXB0b192ZXJpZnlfMTY6IGNyeXB0b192ZXJpZnlfMTYsXG4gIGNyeXB0b192ZXJpZnlfMzI6IGNyeXB0b192ZXJpZnlfMzIsXG4gIGNyeXB0b19zZWNyZXRib3g6IGNyeXB0b19zZWNyZXRib3gsXG4gIGNyeXB0b19zZWNyZXRib3hfb3BlbjogY3J5cHRvX3NlY3JldGJveF9vcGVuLFxuICBjcnlwdG9fc2NhbGFybXVsdDogY3J5cHRvX3NjYWxhcm11bHQsXG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2U6IGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UsXG4gIGNyeXB0b19ib3hfYmVmb3Jlbm06IGNyeXB0b19ib3hfYmVmb3Jlbm0sXG4gIGNyeXB0b19ib3hfYWZ0ZXJubTogY3J5cHRvX2JveF9hZnRlcm5tLFxuICBjcnlwdG9fYm94OiBjcnlwdG9fYm94LFxuICBjcnlwdG9fYm94X29wZW46IGNyeXB0b19ib3hfb3BlbixcbiAgY3J5cHRvX2JveF9rZXlwYWlyOiBjcnlwdG9fYm94X2tleXBhaXIsXG4gIGNyeXB0b19oYXNoOiBjcnlwdG9faGFzaCxcbiAgY3J5cHRvX3NpZ246IGNyeXB0b19zaWduLFxuICBjcnlwdG9fc2lnbl9rZXlwYWlyOiBjcnlwdG9fc2lnbl9rZXlwYWlyLFxuICBjcnlwdG9fc2lnbl9vcGVuOiBjcnlwdG9fc2lnbl9vcGVuLFxuXG4gIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM6IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUzogY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTLFxuICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMsXG4gIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM6IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMsXG4gIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM6IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUzogY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTLFxuICBjcnlwdG9fYm94X05PTkNFQllURVM6IGNyeXB0b19ib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX2JveF9aRVJPQllURVM6IGNyeXB0b19ib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUzogY3J5cHRvX2JveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zaWduX0JZVEVTOiBjcnlwdG9fc2lnbl9CWVRFUyxcbiAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM6IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19zaWduX1NFRURCWVRFUzogY3J5cHRvX3NpZ25fU0VFREJZVEVTLFxuICBjcnlwdG9faGFzaF9CWVRFUzogY3J5cHRvX2hhc2hfQllURVMsXG5cbiAgZ2Y6IGdmLFxuICBEOiBELFxuICBMOiBMLFxuICBwYWNrMjU1MTk6IHBhY2syNTUxOSxcbiAgdW5wYWNrMjU1MTk6IHVucGFjazI1NTE5LFxuICBNOiBNLFxuICBBOiBBLFxuICBTOiBTLFxuICBaOiBaLFxuICBwb3cyNTIzOiBwb3cyNTIzLFxuICBhZGQ6IGFkZCxcbiAgc2V0MjU1MTk6IHNldDI1NTE5LFxuICBtb2RMOiBtb2RMLFxuICBzY2FsYXJtdWx0OiBzY2FsYXJtdWx0LFxuICBzY2FsYXJiYXNlOiBzY2FsYXJiYXNlLFxufTtcblxuLyogSGlnaC1sZXZlbCBBUEkgKi9cblxuZnVuY3Rpb24gY2hlY2tMZW5ndGhzKGssIG4pIHtcbiAgaWYgKGsubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBrZXkgc2l6ZScpO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbm9uY2Ugc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveExlbmd0aHMocGssIHNrKSB7XG4gIGlmIChway5sZW5ndGggIT09IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICBpZiAoc2subGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVzKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlLCB1c2UgVWludDhBcnJheScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnJbaV0gPSAwO1xufVxuXG5uYWNsLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICByYW5kb21ieXRlcyhiLCBuKTtcbiAgcmV0dXJuIGI7XG59O1xuXG5uYWNsLnNlY3JldGJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgbVtpK2NyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1zZ1tpXTtcbiAgY3J5cHRvX3NlY3JldGJveChjLCBtLCBtLmxlbmd0aCwgbm9uY2UsIGtleSk7XG4gIHJldHVybiBjLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94Lm9wZW4gPSBmdW5jdGlvbihib3gsIG5vbmNlLCBrZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKGJveCwgbm9uY2UsIGtleSk7XG4gIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyArIGJveC5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspIGNbaStjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBib3hbaV07XG4gIGlmIChjLmxlbmd0aCA8IDMyKSByZXR1cm4gbnVsbDtcbiAgaWYgKGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBjLmxlbmd0aCwgbm9uY2UsIGtleSkgIT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4gbS5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyk7XG59O1xuXG5uYWNsLnNlY3JldGJveC5rZXlMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTO1xubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM7XG5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTO1xuXG5uYWNsLnNjYWxhck11bHQgPSBmdW5jdGlvbihuLCBwKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuLCBwKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIGlmIChwLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHAgc2l6ZScpO1xuICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCk7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LmJhc2UgPSBmdW5jdGlvbihuKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pO1xuICByZXR1cm4gcTtcbn07XG5cbm5hY2wuc2NhbGFyTXVsdC5zY2FsYXJMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUztcbm5hY2wuc2NhbGFyTXVsdC5ncm91cEVsZW1lbnRMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUztcblxubmFjbC5ib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBuYWNsLnNlY3JldGJveChtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94LmJlZm9yZSA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIGNoZWNrQm94TGVuZ3RocyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCBwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBrO1xufTtcblxubmFjbC5ib3guYWZ0ZXIgPSBuYWNsLnNlY3JldGJveDtcblxubmFjbC5ib3gub3BlbiA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94Lm9wZW4obXNnLCBub25jZSwgayk7XG59O1xuXG5uYWNsLmJveC5vcGVuLmFmdGVyID0gbmFjbC5zZWNyZXRib3gub3BlbjtcblxubmFjbC5ib3gua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyk7XG4gIGNyeXB0b19ib3hfa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocGssIHNlY3JldEtleSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuYm94LnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM7XG5uYWNsLmJveC5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTO1xubmFjbC5ib3guc2hhcmVkS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTO1xubmFjbC5ib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fYm94X05PTkNFQllURVM7XG5uYWNsLmJveC5vdmVyaGVhZExlbmd0aCA9IG5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoO1xuXG5uYWNsLnNpZ24gPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBzaWduZWRNc2cgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyttc2cubGVuZ3RoKTtcbiAgY3J5cHRvX3NpZ24oc2lnbmVkTXNnLCBtc2csIG1zZy5sZW5ndGgsIHNlY3JldEtleSk7XG4gIHJldHVybiBzaWduZWRNc2c7XG59O1xuXG5uYWNsLnNpZ24ub3BlbiA9IGZ1bmN0aW9uKHNpZ25lZE1zZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzaWduZWRNc2csIHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KHNpZ25lZE1zZy5sZW5ndGgpO1xuICB2YXIgbWxlbiA9IGNyeXB0b19zaWduX29wZW4odG1wLCBzaWduZWRNc2csIHNpZ25lZE1zZy5sZW5ndGgsIHB1YmxpY0tleSk7XG4gIGlmIChtbGVuIDwgMCkgcmV0dXJuIG51bGw7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkobWxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgbVtpXSA9IHRtcFtpXTtcbiAgcmV0dXJuIG07XG59O1xuXG5uYWNsLnNpZ24uZGV0YWNoZWQgPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICB2YXIgc2lnbmVkTXNnID0gbmFjbC5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAgdmFyIHNpZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHNpZ1tpXSA9IHNpZ25lZE1zZ1tpXTtcbiAgcmV0dXJuIHNpZztcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkgPSBmdW5jdGlvbihtc2csIHNpZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZywgcHVibGljS2V5KTtcbiAgaWYgKHNpZy5sZW5ndGggIT09IGNyeXB0b19zaWduX0JZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNpZ25hdHVyZSBzaXplJyk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHNtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspIHNtW2ldID0gc2lnW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBzbVtpK2NyeXB0b19zaWduX0JZVEVTXSA9IG1zZ1tpXTtcbiAgcmV0dXJuIChjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBzbS5sZW5ndGgsIHB1YmxpY0tleSkgPj0gMCk7XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5zaWduLmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGsubGVuZ3RoOyBpKyspIHBrW2ldID0gc2VjcmV0S2V5WzMyK2ldO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlZWQpO1xuICBpZiAoc2VlZC5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFRURCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWVkIHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaV0gPSBzZWVkW2ldO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM7XG5uYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM7XG5uYWNsLnNpZ24uc2VlZExlbmd0aCA9IGNyeXB0b19zaWduX1NFRURCWVRFUztcbm5hY2wuc2lnbi5zaWduYXR1cmVMZW5ndGggPSBjcnlwdG9fc2lnbl9CWVRFUztcblxubmFjbC5oYXNoID0gZnVuY3Rpb24obXNnKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2cpO1xuICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19oYXNoX0JZVEVTKTtcbiAgY3J5cHRvX2hhc2goaCwgbXNnLCBtc2cubGVuZ3RoKTtcbiAgcmV0dXJuIGg7XG59O1xuXG5uYWNsLmhhc2guaGFzaExlbmd0aCA9IGNyeXB0b19oYXNoX0JZVEVTO1xuXG5uYWNsLnZlcmlmeSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHgsIHkpO1xuICAvLyBaZXJvIGxlbmd0aCBhcmd1bWVudHMgYXJlIGNvbnNpZGVyZWQgbm90IGVxdWFsLlxuICBpZiAoeC5sZW5ndGggPT09IDAgfHwgeS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHZuKHgsIDAsIHksIDAsIHgubGVuZ3RoKSA9PT0gMCkgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5uYWNsLnNldFBSTkcgPSBmdW5jdGlvbihmbikge1xuICByYW5kb21ieXRlcyA9IGZuO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBJbml0aWFsaXplIFBSTkcgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgQ1NQUk5HLlxuICAvLyBJZiBub3QsIG1ldGhvZHMgY2FsbGluZyByYW5kb21ieXRlcyB3aWxsIHRocm93LlxuICB2YXIgY3J5cHRvID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gKHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG8pIDogbnVsbDtcbiAgaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gQnJvd3NlcnMuXG4gICAgdmFyIFFVT1RBID0gNjU1MzY7XG4gICAgbmFjbC5zZXRQUk5HKGZ1bmN0aW9uKHgsIG4pIHtcbiAgICAgIHZhciBpLCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSkge1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHYuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSB2W2ldO1xuICAgICAgY2xlYW51cCh2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0cnVlKSB7XG4gICAgLy8gTm9kZS5qcy5cbiAgICBjcnlwdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICB2YXIgaSwgdiA9IGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICAgIGNsZWFudXAodik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbn0pKCB0cnVlICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgOiAoc2VsZi5uYWNsID0gc2VsZi5uYWNsIHx8IHt9KSk7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpLmRlZmF1bHQ7XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuXG5TdHJlYW1zIGluIGEgV2ViU29ja2V0IGNvbm5lY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5XZSBtb2RlbCBhIFdlYlNvY2tldCBhcyB0d28gZHVwbGV4IHN0cmVhbXM6IG9uZSBzdHJlYW0gaXMgZm9yIHRoZSB3aXJlIHByb3RvY29sXG5vdmVyIGFuIEkvTyBzb2NrZXQsIGFuZCB0aGUgb3RoZXIgaXMgZm9yIGluY29taW5nL291dGdvaW5nIG1lc3NhZ2VzLlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tKyAgICAgICstLS0tLS0tLS0rICAgICAgKy0tLS0tLS0tLS0rXG4gICAgWzFdIHdyaXRlKGNodW5rKSAtLT58IH5+fn5+fn5+ICstLS0tLT58IHBhcnNlKCkgKy0tLS0tPnwgfn5+fn5+fn4gKy0tPiBlbWl0KCdkYXRhJykgWzJdXG4gICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICArLS0tLSstLS0tKyAgICAgIHwgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgSU8gICAgfCAgICAgICAgICAgfCBbNV0gICAgICAgfCBNZXNzYWdlcyB8XG4gICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgIFYgICAgICAgICAgIHwgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLSsgICAgICB8ICAgICAgICAgIHxcbiAgICBbNF0gZW1pdCgnZGF0YScpIDwtLSsgfn5+fn5+fn4gfDwtLS0tLSsgZnJhbWUoKSB8PC0tLS0tKyB+fn5+fn5+fiB8PC0tIHdyaXRlKGNodW5rKSBbM11cbiAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tKyAgICAgICstLS0tLS0tLS0rICAgICAgKy0tLS0tLS0tLS0rXG5cblxuTWVzc2FnZSB0cmFuc2ZlciBpbiBlYWNoIGRpcmVjdGlvbiBpcyBzaW1wbGU6IElPIHJlY2VpdmVzIGEgYnl0ZSBzdHJlYW0gWzFdIGFuZFxuc2VuZHMgdGhpcyBzdHJlYW0gZm9yIHBhcnNpbmcuIFRoZSBwYXJzZXIgd2lsbCBwZXJpb2RpY2FsbHkgZW1pdCBhIGNvbXBsZXRlXG5tZXNzYWdlIHRleHQgb24gdGhlIE1lc3NhZ2VzIHN0cmVhbSBbMl0uIFNpbWlsYXJseSwgd2hlbiBtZXNzYWdlcyBhcmUgd3JpdHRlblxudG8gdGhlIE1lc3NhZ2VzIHN0cmVhbSBbM10sIHRoZXkgYXJlIGZyYW1lZCB1c2luZyB0aGUgV2ViU29ja2V0IHdpcmUgZm9ybWF0IGFuZFxuZW1pdHRlZCB2aWEgSU8gWzRdLlxuXG5UaGVyZSBpcyBhIGZlZWRiYWNrIGxvb3AgdmlhIFs1XSBzaW5jZSBzb21lIGlucHV0IGZyb20gWzFdIHdpbGwgYmUgdGhpbmdzIGxpa2VcbnBpbmcsIHBvbmcgYW5kIGNsb3NlIGZyYW1lcy4gSW4gdGhlc2UgY2FzZXMgdGhlIHByb3RvY29sIHJlc3BvbmRzIGJ5IGVtaXR0aW5nXG5yZXNwb25zZXMgZGlyZWN0bHkgYmFjayB0byBbNF0gcmF0aGVyIHRoYW4gZW1pdHRpbmcgbWVzc2FnZXMgdmlhIFsyXS5cblxuRm9yIHRoZSBwdXJwb3NlcyBvZiBmbG93IGNvbnRyb2wsIHdlIGNvbnNpZGVyIHRoZSBzb3VyY2VzIG9mIGVhY2ggUmVhZGFibGVcbnN0cmVhbSB0byBiZSBhcyBmb2xsb3dzOlxuXG4qIFsyXSByZWNlaXZlcyBpbnB1dCBmcm9tIFsxXVxuKiBbNF0gcmVjZWl2ZXMgaW5wdXQgZnJvbSBbMV0gYW5kIFszXVxuXG5UaGUgY2xhc3NlcyBiZWxvdyBleHByZXNzIHRoZSByZWxhdGlvbnNoaXBzIGRlc2NyaWJlZCBhYm92ZSB3aXRob3V0IHByZXNjcmliaW5nXG5hbnl0aGluZyBhYm91dCBob3cgcGFyc2UoKSBhbmQgZnJhbWUoKSB3b3JrLCBvdGhlciB0aGFuIGFzc3VtaW5nIHRoZXkgZW1pdFxuJ2RhdGEnIGV2ZW50cyB0byB0aGUgSU8gYW5kIE1lc3NhZ2VzIHN0cmVhbXMuIFRoZXkgd2lsbCB3b3JrIHdpdGggYW55IHByb3RvY29sXG5kcml2ZXIgaGF2aW5nIHRoZXNlIHR3byBtZXRob2RzLlxuKiovXG5cblxudmFyIFN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuU3RyZWFtLFxuICAgIHV0aWwgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxudmFyIElPID0gZnVuY3Rpb24oZHJpdmVyKSB7XG4gIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5fcGF1c2VkICA9IGZhbHNlO1xuICB0aGlzLl9kcml2ZXIgID0gZHJpdmVyO1xufTtcbnV0aWwuaW5oZXJpdHMoSU8sIFN0cmVhbSk7XG5cbi8vIFRoZSBJTyBwYXVzZSgpIGFuZCByZXN1bWUoKSBtZXRob2RzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHNvY2tldCB3ZSBhcmVcbi8vIHBpcGluZyB0byBnZXRzIGJhY2tlZCB1cCBhbmQgZHJhaW5zLiBTaW5jZSBJTyBvdXRwdXQgWzRdIGNvbWVzIGZyb20gSU8gaW5wdXRcbi8vIFsxXSBhbmQgTWVzc2FnZXMgaW5wdXQgWzNdLCB3ZSBuZWVkIHRvIHRlbGwgYm90aCBvZiB0aG9zZSB0byByZXR1cm4gZmFsc2Vcbi8vIGZyb20gd3JpdGUoKSB3aGVuIHRoaXMgc3RyZWFtIGlzIHBhdXNlZC5cblxuSU8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIHRoaXMuX2RyaXZlci5tZXNzYWdlcy5fcGF1c2VkID0gdHJ1ZTtcbn07XG5cbklPLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZHJhaW4nKTtcblxuICB2YXIgbWVzc2FnZXMgPSB0aGlzLl9kcml2ZXIubWVzc2FnZXM7XG4gIG1lc3NhZ2VzLl9wYXVzZWQgPSBmYWxzZTtcbiAgbWVzc2FnZXMuZW1pdCgnZHJhaW4nKTtcbn07XG5cbi8vIFdoZW4gd2UgcmVjZWl2ZSBpbnB1dCBmcm9tIGEgc29ja2V0LCBzZW5kIGl0IHRvIHRoZSBwYXJzZXIgYW5kIHRlbGwgdGhlXG4vLyBzb3VyY2Ugd2hldGhlciB0byBiYWNrIG9mZi5cbklPLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIGlmICghdGhpcy53cml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICB0aGlzLl9kcml2ZXIucGFyc2UoY2h1bmspO1xuICByZXR1cm4gIXRoaXMuX3BhdXNlZDtcbn07XG5cbi8vIFRoZSBJTyBlbmQoKSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc29ja2V0IHBpcGluZyBpbnRvIGl0IGVtaXRzXG4vLyAnY2xvc2UnIG9yICdlbmQnLCBpLmUuIHRoZSBzb2NrZXQgaXMgY2xvc2VkLiBJbiB0aGlzIHNpdHVhdGlvbiB0aGUgTWVzc2FnZXNcbi8vIHN0cmVhbSB3aWxsIG5vdCBlbWl0IGFueSBtb3JlIGRhdGEgc28gd2UgZW1pdCAnZW5kJy5cbklPLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaykge1xuICBpZiAoIXRoaXMud3JpdGFibGUpIHJldHVybjtcbiAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmspO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdmFyIG1lc3NhZ2VzID0gdGhpcy5fZHJpdmVyLm1lc3NhZ2VzO1xuICBpZiAobWVzc2FnZXMucmVhZGFibGUpIHtcbiAgICBtZXNzYWdlcy5yZWFkYWJsZSA9IG1lc3NhZ2VzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgbWVzc2FnZXMuZW1pdCgnZW5kJyk7XG4gIH1cbn07XG5cbklPLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW5kKCk7XG59O1xuXG5cbnZhciBNZXNzYWdlcyA9IGZ1bmN0aW9uKGRyaXZlcikge1xuICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuX3BhdXNlZCAgPSBmYWxzZTtcbiAgdGhpcy5fZHJpdmVyICA9IGRyaXZlcjtcbn07XG51dGlsLmluaGVyaXRzKE1lc3NhZ2VzLCBTdHJlYW0pO1xuXG4vLyBUaGUgTWVzc2FnZXMgcGF1c2UoKSBhbmQgcmVzdW1lKCkgbWV0aG9kcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBhcHAgdGhhdCdzXG4vLyBwcm9jZXNzaW5nIHRoZSBtZXNzYWdlcyBnZXRzIGJhY2tlZCB1cCBhbmQgZHJhaW5zLiBJZiB3ZSdyZSBlbWl0dGluZ1xuLy8gbWVzc2FnZXMgdG9vIGZhc3Qgd2Ugc2hvdWxkIHRlbGwgdGhlIHNvdXJjZSB0byBzbG93IGRvd24uIE1lc3NhZ2Ugb3V0cHV0IFsyXVxuLy8gY29tZXMgZnJvbSBJTyBpbnB1dCBbMV0uXG5cbk1lc3NhZ2VzLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9kcml2ZXIuaW8uX3BhdXNlZCA9IHRydWU7XG59O1xuXG5NZXNzYWdlcy5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2RyaXZlci5pby5fcGF1c2VkID0gZmFsc2U7XG4gIHRoaXMuX2RyaXZlci5pby5lbWl0KCdkcmFpbicpO1xufTtcblxuLy8gV2hlbiB3ZSByZWNlaXZlIG1lc3NhZ2VzIGZyb20gdGhlIHVzZXIsIHNlbmQgdGhlbSB0byB0aGUgZm9ybWF0dGVyIGFuZCB0ZWxsXG4vLyB0aGUgc291cmNlIHdoZXRoZXIgdG8gYmFjayBvZmYuXG5NZXNzYWdlcy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGlmICghdGhpcy53cml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB0aGlzLl9kcml2ZXIudGV4dChtZXNzYWdlKTtcbiAgZWxzZSB0aGlzLl9kcml2ZXIuYmluYXJ5KG1lc3NhZ2UpO1xuICByZXR1cm4gIXRoaXMuX3BhdXNlZDtcbn07XG5cbi8vIFRoZSBNZXNzYWdlcyBlbmQoKSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHN0cmVhbSBwaXBpbmcgaW50byBpdCBlbWl0c1xuLy8gJ2VuZCcuIE1hbnkgc3RyZWFtcyBtYXkgYmUgcGlwZWQgaW50byB0aGUgV2ViU29ja2V0IGFuZCBvbmUgb2YgdGhlbSBlbmRpbmdcbi8vIGRvZXMgbm90IG1lYW4gdGhlIHdob2xlIHNvY2tldCBpcyBkb25lLCBzbyBqdXN0IHByb2Nlc3MgdGhlIGlucHV0IGFuZCBtb3ZlXG4vLyBvbiBsZWF2aW5nIHRoZSBzb2NrZXQgb3Blbi5cbk1lc3NhZ2VzLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUobWVzc2FnZSk7XG59O1xuXG5NZXNzYWdlcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge307XG5cblxuZXhwb3J0cy5JTyA9IElPO1xuZXhwb3J0cy5NZXNzYWdlcyA9IE1lc3NhZ2VzO1xuXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyO1xuXG52YXIgU3RyZWFtUmVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3F1ZXVlICAgICA9IFtdO1xuICB0aGlzLl9xdWV1ZVNpemUgPSAwO1xuICB0aGlzLl9vZmZzZXQgICAgPSAwO1xufTtcblxuU3RyZWFtUmVhZGVyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgaWYgKCFidWZmZXIgfHwgYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICB0aGlzLl9xdWV1ZS5wdXNoKGJ1ZmZlcik7XG4gIHRoaXMuX3F1ZXVlU2l6ZSArPSBidWZmZXIubGVuZ3RoO1xufTtcblxuU3RyZWFtUmVhZGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiB0aGlzLl9xdWV1ZVNpemUpIHJldHVybiBudWxsO1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuXG4gIHRoaXMuX3F1ZXVlU2l6ZSAtPSBsZW5ndGg7XG5cbiAgdmFyIHF1ZXVlICA9IHRoaXMuX3F1ZXVlLFxuICAgICAgcmVtYWluID0gbGVuZ3RoLFxuICAgICAgZmlyc3QgID0gcXVldWVbMF0sXG4gICAgICBidWZmZXJzLCBidWZmZXI7XG5cbiAgaWYgKGZpcnN0Lmxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICBpZiAoZmlyc3QubGVuZ3RoID09PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBxdWV1ZS5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBmaXJzdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgcXVldWVbMF0gPSBmaXJzdC5zbGljZShsZW5ndGgpO1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHF1ZXVlLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgIGlmIChyZW1haW4gPCBxdWV1ZVtpXS5sZW5ndGgpIGJyZWFrO1xuICAgIHJlbWFpbiAtPSBxdWV1ZVtpXS5sZW5ndGg7XG4gIH1cbiAgYnVmZmVycyA9IHF1ZXVlLnNwbGljZSgwLCBpKTtcblxuICBpZiAocmVtYWluID4gMCAmJiBxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgYnVmZmVycy5wdXNoKHF1ZXVlWzBdLnNsaWNlKDAsIHJlbWFpbikpO1xuICAgIHF1ZXVlWzBdID0gcXVldWVbMF0uc2xpY2UocmVtYWluKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBsZW5ndGgpO1xufTtcblxuU3RyZWFtUmVhZGVyLnByb3RvdHlwZS5lYWNoQnl0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIHZhciBidWZmZXIsIG4sIGluZGV4O1xuXG4gIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgYnVmZmVyID0gdGhpcy5fcXVldWVbMF07XG4gICAgbiA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgICB3aGlsZSAodGhpcy5fb2Zmc2V0IDwgbikge1xuICAgICAgaW5kZXggPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgYnVmZmVyW2luZGV4XSk7XG4gICAgfVxuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1SZWFkZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQnVmZmVyICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyLFxuICAgIGNyeXB0byAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLFxuICAgIHVybCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICAgIHV0aWwgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIEh0dHBQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSxcbiAgICBCYXNlICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgICBIeWJpICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMiksXG4gICAgUHJveHkgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG52YXIgQ2xpZW50ID0gZnVuY3Rpb24oX3VybCwgb3B0aW9ucykge1xuICB0aGlzLnZlcnNpb24gPSAnaHliaS0nICsgSHliaS5WRVJTSU9OO1xuICBIeWJpLmNhbGwodGhpcywgbnVsbCwgX3VybCwgb3B0aW9ucyk7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gLTE7XG4gIHRoaXMuX2tleSAgICAgICA9IENsaWVudC5nZW5lcmF0ZUtleSgpO1xuICB0aGlzLl9hY2NlcHQgICAgPSBIeWJpLmdlbmVyYXRlQWNjZXB0KHRoaXMuX2tleSk7XG4gIHRoaXMuX2h0dHAgICAgICA9IG5ldyBIdHRwUGFyc2VyKCdyZXNwb25zZScpO1xuXG4gIHZhciB1cmkgID0gdXJsLnBhcnNlKHRoaXMudXJsKSxcbiAgICAgIGF1dGggPSB1cmkuYXV0aCAmJiBCdWZmZXIuZnJvbSh1cmkuYXV0aCwgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgaWYgKHRoaXMuVkFMSURfUFJPVE9DT0xTLmluZGV4T2YodXJpLnByb3RvY29sKSA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudXJsICsgJyBpcyBub3QgYSB2YWxpZCBXZWJTb2NrZXQgVVJMJyk7XG5cbiAgdGhpcy5fcGF0aG5hbWUgPSAodXJpLnBhdGhuYW1lIHx8ICcvJykgKyAodXJpLnNlYXJjaCB8fCAnJyk7XG5cbiAgdGhpcy5faGVhZGVycy5zZXQoJ0hvc3QnLCB1cmkuaG9zdCk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdVcGdyYWRlJywgJ3dlYnNvY2tldCcpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnQ29ubmVjdGlvbicsICdVcGdyYWRlJyk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LUtleScsIHRoaXMuX2tleSk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LVZlcnNpb24nLCBIeWJpLlZFUlNJT04pO1xuXG4gIGlmICh0aGlzLl9wcm90b2NvbHMubGVuZ3RoID4gMClcbiAgICB0aGlzLl9oZWFkZXJzLnNldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcsIHRoaXMuX3Byb3RvY29scy5qb2luKCcsICcpKTtcblxuICBpZiAoYXV0aClcbiAgICB0aGlzLl9oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgYXV0aCk7XG59O1xudXRpbC5pbmhlcml0cyhDbGllbnQsIEh5YmkpO1xuXG5DbGllbnQuZ2VuZXJhdGVLZXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufTtcblxudmFyIGluc3RhbmNlID0ge1xuICBWQUxJRF9QUk9UT0NPTFM6IFsnd3M6JywgJ3dzczonXSxcblxuICBwcm94eTogZnVuY3Rpb24ob3JpZ2luLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCBvcmlnaW4sIG9wdGlvbnMpO1xuICB9LFxuXG4gIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuX3dyaXRlKHRoaXMuX2hhbmRzaGFrZVJlcXVlc3QoKSk7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSAzKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDApIHJldHVybiBIeWJpLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIGNodW5rKTtcblxuICAgIHRoaXMuX2h0dHAucGFyc2UoY2h1bmspO1xuICAgIGlmICghdGhpcy5faHR0cC5pc0NvbXBsZXRlKCkpIHJldHVybjtcblxuICAgIHRoaXMuX3ZhbGlkYXRlSGFuZHNoYWtlKCk7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gMykgcmV0dXJuO1xuXG4gICAgdGhpcy5fb3BlbigpO1xuICAgIHRoaXMucGFyc2UodGhpcy5faHR0cC5ib2R5KTtcbiAgfSxcblxuICBfaGFuZHNoYWtlUmVxdWVzdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4dGVuc2lvbnMgPSB0aGlzLl9leHRlbnNpb25zLmdlbmVyYXRlT2ZmZXIoKTtcbiAgICBpZiAoZXh0ZW5zaW9ucylcbiAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnLCBleHRlbnNpb25zKTtcblxuICAgIHZhciBzdGFydCAgID0gJ0dFVCAnICsgdGhpcy5fcGF0aG5hbWUgKyAnIEhUVFAvMS4xJyxcbiAgICAgICAgaGVhZGVycyA9IFtzdGFydCwgdGhpcy5faGVhZGVycy50b1N0cmluZygpLCAnJ107XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGVhZGVycy5qb2luKCdcXHJcXG4nKSwgJ3V0ZjgnKTtcbiAgfSxcblxuICBfZmFpbEhhbmRzaGFrZTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSAnRXJyb3IgZHVyaW5nIFdlYlNvY2tldCBoYW5kc2hha2U6ICcgKyBtZXNzYWdlO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDM7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG5ldyBCYXNlLkNsb3NlRXZlbnQodGhpcy5FUlJPUlMucHJvdG9jb2xfZXJyb3IsIG1lc3NhZ2UpKTtcbiAgfSxcblxuICBfdmFsaWRhdGVIYW5kc2hha2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHRoaXMuX2h0dHAuc3RhdHVzQ29kZTtcbiAgICB0aGlzLmhlYWRlcnMgICAgPSB0aGlzLl9odHRwLmhlYWRlcnM7XG5cbiAgICBpZiAodGhpcy5faHR0cC5lcnJvcilcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKHRoaXMuX2h0dHAuZXJyb3IubWVzc2FnZSk7XG5cbiAgICBpZiAodGhpcy5faHR0cC5zdGF0dXNDb2RlICE9PSAxMDEpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZSgnVW5leHBlY3RlZCByZXNwb25zZSBjb2RlOiAnICsgdGhpcy5faHR0cC5zdGF0dXNDb2RlKTtcblxuICAgIHZhciBoZWFkZXJzICAgID0gdGhpcy5faHR0cC5oZWFkZXJzLFxuICAgICAgICB1cGdyYWRlICAgID0gaGVhZGVyc1sndXBncmFkZSddIHx8ICcnLFxuICAgICAgICBjb25uZWN0aW9uID0gaGVhZGVyc1snY29ubmVjdGlvbiddIHx8ICcnLFxuICAgICAgICBhY2NlcHQgICAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSB8fCAnJyxcbiAgICAgICAgcHJvdG9jb2wgICA9IGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXSB8fCAnJztcblxuICAgIGlmICh1cGdyYWRlID09PSAnJylcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKFwiJ1VwZ3JhZGUnIGhlYWRlciBpcyBtaXNzaW5nXCIpO1xuICAgIGlmICh1cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoXCInVXBncmFkZScgaGVhZGVyIHZhbHVlIGlzIG5vdCAnV2ViU29ja2V0J1wiKTtcblxuICAgIGlmIChjb25uZWN0aW9uID09PSAnJylcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKFwiJ0Nvbm5lY3Rpb24nIGhlYWRlciBpcyBtaXNzaW5nXCIpO1xuICAgIGlmIChjb25uZWN0aW9uLnRvTG93ZXJDYXNlKCkgIT09ICd1cGdyYWRlJylcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKFwiJ0Nvbm5lY3Rpb24nIGhlYWRlciB2YWx1ZSBpcyBub3QgJ1VwZ3JhZGUnXCIpO1xuXG4gICAgaWYgKGFjY2VwdCAhPT0gdGhpcy5fYWNjZXB0KVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoJ1NlYy1XZWJTb2NrZXQtQWNjZXB0IG1pc21hdGNoJyk7XG5cbiAgICB0aGlzLnByb3RvY29sID0gbnVsbDtcblxuICAgIGlmIChwcm90b2NvbCAhPT0gJycpIHtcbiAgICAgIGlmICh0aGlzLl9wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPCAwKVxuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZSgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMuYWN0aXZhdGUodGhpcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgQ2xpZW50LnByb3RvdHlwZVtrZXldID0gaW5zdGFuY2Vba2V5XTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnQ7XG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cblxudmFyIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5leHBvcnRzLkhUVFBQYXJzZXIgPSBIVFRQUGFyc2VyO1xuZnVuY3Rpb24gSFRUUFBhcnNlcih0eXBlKSB7XG4gIGFzc2VydC5vayh0eXBlID09PSBIVFRQUGFyc2VyLlJFUVVFU1QgfHwgdHlwZSA9PT0gSFRUUFBhcnNlci5SRVNQT05TRSB8fCB0eXBlID09PSB1bmRlZmluZWQpO1xuICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTm9kZSB2MTIrXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pbml0aWFsaXplKHR5cGUpO1xuICB9XG4gIHRoaXMubWF4SGVhZGVyU2l6ZT1IVFRQUGFyc2VyLm1heEhlYWRlclNpemVcbn1cbkhUVFBQYXJzZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAodHlwZSwgYXN5bmNfcmVzb3VyY2UpIHtcbiAgYXNzZXJ0Lm9rKHR5cGUgPT09IEhUVFBQYXJzZXIuUkVRVUVTVCB8fCB0eXBlID09PSBIVFRQUGFyc2VyLlJFU1BPTlNFKTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zdGF0ZSA9IHR5cGUgKyAnX0xJTkUnO1xuICB0aGlzLmluZm8gPSB7XG4gICAgaGVhZGVyczogW10sXG4gICAgdXBncmFkZTogZmFsc2VcbiAgfTtcbiAgdGhpcy50cmFpbGVycyA9IFtdO1xuICB0aGlzLmxpbmUgPSAnJztcbiAgdGhpcy5pc0NodW5rZWQgPSBmYWxzZTtcbiAgdGhpcy5jb25uZWN0aW9uID0gJyc7XG4gIHRoaXMuaGVhZGVyU2l6ZSA9IDA7IC8vIGZvciBwcmV2ZW50aW5nIHRvbyBiaWcgaGVhZGVyc1xuICB0aGlzLmJvZHlfYnl0ZXMgPSBudWxsO1xuICB0aGlzLmlzVXNlckNhbGwgPSBmYWxzZTtcbiAgdGhpcy5oYWRFcnJvciA9IGZhbHNlO1xufTtcblxuSFRUUFBhcnNlci5lbmNvZGluZyA9ICdhc2NpaSc7XG5IVFRQUGFyc2VyLm1heEhlYWRlclNpemUgPSA4MCAqIDEwMjQ7IC8vIG1heEhlYWRlclNpemUgKGluIGJ5dGVzKSBpcyBjb25maWd1cmFibGUsIGJ1dCA4MGtiIGJ5IGRlZmF1bHQ7XG5IVFRQUGFyc2VyLlJFUVVFU1QgPSAnUkVRVUVTVCc7XG5IVFRQUGFyc2VyLlJFU1BPTlNFID0gJ1JFU1BPTlNFJztcblxuLy8gTm90ZTogKm5vdCogc3RhcnRpbmcgd2l0aCBrT25IZWFkZXJzPTAgbGluZSB0aGUgTm9kZSBwYXJzZXIsIGJlY2F1c2UgYW55XG4vLyAgIG5ld2x5IGFkZGVkIGNvbnN0YW50cyAoa09uVGltZW91dCBpbiBOb2RlIHYxMi4xOS4wKSB3aWxsIG92ZXJ3cml0ZSAwIVxudmFyIGtPbkhlYWRlcnMgPSBIVFRQUGFyc2VyLmtPbkhlYWRlcnMgPSAxO1xudmFyIGtPbkhlYWRlcnNDb21wbGV0ZSA9IEhUVFBQYXJzZXIua09uSGVhZGVyc0NvbXBsZXRlID0gMjtcbnZhciBrT25Cb2R5ID0gSFRUUFBhcnNlci5rT25Cb2R5ID0gMztcbnZhciBrT25NZXNzYWdlQ29tcGxldGUgPSBIVFRQUGFyc2VyLmtPbk1lc3NhZ2VDb21wbGV0ZSA9IDQ7XG5cbi8vIFNvbWUgaGFuZGxlciBzdHVicywgbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XG5IVFRQUGFyc2VyLnByb3RvdHlwZVtrT25IZWFkZXJzXSA9XG5IVFRQUGFyc2VyLnByb3RvdHlwZVtrT25IZWFkZXJzQ29tcGxldGVdID1cbkhUVFBQYXJzZXIucHJvdG90eXBlW2tPbkJvZHldID1cbkhUVFBQYXJzZXIucHJvdG90eXBlW2tPbk1lc3NhZ2VDb21wbGV0ZV0gPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGNvbXBhdE1vZGUwXzEyID0gdHJ1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVFRQUGFyc2VyLCAna09uRXhlY3V0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGhhY2sgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIGNvbXBhdE1vZGUwXzEyID0gZmFsc2U7XG4gICAgICByZXR1cm4gOTk7XG4gICAgfVxuICB9KTtcblxudmFyIG1ldGhvZHMgPSBleHBvcnRzLm1ldGhvZHMgPSBIVFRQUGFyc2VyLm1ldGhvZHMgPSBbXG4gICdERUxFVEUnLFxuICAnR0VUJyxcbiAgJ0hFQUQnLFxuICAnUE9TVCcsXG4gICdQVVQnLFxuICAnQ09OTkVDVCcsXG4gICdPUFRJT05TJyxcbiAgJ1RSQUNFJyxcbiAgJ0NPUFknLFxuICAnTE9DSycsXG4gICdNS0NPTCcsXG4gICdNT1ZFJyxcbiAgJ1BST1BGSU5EJyxcbiAgJ1BST1BQQVRDSCcsXG4gICdTRUFSQ0gnLFxuICAnVU5MT0NLJyxcbiAgJ0JJTkQnLFxuICAnUkVCSU5EJyxcbiAgJ1VOQklORCcsXG4gICdBQ0wnLFxuICAnUkVQT1JUJyxcbiAgJ01LQUNUSVZJVFknLFxuICAnQ0hFQ0tPVVQnLFxuICAnTUVSR0UnLFxuICAnTS1TRUFSQ0gnLFxuICAnTk9USUZZJyxcbiAgJ1NVQlNDUklCRScsXG4gICdVTlNVQlNDUklCRScsXG4gICdQQVRDSCcsXG4gICdQVVJHRScsXG4gICdNS0NBTEVOREFSJyxcbiAgJ0xJTksnLFxuICAnVU5MSU5LJyxcbiAgJ1NPVVJDRScsXG5dO1xudmFyIG1ldGhvZF9jb25uZWN0ID0gbWV0aG9kcy5pbmRleE9mKCdDT05ORUNUJyk7XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5yZWluaXRpYWxpemUgPSBIVFRQUGFyc2VyO1xuSFRUUFBhcnNlci5wcm90b3R5cGUuY2xvc2UgPVxuSFRUUFBhcnNlci5wcm90b3R5cGUucGF1c2UgPVxuSFRUUFBhcnNlci5wcm90b3R5cGUucmVzdW1lID1cbkhUVFBQYXJzZXIucHJvdG90eXBlLmZyZWUgPSBmdW5jdGlvbiAoKSB7fTtcbkhUVFBQYXJzZXIucHJvdG90eXBlLl9jb21wYXRNb2RlMF8xMSA9IGZhbHNlO1xuSFRUUFBhcnNlci5wcm90b3R5cGUuZ2V0QXN5bmNJZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxudmFyIGhlYWRlclN0YXRlID0ge1xuICBSRVFVRVNUX0xJTkU6IHRydWUsXG4gIFJFU1BPTlNFX0xJTkU6IHRydWUsXG4gIEhFQURFUjogdHJ1ZVxufTtcbkhUVFBQYXJzZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoY2h1bmssIHN0YXJ0LCBsZW5ndGgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhUVFBQYXJzZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgSFRUUFBhcnNlcicpO1xuICB9XG5cbiAgLy8gYmFja3dhcmQgY29tcGF0IHRvIG5vZGUgPCAwLjExLjRcbiAgLy8gTm90ZTogdGhlIHN0YXJ0IGFuZCBsZW5ndGggcGFyYW1zIHdlcmUgcmVtb3ZlZCBpbiBuZXdlciB2ZXJzaW9uXG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgbGVuZ3RoID0gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgPyBsZW5ndGggOiBjaHVuay5sZW5ndGg7XG5cbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLm9mZnNldCA9IHN0YXJ0O1xuICB2YXIgZW5kID0gdGhpcy5lbmQgPSBzdGFydCArIGxlbmd0aDtcbiAgdHJ5IHtcbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCBlbmQpIHtcbiAgICAgIGlmICh0aGlzW3RoaXMuc3RhdGVdKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodGhpcy5pc1VzZXJDYWxsKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRoaXMuaGFkRXJyb3IgPSB0cnVlO1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgdGhpcy5jaHVuayA9IG51bGw7XG4gIGxlbmd0aCA9IHRoaXMub2Zmc2V0IC0gc3RhcnQ7XG4gIGlmIChoZWFkZXJTdGF0ZVt0aGlzLnN0YXRlXSkge1xuICAgIHRoaXMuaGVhZGVyU2l6ZSArPSBsZW5ndGg7XG4gICAgaWYgKHRoaXMuaGVhZGVyU2l6ZSA+ICh0aGlzLm1heEhlYWRlclNpemV8fEhUVFBQYXJzZXIubWF4SGVhZGVyU2l6ZSkpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ21heCBoZWFkZXIgc2l6ZSBleGNlZWRlZCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufTtcblxudmFyIHN0YXRlRmluaXNoQWxsb3dlZCA9IHtcbiAgUkVRVUVTVF9MSU5FOiB0cnVlLFxuICBSRVNQT05TRV9MSU5FOiB0cnVlLFxuICBCT0RZX1JBVzogdHJ1ZVxufTtcbkhUVFBQYXJzZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaGFkRXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFzdGF0ZUZpbmlzaEFsbG93ZWRbdGhpcy5zdGF0ZV0pIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlIGZvciBFT0YnKTtcbiAgfVxuICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0JPRFlfUkFXJykge1xuICAgIHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbk1lc3NhZ2VDb21wbGV0ZV0oKSk7XG4gIH1cbn07XG5cbi8vIFRoZXNlIHRocmVlIG1ldGhvZHMgYXJlIHVzZWQgZm9yIGFuIGludGVybmFsIHNwZWVkIG9wdGltaXphdGlvbiwgYW5kIGl0IGFsc29cbi8vIHdvcmtzIGlmIHRoZXNlcyBhcmUgbm9vcHMuIEJhc2ljYWxseSBjb25zdW1lKCkgYXNrcyB1cyB0byByZWFkIHRoZSBieXRlc1xuLy8gb3Vyc2VsdmVzLCBidXQgaWYgd2UgZG9uJ3QgZG8gaXQgd2UgZ2V0IHRoZW0gdGhyb3VnaCBleGVjdXRlKCkuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lID1cbkhUVFBQYXJzZXIucHJvdG90eXBlLnVuY29uc3VtZSA9XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5nZXRDdXJyZW50QnVmZmVyID0gZnVuY3Rpb24gKCkge307XG5cbi8vRm9yIGNvcnJlY3QgZXJyb3IgaGFuZGxpbmcgLSBzZWUgSFRUUFBhcnNlciNleGVjdXRlXG4vL1VzYWdlOiB0aGlzLnVzZXJDYWxsKCkodXNlckZ1bmN0aW9uKCdhcmcnKSk7XG5IVFRQUGFyc2VyLnByb3RvdHlwZS51c2VyQ2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pc1VzZXJDYWxsID0gdHJ1ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKHJldCkge1xuICAgIHNlbGYuaXNVc2VyQ2FsbCA9IGZhbHNlO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG59O1xuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5uZXh0UmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy51c2VyQ2FsbCgpKHRoaXNba09uTWVzc2FnZUNvbXBsZXRlXSgpKTtcbiAgdGhpcy5yZWluaXRpYWxpemUodGhpcy50eXBlKTtcbn07XG5cbkhUVFBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVMaW5lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW5kID0gdGhpcy5lbmQsXG4gICAgICBjaHVuayA9IHRoaXMuY2h1bms7XG4gIGZvciAodmFyIGkgPSB0aGlzLm9mZnNldDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGNodW5rW2ldID09PSAweDBhKSB7IC8vIFxcblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmUgKyBjaHVuay50b1N0cmluZyhIVFRQUGFyc2VyLmVuY29kaW5nLCB0aGlzLm9mZnNldCwgaSk7XG4gICAgICBpZiAobGluZS5jaGFyQXQobGluZS5sZW5ndGggLSAxKSA9PT0gJ1xccicpIHtcbiAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmUgPSAnJztcbiAgICAgIHRoaXMub2Zmc2V0ID0gaSArIDE7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gIH1cbiAgLy9saW5lIHNwbGl0IG92ZXIgbXVsdGlwbGUgY2h1bmtzXG4gIHRoaXMubGluZSArPSBjaHVuay50b1N0cmluZyhIVFRQUGFyc2VyLmVuY29kaW5nLCB0aGlzLm9mZnNldCwgdGhpcy5lbmQpO1xuICB0aGlzLm9mZnNldCA9IHRoaXMuZW5kO1xufTtcblxudmFyIGhlYWRlckV4cCA9IC9eKFteOiBcXHRdKyk6WyBcXHRdKigoPzouKlteIFxcdF0pfCkvO1xudmFyIGhlYWRlckNvbnRpbnVlRXhwID0gL15bIFxcdF0rKC4qW14gXFx0XSkvO1xuSFRUUFBhcnNlci5wcm90b3R5cGUucGFyc2VIZWFkZXIgPSBmdW5jdGlvbiAobGluZSwgaGVhZGVycykge1xuICBpZiAobGluZS5pbmRleE9mKCdcXHInKSAhPT0gLTEpIHtcbiAgICB0aHJvdyBwYXJzZUVycm9yQ29kZSgnSFBFX0xGX0VYUEVDVEVEJyk7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBoZWFkZXJFeHAuZXhlYyhsaW5lKTtcbiAgdmFyIGsgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgaWYgKGspIHsgLy8gc2tpcCBlbXB0eSBzdHJpbmcgKG1hbGZvcm1lZCBoZWFkZXIpXG4gICAgaGVhZGVycy5wdXNoKGspO1xuICAgIGhlYWRlcnMucHVzaChtYXRjaFsyXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1hdGNoQ29udGludWUgPSBoZWFkZXJDb250aW51ZUV4cC5leGVjKGxpbmUpO1xuICAgIGlmIChtYXRjaENvbnRpbnVlICYmIGhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICBpZiAoaGVhZGVyc1toZWFkZXJzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGhlYWRlcnNbaGVhZGVycy5sZW5ndGggLSAxXSArPSAnICc7XG4gICAgICB9XG4gICAgICBoZWFkZXJzW2hlYWRlcnMubGVuZ3RoIC0gMV0gKz0gbWF0Y2hDb250aW51ZVsxXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZXF1ZXN0RXhwID0gL14oW0EtWi1dKykgKFteIF0rKSBIVFRQXFwvKFxcZClcXC4oXFxkKSQvO1xuSFRUUFBhcnNlci5wcm90b3R5cGUuUkVRVUVTVF9MSU5FID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGluZSA9IHRoaXMuY29uc3VtZUxpbmUoKTtcbiAgaWYgKCFsaW5lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IHJlcXVlc3RFeHAuZXhlYyhsaW5lKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgdGhyb3cgcGFyc2VFcnJvckNvZGUoJ0hQRV9JTlZBTElEX0NPTlNUQU5UJyk7XG4gIH1cbiAgdGhpcy5pbmZvLm1ldGhvZCA9IHRoaXMuX2NvbXBhdE1vZGUwXzExID8gbWF0Y2hbMV0gOiBtZXRob2RzLmluZGV4T2YobWF0Y2hbMV0pO1xuICBpZiAodGhpcy5pbmZvLm1ldGhvZCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVxdWVzdCBtZXRob2QnKTtcbiAgfVxuICB0aGlzLmluZm8udXJsID0gbWF0Y2hbMl07XG4gIHRoaXMuaW5mby52ZXJzaW9uTWFqb3IgPSArbWF0Y2hbM107XG4gIHRoaXMuaW5mby52ZXJzaW9uTWlub3IgPSArbWF0Y2hbNF07XG4gIHRoaXMuYm9keV9ieXRlcyA9IDA7XG4gIHRoaXMuc3RhdGUgPSAnSEVBREVSJztcbn07XG5cbnZhciByZXNwb25zZUV4cCA9IC9eSFRUUFxcLyhcXGQpXFwuKFxcZCkgKFxcZHszfSkgPyguKikkLztcbkhUVFBQYXJzZXIucHJvdG90eXBlLlJFU1BPTlNFX0xJTkUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAoIWxpbmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gcmVzcG9uc2VFeHAuZXhlYyhsaW5lKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgdGhyb3cgcGFyc2VFcnJvckNvZGUoJ0hQRV9JTlZBTElEX0NPTlNUQU5UJyk7XG4gIH1cbiAgdGhpcy5pbmZvLnZlcnNpb25NYWpvciA9ICttYXRjaFsxXTtcbiAgdGhpcy5pbmZvLnZlcnNpb25NaW5vciA9ICttYXRjaFsyXTtcbiAgdmFyIHN0YXR1c0NvZGUgPSB0aGlzLmluZm8uc3RhdHVzQ29kZSA9ICttYXRjaFszXTtcbiAgdGhpcy5pbmZvLnN0YXR1c01lc3NhZ2UgPSBtYXRjaFs0XTtcbiAgLy8gSW1wbGllZCB6ZXJvIGxlbmd0aC5cbiAgaWYgKChzdGF0dXNDb2RlIC8gMTAwIHwgMCkgPT09IDEgfHwgc3RhdHVzQ29kZSA9PT0gMjA0IHx8IHN0YXR1c0NvZGUgPT09IDMwNCkge1xuICAgIHRoaXMuYm9keV9ieXRlcyA9IDA7XG4gIH1cbiAgdGhpcy5zdGF0ZSA9ICdIRUFERVInO1xufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuc2hvdWxkS2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pbmZvLnZlcnNpb25NYWpvciA+IDAgJiYgdGhpcy5pbmZvLnZlcnNpb25NaW5vciA+IDApIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLmluZGV4T2YoJ2Nsb3NlJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuY29ubmVjdGlvbi5pbmRleE9mKCdrZWVwLWFsaXZlJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLmJvZHlfYnl0ZXMgIT09IG51bGwgfHwgdGhpcy5pc0NodW5rZWQpIHsgLy8gfHwgc2tpcEJvZHlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5IRUFERVIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbmZvID0gdGhpcy5pbmZvO1xuICBpZiAobGluZSkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIobGluZSwgaW5mby5oZWFkZXJzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaGVhZGVycyA9IGluZm8uaGVhZGVycztcbiAgICB2YXIgaGFzQ29udGVudExlbmd0aCA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50Q29udGVudExlbmd0aFZhbHVlO1xuICAgIHZhciBoYXNVcGdyYWRlSGVhZGVyID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBzd2l0Y2ggKGhlYWRlcnNbaV0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICd0cmFuc2Zlci1lbmNvZGluZyc6XG4gICAgICAgICAgdGhpcy5pc0NodW5rZWQgPSBoZWFkZXJzW2kgKyAxXS50b0xvd2VyQ2FzZSgpID09PSAnY2h1bmtlZCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbnRlbnQtbGVuZ3RoJzpcbiAgICAgICAgICBjdXJyZW50Q29udGVudExlbmd0aFZhbHVlID0gK2hlYWRlcnNbaSArIDFdO1xuICAgICAgICAgIGlmIChoYXNDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBGaXggZHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoIGhlYWRlciB3aXRoIHNhbWUgdmFsdWVzLlxuICAgICAgICAgICAgLy8gVGhyb3cgZXJyb3Igb25seSBpZiB2YWx1ZXMgYXJlIGRpZmZlcmVudC5cbiAgICAgICAgICAgIC8vIEtub3duIGlzc3VlczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZXF1ZXN0L3JlcXVlc3QvaXNzdWVzLzIwOTEjaXNzdWVjb21tZW50LTMyODcxNTExM1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy82NTE3I2lzc3VlY29tbWVudC0yMTYyNjM3NzFcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGVudExlbmd0aFZhbHVlICE9PSB0aGlzLmJvZHlfYnl0ZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcGFyc2VFcnJvckNvZGUoJ0hQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc0NvbnRlbnRMZW5ndGggPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ib2R5X2J5dGVzID0gY3VycmVudENvbnRlbnRMZW5ndGhWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Nvbm5lY3Rpb24nOlxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiArPSBoZWFkZXJzW2kgKyAxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1cGdyYWRlJzpcbiAgICAgICAgICBoYXNVcGdyYWRlSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBib3RoIGlzQ2h1bmtlZCBhbmQgaGFzQ29udGVudExlbmd0aCwgaXNDaHVua2VkIHdpbnNcbiAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIHNvIHRoZSBib2R5IGlzIHBhcnNlZCB1c2luZyB0aGUgY2h1bmtlZCBtZXRob2QsIGFuZCBtYXRjaGVzXG4gICAgLy8gQ2hyb21lJ3MgYmVoYXZpb3IuICBXZSBjb3VsZCwgbWF5YmUsIGlnbm9yZSB0aGVtIGJvdGggKHdvdWxkIGdldCBjaHVua2VkXG4gICAgLy8gZW5jb2RpbmcgaW50byB0aGUgYm9keSksIGFuZC9vciBkaXNhYmxlIHNob3VsZEtlZXBBbGl2ZSB0byBiZSBtb3JlXG4gICAgLy8gcmVzaWxpZW50LlxuICAgIGlmICh0aGlzLmlzQ2h1bmtlZCAmJiBoYXNDb250ZW50TGVuZ3RoKSB7XG4gICAgICBoYXNDb250ZW50TGVuZ3RoID0gZmFsc2U7XG4gICAgICB0aGlzLmJvZHlfYnl0ZXMgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIExvZ2ljIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9odHRwLXBhcnNlci9ibG9iLzkyMWQ1NTg1NTE1YTE1M2ZhMDBlNDExY2YxNDQyODBjNTliNDFmOTAvaHR0cF9wYXJzZXIuYyNMMTcyNy1MMTczN1xuICAgIC8vIFwiRm9yIHJlc3BvbnNlcywgXCJVcGdyYWRlOiBmb29cIiBhbmQgXCJDb25uZWN0aW9uOiB1cGdyYWRlXCIgYXJlXG4gICAgLy8gICBtYW5kYXRvcnkgb25seSB3aGVuIGl0IGlzIGEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMgcmVzcG9uc2UsXG4gICAgLy8gICBvdGhlcndpc2UgaXQgaXMgcHVyZWx5IGluZm9ybWF0aW9uYWwsIHRvIGFubm91bmNlIHN1cHBvcnQuXG4gICAgaWYgKGhhc1VwZ3JhZGVIZWFkZXIgJiYgdGhpcy5jb25uZWN0aW9uLmluZGV4T2YoJ3VwZ3JhZGUnKSAhPSAtMSkge1xuICAgICAgaW5mby51cGdyYWRlID0gdGhpcy50eXBlID09PSBIVFRQUGFyc2VyLlJFUVVFU1QgfHwgaW5mby5zdGF0dXNDb2RlID09PSAxMDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8udXBncmFkZSA9IGluZm8ubWV0aG9kID09PSBtZXRob2RfY29ubmVjdDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NodW5rZWQgJiYgaW5mby51cGdyYWRlKSB7XG4gICAgICB0aGlzLmlzQ2h1bmtlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGluZm8uc2hvdWxkS2VlcEFsaXZlID0gdGhpcy5zaG91bGRLZWVwQWxpdmUoKTtcbiAgICAvL3Byb2JsZW0gd2hpY2ggYWxzbyBleGlzdHMgaW4gb3JpZ2luYWwgbm9kZTogd2Ugc2hvdWxkIGtub3cgc2tpcEJvZHkgYmVmb3JlIGNhbGxpbmcgb25IZWFkZXJzQ29tcGxldGVcbiAgICB2YXIgc2tpcEJvZHk7XG4gICAgaWYgKGNvbXBhdE1vZGUwXzEyKSB7XG4gICAgICBza2lwQm9keSA9IHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbkhlYWRlcnNDb21wbGV0ZV0oaW5mbykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBza2lwQm9keSA9IHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbkhlYWRlcnNDb21wbGV0ZV0oaW5mby52ZXJzaW9uTWFqb3IsXG4gICAgICAgICAgaW5mby52ZXJzaW9uTWlub3IsIGluZm8uaGVhZGVycywgaW5mby5tZXRob2QsIGluZm8udXJsLCBpbmZvLnN0YXR1c0NvZGUsXG4gICAgICAgICAgaW5mby5zdGF0dXNNZXNzYWdlLCBpbmZvLnVwZ3JhZGUsIGluZm8uc2hvdWxkS2VlcEFsaXZlKSk7XG4gICAgfVxuICAgIGlmIChza2lwQm9keSA9PT0gMikge1xuICAgICAgdGhpcy5uZXh0UmVxdWVzdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2h1bmtlZCAmJiAhc2tpcEJvZHkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAnQk9EWV9DSFVOS0hFQUQnO1xuICAgIH0gZWxzZSBpZiAoc2tpcEJvZHkgfHwgdGhpcy5ib2R5X2J5dGVzID09PSAwKSB7XG4gICAgICB0aGlzLm5leHRSZXF1ZXN0KCk7XG4gICAgICAvLyBGb3Igb2xkZXIgdmVyc2lvbnMgb2Ygbm9kZSAodjYueCBhbmQgb2xkZXI/KSwgdGhhdCByZXR1cm4gc2tpcEJvZHk9MSBvciBza2lwQm9keT10cnVlLFxuICAgICAgLy8gICBuZWVkIHRoaXMgXCJyZXR1cm4gdHJ1ZTtcIiBpZiBpdCdzIGFuIHVwZ3JhZGUgcmVxdWVzdC5cbiAgICAgIHJldHVybiBpbmZvLnVwZ3JhZGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJvZHlfYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAnQk9EWV9SQVcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gJ0JPRFlfU0laRUQnO1xuICAgIH1cbiAgfVxufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9DSFVOS0hFQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuYm9keV9ieXRlcyA9IHBhcnNlSW50KGxpbmUsIDE2KTtcbiAgaWYgKCF0aGlzLmJvZHlfYnl0ZXMpIHtcbiAgICB0aGlzLnN0YXRlID0gJ0JPRFlfQ0hVTktUUkFJTEVSUyc7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGF0ZSA9ICdCT0RZX0NIVU5LJztcbiAgfVxufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9DSFVOSyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHRoaXMuZW5kIC0gdGhpcy5vZmZzZXQsIHRoaXMuYm9keV9ieXRlcyk7XG4gIHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbkJvZHldKHRoaXMuY2h1bmssIHRoaXMub2Zmc2V0LCBsZW5ndGgpKTtcbiAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICB0aGlzLmJvZHlfYnl0ZXMgLT0gbGVuZ3RoO1xuICBpZiAoIXRoaXMuYm9keV9ieXRlcykge1xuICAgIHRoaXMuc3RhdGUgPSAnQk9EWV9DSFVOS0VNUFRZTElORSc7XG4gIH1cbn07XG5cbkhUVFBQYXJzZXIucHJvdG90eXBlLkJPRFlfQ0hVTktFTVBUWUxJTkUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydC5lcXVhbChsaW5lLCAnJyk7XG4gIHRoaXMuc3RhdGUgPSAnQk9EWV9DSFVOS0hFQUQnO1xufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9DSFVOS1RSQUlMRVJTID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGluZSA9IHRoaXMuY29uc3VtZUxpbmUoKTtcbiAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobGluZSkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIobGluZSwgdGhpcy50cmFpbGVycyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMudHJhaWxlcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVzZXJDYWxsKCkodGhpc1trT25IZWFkZXJzXSh0aGlzLnRyYWlsZXJzLCAnJykpO1xuICAgIH1cbiAgICB0aGlzLm5leHRSZXF1ZXN0KCk7XG4gIH1cbn07XG5cbkhUVFBQYXJzZXIucHJvdG90eXBlLkJPRFlfUkFXID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5lbmQgLSB0aGlzLm9mZnNldDtcbiAgdGhpcy51c2VyQ2FsbCgpKHRoaXNba09uQm9keV0odGhpcy5jaHVuaywgdGhpcy5vZmZzZXQsIGxlbmd0aCkpO1xuICB0aGlzLm9mZnNldCA9IHRoaXMuZW5kO1xufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9TSVpFRCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHRoaXMuZW5kIC0gdGhpcy5vZmZzZXQsIHRoaXMuYm9keV9ieXRlcyk7XG4gIHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbkJvZHldKHRoaXMuY2h1bmssIHRoaXMub2Zmc2V0LCBsZW5ndGgpKTtcbiAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICB0aGlzLmJvZHlfYnl0ZXMgLT0gbGVuZ3RoO1xuICBpZiAoIXRoaXMuYm9keV9ieXRlcykge1xuICAgIHRoaXMubmV4dFJlcXVlc3QoKTtcbiAgfVxufTtcblxuLy8gYmFja3dhcmQgY29tcGF0IHRvIG5vZGUgPCAwLjExLjZcblsnSGVhZGVycycsICdIZWFkZXJzQ29tcGxldGUnLCAnQm9keScsICdNZXNzYWdlQ29tcGxldGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBrID0gSFRUUFBhcnNlclsna09uJyArIG5hbWVdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRUUFBhcnNlci5wcm90b3R5cGUsICdvbicgKyBuYW1lLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1trXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHRvKSB7XG4gICAgICAvLyBoYWNrIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICB0aGlzLl9jb21wYXRNb2RlMF8xMSA9IHRydWU7XG4gICAgICBtZXRob2RfY29ubmVjdCA9ICdDT05ORUNUJztcbiAgICAgIHJldHVybiAodGhpc1trXSA9IHRvKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIHBhcnNlRXJyb3JDb2RlKGNvZGUpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUGFyc2UgRXJyb3InKTtcbiAgZXJyLmNvZGUgPSBjb2RlO1xuICByZXR1cm4gZXJyO1xufVxuXG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBQYXJzZXIgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzApLFxuICAgIFBpcGVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cbnZhciBFeHRlbnNpb25zID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3JzdjEgPSB0aGlzLl9yc3YyID0gdGhpcy5fcnN2MyA9IG51bGw7XG5cbiAgdGhpcy5fYnlOYW1lICAgPSB7fTtcbiAgdGhpcy5faW5PcmRlciAgPSBbXTtcbiAgdGhpcy5fc2Vzc2lvbnMgPSBbXTtcbiAgdGhpcy5faW5kZXggICAgPSB7fTtcbn07XG5cbkV4dGVuc2lvbnMuTUVTU0FHRV9PUENPREVTID0gWzEsIDJdO1xuXG52YXIgaW5zdGFuY2UgPSB7XG4gIGFkZDogZnVuY3Rpb24oZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBleHQubmFtZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4dGVuc2lvbi5uYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICBpZiAoZXh0LnR5cGUgIT09ICdwZXJtZXNzYWdlJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0ZW5zaW9uLnR5cGUgbXVzdCBiZSBcInBlcm1lc3NhZ2VcIicpO1xuXG4gICAgaWYgKHR5cGVvZiBleHQucnN2MSAhPT0gJ2Jvb2xlYW4nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHRlbnNpb24ucnN2MSBtdXN0IGJlIHRydWUgb3IgZmFsc2UnKTtcbiAgICBpZiAodHlwZW9mIGV4dC5yc3YyICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4dGVuc2lvbi5yc3YyIG11c3QgYmUgdHJ1ZSBvciBmYWxzZScpO1xuICAgIGlmICh0eXBlb2YgZXh0LnJzdjMgIT09ICdib29sZWFuJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0ZW5zaW9uLnJzdjMgbXVzdCBiZSB0cnVlIG9yIGZhbHNlJyk7XG5cbiAgICBpZiAodGhpcy5fYnlOYW1lLmhhc093blByb3BlcnR5KGV4dC5uYW1lKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FuIGV4dGVuc2lvbiB3aXRoIG5hbWUgXCInICsgZXh0Lm5hbWUgKyAnXCIgaXMgYWxyZWFkeSByZWdpc3RlcmVkJyk7XG5cbiAgICB0aGlzLl9ieU5hbWVbZXh0Lm5hbWVdID0gZXh0O1xuICAgIHRoaXMuX2luT3JkZXIucHVzaChleHQpO1xuICB9LFxuXG4gIGdlbmVyYXRlT2ZmZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZXNzaW9ucyA9IFtdLFxuICAgICAgICBvZmZlciAgICA9IFtdLFxuICAgICAgICBpbmRleCAgICA9IHt9O1xuXG4gICAgdGhpcy5faW5PcmRlci5mb3JFYWNoKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgdmFyIHNlc3Npb24gPSBleHQuY3JlYXRlQ2xpZW50U2Vzc2lvbigpO1xuICAgICAgaWYgKCFzZXNzaW9uKSByZXR1cm47XG5cbiAgICAgIHZhciByZWNvcmQgPSBbZXh0LCBzZXNzaW9uXTtcbiAgICAgIHNlc3Npb25zLnB1c2gocmVjb3JkKTtcbiAgICAgIGluZGV4W2V4dC5uYW1lXSA9IHJlY29yZDtcblxuICAgICAgdmFyIG9mZmVycyA9IHNlc3Npb24uZ2VuZXJhdGVPZmZlcigpO1xuICAgICAgb2ZmZXJzID0gb2ZmZXJzID8gW10uY29uY2F0KG9mZmVycykgOiBbXTtcblxuICAgICAgb2ZmZXJzLmZvckVhY2goZnVuY3Rpb24ob2ZmKSB7XG4gICAgICAgIG9mZmVyLnB1c2goUGFyc2VyLnNlcmlhbGl6ZVBhcmFtcyhleHQubmFtZSwgb2ZmKSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX3Nlc3Npb25zID0gc2Vzc2lvbnM7XG4gICAgdGhpcy5faW5kZXggICAgPSBpbmRleDtcblxuICAgIHJldHVybiBvZmZlci5sZW5ndGggPiAwID8gb2ZmZXIuam9pbignLCAnKSA6IG51bGw7XG4gIH0sXG5cbiAgYWN0aXZhdGU6IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIHZhciByZXNwb25zZXMgPSBQYXJzZXIucGFyc2VIZWFkZXIoaGVhZGVyKSxcbiAgICAgICAgc2Vzc2lvbnMgID0gW107XG5cbiAgICByZXNwb25zZXMuZWFjaE9mZmVyKGZ1bmN0aW9uKG5hbWUsIHBhcmFtcykge1xuICAgICAgdmFyIHJlY29yZCA9IHRoaXMuX2luZGV4W25hbWVdO1xuXG4gICAgICBpZiAoIXJlY29yZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgc2VudCBhbiBleHRlbnNpb24gcmVzcG9uc2UgZm9yIHVua25vd24gZXh0ZW5zaW9uIFwiJyArIG5hbWUgKyAnXCInKTtcblxuICAgICAgdmFyIGV4dCAgICAgID0gcmVjb3JkWzBdLFxuICAgICAgICAgIHNlc3Npb24gID0gcmVjb3JkWzFdLFxuICAgICAgICAgIHJlc2VydmVkID0gdGhpcy5fcmVzZXJ2ZWQoZXh0KTtcblxuICAgICAgaWYgKHJlc2VydmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBzZW50IHR3byBleHRlbnNpb24gcmVzcG9uc2VzIHRoYXQgdXNlIHRoZSBSU1YnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2VydmVkWzBdICsgJyBiaXQ6IFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNlcnZlZFsxXSArICdcIiBhbmQgXCInICsgZXh0Lm5hbWUgKyAnXCInKTtcblxuICAgICAgaWYgKHNlc3Npb24uYWN0aXZhdGUocGFyYW1zKSAhPT0gdHJ1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgc2VudCB1bmFjY2VwdGFibGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgUGFyc2VyLnNlcmlhbGl6ZVBhcmFtcyhuYW1lLCBwYXJhbXMpKTtcblxuICAgICAgdGhpcy5fcmVzZXJ2ZShleHQpO1xuICAgICAgc2Vzc2lvbnMucHVzaChyZWNvcmQpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fc2Vzc2lvbnMgPSBzZXNzaW9ucztcbiAgICB0aGlzLl9waXBlbGluZSA9IG5ldyBQaXBlbGluZShzZXNzaW9ucyk7XG4gIH0sXG5cbiAgZ2VuZXJhdGVSZXNwb25zZTogZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgdmFyIHNlc3Npb25zID0gW10sXG4gICAgICAgIHJlc3BvbnNlID0gW10sXG4gICAgICAgIG9mZmVycyAgID0gUGFyc2VyLnBhcnNlSGVhZGVyKGhlYWRlcik7XG5cbiAgICB0aGlzLl9pbk9yZGVyLmZvckVhY2goZnVuY3Rpb24oZXh0KSB7XG4gICAgICB2YXIgb2ZmZXIgPSBvZmZlcnMuYnlOYW1lKGV4dC5uYW1lKTtcbiAgICAgIGlmIChvZmZlci5sZW5ndGggPT09IDAgfHwgdGhpcy5fcmVzZXJ2ZWQoZXh0KSkgcmV0dXJuO1xuXG4gICAgICB2YXIgc2Vzc2lvbiA9IGV4dC5jcmVhdGVTZXJ2ZXJTZXNzaW9uKG9mZmVyKTtcbiAgICAgIGlmICghc2Vzc2lvbikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9yZXNlcnZlKGV4dCk7XG4gICAgICBzZXNzaW9ucy5wdXNoKFtleHQsIHNlc3Npb25dKTtcbiAgICAgIHJlc3BvbnNlLnB1c2goUGFyc2VyLnNlcmlhbGl6ZVBhcmFtcyhleHQubmFtZSwgc2Vzc2lvbi5nZW5lcmF0ZVJlc3BvbnNlKCkpKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX3Nlc3Npb25zID0gc2Vzc2lvbnM7XG4gICAgdGhpcy5fcGlwZWxpbmUgPSBuZXcgUGlwZWxpbmUoc2Vzc2lvbnMpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmxlbmd0aCA+IDAgPyByZXNwb25zZS5qb2luKCcsICcpIDogbnVsbDtcbiAgfSxcblxuICB2YWxpZEZyYW1lUnN2OiBmdW5jdGlvbihmcmFtZSkge1xuICAgIHZhciBhbGxvd2VkID0geyByc3YxOiBmYWxzZSwgcnN2MjogZmFsc2UsIHJzdjM6IGZhbHNlIH0sXG4gICAgICAgIGV4dDtcblxuICAgIGlmIChFeHRlbnNpb25zLk1FU1NBR0VfT1BDT0RFUy5pbmRleE9mKGZyYW1lLm9wY29kZSkgPj0gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLl9zZXNzaW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZXh0ID0gdGhpcy5fc2Vzc2lvbnNbaV1bMF07XG4gICAgICAgIGFsbG93ZWQucnN2MSA9IGFsbG93ZWQucnN2MSB8fCBleHQucnN2MTtcbiAgICAgICAgYWxsb3dlZC5yc3YyID0gYWxsb3dlZC5yc3YyIHx8IGV4dC5yc3YyO1xuICAgICAgICBhbGxvd2VkLnJzdjMgPSBhbGxvd2VkLnJzdjMgfHwgZXh0LnJzdjM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChhbGxvd2VkLnJzdjEgfHwgIWZyYW1lLnJzdjEpICYmXG4gICAgICAgICAgIChhbGxvd2VkLnJzdjIgfHwgIWZyYW1lLnJzdjIpICYmXG4gICAgICAgICAgIChhbGxvd2VkLnJzdjMgfHwgIWZyYW1lLnJzdjMpO1xuICB9LFxuXG4gIHByb2Nlc3NJbmNvbWluZ01lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcGlwZWxpbmUucHJvY2Vzc0luY29taW5nTWVzc2FnZShtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCk7XG4gIH0sXG5cbiAgcHJvY2Vzc091dGdvaW5nTWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9waXBlbGluZS5wcm9jZXNzT3V0Z29pbmdNZXNzYWdlKG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuX3BpcGVsaW5lKSByZXR1cm4gY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgICB0aGlzLl9waXBlbGluZS5jbG9zZShjYWxsYmFjaywgY29udGV4dCk7XG4gIH0sXG5cbiAgX3Jlc2VydmU6IGZ1bmN0aW9uKGV4dCkge1xuICAgIHRoaXMuX3JzdjEgPSB0aGlzLl9yc3YxIHx8IChleHQucnN2MSAmJiBleHQubmFtZSk7XG4gICAgdGhpcy5fcnN2MiA9IHRoaXMuX3JzdjIgfHwgKGV4dC5yc3YyICYmIGV4dC5uYW1lKTtcbiAgICB0aGlzLl9yc3YzID0gdGhpcy5fcnN2MyB8fCAoZXh0LnJzdjMgJiYgZXh0Lm5hbWUpO1xuICB9LFxuXG4gIF9yZXNlcnZlZDogZnVuY3Rpb24oZXh0KSB7XG4gICAgaWYgKHRoaXMuX3JzdjEgJiYgZXh0LnJzdjEpIHJldHVybiBbMSwgdGhpcy5fcnN2MV07XG4gICAgaWYgKHRoaXMuX3JzdjIgJiYgZXh0LnJzdjIpIHJldHVybiBbMiwgdGhpcy5fcnN2Ml07XG4gICAgaWYgKHRoaXMuX3JzdjMgJiYgZXh0LnJzdjMpIHJldHVybiBbMywgdGhpcy5fcnN2M107XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIEV4dGVuc2lvbnMucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuc2lvbnM7XG5cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgVE9LRU4gICAgPSAvKFshI1xcJCUmJ1xcKlxcK1xcLVxcLlxcXl9gXFx8fjAtOUEtWmEtel0rKS8sXG4gICAgTk9UT0tFTiAgPSAvKFteISNcXCQlJidcXCpcXCtcXC1cXC5cXF5fYFxcfH4wLTlBLVphLXpdKS9nLFxuICAgIFFVT1RFRCAgID0gL1wiKCg/OlxcXFxbXFx4MDAtXFx4N2ZdfFteXFx4MDAtXFx4MDhcXHgwYS1cXHgxZlxceDdmXCJcXFxcXSkqKVwiLyxcbiAgICBQQVJBTSAgICA9IG5ldyBSZWdFeHAoVE9LRU4uc291cmNlICsgJyg/Oj0oPzonICsgVE9LRU4uc291cmNlICsgJ3wnICsgUVVPVEVELnNvdXJjZSArICcpKT8nKSxcbiAgICBFWFQgICAgICA9IG5ldyBSZWdFeHAoVE9LRU4uc291cmNlICsgJyg/OiAqOyAqJyArIFBBUkFNLnNvdXJjZSArICcpKicsICdnJyksXG4gICAgRVhUX0xJU1QgPSBuZXcgUmVnRXhwKCdeJyArIEVYVC5zb3VyY2UgKyAnKD86ICosIConICsgRVhULnNvdXJjZSArICcpKiQnKSxcbiAgICBOVU1CRVIgICA9IC9eLT8oMHxbMS05XVswLTldKikoXFwuWzAtOV0rKT8kLztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFBhcnNlciA9IHtcbiAgcGFyc2VIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIHZhciBvZmZlcnMgPSBuZXcgT2ZmZXJzKCk7XG4gICAgaWYgKGhlYWRlciA9PT0gJycgfHwgaGVhZGVyID09PSB1bmRlZmluZWQpIHJldHVybiBvZmZlcnM7XG5cbiAgICBpZiAoIUVYVF9MSVNULnRlc3QoaGVhZGVyKSlcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyOiAnICsgaGVhZGVyKTtcblxuICAgIHZhciB2YWx1ZXMgPSBoZWFkZXIubWF0Y2goRVhUKTtcblxuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgcGFyYW1zID0gdmFsdWUubWF0Y2gobmV3IFJlZ0V4cChQQVJBTS5zb3VyY2UsICdnJykpLFxuICAgICAgICAgIG5hbWUgICA9IHBhcmFtcy5zaGlmdCgpLFxuICAgICAgICAgIG9mZmVyICA9IHt9O1xuXG4gICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICB2YXIgYXJncyA9IHBhcmFtLm1hdGNoKFBBUkFNKSwga2V5ID0gYXJnc1sxXSwgZGF0YTtcblxuICAgICAgICBpZiAoYXJnc1syXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGF0YSA9IGFyZ3NbMl07XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGF0YSA9IGFyZ3NbM10ucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE5VTUJFUi50ZXN0KGRhdGEpKSBkYXRhID0gcGFyc2VGbG9hdChkYXRhKTtcblxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvZmZlciwga2V5KSkge1xuICAgICAgICAgIG9mZmVyW2tleV0gPSBbXS5jb25jYXQob2ZmZXJba2V5XSk7XG4gICAgICAgICAgb2ZmZXJba2V5XS5wdXNoKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZmVyW2tleV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIG9mZmVycy5wdXNoKG5hbWUsIG9mZmVyKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiBvZmZlcnM7XG4gIH0sXG5cbiAgc2VyaWFsaXplUGFyYW1zOiBmdW5jdGlvbihuYW1lLCBwYXJhbXMpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICB2YXIgcHJpbnQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHsgcHJpbnQoa2V5LCB2KSB9KTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YWx1ZXMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKE5PVE9LRU4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goa2V5ICsgJz1cIicgKyB2YWx1ZS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykgcHJpbnQoa2V5LCBwYXJhbXNba2V5XSk7XG5cbiAgICByZXR1cm4gW25hbWVdLmNvbmNhdCh2YWx1ZXMpLmpvaW4oJzsgJyk7XG4gIH1cbn07XG5cbnZhciBPZmZlcnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYnlOYW1lICA9IHt9O1xuICB0aGlzLl9pbk9yZGVyID0gW107XG59O1xuXG5PZmZlcnMucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihuYW1lLCBwYXJhbXMpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2J5TmFtZSwgbmFtZSkpXG4gICAgdGhpcy5fYnlOYW1lW25hbWVdID0gW107XG5cbiAgdGhpcy5fYnlOYW1lW25hbWVdLnB1c2gocGFyYW1zKTtcbiAgdGhpcy5faW5PcmRlci5wdXNoKHsgbmFtZTogbmFtZSwgcGFyYW1zOiBwYXJhbXMgfSk7XG59O1xuXG5PZmZlcnMucHJvdG90eXBlLmVhY2hPZmZlciA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ID0gdGhpcy5faW5PcmRlcjtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBsaXN0Lmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGxpc3RbaV0ubmFtZSwgbGlzdFtpXS5wYXJhbXMpO1xufTtcblxuT2ZmZXJzLnByb3RvdHlwZS5ieU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9ieU5hbWVbbmFtZV0gfHwgW107XG59O1xuXG5PZmZlcnMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2luT3JkZXIuc2xpY2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyO1xuXG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIENlbGwgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpLFxuICAgIFBsZWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgUGlwZWxpbmUgPSBmdW5jdGlvbihzZXNzaW9ucykge1xuICB0aGlzLl9jZWxscyAgID0gc2Vzc2lvbnMubWFwKGZ1bmN0aW9uKHNlc3Npb24pIHsgcmV0dXJuIG5ldyBDZWxsKHNlc3Npb24pIH0pO1xuICB0aGlzLl9zdG9wcGVkID0geyBpbmNvbWluZzogZmFsc2UsIG91dGdvaW5nOiBmYWxzZSB9O1xufTtcblxuUGlwZWxpbmUucHJvdG90eXBlLnByb2Nlc3NJbmNvbWluZ01lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAodGhpcy5fc3RvcHBlZC5pbmNvbWluZykgcmV0dXJuO1xuICB0aGlzLl9sb29wKCdpbmNvbWluZycsIHRoaXMuX2NlbGxzLmxlbmd0aCAtIDEsIC0xLCAtMSwgbWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xufTtcblxuUGlwZWxpbmUucHJvdG90eXBlLnByb2Nlc3NPdXRnb2luZ01lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAodGhpcy5fc3RvcHBlZC5vdXRnb2luZykgcmV0dXJuO1xuICB0aGlzLl9sb29wKCdvdXRnb2luZycsIDAsIHRoaXMuX2NlbGxzLmxlbmd0aCwgMSwgbWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xufTtcblxuUGlwZWxpbmUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgdGhpcy5fc3RvcHBlZCA9IHsgaW5jb21pbmc6IHRydWUsIG91dGdvaW5nOiB0cnVlIH07XG5cbiAgdmFyIGNsb3NlZCA9IHRoaXMuX2NlbGxzLm1hcChmdW5jdGlvbihhKSB7IHJldHVybiBhLmNsb3NlKCkgfSk7XG4gIGlmIChjYWxsYmFjaylcbiAgICBQbGVkZ2UuYWxsKGNsb3NlZCkudGhlbihmdW5jdGlvbigpIHsgY2FsbGJhY2suY2FsbChjb250ZXh0KSB9KTtcbn07XG5cblBpcGVsaW5lLnByb3RvdHlwZS5fbG9vcCA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgc3RhcnQsIGVuZCwgc3RlcCwgbWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgdmFyIGNlbGxzID0gdGhpcy5fY2VsbHMsXG4gICAgICBuICAgICA9IGNlbGxzLmxlbmd0aCxcbiAgICAgIHNlbGYgID0gdGhpcztcblxuICB3aGlsZSAobi0tKSBjZWxsc1tuXS5wZW5kaW5nKGRpcmVjdGlvbik7XG5cbiAgdmFyIHBpcGUgPSBmdW5jdGlvbihpbmRleCwgZXJyb3IsIG1zZykge1xuICAgIGlmIChpbmRleCA9PT0gZW5kKSByZXR1cm4gY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnJvciwgbXNnKTtcblxuICAgIGNlbGxzW2luZGV4XVtkaXJlY3Rpb25dKGVycm9yLCBtc2csIGZ1bmN0aW9uKGVyciwgbSkge1xuICAgICAgaWYgKGVycikgc2VsZi5fc3RvcHBlZFtkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgIHBpcGUoaW5kZXggKyBzdGVwLCBlcnIsIG0pO1xuICAgIH0pO1xuICB9O1xuICBwaXBlKHN0YXJ0LCBudWxsLCBtZXNzYWdlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGlwZWxpbmU7XG5cblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRnVuY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpLFxuICAgIFBsZWRnZSAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIENlbGwgPSBmdW5jdGlvbih0dXBsZSkge1xuICB0aGlzLl9leHQgICAgID0gdHVwbGVbMF07XG4gIHRoaXMuX3Nlc3Npb24gPSB0dXBsZVsxXTtcblxuICB0aGlzLl9mdW5jdG9ycyA9IHtcbiAgICBpbmNvbWluZzogbmV3IEZ1bmN0b3IodGhpcy5fc2Vzc2lvbiwgJ3Byb2Nlc3NJbmNvbWluZ01lc3NhZ2UnKSxcbiAgICBvdXRnb2luZzogbmV3IEZ1bmN0b3IodGhpcy5fc2Vzc2lvbiwgJ3Byb2Nlc3NPdXRnb2luZ01lc3NhZ2UnKVxuICB9O1xufTtcblxuQ2VsbC5wcm90b3R5cGUucGVuZGluZyA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICB2YXIgZnVuY3RvciA9IHRoaXMuX2Z1bmN0b3JzW2RpcmVjdGlvbl07XG4gIGlmICghZnVuY3Rvci5fc3RvcHBlZCkgZnVuY3Rvci5wZW5kaW5nICs9IDE7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5pbmNvbWluZyA9IGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICB0aGlzLl9leGVjKCdpbmNvbWluZycsIGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCk7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5vdXRnb2luZyA9IGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICB0aGlzLl9leGVjKCdvdXRnb2luZycsIGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCk7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbG9zZWQgPSB0aGlzLl9jbG9zZWQgfHwgbmV3IFBsZWRnZSgpO1xuICB0aGlzLl9kb0Nsb3NlKCk7XG4gIHJldHVybiB0aGlzLl9jbG9zZWQ7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5fZXhlYyA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZXJyb3IsIG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIHRoaXMuX2Z1bmN0b3JzW2RpcmVjdGlvbl0uY2FsbChlcnJvciwgbWVzc2FnZSwgZnVuY3Rpb24oZXJyLCBtc2cpIHtcbiAgICBpZiAoZXJyKSBlcnIubWVzc2FnZSA9IHRoaXMuX2V4dC5uYW1lICsgJzogJyArIGVyci5tZXNzYWdlO1xuICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyLCBtc2cpO1xuICAgIHRoaXMuX2RvQ2xvc2UoKTtcbiAgfSwgdGhpcyk7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5fZG9DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmluICA9IHRoaXMuX2Z1bmN0b3JzLmluY29taW5nLFxuICAgICAgZm91dCA9IHRoaXMuX2Z1bmN0b3JzLm91dGdvaW5nO1xuXG4gIGlmICghdGhpcy5fY2xvc2VkIHx8IGZpbi5wZW5kaW5nICsgZm91dC5wZW5kaW5nICE9PSAwKSByZXR1cm47XG4gIGlmICh0aGlzLl9zZXNzaW9uKSB0aGlzLl9zZXNzaW9uLmNsb3NlKCk7XG4gIHRoaXMuX3Nlc3Npb24gPSBudWxsO1xuICB0aGlzLl9jbG9zZWQuZG9uZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsO1xuXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFJpbmdCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIEZ1bmN0b3IgPSBmdW5jdGlvbihzZXNzaW9uLCBtZXRob2QpIHtcbiAgdGhpcy5fc2Vzc2lvbiA9IHNlc3Npb247XG4gIHRoaXMuX21ldGhvZCAgPSBtZXRob2Q7XG4gIHRoaXMuX3F1ZXVlICAgPSBuZXcgUmluZ0J1ZmZlcihGdW5jdG9yLlFVRVVFX1NJWkUpO1xuICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gIHRoaXMucGVuZGluZyAgPSAwO1xufTtcblxuRnVuY3Rvci5RVUVVRV9TSVpFID0gODtcblxuRnVuY3Rvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAodGhpcy5fc3RvcHBlZCkgcmV0dXJuO1xuXG4gIHZhciByZWNvcmQgPSB7IGVycm9yOiBlcnJvciwgbWVzc2FnZTogbWVzc2FnZSwgY2FsbGJhY2s6IGNhbGxiYWNrLCBjb250ZXh0OiBjb250ZXh0LCBkb25lOiBmYWxzZSB9LFxuICAgICAgY2FsbGVkID0gZmFsc2UsXG4gICAgICBzZWxmICAgPSB0aGlzO1xuXG4gIHRoaXMuX3F1ZXVlLnB1c2gocmVjb3JkKTtcblxuICBpZiAocmVjb3JkLmVycm9yKSB7XG4gICAgcmVjb3JkLmRvbmUgPSB0cnVlO1xuICAgIHRoaXMuX3N0b3AoKTtcbiAgICByZXR1cm4gdGhpcy5fZmx1c2hRdWV1ZSgpO1xuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihlcnIsIG1zZykge1xuICAgIGlmICghKGNhbGxlZCBeIChjYWxsZWQgPSB0cnVlKSkpIHJldHVybjtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHNlbGYuX3N0b3AoKTtcbiAgICAgIHJlY29yZC5lcnJvciAgID0gZXJyO1xuICAgICAgcmVjb3JkLm1lc3NhZ2UgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvcmQubWVzc2FnZSA9IG1zZztcbiAgICB9XG5cbiAgICByZWNvcmQuZG9uZSA9IHRydWU7XG4gICAgc2VsZi5fZmx1c2hRdWV1ZSgpO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgdGhpcy5fc2Vzc2lvblt0aGlzLl9tZXRob2RdKG1lc3NhZ2UsIGhhbmRsZXIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBoYW5kbGVyKGVycik7XG4gIH1cbn07XG5cbkZ1bmN0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGVuZGluZyAgPSB0aGlzLl9xdWV1ZS5sZW5ndGg7XG4gIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xufTtcblxuRnVuY3Rvci5wcm90b3R5cGUuX2ZsdXNoUXVldWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWUsIHJlY29yZDtcblxuICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCAmJiBxdWV1ZS5wZWVrKCkuZG9uZSkge1xuICAgIHJlY29yZCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKHJlY29yZC5lcnJvcikge1xuICAgICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgICAgIHF1ZXVlLmNsZWFyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGVuZGluZyAtPSAxO1xuICAgIH1cbiAgICByZWNvcmQuY2FsbGJhY2suY2FsbChyZWNvcmQuY29udGV4dCwgcmVjb3JkLmVycm9yLCByZWNvcmQubWVzc2FnZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3RvcjtcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGcmFtZSA9IGZ1bmN0aW9uKCkge307XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgZmluYWw6ICAgICAgICBmYWxzZSxcbiAgcnN2MTogICAgICAgICBmYWxzZSxcbiAgcnN2MjogICAgICAgICBmYWxzZSxcbiAgcnN2MzogICAgICAgICBmYWxzZSxcbiAgb3Bjb2RlOiAgICAgICBudWxsLFxuICBtYXNrZWQ6ICAgICAgIGZhbHNlLFxuICBtYXNraW5nS2V5OiAgIG51bGwsXG4gIGxlbmd0aEJ5dGVzOiAgMSxcbiAgbGVuZ3RoOiAgICAgICAwLFxuICBwYXlsb2FkOiAgICAgIG51bGxcbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgRnJhbWUucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lO1xuXG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyO1xuXG52YXIgTWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJzdjEgICAgPSBmYWxzZTtcbiAgdGhpcy5yc3YyICAgID0gZmFsc2U7XG4gIHRoaXMucnN2MyAgICA9IGZhbHNlO1xuICB0aGlzLm9wY29kZSAgPSBudWxsO1xuICB0aGlzLmxlbmd0aCAgPSAwO1xuICB0aGlzLl9jaHVua3MgPSBbXTtcbn07XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSA9IHRoaXMuZGF0YSB8fCBCdWZmZXIuY29uY2F0KHRoaXMuX2NodW5rcywgdGhpcy5sZW5ndGgpO1xuICB9LFxuXG4gIHB1c2hGcmFtZTogZnVuY3Rpb24oZnJhbWUpIHtcbiAgICB0aGlzLnJzdjEgPSB0aGlzLnJzdjEgfHwgZnJhbWUucnN2MTtcbiAgICB0aGlzLnJzdjIgPSB0aGlzLnJzdjIgfHwgZnJhbWUucnN2MjtcbiAgICB0aGlzLnJzdjMgPSB0aGlzLnJzdjMgfHwgZnJhbWUucnN2MztcblxuICAgIGlmICh0aGlzLm9wY29kZSA9PT0gbnVsbCkgdGhpcy5vcGNvZGUgPSBmcmFtZS5vcGNvZGU7XG5cbiAgICB0aGlzLl9jaHVua3MucHVzaChmcmFtZS5wYXlsb2FkKTtcbiAgICB0aGlzLmxlbmd0aCArPSBmcmFtZS5sZW5ndGg7XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgTWVzc2FnZS5wcm90b3R5cGVba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZTtcblxuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBCdWZmZXIgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXIsXG4gICAgU3RyZWFtICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuU3RyZWFtLFxuICAgIHVybCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICAgIHV0aWwgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIEJhc2UgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuICAgIEhlYWRlcnMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLFxuICAgIEh0dHBQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIFBPUlRTID0geyAnd3M6JzogODAsICd3c3M6JzogNDQzIH07XG5cbnZhciBQcm94eSA9IGZ1bmN0aW9uKGNsaWVudCwgb3JpZ2luLCBvcHRpb25zKSB7XG4gIHRoaXMuX2NsaWVudCAgPSBjbGllbnQ7XG4gIHRoaXMuX2h0dHAgICAgPSBuZXcgSHR0cFBhcnNlcigncmVzcG9uc2UnKTtcbiAgdGhpcy5fb3JpZ2luICA9ICh0eXBlb2YgY2xpZW50LnVybCA9PT0gJ29iamVjdCcpID8gY2xpZW50LnVybCA6IHVybC5wYXJzZShjbGllbnQudXJsKTtcbiAgdGhpcy5fdXJsICAgICA9ICh0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JykgPyBvcmlnaW4gOiB1cmwucGFyc2Uob3JpZ2luKTtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX3N0YXRlICAgPSAwO1xuXG4gIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5fcGF1c2VkICA9IGZhbHNlO1xuXG4gIHRoaXMuX2hlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnSG9zdCcsIHRoaXMuX29yaWdpbi5ob3N0KTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ0Nvbm5lY3Rpb24nLCAna2VlcC1hbGl2ZScpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnUHJveHktQ29ubmVjdGlvbicsICdrZWVwLWFsaXZlJyk7XG5cbiAgdmFyIGF1dGggPSB0aGlzLl91cmwuYXV0aCAmJiBCdWZmZXIuZnJvbSh0aGlzLl91cmwuYXV0aCwgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGlmIChhdXRoKSB0aGlzLl9oZWFkZXJzLnNldCgnUHJveHktQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgYXV0aCk7XG59O1xudXRpbC5pbmhlcml0cyhQcm94eSwgU3RyZWFtKTtcblxudmFyIGluc3RhbmNlID0ge1xuICBzZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5faGVhZGVycy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IDApIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IDE7XG5cbiAgICB2YXIgb3JpZ2luID0gdGhpcy5fb3JpZ2luLFxuICAgICAgICBwb3J0ICAgPSBvcmlnaW4ucG9ydCB8fCBQT1JUU1tvcmlnaW4ucHJvdG9jb2xdLFxuICAgICAgICBzdGFydCAgPSAnQ09OTkVDVCAnICsgb3JpZ2luLmhvc3RuYW1lICsgJzonICsgcG9ydCArICcgSFRUUC8xLjEnO1xuXG4gICAgdmFyIGhlYWRlcnMgPSBbc3RhcnQsIHRoaXMuX2hlYWRlcnMudG9TdHJpbmcoKSwgJyddO1xuXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgQnVmZmVyLmZyb20oaGVhZGVycy5qb2luKCdcXHJcXG4nKSwgJ3V0ZjgnKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG5cbiAgcmVzdW1lOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0sXG5cbiAgd3JpdGU6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICB0aGlzLl9odHRwLnBhcnNlKGNodW5rKTtcbiAgICBpZiAoIXRoaXMuX2h0dHAuaXNDb21wbGV0ZSgpKSByZXR1cm4gIXRoaXMuX3BhdXNlZDtcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHRoaXMuX2h0dHAuc3RhdHVzQ29kZTtcbiAgICB0aGlzLmhlYWRlcnMgICAgPSB0aGlzLl9odHRwLmhlYWRlcnM7XG5cbiAgICBpZiAodGhpcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIG5ldyBCYXNlLkNvbm5lY3RFdmVudCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBcIkNhbid0IGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBhdCBcIiArIHRoaXMuX29yaWdpbi5ocmVmO1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgfVxuICAgIHRoaXMuZW5kKCk7XG4gICAgcmV0dXJuICF0aGlzLl9wYXVzZWQ7XG4gIH0sXG5cbiAgZW5kOiBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmICghdGhpcy53cml0YWJsZSkgcmV0dXJuO1xuICAgIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rKTtcbiAgICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW5kKCk7XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgUHJveHkucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3h5O1xuXG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIEh0dHBQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSxcbiAgICBCYXNlICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgICBEcmFmdDc1ICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG4gICAgRHJhZnQ3NiAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpLFxuICAgIEh5YmkgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIFNlcnZlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIG51bGwsIG51bGwsIG9wdGlvbnMpO1xuICB0aGlzLl9odHRwID0gbmV3IEh0dHBQYXJzZXIoJ3JlcXVlc3QnKTtcbn07XG51dGlsLmluaGVyaXRzKFNlcnZlciwgQmFzZSk7XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgRVZFTlRTOiBbJ29wZW4nLCAnbWVzc2FnZScsICdlcnJvcicsICdjbG9zZScsICdwaW5nJywgJ3BvbmcnXSxcblxuICBfYmluZEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge30pO1xuICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7fSk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlKSByZXR1cm4gdGhpcy5fZGVsZWdhdGUucGFyc2UoY2h1bmspO1xuXG4gICAgdGhpcy5faHR0cC5wYXJzZShjaHVuayk7XG4gICAgaWYgKCF0aGlzLl9odHRwLmlzQ29tcGxldGUoKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5tZXRob2QgID0gdGhpcy5faHR0cC5tZXRob2Q7XG4gICAgdGhpcy51cmwgICAgID0gdGhpcy5faHR0cC51cmw7XG4gICAgdGhpcy5oZWFkZXJzID0gdGhpcy5faHR0cC5oZWFkZXJzO1xuICAgIHRoaXMuYm9keSAgICA9IHRoaXMuX2h0dHAuYm9keTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9kZWxlZ2F0ZSA9IFNlcnZlci5odHRwKHRoaXMsIHRoaXMuX29wdGlvbnMpO1xuICAgIHRoaXMuX2RlbGVnYXRlLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcztcbiAgICB0aGlzLl9kZWxlZ2F0ZS5pbyA9IHRoaXMuaW87XG4gICAgdGhpcy5fb3BlbigpO1xuXG4gICAgdGhpcy5FVkVOVFMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgdGhpcy5fZGVsZWdhdGUub24oZXZlbnQsIGZ1bmN0aW9uKGUpIHsgc2VsZi5lbWl0KGV2ZW50LCBlKSB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMucHJvdG9jb2wgPSB0aGlzLl9kZWxlZ2F0ZS5wcm90b2NvbDtcbiAgICB0aGlzLnZlcnNpb24gID0gdGhpcy5fZGVsZWdhdGUudmVyc2lvbjtcblxuICAgIHRoaXMucGFyc2UodGhpcy5faHR0cC5ib2R5KTtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBuZXcgQmFzZS5Db25uZWN0RXZlbnQoKSk7XG4gIH0sXG5cbiAgX29wZW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX19xdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKG1zZykge1xuICAgICAgdGhpcy5fZGVsZWdhdGVbbXNnWzBdXS5hcHBseSh0aGlzLl9kZWxlZ2F0ZSwgbXNnWzFdKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9fcXVldWUgPSBbXTtcbiAgfVxufTtcblxuWydhZGRFeHRlbnNpb24nLCAnc2V0SGVhZGVyJywgJ3N0YXJ0JywgJ2ZyYW1lJywgJ3RleHQnLCAnYmluYXJ5JywgJ3BpbmcnLCAnY2xvc2UnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpbnN0YW5jZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGVbbWV0aG9kXS5hcHBseSh0aGlzLl9kZWxlZ2F0ZSwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX3F1ZXVlLnB1c2goW21ldGhvZCwgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG59KTtcblxuZm9yICh2YXIga2V5IGluIGluc3RhbmNlKVxuICBTZXJ2ZXIucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5TZXJ2ZXIuaXNTZWN1cmVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5jb25uZWN0aW9uICYmIHJlcXVlc3QuY29ubmVjdGlvbi5hdXRob3JpemVkICE9PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICBpZiAocmVxdWVzdC5zb2NrZXQgJiYgcmVxdWVzdC5zb2NrZXQuc2VjdXJlKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcbiAgaWYgKCFoZWFkZXJzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChoZWFkZXJzWydodHRwcyddID09PSAnb24nKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGhlYWRlcnNbJ3gtZm9yd2FyZGVkLXNzbCddID09PSAnb24nKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGhlYWRlcnNbJ3gtZm9yd2FyZGVkLXNjaGVtZSddID09PSAnaHR0cHMnKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10gPT09ICdodHRwcycpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblNlcnZlci5kZXRlcm1pbmVVcmwgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHZhciBzY2hlbWUgPSB0aGlzLmlzU2VjdXJlUmVxdWVzdChyZXF1ZXN0KSA/ICd3c3M6JyA6ICd3czonO1xuICByZXR1cm4gc2NoZW1lICsgJy8vJyArIHJlcXVlc3QuaGVhZGVycy5ob3N0ICsgcmVxdWVzdC51cmw7XG59O1xuXG5TZXJ2ZXIuaHR0cCA9IGZ1bmN0aW9uKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnJlcXVpcmVNYXNraW5nID09PSB1bmRlZmluZWQpIG9wdGlvbnMucmVxdWlyZU1hc2tpbmcgPSB0cnVlO1xuXG4gIHZhciBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgdmVyc2lvbiA9IGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddLFxuICAgICAga2V5ICAgICA9IGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10sXG4gICAgICBrZXkxICAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXkxJ10sXG4gICAgICBrZXkyICAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXkyJ10sXG4gICAgICB1cmwgICAgID0gdGhpcy5kZXRlcm1pbmVVcmwocmVxdWVzdCk7XG5cbiAgaWYgKHZlcnNpb24gfHwga2V5KVxuICAgIHJldHVybiBuZXcgSHliaShyZXF1ZXN0LCB1cmwsIG9wdGlvbnMpO1xuICBlbHNlIGlmIChrZXkxIHx8IGtleTIpXG4gICAgcmV0dXJuIG5ldyBEcmFmdDc2KHJlcXVlc3QsIHVybCwgb3B0aW9ucyk7XG4gIGVsc2VcbiAgICByZXR1cm4gbmV3IERyYWZ0NzUocmVxdWVzdCwgdXJsLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmVyO1xuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJ1ZmZlcixcbiAgICBCYXNlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgICBEcmFmdDc1ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG4gICAgY3J5cHRvICA9IF9fd2VicGFja19yZXF1aXJlX18oMyksXG4gICAgdXRpbCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxudmFyIG51bWJlckZyb21LZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIHBhcnNlSW50KChrZXkubWF0Y2goL1swLTldL2cpIHx8IFtdKS5qb2luKCcnKSwgMTApO1xufTtcblxudmFyIHNwYWNlc0luS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHJldHVybiAoa2V5Lm1hdGNoKC8gL2cpIHx8IFtdKS5sZW5ndGg7XG59O1xuXG5cbnZhciBEcmFmdDc2ID0gZnVuY3Rpb24ocmVxdWVzdCwgdXJsLCBvcHRpb25zKSB7XG4gIERyYWZ0NzUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5fc3RhZ2UgID0gLTE7XG4gIHRoaXMuX2JvZHkgICA9IFtdO1xuICB0aGlzLnZlcnNpb24gPSAnaGl4aWUtNzYnO1xuXG4gIHRoaXMuX2hlYWRlcnMuY2xlYXIoKTtcblxuICB0aGlzLl9oZWFkZXJzLnNldCgnVXBncmFkZScsICdXZWJTb2NrZXQnKTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ0Nvbm5lY3Rpb24nLCAnVXBncmFkZScpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnU2VjLVdlYlNvY2tldC1PcmlnaW4nLCB0aGlzLl9yZXF1ZXN0LmhlYWRlcnMub3JpZ2luKTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ1NlYy1XZWJTb2NrZXQtTG9jYXRpb24nLCB0aGlzLnVybCk7XG59O1xudXRpbC5pbmhlcml0cyhEcmFmdDc2LCBEcmFmdDc1KTtcblxudmFyIGluc3RhbmNlID0ge1xuICBCT0RZX1NJWkU6IDgsXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghRHJhZnQ3NS5wcm90b3R5cGUuc3RhcnQuY2FsbCh0aGlzKSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NlbmRIYW5kc2hha2VCb2R5KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDMpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSAxKSB0aGlzLl93cml0ZShCdWZmZXIuZnJvbShbMHhGRiwgMHgwMF0pKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAzO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBuZXcgQmFzZS5DbG9zZUV2ZW50KG51bGwsIG51bGwpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfaGFuZHNoYWtlUmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoZWFkZXJzID0gdGhpcy5fcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgICBrZXkxICAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXkxJ10sXG4gICAgICAgIGtleTIgICAgPSBoZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleTInXTtcblxuICAgIGlmICgha2V5MSkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGhlYWRlcjogU2VjLVdlYlNvY2tldC1LZXkxJyk7XG4gICAgaWYgKCFrZXkyKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgaGVhZGVyOiBTZWMtV2ViU29ja2V0LUtleTInKTtcblxuICAgIHZhciBudW1iZXIxID0gbnVtYmVyRnJvbUtleShrZXkxKSxcbiAgICAgICAgc3BhY2VzMSA9IHNwYWNlc0luS2V5KGtleTEpLFxuXG4gICAgICAgIG51bWJlcjIgPSBudW1iZXJGcm9tS2V5KGtleTIpLFxuICAgICAgICBzcGFjZXMyID0gc3BhY2VzSW5LZXkoa2V5Mik7XG5cbiAgICBpZiAobnVtYmVyMSAlIHNwYWNlczEgIT09IDAgfHwgbnVtYmVyMiAlIHNwYWNlczIgIT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBzZW50IGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVycycpO1xuXG4gICAgdGhpcy5fa2V5VmFsdWVzID0gW251bWJlcjEgLyBzcGFjZXMxLCBudW1iZXIyIC8gc3BhY2VzMl07XG5cbiAgICB2YXIgc3RhcnQgICA9ICdIVFRQLzEuMSAxMDEgV2ViU29ja2V0IFByb3RvY29sIEhhbmRzaGFrZScsXG4gICAgICAgIGhlYWRlcnMgPSBbc3RhcnQsIHRoaXMuX2hlYWRlcnMudG9TdHJpbmcoKSwgJyddO1xuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhlYWRlcnMuam9pbignXFxyXFxuJyksICdiaW5hcnknKTtcbiAgfSxcblxuICBfaGFuZHNoYWtlU2lnbmF0dXJlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fYm9keS5sZW5ndGggPCB0aGlzLkJPRFlfU0laRSkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgbWQ1ICAgID0gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLFxuICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoOCArIHRoaXMuQk9EWV9TSVpFKTtcblxuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHRoaXMuX2tleVZhbHVlc1swXSwgMCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5fa2V5VmFsdWVzWzFdLCA0KTtcbiAgICBCdWZmZXIuZnJvbSh0aGlzLl9ib2R5KS5jb3B5KGJ1ZmZlciwgOCwgMCwgdGhpcy5CT0RZX1NJWkUpO1xuXG4gICAgbWQ1LnVwZGF0ZShidWZmZXIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShtZDUuZGlnZXN0KCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICB9LFxuXG4gIF9zZW5kSGFuZHNoYWtlQm9keTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9zdGFydGVkKSByZXR1cm47XG4gICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuX2hhbmRzaGFrZVNpZ25hdHVyZSgpO1xuICAgIGlmICghc2lnbmF0dXJlKSByZXR1cm47XG5cbiAgICB0aGlzLl93cml0ZShzaWduYXR1cmUpO1xuICAgIHRoaXMuX3N0YWdlID0gMDtcbiAgICB0aGlzLl9vcGVuKCk7XG5cbiAgICBpZiAodGhpcy5fYm9keS5sZW5ndGggPiB0aGlzLkJPRFlfU0laRSlcbiAgICAgIHRoaXMucGFyc2UodGhpcy5fYm9keS5zbGljZSh0aGlzLkJPRFlfU0laRSkpO1xuICB9LFxuXG4gIF9wYXJzZUxlYWRpbmdCeXRlOiBmdW5jdGlvbihvY3RldCkge1xuICAgIGlmIChvY3RldCAhPT0gMHhGRilcbiAgICAgIHJldHVybiBEcmFmdDc1LnByb3RvdHlwZS5fcGFyc2VMZWFkaW5nQnl0ZS5jYWxsKHRoaXMsIG9jdGV0KTtcblxuICAgIHRoaXMuX2Nsb3NpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2xlbmd0aCAgPSAwO1xuICAgIHRoaXMuX3N0YWdlICAgPSAxO1xuICB9XG59O1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIERyYWZ0NzYucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0NzY7XG5cblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBuZXQgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKSxcbiAgICB0bHMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKSxcbiAgICB1cmwgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICAgIGRyaXZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCksXG4gICAgQVBJICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSksXG4gICAgRXZlbnQgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIERFRkFVTFRfUE9SVFMgICAgPSB7J2h0dHA6JzogODAsICdodHRwczonOiA0NDMsICd3czonOjgwLCAnd3NzOic6IDQ0M30sXG4gICAgU0VDVVJFX1BST1RPQ09MUyA9IFsnaHR0cHM6JywgJ3dzczonXTtcblxudmFyIENsaWVudCA9IGZ1bmN0aW9uKF91cmwsIHByb3RvY29scywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLnVybCAgICAgPSBfdXJsO1xuICB0aGlzLl9kcml2ZXIgPSBkcml2ZXIuY2xpZW50KHRoaXMudXJsLCB7bWF4TGVuZ3RoOiBvcHRpb25zLm1heExlbmd0aCwgcHJvdG9jb2xzOiBwcm90b2NvbHN9KTtcblxuICBbJ29wZW4nLCAnZXJyb3InXS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5fZHJpdmVyLm9uKGV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuaGVhZGVycyAgICA9IHNlbGYuX2RyaXZlci5oZWFkZXJzO1xuICAgICAgc2VsZi5zdGF0dXNDb2RlID0gc2VsZi5fZHJpdmVyLnN0YXR1c0NvZGU7XG4gICAgfSk7XG4gIH0sIHRoaXMpO1xuXG4gIHZhciBwcm94eSAgICAgID0gb3B0aW9ucy5wcm94eSB8fCB7fSxcbiAgICAgIGVuZHBvaW50ICAgPSB1cmwucGFyc2UocHJveHkub3JpZ2luIHx8IHRoaXMudXJsKSxcbiAgICAgIHBvcnQgICAgICAgPSBlbmRwb2ludC5wb3J0IHx8IERFRkFVTFRfUE9SVFNbZW5kcG9pbnQucHJvdG9jb2xdLFxuICAgICAgc2VjdXJlICAgICA9IFNFQ1VSRV9QUk9UT0NPTFMuaW5kZXhPZihlbmRwb2ludC5wcm90b2NvbCkgPj0gMCxcbiAgICAgIG9uQ29ubmVjdCAgPSBmdW5jdGlvbigpIHsgc2VsZi5fb25Db25uZWN0KCkgfSxcbiAgICAgIG5ldE9wdGlvbnMgPSBvcHRpb25zLm5ldCB8fCB7fSxcbiAgICAgIG9yaWdpblRMUyAgPSBvcHRpb25zLnRscyB8fCB7fSxcbiAgICAgIHNvY2tldFRMUyAgPSBwcm94eS5vcmlnaW4gPyAocHJveHkudGxzIHx8IHt9KSA6IG9yaWdpblRMUyxcbiAgICAgIHNlbGYgICAgICAgPSB0aGlzO1xuXG4gIG5ldE9wdGlvbnMuaG9zdCA9IHNvY2tldFRMUy5ob3N0ID0gZW5kcG9pbnQuaG9zdG5hbWU7XG4gIG5ldE9wdGlvbnMucG9ydCA9IHNvY2tldFRMUy5wb3J0ID0gcG9ydDtcblxuICBvcmlnaW5UTFMuY2EgPSBvcmlnaW5UTFMuY2EgfHwgb3B0aW9ucy5jYTtcbiAgc29ja2V0VExTLnNlcnZlcm5hbWUgPSBzb2NrZXRUTFMuc2VydmVybmFtZSB8fCBlbmRwb2ludC5ob3N0bmFtZTtcblxuICB0aGlzLl9zdHJlYW0gPSBzZWN1cmVcbiAgICAgICAgICAgICAgID8gdGxzLmNvbm5lY3Qoc29ja2V0VExTLCBvbkNvbm5lY3QpXG4gICAgICAgICAgICAgICA6IG5ldC5jb25uZWN0KG5ldE9wdGlvbnMsIG9uQ29ubmVjdCk7XG5cbiAgaWYgKHByb3h5Lm9yaWdpbikgdGhpcy5fY29uZmlndXJlUHJveHkocHJveHksIG9yaWdpblRMUyk7XG5cbiAgQVBJLmNhbGwodGhpcywgb3B0aW9ucyk7XG59O1xudXRpbC5pbmhlcml0cyhDbGllbnQsIEFQSSk7XG5cbkNsaWVudC5wcm90b3R5cGUuX29uQ29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd29ya2VyID0gdGhpcy5fcHJveHkgfHwgdGhpcy5fZHJpdmVyO1xuICB3b3JrZXIuc3RhcnQoKTtcbn07XG5cbkNsaWVudC5wcm90b3R5cGUuX2NvbmZpZ3VyZVByb3h5ID0gZnVuY3Rpb24ocHJveHksIG9yaWdpblRMUykge1xuICB2YXIgdXJpICAgID0gdXJsLnBhcnNlKHRoaXMudXJsKSxcbiAgICAgIHNlY3VyZSA9IFNFQ1VSRV9QUk9UT0NPTFMuaW5kZXhPZih1cmkucHJvdG9jb2wpID49IDAsXG4gICAgICBzZWxmICAgPSB0aGlzLFxuICAgICAgbmFtZTtcblxuICB0aGlzLl9wcm94eSA9IHRoaXMuX2RyaXZlci5wcm94eShwcm94eS5vcmlnaW4pO1xuXG4gIGlmIChwcm94eS5oZWFkZXJzKSB7XG4gICAgZm9yIChuYW1lIGluIHByb3h5LmhlYWRlcnMpIHRoaXMuX3Byb3h5LnNldEhlYWRlcihuYW1lLCBwcm94eS5oZWFkZXJzW25hbWVdKTtcbiAgfVxuXG4gIHRoaXMuX3Byb3h5LnBpcGUodGhpcy5fc3RyZWFtLCB7ZW5kOiBmYWxzZX0pO1xuICB0aGlzLl9zdHJlYW0ucGlwZSh0aGlzLl9wcm94eSk7XG5cbiAgdGhpcy5fcHJveHkub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VjdXJlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtzb2NrZXQ6IHNlbGYuX3N0cmVhbSwgc2VydmVybmFtZTogdXJpLmhvc3RuYW1lfTtcbiAgICAgIGZvciAobmFtZSBpbiBvcmlnaW5UTFMpIG9wdGlvbnNbbmFtZV0gPSBvcmlnaW5UTFNbbmFtZV07XG4gICAgICBzZWxmLl9zdHJlYW0gPSB0bHMuY29ubmVjdChvcHRpb25zKTtcbiAgICAgIHNlbGYuX2NvbmZpZ3VyZVN0cmVhbSgpO1xuICAgIH1cbiAgICBzZWxmLl9kcml2ZXIuaW8ucGlwZShzZWxmLl9zdHJlYW0pO1xuICAgIHNlbGYuX3N0cmVhbS5waXBlKHNlbGYuX2RyaXZlci5pbyk7XG4gICAgc2VsZi5fZHJpdmVyLnN0YXJ0KCk7XG4gIH0pO1xuXG4gIHRoaXMuX3Byb3h5Lm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgc2VsZi5fZHJpdmVyLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50O1xuXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV0XCIpO1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRsc1wiKTtcblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgU3RyZWFtICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLlN0cmVhbSxcbiAgICB1dGlsICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgZHJpdmVyICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLFxuICAgIEhlYWRlcnMgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KSxcbiAgICBBUEkgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpLFxuICAgIEV2ZW50VGFyZ2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG4gICAgRXZlbnQgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgRXZlbnRTb3VyY2UgPSBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSwgb3B0aW9ucykge1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fc3RyZWFtID0gcmVzcG9uc2Uuc29ja2V0O1xuICB0aGlzLl9waW5nICAgPSBvcHRpb25zLnBpbmcgIHx8IHRoaXMuREVGQVVMVF9QSU5HO1xuICB0aGlzLl9yZXRyeSAgPSBvcHRpb25zLnJldHJ5IHx8IHRoaXMuREVGQVVMVF9SRVRSWTtcblxuICB2YXIgc2NoZW1lICAgICAgID0gZHJpdmVyLmlzU2VjdXJlUmVxdWVzdChyZXF1ZXN0KSA/ICdodHRwczonIDogJ2h0dHA6JztcbiAgdGhpcy51cmwgICAgICAgICA9IHNjaGVtZSArICcvLycgKyByZXF1ZXN0LmhlYWRlcnMuaG9zdCArIHJlcXVlc3QudXJsO1xuICB0aGlzLmxhc3RFdmVudElkID0gcmVxdWVzdC5oZWFkZXJzWydsYXN0LWV2ZW50LWlkJ10gfHwgJyc7XG4gIHRoaXMucmVhZHlTdGF0ZSAgPSBBUEkuQ09OTkVDVElORztcblxuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCksXG4gICAgICBzZWxmICAgID0gdGhpcztcblxuICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuaGVhZGVycykgaGVhZGVycy5zZXQoa2V5LCBvcHRpb25zLmhlYWRlcnNba2V5XSk7XG4gIH1cblxuICBpZiAoIXRoaXMuX3N0cmVhbSB8fCAhdGhpcy5fc3RyZWFtLndyaXRhYmxlKSByZXR1cm47XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYuX29wZW4oKSB9KTtcblxuICB0aGlzLl9zdHJlYW0uc2V0VGltZW91dCgwKTtcbiAgdGhpcy5fc3RyZWFtLnNldE5vRGVsYXkodHJ1ZSk7XG5cbiAgdmFyIGhhbmRzaGFrZSA9ICdIVFRQLzEuMSAyMDAgT0tcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGU6IHRleHQvZXZlbnQtc3RyZWFtXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbDogbm8tY2FjaGUsIG5vLXN0b3JlXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAnQ29ubmVjdGlvbjogY2xvc2VcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnMudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAnXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAncmV0cnk6ICcgKyBNYXRoLmZsb29yKHRoaXMuX3JldHJ5ICogMTAwMCkgKyAnXFxyXFxuXFxyXFxuJztcblxuICB0aGlzLl93cml0ZShoYW5kc2hha2UpO1xuXG4gIHRoaXMuX3N0cmVhbS5vbignZHJhaW4nLCBmdW5jdGlvbigpIHsgc2VsZi5lbWl0KCdkcmFpbicpIH0pO1xuXG4gIGlmICh0aGlzLl9waW5nKVxuICAgIHRoaXMuX3BpbmdUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkgeyBzZWxmLnBpbmcoKSB9LCB0aGlzLl9waW5nICogMTAwMCk7XG5cbiAgWydlcnJvcicsICdlbmQnXS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi5fc3RyZWFtLm9uKGV2ZW50LCBmdW5jdGlvbigpIHsgc2VsZi5jbG9zZSgpIH0pO1xuICB9KTtcbn07XG51dGlsLmluaGVyaXRzKEV2ZW50U291cmNlLCBTdHJlYW0pO1xuXG5FdmVudFNvdXJjZS5pc0V2ZW50U291cmNlID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnKSByZXR1cm4gZmFsc2U7XG4gIHZhciBhY2NlcHQgPSAocmVxdWVzdC5oZWFkZXJzLmFjY2VwdCB8fCAnJykuc3BsaXQoL1xccyosXFxzKi8pO1xuICByZXR1cm4gYWNjZXB0LmluZGV4T2YoJ3RleHQvZXZlbnQtc3RyZWFtJykgPj0gMDtcbn07XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgREVGQVVMVF9QSU5HOiAgIDEwLFxuICBERUZBVUxUX1JFVFJZOiAgNSxcblxuICBfd3JpdGU6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJlYW0ud3JpdGUoY2h1bmssICd1dGY4Jyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBfb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gQVBJLkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IEFQSS5PUEVOO1xuXG4gICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdvcGVuJyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdvcGVuJywgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9LFxuXG4gIHdyaXRlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZChtZXNzYWdlKTtcbiAgfSxcblxuICBlbmQ6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfSxcblxuICBzZW5kOiBmdW5jdGlvbihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IEFQSS5PUEVOKSByZXR1cm4gZmFsc2U7XG5cbiAgICBtZXNzYWdlID0gU3RyaW5nKG1lc3NhZ2UpLnJlcGxhY2UoLyhcXHJcXG58XFxyfFxcbikvZywgJyQxZGF0YTogJyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgZnJhbWUgPSAnJztcbiAgICBpZiAob3B0aW9ucy5ldmVudCkgZnJhbWUgKz0gJ2V2ZW50OiAnICsgb3B0aW9ucy5ldmVudCArICdcXHJcXG4nO1xuICAgIGlmIChvcHRpb25zLmlkKSAgICBmcmFtZSArPSAnaWQ6ICcgICAgKyBvcHRpb25zLmlkICAgICsgJ1xcclxcbic7XG4gICAgZnJhbWUgKz0gJ2RhdGE6ICcgKyBtZXNzYWdlICsgJ1xcclxcblxcclxcbic7XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGUoZnJhbWUpO1xuICB9LFxuXG4gIHBpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0ZSgnOlxcclxcblxcclxcbicpO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gQVBJLk9QRU4pIHJldHVybiBmYWxzZTtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IEFQSS5DTE9TRUQ7XG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9waW5nVGltZXIpIGNsZWFySW50ZXJ2YWwodGhpcy5fcGluZ1RpbWVyKTtcbiAgICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9zdHJlYW0uZW5kKCk7XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2Nsb3NlJyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdjbG9zZScsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5mb3IgKHZhciBtZXRob2QgaW4gaW5zdGFuY2UpIEV2ZW50U291cmNlLnByb3RvdHlwZVttZXRob2RdID0gaW5zdGFuY2VbbWV0aG9kXTtcbmZvciAodmFyIGtleSBpbiBFdmVudFRhcmdldCkgRXZlbnRTb3VyY2UucHJvdG90eXBlW2tleV0gPSBFdmVudFRhcmdldFtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlO1xuXG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTtcblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpO1xuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIHB1c2hlcl93aXRoX2VuY3J5cHRpb25fUHVzaGVyV2l0aEVuY3J5cHRpb247IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Jhc2U2NC50c1xuZnVuY3Rpb24gZW5jb2RlKHMpIHtcbiAgICByZXR1cm4gYnRvYSh1dG9iKHMpKTtcbn1cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIGI2NGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xudmFyIGI2NHRhYiA9IHt9O1xuZm9yICh2YXIgYmFzZTY0X2kgPSAwLCBsID0gYjY0Y2hhcnMubGVuZ3RoOyBiYXNlNjRfaSA8IGw7IGJhc2U2NF9pKyspIHtcbiAgICBiNjR0YWJbYjY0Y2hhcnMuY2hhckF0KGJhc2U2NF9pKV0gPSBiYXNlNjRfaTtcbn1cbnZhciBjYl91dG9iID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGNjIDwgMHg4MFxuICAgICAgICA/IGNcbiAgICAgICAgOiBjYyA8IDB4ODAwXG4gICAgICAgICAgICA/IGZyb21DaGFyQ29kZSgweGMwIHwgKGNjID4+PiA2KSkgKyBmcm9tQ2hhckNvZGUoMHg4MCB8IChjYyAmIDB4M2YpKVxuICAgICAgICAgICAgOiBmcm9tQ2hhckNvZGUoMHhlMCB8ICgoY2MgPj4+IDEyKSAmIDB4MGYpKSArXG4gICAgICAgICAgICAgICAgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKSArXG4gICAgICAgICAgICAgICAgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSk7XG59O1xudmFyIHV0b2IgPSBmdW5jdGlvbiAodSkge1xuICAgIHJldHVybiB1LnJlcGxhY2UoL1teXFx4MDAtXFx4N0ZdL2csIGNiX3V0b2IpO1xufTtcbnZhciBjYl9lbmNvZGUgPSBmdW5jdGlvbiAoY2NjKSB7XG4gICAgdmFyIHBhZGxlbiA9IFswLCAyLCAxXVtjY2MubGVuZ3RoICUgM107XG4gICAgdmFyIG9yZCA9IChjY2MuY2hhckNvZGVBdCgwKSA8PCAxNikgfFxuICAgICAgICAoKGNjYy5sZW5ndGggPiAxID8gY2NjLmNoYXJDb2RlQXQoMSkgOiAwKSA8PCA4KSB8XG4gICAgICAgIChjY2MubGVuZ3RoID4gMiA/IGNjYy5jaGFyQ29kZUF0KDIpIDogMCk7XG4gICAgdmFyIGNoYXJzID0gW1xuICAgICAgICBiNjRjaGFycy5jaGFyQXQob3JkID4+PiAxOCksXG4gICAgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MyksXG4gICAgICAgIHBhZGxlbiA+PSAyID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDYpICYgNjMpLFxuICAgICAgICBwYWRsZW4gPj0gMSA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdChvcmQgJiA2MylcbiAgICBdO1xuICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbn07XG52YXIgYnRvYSA9IGdsb2JhbC5idG9hIHx8XG4gICAgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZSgvW1xcc1xcU117MSwzfS9nLCBjYl9lbmNvZGUpO1xuICAgIH07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdGltZXJzL2Fic3RyYWN0X3RpbWVyLnRzXG5jbGFzcyBUaW1lciB7XG4gICAgY29uc3RydWN0b3Ioc2V0LCBjbGVhciwgZGVsYXksIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2xlYXIgPSBjbGVhcjtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBjYWxsYmFjayh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH1cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVyICE9PSBudWxsO1xuICAgIH1cbiAgICBlbnN1cmVBYm9ydGVkKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgdGhpcy5jbGVhcih0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYWJzdHJhY3RfdGltZXIgPSAoVGltZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3V0aWxzL3RpbWVycy9pbmRleC50c1xuXG5mdW5jdGlvbiB0aW1lcnNfY2xlYXJUaW1lb3V0KHRpbWVyKSB7XG4gICAgZ2xvYmFsLmNsZWFyVGltZW91dCh0aW1lcik7XG59XG5mdW5jdGlvbiB0aW1lcnNfY2xlYXJJbnRlcnZhbCh0aW1lcikge1xuICAgIGdsb2JhbC5jbGVhckludGVydmFsKHRpbWVyKTtcbn1cbmNsYXNzIHRpbWVyc19PbmVPZmZUaW1lciBleHRlbmRzIGFic3RyYWN0X3RpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcihkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIoc2V0VGltZW91dCwgdGltZXJzX2NsZWFyVGltZW91dCwgZGVsYXksIGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyB0aW1lcnNfUGVyaW9kaWNUaW1lciBleHRlbmRzIGFic3RyYWN0X3RpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcihkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIoc2V0SW50ZXJ2YWwsIHRpbWVyc19jbGVhckludGVydmFsLCBkZWxheSwgZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbC50c1xuXG52YXIgVXRpbCA9IHtcbiAgICBub3coKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdykge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlZmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGltZXJzX09uZU9mZlRpbWVyKDAsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG1ldGhvZChuYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIHZhciBib3VuZEFyZ3VtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W25hbWVdLmFwcGx5KG9iamVjdCwgYm91bmRBcmd1bWVudHMuY29uY2F0KGFyZ3VtZW50cykpO1xuICAgICAgICB9O1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsID0gKFV0aWwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3V0aWxzL2NvbGxlY3Rpb25zLnRzXG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgLi4uc291cmNlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zW3Byb3BlcnR5XSAmJlxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNbcHJvcGVydHldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1twcm9wZXJ0eV0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBleHRlbmQodGFyZ2V0W3Byb3BlcnR5XSB8fCB7fSwgZXh0ZW5zaW9uc1twcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGV4dGVuc2lvbnNbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgdmFyIG0gPSBbJ1B1c2hlciddO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbS5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtLnB1c2goc2FmZUpTT05TdHJpbmdpZnkoYXJndW1lbnRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uam9pbignIDogJyk7XG59XG5mdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyYXksIGl0ZW0pIHtcbiAgICB2YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIGlmIChhcnJheSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gb2JqZWN0QXBwbHkob2JqZWN0LCBmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgZihvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBhcHBseShhcnJheSwgZiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZi5jYWxsKGNvbnRleHQgfHwgZ2xvYmFsLCBhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGYoYXJyYXlbaV0sIGksIGFycmF5LCByZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGYpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGYodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXIoYXJyYXksIHRlc3QpIHtcbiAgICB0ZXN0ID1cbiAgICAgICAgdGVzdCB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXN0KGFycmF5W2ldLCBpLCBhcnJheSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXJPYmplY3Qob2JqZWN0LCB0ZXN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKCh0ZXN0ICYmIHRlc3QodmFsdWUsIGtleSwgb2JqZWN0LCByZXN1bHQpKSB8fCBCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmbGF0dGVuKG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBvYmplY3RBcHBseShvYmplY3QsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFueShhcnJheSwgdGVzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdGlvbnNfYWxsKGFycmF5LCB0ZXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5jb2RlUGFyYW1zT2JqZWN0KGRhdGEpIHtcbiAgICByZXR1cm4gbWFwT2JqZWN0KGRhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSBzYWZlSlNPTlN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlbmNvZGUodmFsdWUudG9TdHJpbmcoKSkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRRdWVyeVN0cmluZyhkYXRhKSB7XG4gICAgdmFyIHBhcmFtcyA9IGZpbHRlck9iamVjdChkYXRhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgdmFyIHF1ZXJ5ID0gbWFwKGZsYXR0ZW4oZW5jb2RlUGFyYW1zT2JqZWN0KHBhcmFtcykpLCB1dGlsLm1ldGhvZCgnam9pbicsICc9JykpLmpvaW4oJyYnKTtcbiAgICByZXR1cm4gcXVlcnk7XG59XG5mdW5jdGlvbiBkZWN5Y2xlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBvYmplY3RzID0gW10sIHBhdGhzID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBkZXJleih2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgaSwgbmFtZSwgbnU7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgJHJlZjogcGF0aHNbaV0gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICAgIG51ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVbaV0gPSBkZXJleih2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBudSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVbbmFtZV0gPSBkZXJleih2YWx1ZVtuYW1lXSwgcGF0aCArICdbJyArIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnU7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pKG9iamVjdCwgJyQnKTtcbn1cbmZ1bmN0aW9uIHNhZmVKU09OU3RyaW5naWZ5KHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3VyY2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGVjeWNsZU9iamVjdChzb3VyY2UpKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZGVmYXVsdHMudHNcbnZhciBEZWZhdWx0cyA9IHtcbiAgICBWRVJTSU9OOiBcIjguMy4wXCIsXG4gICAgUFJPVE9DT0w6IDcsXG4gICAgd3NQb3J0OiA4MCxcbiAgICB3c3NQb3J0OiA0NDMsXG4gICAgd3NQYXRoOiAnJyxcbiAgICBodHRwSG9zdDogJ3NvY2tqcy5wdXNoZXIuY29tJyxcbiAgICBodHRwUG9ydDogODAsXG4gICAgaHR0cHNQb3J0OiA0NDMsXG4gICAgaHR0cFBhdGg6ICcvcHVzaGVyJyxcbiAgICBzdGF0c19ob3N0OiAnc3RhdHMucHVzaGVyLmNvbScsXG4gICAgYXV0aEVuZHBvaW50OiAnL3B1c2hlci9hdXRoJyxcbiAgICBhdXRoVHJhbnNwb3J0OiAnYWpheCcsXG4gICAgYWN0aXZpdHlUaW1lb3V0OiAxMjAwMDAsXG4gICAgcG9uZ1RpbWVvdXQ6IDMwMDAwLFxuICAgIHVuYXZhaWxhYmxlVGltZW91dDogMTAwMDAsXG4gICAgdXNlckF1dGhlbnRpY2F0aW9uOiB7XG4gICAgICAgIGVuZHBvaW50OiAnL3B1c2hlci91c2VyLWF1dGgnLFxuICAgICAgICB0cmFuc3BvcnQ6ICdhamF4J1xuICAgIH0sXG4gICAgY2hhbm5lbEF1dGhvcml6YXRpb246IHtcbiAgICAgICAgZW5kcG9pbnQ6ICcvcHVzaGVyL2F1dGgnLFxuICAgICAgICB0cmFuc3BvcnQ6ICdhamF4J1xuICAgIH0sXG4gICAgY2RuX2h0dHA6IFwiaHR0cDovL2pzLnB1c2hlci5jb21cIixcbiAgICBjZG5faHR0cHM6IFwiaHR0cHM6Ly9qcy5wdXNoZXIuY29tXCIsXG4gICAgZGVwZW5kZW5jeV9zdWZmaXg6IFwiXCJcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWZhdWx0cyA9IChEZWZhdWx0cyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy91cmxfc2NoZW1lcy50c1xuXG5mdW5jdGlvbiBnZXRHZW5lcmljVVJMKGJhc2VTY2hlbWUsIHBhcmFtcywgcGF0aCkge1xuICAgIHZhciBzY2hlbWUgPSBiYXNlU2NoZW1lICsgKHBhcmFtcy51c2VUTFMgPyAncycgOiAnJyk7XG4gICAgdmFyIGhvc3QgPSBwYXJhbXMudXNlVExTID8gcGFyYW1zLmhvc3RUTFMgOiBwYXJhbXMuaG9zdE5vblRMUztcbiAgICByZXR1cm4gc2NoZW1lICsgJzovLycgKyBob3N0ICsgcGF0aDtcbn1cbmZ1bmN0aW9uIGdldEdlbmVyaWNQYXRoKGtleSwgcXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcGF0aCA9ICcvYXBwLycgKyBrZXk7XG4gICAgdmFyIHF1ZXJ5ID0gJz9wcm90b2NvbD0nICtcbiAgICAgICAgZGVmYXVsdHMuUFJPVE9DT0wgK1xuICAgICAgICAnJmNsaWVudD1qcycgK1xuICAgICAgICAnJnZlcnNpb249JyArXG4gICAgICAgIGRlZmF1bHRzLlZFUlNJT04gK1xuICAgICAgICAocXVlcnlTdHJpbmcgPyAnJicgKyBxdWVyeVN0cmluZyA6ICcnKTtcbiAgICByZXR1cm4gcGF0aCArIHF1ZXJ5O1xufVxudmFyIHdzID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICB2YXIgcGF0aCA9IChwYXJhbXMuaHR0cFBhdGggfHwgJycpICsgZ2V0R2VuZXJpY1BhdGgoa2V5LCAnZmxhc2g9ZmFsc2UnKTtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ3dzJywgcGFyYW1zLCBwYXRoKTtcbiAgICB9XG59O1xudmFyIGh0dHAgPSB7XG4gICAgZ2V0SW5pdGlhbDogZnVuY3Rpb24gKGtleSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXRoID0gKHBhcmFtcy5odHRwUGF0aCB8fCAnL3B1c2hlcicpICsgZ2V0R2VuZXJpY1BhdGgoa2V5KTtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ2h0dHAnLCBwYXJhbXMsIHBhdGgpO1xuICAgIH1cbn07XG52YXIgc29ja2pzID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gZ2V0R2VuZXJpY1VSTCgnaHR0cCcsIHBhcmFtcywgcGFyYW1zLmh0dHBQYXRoIHx8ICcvcHVzaGVyJyk7XG4gICAgfSxcbiAgICBnZXRQYXRoOiBmdW5jdGlvbiAoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNQYXRoKGtleSk7XG4gICAgfVxufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9ldmVudHMvY2FsbGJhY2tfcmVnaXN0cnkudHNcblxuY2xhc3MgY2FsbGJhY2tfcmVnaXN0cnlfQ2FsbGJhY2tSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW3ByZWZpeChuYW1lKV07XG4gICAgfVxuICAgIGFkZChuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgcHJlZml4ZWRFdmVudE5hbWUgPSBwcmVmaXgobmFtZSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrc1twcmVmaXhlZEV2ZW50TmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW3ByZWZpeGVkRXZlbnROYW1lXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzW3ByZWZpeGVkRXZlbnROYW1lXS5wdXNoKHtcbiAgICAgICAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZShuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICBpZiAoIW5hbWUgJiYgIWNhbGxiYWNrICYmICFjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lID8gW3ByZWZpeChuYW1lKV0gOiBrZXlzKHRoaXMuX2NhbGxiYWNrcyk7XG4gICAgICAgIGlmIChjYWxsYmFjayB8fCBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNhbGxiYWNrKG5hbWVzLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbENhbGxiYWNrcyhuYW1lcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2FsbGJhY2sobmFtZXMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGFwcGx5KG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW25hbWVdID0gZmlsdGVyKHRoaXMuX2NhbGxiYWNrc1tuYW1lXSB8fCBbXSwgZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gYmluZGluZy5mbikgfHxcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQgJiYgY29udGV4dCAhPT0gYmluZGluZy5jb250ZXh0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbmFtZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIHJlbW92ZUFsbENhbGxiYWNrcyhuYW1lcykge1xuICAgICAgICBhcHBseShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbbmFtZV07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZWZpeChuYW1lKSB7XG4gICAgcmV0dXJuICdfJyArIG5hbWU7XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZXZlbnRzL2Rpc3BhdGNoZXIudHNcblxuXG5jbGFzcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGZhaWxUaHJvdWdoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IGNhbGxiYWNrX3JlZ2lzdHJ5X0NhbGxiYWNrUmVnaXN0cnkoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuZmFpbFRocm91Z2ggPSBmYWlsVGhyb3VnaDtcbiAgICB9XG4gICAgYmluZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJpbmRfZ2xvYmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnJlbW92ZShldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9nbG9iYWwoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3MgPSBmaWx0ZXIodGhpcy5nbG9iYWxfY2FsbGJhY2tzIHx8IFtdLCBjID0+IGMgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9hbGwoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgIHRoaXMudW5iaW5kX2dsb2JhbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIGRhdGEsIG1ldGFkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbG9iYWxfY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3NbaV0oZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGRhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrcyAmJiBjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uZm4uYXBwbHkoY2FsbGJhY2tzW2ldLmNvbnRleHQgfHwgZ2xvYmFsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZhaWxUaHJvdWdoKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWxUaHJvdWdoKGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2xvZ2dlci50c1xuXG5cbmNsYXNzIGxvZ2dlcl9Mb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdsb2JhbExvZyA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLmNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMubG9nKHRoaXMuZ2xvYmFsTG9nLCBhcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMubG9nKHRoaXMuZ2xvYmFsTG9nV2FybiwgYXJncyk7XG4gICAgfVxuICAgIGVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5sb2codGhpcy5nbG9iYWxMb2dFcnJvciwgYXJncyk7XG4gICAgfVxuICAgIGdsb2JhbExvZ1dhcm4obWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgZ2xvYmFsLmNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdsb2JhbExvZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICBnbG9iYWwuY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nV2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2coZGVmYXVsdExvZ2dpbmdGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IHN0cmluZ2lmeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoY29yZV9wdXNoZXIubG9nKSB7XG4gICAgICAgICAgICBjb3JlX3B1c2hlci5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29yZV9wdXNoZXIubG9nVG9Db25zb2xlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2cgPSBkZWZhdWx0TG9nZ2luZ0Z1bmN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBsb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsb2dnZXIgPSAobmV3IGxvZ2dlcl9Mb2dnZXIoKSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnRfY29ubmVjdGlvbi50c1xuXG5cblxuXG5cbmNsYXNzIHRyYW5zcG9ydF9jb25uZWN0aW9uX1RyYW5zcG9ydENvbm5lY3Rpb24gZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGhvb2tzLCBuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSA9IG5vZGVfcnVudGltZS50cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXI7XG4gICAgICAgIHRoaXMuaG9va3MgPSBob29rcztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICduZXcnO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gb3B0aW9ucy50aW1lbGluZTtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVvdXQgPSBvcHRpb25zLmFjdGl2aXR5VGltZW91dDtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMudGltZWxpbmUuZ2VuZXJhdGVVbmlxdWVJRCgpO1xuICAgIH1cbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3MoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaG9va3MuaGFuZGxlc0FjdGl2aXR5Q2hlY2tzKTtcbiAgICB9XG4gICAgc3VwcG9ydHNQaW5nKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhvb2tzLnN1cHBvcnRzUGluZyk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCB8fCB0aGlzLnN0YXRlICE9PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IHRoaXMuaG9va3MudXJscy5nZXRJbml0aWFsKHRoaXMua2V5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSB0aGlzLmhvb2tzLmdldFNvY2tldCh1cmwsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwuZGVmZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0Nvbm5lY3RpbmcnLCB7IHRyYW5zcG9ydDogdGhpcy5uYW1lLCB1cmwgfSk7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgdXRpbC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ29wZW4nICYmIHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmJlZm9yZU9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MuYmVmb3JlT3Blbih0aGlzLnNvY2tldCwgdGhpcy5ob29rcy51cmxzLmdldFBhdGgodGhpcy5rZXksIHRoaXMub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ29wZW4nKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7IHR5cGU6ICdXZWJTb2NrZXRFcnJvcicsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5lcnJvcih0aGlzLmJ1aWxkVGltZWxpbmVNZXNzYWdlKHsgZXJyb3I6IGVycm9yLnRvU3RyaW5nKCkgfSkpO1xuICAgIH1cbiAgICBvbkNsb3NlKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nsb3NlZCcsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjbG9zZUV2ZW50LmNvZGUsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBjbG9zZUV2ZW50LnJlYXNvbixcbiAgICAgICAgICAgICAgICB3YXNDbGVhbjogY2xvc2VFdmVudC53YXNDbGVhblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgfVxuICAgIG9uQWN0aXZpdHkoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnYWN0aXZpdHknKTtcbiAgICB9XG4gICAgYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSBjbG9zZUV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZShjbG9zZUV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQub25hY3Rpdml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShzdGF0ZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHRoaXMuYnVpbGRUaW1lbGluZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVtaXQoc3RhdGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIGJ1aWxkVGltZWxpbmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7IGNpZDogdGhpcy5pZCB9LCBtZXNzYWdlKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnQudHNcblxuY2xhc3MgdHJhbnNwb3J0X1RyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3IoaG9va3MpIHtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZChlbnZpcm9ubWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob29rcy5pc1N1cHBvcnRlZChlbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbm5lY3Rpb24obmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zcG9ydF9jb25uZWN0aW9uX1RyYW5zcG9ydENvbm5lY3Rpb24odGhpcy5ob29rcywgbmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL3RyYW5zcG9ydHMvdHJhbnNwb3J0cy50c1xuXG5cblxuXG52YXIgV1NUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCh7XG4gICAgdXJsczogd3MsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiBmYWxzZSxcbiAgICBzdXBwb3J0c1Bpbmc6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4obm9kZV9ydW50aW1lLmdldFdlYlNvY2tldEFQSSgpKTtcbiAgICB9LFxuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKG5vZGVfcnVudGltZS5nZXRXZWJTb2NrZXRBUEkoKSk7XG4gICAgfSxcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVfcnVudGltZS5jcmVhdGVXZWJTb2NrZXQodXJsKTtcbiAgICB9XG59KTtcbnZhciBodHRwQ29uZmlndXJhdGlvbiA9IHtcbiAgICB1cmxzOiBodHRwLFxuICAgIGhhbmRsZXNBY3Rpdml0eUNoZWNrczogZmFsc2UsXG4gICAgc3VwcG9ydHNQaW5nOiB0cnVlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbnZhciBzdHJlYW1pbmdDb25maWd1cmF0aW9uID0gZXh0ZW5kKHtcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVfcnVudGltZS5IVFRQRmFjdG9yeS5jcmVhdGVTdHJlYW1pbmdTb2NrZXQodXJsKTtcbiAgICB9XG59LCBodHRwQ29uZmlndXJhdGlvbik7XG52YXIgcG9sbGluZ0NvbmZpZ3VyYXRpb24gPSBleHRlbmQoe1xuICAgIGdldFNvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gbm9kZV9ydW50aW1lLkhUVFBGYWN0b3J5LmNyZWF0ZVBvbGxpbmdTb2NrZXQodXJsKTtcbiAgICB9XG59LCBodHRwQ29uZmlndXJhdGlvbik7XG52YXIgeGhyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbm9kZV9ydW50aW1lLmlzWEhSU3VwcG9ydGVkKCk7XG4gICAgfVxufTtcbnZhciBYSFJTdHJlYW1pbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCgoZXh0ZW5kKHt9LCBzdHJlYW1pbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSkpO1xudmFyIFhIUlBvbGxpbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydChleHRlbmQoe30sIHBvbGxpbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSk7XG52YXIgVHJhbnNwb3J0cyA9IHtcbiAgICB3czogV1NUcmFuc3BvcnQsXG4gICAgeGhyX3N0cmVhbWluZzogWEhSU3RyZWFtaW5nVHJhbnNwb3J0LFxuICAgIHhocl9wb2xsaW5nOiBYSFJQb2xsaW5nVHJhbnNwb3J0XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0cyA9IChUcmFuc3BvcnRzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL2Fzc2lzdGFudF90b190aGVfdHJhbnNwb3J0X21hbmFnZXIudHNcblxuXG5jbGFzcyBhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLm1pblBpbmdEZWxheSA9IG9wdGlvbnMubWluUGluZ0RlbGF5O1xuICAgICAgICB0aGlzLm1heFBpbmdEZWxheSA9IG9wdGlvbnMubWF4UGluZ0RlbGF5O1xuICAgICAgICB0aGlzLnBpbmdEZWxheSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY3JlYXRlQ29ubmVjdGlvbihuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogdGhpcy5waW5nRGVsYXlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ29ubmVjdGlvbihuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG9wZW5UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB2YXIgb25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51bmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgICAgICBvcGVuVGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQ2xvc2VkID0gY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnVuYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA9PT0gMTAwMiB8fCBjbG9zZUV2ZW50LmNvZGUgPT09IDEwMDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIucmVwb3J0RGVhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjbG9zZUV2ZW50Lndhc0NsZWFuICYmIG9wZW5UaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlmZXNwYW4gPSB1dGlsLm5vdygpIC0gb3BlblRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBpZiAobGlmZXNwYW4gPCAyICogdGhpcy5tYXhQaW5nRGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLnJlcG9ydERlYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGluZ0RlbGF5ID0gTWF0aC5tYXgobGlmZXNwYW4gLyAyLCB0aGlzLm1pblBpbmdEZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25uZWN0aW9uLmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5pc0FsaXZlKCkgJiYgdGhpcy50cmFuc3BvcnQuaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25uZWN0aW9uL3Byb3RvY29sL3Byb3RvY29sLnRzXG5jb25zdCBQcm90b2NvbCA9IHtcbiAgICBkZWNvZGVNZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZURhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2VFdmVudC5kYXRhKTtcbiAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudERhdGEgPSBtZXNzYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwdXNoZXJFdmVudERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaGVyRXZlbnREYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlRGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHB1c2hlckV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlRGF0YS5ldmVudCxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBtZXNzYWdlRGF0YS5jaGFubmVsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHB1c2hlckV2ZW50RGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlRGF0YS51c2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgcHVzaGVyRXZlbnQudXNlcl9pZCA9IG1lc3NhZ2VEYXRhLnVzZXJfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVzaGVyRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ01lc3NhZ2VQYXJzZUVycm9yJywgZXJyb3I6IGUsIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVuY29kZU1lc3NhZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXZlbnQpO1xuICAgIH0sXG4gICAgcHJvY2Vzc0hhbmRzaGFrZTogZnVuY3Rpb24gKG1lc3NhZ2VFdmVudCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFByb3RvY29sLmRlY29kZU1lc3NhZ2UobWVzc2FnZUV2ZW50KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnQgPT09ICdwdXNoZXI6Y29ubmVjdGlvbl9lc3RhYmxpc2hlZCcpIHtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZS5kYXRhLmFjdGl2aXR5X3RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTm8gYWN0aXZpdHkgdGltZW91dCBzcGVjaWZpZWQgaW4gaGFuZHNoYWtlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICBpZDogbWVzc2FnZS5kYXRhLnNvY2tldF9pZCxcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IG1lc3NhZ2UuZGF0YS5hY3Rpdml0eV90aW1lb3V0ICogMTAwMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmV2ZW50ID09PSAncHVzaGVyOmVycm9yJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuZ2V0Q2xvc2VBY3Rpb24obWVzc2FnZS5kYXRhKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5nZXRDbG9zZUVycm9yKG1lc3NhZ2UuZGF0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBoYW5kc2hha2UnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRDbG9zZUFjdGlvbjogZnVuY3Rpb24gKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQwMDApIHtcbiAgICAgICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgPj0gMTAwMiAmJiBjbG9zZUV2ZW50LmNvZGUgPD0gMTAwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYmFja29mZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPT09IDQwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAndGxzX29ubHknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQxMDApIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xvc2VFdmVudC5jb2RlIDwgNDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuICdiYWNrb2ZmJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPCA0MzAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JldHJ5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldENsb3NlRXJyb3I6IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgIT09IDEwMDAgJiYgY2xvc2VFdmVudC5jb2RlICE9PSAxMDAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQdXNoZXJFcnJvcicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjbG9zZUV2ZW50LmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNsb3NlRXZlbnQucmVhc29uIHx8IGNsb3NlRXZlbnQubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwcm90b2NvbCA9IChQcm90b2NvbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9jb25uZWN0aW9uLnRzXG5cblxuXG5cbmNsYXNzIGNvbm5lY3Rpb25fQ29ubmVjdGlvbiBleHRlbmRzIGRpc3BhdGNoZXJfRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoaWQsIHRyYW5zcG9ydCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLmFjdGl2aXR5VGltZW91dCA9IHRyYW5zcG9ydC5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgIH1cbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5oYW5kbGVzQWN0aXZpdHlDaGVja3MoKTtcbiAgICB9XG4gICAgc2VuZChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgICBzZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0geyBldmVudDogbmFtZSwgZGF0YTogZGF0YSB9O1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgZXZlbnQuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdFdmVudCBzZW50JywgZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHByb3RvY29sLmVuY29kZU1lc3NhZ2UoZXZlbnQpKTtcbiAgICB9XG4gICAgcGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5waW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRfZXZlbnQoJ3B1c2hlcjpwaW5nJywge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoZXJFdmVudCA9IHByb3RvY29sLmRlY29kZU1lc3NhZ2UobWVzc2FnZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZXNzYWdlUGFyc2VFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHVzaGVyRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0V2ZW50IHJlY2QnLCBwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHVzaGVyRXZlbnQuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1c2hlcjplcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1B1c2hlckVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHVzaGVyRXZlbnQuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBvbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHB1c2hlckV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aXZpdHk6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2aXR5Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlZDogY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQgJiYgY2xvc2VFdmVudC5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VFdmVudChjbG9zZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1bmJpbmRMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICBvYmplY3RBcHBseShsaXN0ZW5lcnMsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBvYmplY3RBcHBseShsaXN0ZW5lcnMsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmJpbmQoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUNsb3NlRXZlbnQoY2xvc2VFdmVudCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gcHJvdG9jb2wuZ2V0Q2xvc2VBY3Rpb24oY2xvc2VFdmVudCk7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoYWN0aW9uLCB7IGFjdGlvbjogYWN0aW9uLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9oYW5kc2hha2UvaW5kZXgudHNcblxuXG5cbmNsYXNzIGhhbmRzaGFrZV9IYW5kc2hha2Uge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5iaW5kTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLm9uTWVzc2FnZSA9IG0gPT4ge1xuICAgICAgICAgICAgdGhpcy51bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb3RvY29sLnByb2Nlc3NIYW5kc2hha2UobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKCdlcnJvcicsIHsgZXJyb3I6IGUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjdGlvbiA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaCgnY29ubmVjdGVkJywge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBuZXcgY29ubmVjdGlvbl9Db25uZWN0aW9uKHJlc3VsdC5pZCwgdGhpcy50cmFuc3BvcnQpLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IHJlc3VsdC5hY3Rpdml0eVRpbWVvdXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKHJlc3VsdC5hY3Rpb24sIHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2xvc2VkID0gY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHByb3RvY29sLmdldENsb3NlQWN0aW9uKGNsb3NlRXZlbnQpIHx8ICdiYWNrb2ZmJztcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaChhY3Rpb24sIHsgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5iaW5kKCdtZXNzYWdlJywgdGhpcy5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5iaW5kKCdjbG9zZWQnLCB0aGlzLm9uQ2xvc2VkKTtcbiAgICB9XG4gICAgdW5iaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoJ21lc3NhZ2UnLCB0aGlzLm9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnVuYmluZCgnY2xvc2VkJywgdGhpcy5vbkNsb3NlZCk7XG4gICAgfVxuICAgIGZpbmlzaChhY3Rpb24sIHBhcmFtcykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGV4dGVuZCh7IHRyYW5zcG9ydDogdGhpcy50cmFuc3BvcnQsIGFjdGlvbjogYWN0aW9uIH0sIHBhcmFtcykpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90aW1lbGluZS90aW1lbGluZV9zZW5kZXIudHNcblxuY2xhc3MgdGltZWxpbmVfc2VuZGVyX1RpbWVsaW5lU2VuZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0aW1lbGluZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gdGltZWxpbmU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIHNlbmQodXNlVExTLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVsaW5lLnNlbmQobm9kZV9ydW50aW1lLlRpbWVsaW5lVHJhbnNwb3J0LmdldEFnZW50KHRoaXMsIHVzZVRMUyksIGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZXJyb3JzLnRzXG5jbGFzcyBCYWRFdmVudE5hbWUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgQmFkQ2hhbm5lbE5hbWUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgUmVxdWVzdFRpbWVkT3V0IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFRyYW5zcG9ydFByaW9yaXR5VG9vTG93IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFRyYW5zcG9ydENsb3NlZCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBVbnN1cHBvcnRlZEZlYXR1cmUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgVW5zdXBwb3J0ZWRUcmFuc3BvcnQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgVW5zdXBwb3J0ZWRTdHJhdGVneSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBIVFRQQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1cywgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy91cmxfc3RvcmUudHNcbmNvbnN0IHVybFN0b3JlID0ge1xuICAgIGJhc2VVcmw6ICdodHRwczovL3B1c2hlci5jb20nLFxuICAgIHVybHM6IHtcbiAgICAgICAgYXV0aGVudGljYXRpb25FbmRwb2ludDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NoYW5uZWxzL3NlcnZlcl9hcGkvYXV0aGVudGljYXRpbmdfdXNlcnMnXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGhvcml6YXRpb25FbmRwb2ludDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NoYW5uZWxzL3NlcnZlcl9hcGkvYXV0aG9yaXppbmctdXNlcnMvJ1xuICAgICAgICB9LFxuICAgICAgICBqYXZhc2NyaXB0UXVpY2tTdGFydDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2phdmFzY3JpcHRfcXVpY2tfc3RhcnQnXG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJpbmdDbGllbnRFdmVudHM6IHtcbiAgICAgICAgICAgIHBhdGg6ICcvZG9jcy9jbGllbnRfYXBpX2d1aWRlL2NsaWVudF9ldmVudHMjdHJpZ2dlci1ldmVudHMnXG4gICAgICAgIH0sXG4gICAgICAgIGVuY3J5cHRlZENoYW5uZWxTdXBwb3J0OiB7XG4gICAgICAgICAgICBmdWxsVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL3B1c2hlci9wdXNoZXItanMvdHJlZS9jYzQ5MTAxNTM3MWE0YmRlNTc0M2QxYzg3YTBmYmFjMGZlYjUzMTk1I2VuY3J5cHRlZC1jaGFubmVsLXN1cHBvcnQnXG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgYnVpbGRMb2dTdWZmaXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgY29uc3QgdXJsUHJlZml4ID0gJ1NlZTonO1xuICAgIGNvbnN0IHVybE9iaiA9IHVybFN0b3JlLnVybHNba2V5XTtcbiAgICBpZiAoIXVybE9iailcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGxldCB1cmw7XG4gICAgaWYgKHVybE9iai5mdWxsVXJsKSB7XG4gICAgICAgIHVybCA9IHVybE9iai5mdWxsVXJsO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmxPYmoucGF0aCkge1xuICAgICAgICB1cmwgPSB1cmxTdG9yZS5iYXNlVXJsICsgdXJsT2JqLnBhdGg7XG4gICAgfVxuICAgIGlmICghdXJsKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGAke3VybFByZWZpeH0gJHt1cmx9YDtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1cmxfc3RvcmUgPSAoeyBidWlsZExvZ1N1ZmZpeCB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9jaGFubmVsLnRzXG5cblxuXG5cblxuY2xhc3MgY2hhbm5lbF9DaGFubmVsIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgc3VwZXIoZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiAnICsgbmFtZSArICcgZm9yICcgKyBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnB1c2hlciA9IHB1c2hlcjtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBhdXRob3JpemUoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7IGF1dGg6ICcnIH0pO1xuICAgIH1cbiAgICB0cmlnZ2VyKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIGlmIChldmVudC5pbmRleE9mKCdjbGllbnQtJykgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCYWRFdmVudE5hbWUoXCJFdmVudCAnXCIgKyBldmVudCArIFwiJyBkb2VzIG5vdCBzdGFydCB3aXRoICdjbGllbnQtJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgndHJpZ2dlcmluZ0NsaWVudEV2ZW50cycpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYENsaWVudCBldmVudCB0cmlnZ2VyZWQgYmVmb3JlIGNoYW5uZWwgJ3N1YnNjcmlwdGlvbl9zdWNjZWVkZWQnIGV2ZW50IC4gJHtzdWZmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoZXZlbnQsIGRhdGEsIHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uU3VjY2VlZGVkRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fY291bnQnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkNvdW50RXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnVuc3Vic2NyaWJlKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlU3Vic2NyaXB0aW9uQ291bnRFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5zdWJzY3JpcHRpb25fY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ291bnQgPSBldmVudC5kYXRhLnN1YnNjcmlwdGlvbl9jb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fY291bnQnLCBldmVudC5kYXRhKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRob3JpemUodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zb2NrZXRfaWQsIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOnN1YnNjcmlwdGlvbl9lcnJvcicsIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0F1dGhFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgaW5zdGFuY2VvZiBIVFRQQXV0aEVycm9yID8geyBzdGF0dXM6IGVycm9yLnN0YXR1cyB9IDoge30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjpzdWJzY3JpYmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGF1dGg6IGRhdGEuYXV0aCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbF9kYXRhOiBkYXRhLmNoYW5uZWxfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjp1bnN1YnNjcmliZScsIHtcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMubmFtZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlaW5zdGF0ZVN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY2hhbm5lbHMvcHJpdmF0ZV9jaGFubmVsLnRzXG5cbmNsYXNzIHByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbCBleHRlbmRzIGNoYW5uZWxfQ2hhbm5lbCB7XG4gICAgYXV0aG9yaXplKHNvY2tldElkLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoZXIuY29uZmlnLmNoYW5uZWxBdXRob3JpemVyKHtcbiAgICAgICAgICAgIGNoYW5uZWxOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBzb2NrZXRJZDogc29ja2V0SWRcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9tZW1iZXJzLnRzXG5cbmNsYXNzIG1lbWJlcnNfTWVtYmVycyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgZ2V0KGlkKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tZW1iZXJzLCBpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGluZm86IHRoaXMubWVtYmVyc1tpZF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIG9iamVjdEFwcGx5KHRoaXMubWVtYmVycywgKG1lbWJlciwgaWQpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZ2V0KGlkKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRNeUlEKGlkKSB7XG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xuICAgIH1cbiAgICBvblN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25EYXRhKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IHN1YnNjcmlwdGlvbkRhdGEucHJlc2VuY2UuaGFzaDtcbiAgICAgICAgdGhpcy5jb3VudCA9IHN1YnNjcmlwdGlvbkRhdGEucHJlc2VuY2UuY291bnQ7XG4gICAgICAgIHRoaXMubWUgPSB0aGlzLmdldCh0aGlzLm15SUQpO1xuICAgIH1cbiAgICBhZGRNZW1iZXIobWVtYmVyRGF0YSkge1xuICAgICAgICBpZiAodGhpcy5nZXQobWVtYmVyRGF0YS51c2VyX2lkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVtYmVyc1ttZW1iZXJEYXRhLnVzZXJfaWRdID0gbWVtYmVyRGF0YS51c2VyX2luZm87XG4gICAgICAgIHJldHVybiB0aGlzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpO1xuICAgIH1cbiAgICByZW1vdmVNZW1iZXIobWVtYmVyRGF0YSkge1xuICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5nZXQobWVtYmVyRGF0YS51c2VyX2lkKTtcbiAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWVtYmVyc1ttZW1iZXJEYXRhLnVzZXJfaWRdO1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1iZXI7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMubXlJRCA9IG51bGw7XG4gICAgICAgIHRoaXMubWUgPSBudWxsO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9wcmVzZW5jZV9jaGFubmVsLnRzXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5cblxuXG5cbmNsYXNzIHByZXNlbmNlX2NoYW5uZWxfUHJlc2VuY2VDaGFubmVsIGV4dGVuZHMgcHJpdmF0ZV9jaGFubmVsX1ByaXZhdGVDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgcHVzaGVyKTtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbmV3IG1lbWJlcnNfTWVtYmVycygpO1xuICAgIH1cbiAgICBhdXRob3JpemUoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyLmF1dGhvcml6ZShzb2NrZXRJZCwgKGVycm9yLCBhdXRoRGF0YSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGF1dGhEYXRhID0gYXV0aERhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGhEYXRhLmNoYW5uZWxfZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFubmVsRGF0YSA9IEpTT04ucGFyc2UoYXV0aERhdGEuY2hhbm5lbF9kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldE15SUQoY2hhbm5lbERhdGEudXNlcl9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnB1c2hlci51c2VyLnNpZ25pbkRvbmVQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wdXNoZXIudXNlci51c2VyX2RhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldE15SUQodGhpcy5wdXNoZXIudXNlci51c2VyX2RhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnYXV0aG9yaXphdGlvbkVuZHBvaW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEludmFsaWQgYXV0aCByZXNwb25zZSBmb3IgY2hhbm5lbCAnJHt0aGlzLm5hbWV9JywgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkICdjaGFubmVsX2RhdGEnIGZpZWxkLiAke3N1ZmZpeH0sIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBvciB0aGUgdXNlciBzaG91bGQgYmUgc2lnbmVkIGluLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soJ0ludmFsaWQgYXV0aCByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGF1dGhEYXRhKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludGVybmFsRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICBpZiAoZXZlbnQudXNlcl9pZCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnVzZXJfaWQgPSBldmVudC51c2VyX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUludGVybmFsRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX2NvdW50JzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkNvdW50RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHVzaGVyX2ludGVybmFsOm1lbWJlcl9hZGRlZCc6XG4gICAgICAgICAgICAgICAgdmFyIGFkZGVkTWVtYmVyID0gdGhpcy5tZW1iZXJzLmFkZE1lbWJlcihkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjptZW1iZXJfYWRkZWQnLCBhZGRlZE1lbWJlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6bWVtYmVyX3JlbW92ZWQnOlxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkTWVtYmVyID0gdGhpcy5tZW1iZXJzLnJlbW92ZU1lbWJlcihkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE1lbWJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjptZW1iZXJfcmVtb3ZlZCcsIHJlbW92ZWRNZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hlci51bnN1YnNjcmliZSh0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzLm9uU3Vic2NyaXB0aW9uKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwdXNoZXI6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcsIHRoaXMubWVtYmVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLnJlc2V0KCk7XG4gICAgICAgIHN1cGVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi91dGY4L2xpYi91dGY4LmpzXG52YXIgdXRmOCA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvYmFzZTY0L2xpYi9iYXNlNjQuanNcbnZhciBiYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2VuY3J5cHRlZF9jaGFubmVsLnRzXG5cblxuXG5cblxuY2xhc3MgZW5jcnlwdGVkX2NoYW5uZWxfRW5jcnlwdGVkQ2hhbm5lbCBleHRlbmRzIHByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcHVzaGVyLCBuYWNsKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHB1c2hlcik7XG4gICAgICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uYWNsID0gbmFjbDtcbiAgICB9XG4gICAgYXV0aG9yaXplKHNvY2tldElkLCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlci5hdXRob3JpemUoc29ja2V0SWQsIChlcnJvciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBhdXRoRGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNoYXJlZFNlY3JldCA9IGF1dGhEYXRhWydzaGFyZWRfc2VjcmV0J107XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFNlY3JldCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgTm8gc2hhcmVkX3NlY3JldCBrZXkgaW4gYXV0aCBwYXlsb2FkIGZvciBlbmNyeXB0ZWQgY2hhbm5lbDogJHt0aGlzLm5hbWV9YCksIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2V5ID0gT2JqZWN0KGJhc2U2NFtcImRlY29kZVwiXSkoc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgIGRlbGV0ZSBhdXRoRGF0YVsnc2hhcmVkX3NlY3JldCddO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYXV0aERhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJpZ2dlcihldmVudCwgZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGZWF0dXJlKCdDbGllbnQgZXZlbnRzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBmb3IgZW5jcnlwdGVkIGNoYW5uZWxzJyk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMCB8fFxuICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgc3VwZXIuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlRW5jcnlwdGVkRXZlbnQoZXZlbnROYW1lLCBkYXRhKTtcbiAgICB9XG4gICAgaGFuZGxlRW5jcnlwdGVkRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdSZWNlaXZlZCBlbmNyeXB0ZWQgZXZlbnQgYmVmb3JlIGtleSBoYXMgYmVlbiByZXRyaWV2ZWQgZnJvbSB0aGUgYXV0aEVuZHBvaW50Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmNpcGhlcnRleHQgfHwgIWRhdGEubm9uY2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignVW5leHBlY3RlZCBmb3JtYXQgZm9yIGVuY3J5cHRlZCBldmVudCwgZXhwZWN0ZWQgb2JqZWN0IHdpdGggYGNpcGhlcnRleHRgIGFuZCBgbm9uY2VgIGZpZWxkcywgZ290OiAnICtcbiAgICAgICAgICAgICAgICBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2lwaGVyVGV4dCA9IE9iamVjdChiYXNlNjRbXCJkZWNvZGVcIl0pKGRhdGEuY2lwaGVydGV4dCk7XG4gICAgICAgIGlmIChjaXBoZXJUZXh0Lmxlbmd0aCA8IHRoaXMubmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IGNpcGhlcnRleHQgbGVuZ3RoIHRvIGJlICR7dGhpcy5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aH0sIGdvdDogJHtjaXBoZXJUZXh0Lmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9uY2UgPSBPYmplY3QoYmFzZTY0W1wiZGVjb2RlXCJdKShkYXRhLm5vbmNlKTtcbiAgICAgICAgaWYgKG5vbmNlLmxlbmd0aCA8IHRoaXMubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IG5vbmNlIGxlbmd0aCB0byBiZSAke3RoaXMubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGh9LCBnb3Q6ICR7bm9uY2UubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlcyA9IHRoaXMubmFjbC5zZWNyZXRib3gub3BlbihjaXBoZXJUZXh0LCBub25jZSwgdGhpcy5rZXkpO1xuICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRmFpbGVkIHRvIGRlY3J5cHQgYW4gZXZlbnQsIHByb2JhYmx5IGJlY2F1c2UgaXQgd2FzIGVuY3J5cHRlZCB3aXRoIGEgZGlmZmVyZW50IGtleS4gRmV0Y2hpbmcgYSBuZXcga2V5IGZyb20gdGhlIGF1dGhFbmRwb2ludC4uLicpO1xuICAgICAgICAgICAgdGhpcy5hdXRob3JpemUodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zb2NrZXRfaWQsIChlcnJvciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbWFrZSBhIHJlcXVlc3QgdG8gdGhlIGF1dGhFbmRwb2ludDogJHthdXRoRGF0YX0uIFVuYWJsZSB0byBmZXRjaCBuZXcga2V5LCBzbyBkcm9wcGluZyBlbmNyeXB0ZWQgZXZlbnRgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlcyA9IHRoaXMubmFjbC5zZWNyZXRib3gub3BlbihjaXBoZXJUZXh0LCBub25jZSwgdGhpcy5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBkZWNyeXB0IGV2ZW50IHdpdGggbmV3IGtleS4gRHJvcHBpbmcgZW5jcnlwdGVkIGV2ZW50YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCB0aGlzLmdldERhdGFUb0VtaXQoYnl0ZXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoZXZlbnQsIHRoaXMuZ2V0RGF0YVRvRW1pdChieXRlcykpO1xuICAgIH1cbiAgICBnZXREYXRhVG9FbWl0KGJ5dGVzKSB7XG4gICAgICAgIGxldCByYXcgPSBPYmplY3QodXRmOFtcImRlY29kZVwiXSkoYnl0ZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiByYXc7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9jb25uZWN0aW9uX21hbmFnZXIudHNcblxuXG5cblxuXG5jbGFzcyBjb25uZWN0aW9uX21hbmFnZXJfQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ2luaXRpYWxpemVkJztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSB0aGlzLm9wdGlvbnMudGltZWxpbmU7XG4gICAgICAgIHRoaXMudXNpbmdUTFMgPSB0aGlzLm9wdGlvbnMudXNlVExTO1xuICAgICAgICB0aGlzLmVycm9yQ2FsbGJhY2tzID0gdGhpcy5idWlsZEVycm9yQ2FsbGJhY2tzKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcyA9IHRoaXMuYnVpbGRDb25uZWN0aW9uQ2FsbGJhY2tzKHRoaXMuZXJyb3JDYWxsYmFja3MpO1xuICAgICAgICB0aGlzLmhhbmRzaGFrZUNhbGxiYWNrcyA9IHRoaXMuYnVpbGRIYW5kc2hha2VDYWxsYmFja3ModGhpcy5lcnJvckNhbGxiYWNrcyk7XG4gICAgICAgIHZhciBOZXR3b3JrID0gbm9kZV9ydW50aW1lLmdldE5ldHdvcmsoKTtcbiAgICAgICAgTmV0d29yay5iaW5kKCdvbmxpbmUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBuZXRpbmZvOiAnb25saW5lJyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ3VuYXZhaWxhYmxlJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0cnlJbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE5ldHdvcmsuYmluZCgnb2ZmbGluZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IG5ldGluZm86ICdvZmZsaW5lJyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0cmF0ZWd5KCk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gfHwgdGhpcy5ydW5uZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgnZmFpbGVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgnY29ubmVjdGluZycpO1xuICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICB0aGlzLnNldFVuYXZhaWxhYmxlVGltZXIoKTtcbiAgICB9XG4gICAgc2VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEludGVybmFsbHkoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgfVxuICAgIGlzVXNpbmdUTFMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzaW5nVExTO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IChlcnJvciwgaGFuZHNoYWtlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5lciA9IHRoaXMuc3RyYXRlZ3kuY29ubmVjdCgwLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlLmFjdGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0hhbmRzaGFrZUVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBoYW5kc2hha2UuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmUuZXJyb3IoeyBoYW5kc2hha2VFcnJvcjogaGFuZHNoYWtlLmVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kc2hha2VDYWxsYmFja3NbaGFuZHNoYWtlLmFjdGlvbl0oaGFuZHNoYWtlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVubmVyID0gdGhpcy5zdHJhdGVneS5jb25uZWN0KDAsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYWJvcnRDb25uZWN0aW5nKCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMucnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLnJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdEludGVybmFsbHkoKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIHRoaXMuY2xlYXJSZXRyeVRpbWVyKCk7XG4gICAgICAgIHRoaXMuY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5hYmFuZG9uQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0cmF0ZWd5KCkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5vcHRpb25zLmdldFN0cmF0ZWd5KHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgICAgICAgIHVzZVRMUzogdGhpcy51c2luZ1RMU1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0cnlJbihkZWxheSkge1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBhY3Rpb246ICdyZXRyeScsIGRlbGF5OiBkZWxheSB9KTtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW5nX2luJywgTWF0aC5yb3VuZChkZWxheSAvIDEwMDApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJ5VGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKGRlbGF5IHx8IDAsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEludGVybmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJSZXRyeVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZXRyeVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRVbmF2YWlsYWJsZVRpbWVyKCkge1xuICAgICAgICB0aGlzLnVuYXZhaWxhYmxlVGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKHRoaXMub3B0aW9ucy51bmF2YWlsYWJsZVRpbWVvdXQsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ3VuYXZhaWxhYmxlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhclVuYXZhaWxhYmxlVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuYXZhaWxhYmxlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudW5hdmFpbGFibGVUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZEFjdGl2aXR5Q2hlY2soKSB7XG4gICAgICAgIHRoaXMuc3RvcEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnBpbmcoKTtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcih0aGlzLm9wdGlvbnMucG9uZ1RpbWVvdXQsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmUuZXJyb3IoeyBwb25nX3RpbWVkX291dDogdGhpcy5vcHRpb25zLnBvbmdUaW1lb3V0IH0pO1xuICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzZXRBY3Rpdml0eUNoZWNrKCkge1xuICAgICAgICB0aGlzLnN0b3BBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gJiYgIXRoaXMuY29ubmVjdGlvbi5oYW5kbGVzQWN0aXZpdHlDaGVja3MoKSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcih0aGlzLmFjdGl2aXR5VGltZW91dCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3BBY3Rpdml0eUNoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5hY3Rpdml0eVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2aXR5VGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkQ29ubmVjdGlvbkNhbGxiYWNrcyhlcnJvckNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBlcnJvckNhbGxiYWNrcywge1xuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaW5nOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kX2V2ZW50KCdwdXNoZXI6cG9uZycsIHt9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3Rpdml0eTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJhbmRvbkNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRSZXRyeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnlJbigxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZEhhbmRzaGFrZUNhbGxiYWNrcyhlcnJvckNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBlcnJvckNhbGxiYWNrcywge1xuICAgICAgICAgICAgY29ubmVjdGVkOiAoaGFuZHNoYWtlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVvdXQgPSBNYXRoLm1pbih0aGlzLm9wdGlvbnMuYWN0aXZpdHlUaW1lb3V0LCBoYW5kc2hha2UuYWN0aXZpdHlUaW1lb3V0LCBoYW5kc2hha2UuY29ubmVjdGlvbi5hY3Rpdml0eVRpbWVvdXQgfHwgSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uKGhhbmRzaGFrZS5jb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldF9pZCA9IHRoaXMuY29ubmVjdGlvbi5pZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdjb25uZWN0ZWQnLCB7IHNvY2tldF9pZDogdGhpcy5zb2NrZXRfaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZEVycm9yQ2FsbGJhY2tzKCkge1xuICAgICAgICBsZXQgd2l0aEVycm9yRW1pdHRlZCA9IGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgeyB0eXBlOiAnV2ViU29ja2V0RXJyb3InLCBlcnJvcjogcmVzdWx0LmVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRsc19vbmx5OiB3aXRoRXJyb3JFbWl0dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzaW5nVExTID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0cmF0ZWd5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZWZ1c2VkOiB3aXRoRXJyb3JFbWl0dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYmFja29mZjogd2l0aEVycm9yRW1pdHRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDEwMDApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXRyeTogd2l0aEVycm9yRW1pdHRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGZvciAodmFyIGV2ZW50IGluIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoZXZlbnQsIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgfVxuICAgIGFiYW5kb25Db25uZWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgZm9yICh2YXIgZXZlbnQgaW4gdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24udW5iaW5kKGV2ZW50LCB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3NbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBkYXRhKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gbmV3U3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZURlc2NyaXB0aW9uID0gbmV3U3RhdGU7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGVEZXNjcmlwdGlvbiA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZURlc2NyaXB0aW9uICs9ICcgd2l0aCBuZXcgc29ja2V0IElEICcgKyBkYXRhLnNvY2tldF9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnU3RhdGUgY2hhbmdlZCcsIHByZXZpb3VzU3RhdGUgKyAnIC0+ICcgKyBuZXdTdGF0ZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IHN0YXRlOiBuZXdTdGF0ZSwgcGFyYW1zOiBkYXRhIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGF0ZV9jaGFuZ2UnLCB7IHByZXZpb3VzOiBwcmV2aW91c1N0YXRlLCBjdXJyZW50OiBuZXdTdGF0ZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChuZXdTdGF0ZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkUmV0cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2NoYW5uZWxzLnRzXG5cblxuXG5cbmNsYXNzIGNoYW5uZWxzX0NoYW5uZWxzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IHt9O1xuICAgIH1cbiAgICBhZGQobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGFubmVsc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tuYW1lXSA9IGNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tuYW1lXTtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdmFsdWVzKHRoaXMuY2hhbm5lbHMpO1xuICAgIH1cbiAgICBmaW5kKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgfVxuICAgIHJlbW92ZShuYW1lKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tuYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBvYmplY3RBcHBseSh0aGlzLmNoYW5uZWxzLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgY2hhbm5lbC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZigncHJpdmF0ZS1lbmNyeXB0ZWQtJykgPT09IDApIHtcbiAgICAgICAgaWYgKHB1c2hlci5jb25maWcubmFjbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlRW5jcnlwdGVkQ2hhbm5lbChuYW1lLCBwdXNoZXIsIHB1c2hlci5jb25maWcubmFjbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVyck1zZyA9ICdUcmllZCB0byBzdWJzY3JpYmUgdG8gYSBwcml2YXRlLWVuY3J5cHRlZC0gY2hhbm5lbCBidXQgbm8gbmFjbCBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUnO1xuICAgICAgICBsZXQgc3VmZml4ID0gdXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCdlbmNyeXB0ZWRDaGFubmVsU3VwcG9ydCcpO1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGZWF0dXJlKGAke2Vyck1zZ30uICR7c3VmZml4fWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3ByaXZhdGUtJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlUHJpdmF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdwcmVzZW5jZS0nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVQcmVzZW5jZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCcjJykgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEJhZENoYW5uZWxOYW1lKCdDYW5ub3QgY3JlYXRlIGEgY2hhbm5lbCB3aXRoIG5hbWUgXCInICsgbmFtZSArICdcIi4nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvZmFjdG9yeS50c1xuXG5cblxuXG5cblxuXG5cblxudmFyIEZhY3RvcnkgPSB7XG4gICAgY3JlYXRlQ2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2hhbm5lbHNfQ2hhbm5lbHMoKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbm5lY3Rpb25NYW5hZ2VyKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbm5lY3Rpb25fbWFuYWdlcl9Db25uZWN0aW9uTWFuYWdlcihrZXksIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjaGFubmVsX0NoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9LFxuICAgIGNyZWF0ZVByaXZhdGVDaGFubmVsKG5hbWUsIHB1c2hlcikge1xuICAgICAgICByZXR1cm4gbmV3IHByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH0sXG4gICAgY3JlYXRlUHJlc2VuY2VDaGFubmVsKG5hbWUsIHB1c2hlcikge1xuICAgICAgICByZXR1cm4gbmV3IHByZXNlbmNlX2NoYW5uZWxfUHJlc2VuY2VDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfSxcbiAgICBjcmVhdGVFbmNyeXB0ZWRDaGFubmVsKG5hbWUsIHB1c2hlciwgbmFjbCkge1xuICAgICAgICByZXR1cm4gbmV3IGVuY3J5cHRlZF9jaGFubmVsX0VuY3J5cHRlZENoYW5uZWwobmFtZSwgcHVzaGVyLCBuYWNsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVRpbWVsaW5lU2VuZGVyKHRpbWVsaW5lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGltZWxpbmVfc2VuZGVyX1RpbWVsaW5lU2VuZGVyKHRpbWVsaW5lLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhhbmRzaGFrZSh0cmFuc3BvcnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgaGFuZHNoYWtlX0hhbmRzaGFrZSh0cmFuc3BvcnQsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGNyZWF0ZUFzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlcihtYW5hZ2VyLCB0cmFuc3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlcihtYW5hZ2VyLCB0cmFuc3BvcnQsIG9wdGlvbnMpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmYWN0b3J5ID0gKEZhY3RvcnkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RyYW5zcG9ydHMvdHJhbnNwb3J0X21hbmFnZXIudHNcblxuY2xhc3MgdHJhbnNwb3J0X21hbmFnZXJfVHJhbnNwb3J0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmxpdmVzTGVmdCA9IHRoaXMub3B0aW9ucy5saXZlcyB8fCBJbmZpbml0eTtcbiAgICB9XG4gICAgZ2V0QXNzaXN0YW50KHRyYW5zcG9ydCkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIodGhpcywgdHJhbnNwb3J0LCB7XG4gICAgICAgICAgICBtaW5QaW5nRGVsYXk6IHRoaXMub3B0aW9ucy5taW5QaW5nRGVsYXksXG4gICAgICAgICAgICBtYXhQaW5nRGVsYXk6IHRoaXMub3B0aW9ucy5tYXhQaW5nRGVsYXlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQWxpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdmVzTGVmdCA+IDA7XG4gICAgfVxuICAgIHJlcG9ydERlYXRoKCkge1xuICAgICAgICB0aGlzLmxpdmVzTGVmdCAtPSAxO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL3NlcXVlbnRpYWxfc3RyYXRlZ3kudHNcblxuXG5cbmNsYXNzIHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVnaWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ2llcyA9IHN0cmF0ZWdpZXM7XG4gICAgICAgIHRoaXMubG9vcCA9IEJvb2xlYW4ob3B0aW9ucy5sb29wKTtcbiAgICAgICAgdGhpcy5mYWlsRmFzdCA9IEJvb2xlYW4ob3B0aW9ucy5mYWlsRmFzdCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgdGhpcy50aW1lb3V0TGltaXQgPSBvcHRpb25zLnRpbWVvdXRMaW1pdDtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5zdHJhdGVnaWVzLCB1dGlsLm1ldGhvZCgnaXNTdXBwb3J0ZWQnKSk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdHJhdGVnaWVzID0gdGhpcy5zdHJhdGVnaWVzO1xuICAgICAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICB2YXIgcnVubmVyID0gbnVsbDtcbiAgICAgICAgdmFyIHRyeU5leHRTdHJhdGVneSA9IChlcnJvciwgaGFuZHNoYWtlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaGFuZHNoYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50ICUgc3RyYXRlZ2llcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50IDwgc3RyYXRlZ2llcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSB0aW1lb3V0ICogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0LCB0aGlzLnRpbWVvdXRMaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcnVubmVyID0gdGhpcy50cnlTdHJhdGVneShzdHJhdGVnaWVzW2N1cnJlbnRdLCBtaW5Qcmlvcml0eSwgeyB0aW1lb3V0LCBmYWlsRmFzdDogdGhpcy5mYWlsRmFzdCB9LCB0cnlOZXh0U3RyYXRlZ3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBydW5uZXIgPSB0aGlzLnRyeVN0cmF0ZWd5KHN0cmF0ZWdpZXNbY3VycmVudF0sIG1pblByaW9yaXR5LCB7IHRpbWVvdXQ6IHRpbWVvdXQsIGZhaWxGYXN0OiB0aGlzLmZhaWxGYXN0IH0sIHRyeU5leHRTdHJhdGVneSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cnlTdHJhdGVneShzdHJhdGVneSwgbWluUHJpb3JpdHksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgICAgIHZhciBydW5uZXIgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKG9wdGlvbnMudGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVubmVyID0gc3RyYXRlZ3kuY29ubmVjdChtaW5Qcmlvcml0eSwgZnVuY3Rpb24gKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiB0aW1lciAmJiB0aW1lci5pc1J1bm5pbmcoKSAmJiAhb3B0aW9ucy5mYWlsRmFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIHRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBoYW5kc2hha2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9iZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5LnRzXG5cblxuY2xhc3MgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVnaWVzKSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ2llcyA9IHN0cmF0ZWdpZXM7XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuc3RyYXRlZ2llcywgdXRpbC5tZXRob2QoJ2lzU3VwcG9ydGVkJykpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY29ubmVjdCh0aGlzLnN0cmF0ZWdpZXMsIG1pblByaW9yaXR5LCBmdW5jdGlvbiAoaSwgcnVubmVycykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyc1tpXS5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsUnVubmVyc0ZhaWxlZChydW5uZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBseShydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KGhhbmRzaGFrZS50cmFuc3BvcnQucHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhbmRzaGFrZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb25uZWN0KHN0cmF0ZWdpZXMsIG1pblByaW9yaXR5LCBjYWxsYmFja0J1aWxkZXIpIHtcbiAgICB2YXIgcnVubmVycyA9IG1hcChzdHJhdGVnaWVzLCBmdW5jdGlvbiAoc3RyYXRlZ3ksIGksIF8sIHJzKSB7XG4gICAgICAgIHJldHVybiBzdHJhdGVneS5jb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFja0J1aWxkZXIoaSwgcnMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXBwbHkocnVubmVycywgYWJvcnRSdW5uZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgYXBwbHkocnVubmVycywgZnVuY3Rpb24gKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gYWxsUnVubmVyc0ZhaWxlZChydW5uZXJzKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25zX2FsbChydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHJ1bm5lci5lcnJvcik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhYm9ydFJ1bm5lcihydW5uZXIpIHtcbiAgICBpZiAoIXJ1bm5lci5lcnJvciAmJiAhcnVubmVyLmFib3J0ZWQpIHtcbiAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgIHJ1bm5lci5hYm9ydGVkID0gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy93ZWJzb2NrZXRfcHJpb3JpdGl6ZWRfY2FjaGVkX3N0cmF0ZWd5LnRzXG5cblxuXG5cbmNsYXNzIHdlYnNvY2tldF9wcmlvcml0aXplZF9jYWNoZWRfc3RyYXRlZ3lfV2ViU29ja2V0UHJpb3JpdGl6ZWRDYWNoZWRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ3ksIHRyYW5zcG9ydHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzO1xuICAgICAgICB0aGlzLnR0bCA9IG9wdGlvbnMudHRsIHx8IDE4MDAgKiAxMDAwO1xuICAgICAgICB0aGlzLnVzaW5nVExTID0gb3B0aW9ucy51c2VUTFM7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSBvcHRpb25zLnRpbWVsaW5lO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHVzaW5nVExTID0gdGhpcy51c2luZ1RMUztcbiAgICAgICAgdmFyIGluZm8gPSBmZXRjaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKTtcbiAgICAgICAgdmFyIGNhY2hlU2tpcENvdW50ID0gaW5mbyAmJiBpbmZvLmNhY2hlU2tpcENvdW50ID8gaW5mby5jYWNoZVNraXBDb3VudCA6IDA7XG4gICAgICAgIHZhciBzdHJhdGVnaWVzID0gW3RoaXMuc3RyYXRlZ3ldO1xuICAgICAgICBpZiAoaW5mbyAmJiBpbmZvLnRpbWVzdGFtcCArIHRoaXMudHRsID49IHV0aWwubm93KCkpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbaW5mby50cmFuc3BvcnRdO1xuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGlmIChbJ3dzJywgJ3dzcyddLmluY2x1ZGVzKGluZm8udHJhbnNwb3J0KSB8fCBjYWNoZVNraXBDb3VudCA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaW5mby50cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlbmN5OiBpbmZvLmxhdGVuY3lcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmF0ZWdpZXMucHVzaChuZXcgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3koW3RyYW5zcG9ydF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IGluZm8ubGF0ZW5jeSAqIDIgKyAxMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbEZhc3Q6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVTa2lwQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0VGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgdmFyIHJ1bm5lciA9IHN0cmF0ZWdpZXNcbiAgICAgICAgICAgIC5wb3AoKVxuICAgICAgICAgICAgLmNvbm5lY3QobWluUHJpb3JpdHksIGZ1bmN0aW9uIGNiKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGZsdXNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVnaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXAgPSB1dGlsLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIgPSBzdHJhdGVnaWVzLnBvcCgpLmNvbm5lY3QobWluUHJpb3JpdHksIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yZVRyYW5zcG9ydENhY2hlKHVzaW5nVExTLCBoYW5kc2hha2UudHJhbnNwb3J0Lm5hbWUsIHV0aWwubm93KCkgLSBzdGFydFRpbWVzdGFtcCwgY2FjaGVTa2lwQ291bnQpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhbmRzaGFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIG1pblByaW9yaXR5ID0gcDtcbiAgICAgICAgICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUcmFuc3BvcnRDYWNoZUtleSh1c2luZ1RMUykge1xuICAgIHJldHVybiAncHVzaGVyVHJhbnNwb3J0JyArICh1c2luZ1RMUyA/ICdUTFMnIDogJ05vblRMUycpO1xufVxuZnVuY3Rpb24gZmV0Y2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUykge1xuICAgIHZhciBzdG9yYWdlID0gbm9kZV9ydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZENhY2hlID0gc3RvcmFnZVtnZXRUcmFuc3BvcnRDYWNoZUtleSh1c2luZ1RMUyldO1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHNlcmlhbGl6ZWRDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGZsdXNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc3RvcmVUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUywgdHJhbnNwb3J0LCBsYXRlbmN5LCBjYWNoZVNraXBDb3VudCkge1xuICAgIHZhciBzdG9yYWdlID0gbm9kZV9ydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdG9yYWdlW2dldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKV0gPSBzYWZlSlNPTlN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB1dGlsLm5vdygpLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IGxhdGVuY3ksXG4gICAgICAgICAgICAgICAgY2FjaGVTa2lwQ291bnQ6IGNhY2hlU2tpcENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmx1c2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUykge1xuICAgIHZhciBzdG9yYWdlID0gbm9kZV9ydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmFnZVtnZXRUcmFuc3BvcnRDYWNoZUtleSh1c2luZ1RMUyldO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9kZWxheWVkX3N0cmF0ZWd5LnRzXG5cbmNsYXNzIGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVneSwgeyBkZWxheTogbnVtYmVyIH0pIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7IGRlbGF5OiBudW1iZXIgfTtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmlzU3VwcG9ydGVkKCk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdHJhdGVneSA9IHRoaXMuc3RyYXRlZ3k7XG4gICAgICAgIHZhciBydW5uZXI7XG4gICAgICAgIHZhciB0aW1lciA9IG5ldyB0aW1lcnNfT25lT2ZmVGltZXIodGhpcy5vcHRpb25zLmRlbGF5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBzdHJhdGVneS5jb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBtaW5Qcmlvcml0eSA9IHA7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvaWZfc3RyYXRlZ3kudHNcbmNsYXNzIElmU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKHRlc3QsIHRydWVCcmFuY2gsIGZhbHNlQnJhbmNoKSB7XG4gICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgIHRoaXMudHJ1ZUJyYW5jaCA9IHRydWVCcmFuY2g7XG4gICAgICAgIHRoaXMuZmFsc2VCcmFuY2ggPSBmYWxzZUJyYW5jaDtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHZhciBicmFuY2ggPSB0aGlzLnRlc3QoKSA/IHRoaXMudHJ1ZUJyYW5jaCA6IHRoaXMuZmFsc2VCcmFuY2g7XG4gICAgICAgIHJldHVybiBicmFuY2guaXNTdXBwb3J0ZWQoKTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGJyYW5jaCA9IHRoaXMudGVzdCgpID8gdGhpcy50cnVlQnJhbmNoIDogdGhpcy5mYWxzZUJyYW5jaDtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5jb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvZmlyc3RfY29ubmVjdGVkX3N0cmF0ZWd5LnRzXG5jbGFzcyBGaXJzdENvbm5lY3RlZFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVneSkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcnVubmVyID0gdGhpcy5zdHJhdGVneS5jb25uZWN0KG1pblByaW9yaXR5LCBmdW5jdGlvbiAoZXJyb3IsIGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgaWYgKGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGhhbmRzaGFrZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy9kZWZhdWx0X3N0cmF0ZWd5LnRzXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gdGVzdFN1cHBvcnRzU3RyYXRlZ3koc3RyYXRlZ3kpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9O1xufVxudmFyIGdldERlZmF1bHRTdHJhdGVneSA9IGZ1bmN0aW9uIChjb25maWcsIGJhc2VPcHRpb25zLCBkZWZpbmVUcmFuc3BvcnQpIHtcbiAgICB2YXIgZGVmaW5lZFRyYW5zcG9ydHMgPSB7fTtcbiAgICBmdW5jdGlvbiBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneShuYW1lLCB0eXBlLCBwcmlvcml0eSwgb3B0aW9ucywgbWFuYWdlcikge1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0KGNvbmZpZywgbmFtZSwgdHlwZSwgcHJpb3JpdHksIG9wdGlvbnMsIG1hbmFnZXIpO1xuICAgICAgICBkZWZpbmVkVHJhbnNwb3J0c1tuYW1lXSA9IHRyYW5zcG9ydDtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICB9XG4gICAgdmFyIHdzX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlT3B0aW9ucywge1xuICAgICAgICBob3N0Tm9uVExTOiBjb25maWcud3NIb3N0ICsgJzonICsgY29uZmlnLndzUG9ydCxcbiAgICAgICAgaG9zdFRMUzogY29uZmlnLndzSG9zdCArICc6JyArIGNvbmZpZy53c3NQb3J0LFxuICAgICAgICBodHRwUGF0aDogY29uZmlnLndzUGF0aFxuICAgIH0pO1xuICAgIHZhciB3c3Nfb3B0aW9ucyA9IGV4dGVuZCh7fSwgd3Nfb3B0aW9ucywge1xuICAgICAgICB1c2VUTFM6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgaHR0cF9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZU9wdGlvbnMsIHtcbiAgICAgICAgaG9zdE5vblRMUzogY29uZmlnLmh0dHBIb3N0ICsgJzonICsgY29uZmlnLmh0dHBQb3J0LFxuICAgICAgICBob3N0VExTOiBjb25maWcuaHR0cEhvc3QgKyAnOicgKyBjb25maWcuaHR0cHNQb3J0LFxuICAgICAgICBodHRwUGF0aDogY29uZmlnLmh0dHBQYXRoXG4gICAgfSk7XG4gICAgdmFyIHRpbWVvdXRzID0ge1xuICAgICAgICBsb29wOiB0cnVlLFxuICAgICAgICB0aW1lb3V0OiAxNTAwMCxcbiAgICAgICAgdGltZW91dExpbWl0OiA2MDAwMFxuICAgIH07XG4gICAgdmFyIHdzX21hbmFnZXIgPSBuZXcgdHJhbnNwb3J0X21hbmFnZXJfVHJhbnNwb3J0TWFuYWdlcih7XG4gICAgICAgIG1pblBpbmdEZWxheTogMTAwMDAsXG4gICAgICAgIG1heFBpbmdEZWxheTogY29uZmlnLmFjdGl2aXR5VGltZW91dFxuICAgIH0pO1xuICAgIHZhciBzdHJlYW1pbmdfbWFuYWdlciA9IG5ldyB0cmFuc3BvcnRfbWFuYWdlcl9UcmFuc3BvcnRNYW5hZ2VyKHtcbiAgICAgICAgbGl2ZXM6IDIsXG4gICAgICAgIG1pblBpbmdEZWxheTogMTAwMDAsXG4gICAgICAgIG1heFBpbmdEZWxheTogY29uZmlnLmFjdGl2aXR5VGltZW91dFxuICAgIH0pO1xuICAgIHZhciB3c190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgnd3MnLCAnd3MnLCAzLCB3c19vcHRpb25zLCB3c19tYW5hZ2VyKTtcbiAgICB2YXIgd3NzX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd3c3MnLCAnd3MnLCAzLCB3c3Nfb3B0aW9ucywgd3NfbWFuYWdlcik7XG4gICAgdmFyIHhocl9zdHJlYW1pbmdfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3hocl9zdHJlYW1pbmcnLCAneGhyX3N0cmVhbWluZycsIDEsIGh0dHBfb3B0aW9ucywgc3RyZWFtaW5nX21hbmFnZXIpO1xuICAgIHZhciB4aHJfcG9sbGluZ190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgneGhyX3BvbGxpbmcnLCAneGhyX3BvbGxpbmcnLCAxLCBodHRwX29wdGlvbnMpO1xuICAgIHZhciB3c19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt3c190cmFuc3BvcnRdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHdzc19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt3c3NfdHJhbnNwb3J0XSwgdGltZW91dHMpO1xuICAgIHZhciBzdHJlYW1pbmdfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbeGhyX3N0cmVhbWluZ190cmFuc3BvcnRdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHBvbGxpbmdfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbeGhyX3BvbGxpbmdfdHJhbnNwb3J0XSwgdGltZW91dHMpO1xuICAgIHZhciBodHRwX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3koW1xuICAgICAgICBuZXcgSWZTdHJhdGVneSh0ZXN0U3VwcG9ydHNTdHJhdGVneShzdHJlYW1pbmdfbG9vcCksIG5ldyBiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5X0Jlc3RDb25uZWN0ZWRFdmVyU3RyYXRlZ3koW1xuICAgICAgICAgICAgc3RyZWFtaW5nX2xvb3AsXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3kocG9sbGluZ19sb29wLCB7IGRlbGF5OiA0MDAwIH0pXG4gICAgICAgIF0pLCBwb2xsaW5nX2xvb3ApXG4gICAgXSwgdGltZW91dHMpO1xuICAgIHZhciB3c1N0cmF0ZWd5O1xuICAgIGlmIChiYXNlT3B0aW9ucy51c2VUTFMpIHtcbiAgICAgICAgd3NTdHJhdGVneSA9IG5ldyBiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5X0Jlc3RDb25uZWN0ZWRFdmVyU3RyYXRlZ3koW1xuICAgICAgICAgICAgd3NfbG9vcCxcbiAgICAgICAgICAgIG5ldyBkZWxheWVkX3N0cmF0ZWd5X0RlbGF5ZWRTdHJhdGVneShodHRwX2xvb3AsIHsgZGVsYXk6IDIwMDAgfSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3c1N0cmF0ZWd5ID0gbmV3IGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3lfQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneShbXG4gICAgICAgICAgICB3c19sb29wLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5KHdzc19sb29wLCB7IGRlbGF5OiAyMDAwIH0pLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5KGh0dHBfbG9vcCwgeyBkZWxheTogNTAwMCB9KVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB3ZWJzb2NrZXRfcHJpb3JpdGl6ZWRfY2FjaGVkX3N0cmF0ZWd5X1dlYlNvY2tldFByaW9yaXRpemVkQ2FjaGVkU3RyYXRlZ3kobmV3IEZpcnN0Q29ubmVjdGVkU3RyYXRlZ3kobmV3IElmU3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3kod3NfdHJhbnNwb3J0KSwgd3NTdHJhdGVneSwgaHR0cF9sb29wKSksIGRlZmluZWRUcmFuc3BvcnRzLCB7XG4gICAgICAgIHR0bDogMTgwMDAwMCxcbiAgICAgICAgdGltZWxpbmU6IGJhc2VPcHRpb25zLnRpbWVsaW5lLFxuICAgICAgICB1c2VUTFM6IGJhc2VPcHRpb25zLnVzZVRMU1xuICAgIH0pO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRlZmF1bHRfc3RyYXRlZ3kgPSAoZ2V0RGVmYXVsdFN0cmF0ZWd5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy90cmFuc3BvcnRzL3RyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyLnRzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRfY29ubmVjdGlvbl9pbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudGltZWxpbmUuaW5mbyhzZWxmLmJ1aWxkVGltZWxpbmVNZXNzYWdlKHtcbiAgICAgICAgdHJhbnNwb3J0OiBzZWxmLm5hbWUgKyAoc2VsZi5vcHRpb25zLnVzZVRMUyA/ICdzJyA6ICcnKVxuICAgIH0pKTtcbiAgICBpZiAoc2VsZi5ob29rcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgc2VsZi5jaGFuZ2VTdGF0ZSgnaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgIH1cbn0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9yZXF1ZXN0LnRzXG5cblxuY29uc3QgTUFYX0JVRkZFUl9MRU5HVEggPSAyNTYgKiAxMDI0O1xuY2xhc3MgaHR0cF9yZXF1ZXN0X0hUVFBSZXF1ZXN0IGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihob29rcywgbWV0aG9kLCB1cmwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxuICAgIHN0YXJ0KHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMueGhyID0gdGhpcy5ob29rcy5nZXRSZXF1ZXN0KHRoaXMpO1xuICAgICAgICB0aGlzLnVubG9hZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBub2RlX3J1bnRpbWUuYWRkVW5sb2FkTGlzdGVuZXIodGhpcy51bmxvYWRlcik7XG4gICAgICAgIHRoaXMueGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChwYXlsb2FkKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnVubG9hZGVyKSB7XG4gICAgICAgICAgICBub2RlX3J1bnRpbWUucmVtb3ZlVW5sb2FkTGlzdGVuZXIodGhpcy51bmxvYWRlcik7XG4gICAgICAgICAgICB0aGlzLnVubG9hZGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy54aHIpIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MuYWJvcnRSZXF1ZXN0KHRoaXMueGhyKTtcbiAgICAgICAgICAgIHRoaXMueGhyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNodW5rKHN0YXR1cywgZGF0YSkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGNodW5rID0gdGhpcy5hZHZhbmNlQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjaHVuaycsIHsgc3RhdHVzOiBzdGF0dXMsIGRhdGE6IGNodW5rIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNCdWZmZXJUb29Mb25nKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2J1ZmZlcl90b29fbG9uZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkdmFuY2VCdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIHZhciB1bnJlYWREYXRhID0gYnVmZmVyLnNsaWNlKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB2YXIgZW5kT2ZMaW5lUG9zaXRpb24gPSB1bnJlYWREYXRhLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICBpZiAoZW5kT2ZMaW5lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGVuZE9mTGluZVBvc2l0aW9uICsgMTtcbiAgICAgICAgICAgIHJldHVybiB1bnJlYWREYXRhLnNsaWNlKDAsIGVuZE9mTGluZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQnVmZmVyVG9vTG9uZyhidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyLmxlbmd0aCA+IE1BWF9CVUZGRVJfTEVOR1RIO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9odHRwL3N0YXRlLnRzXG52YXIgU3RhdGU7XG4oZnVuY3Rpb24gKFN0YXRlKSB7XG4gICAgU3RhdGVbU3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QRU5cIl0gPSAxXSA9IFwiT1BFTlwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQ0xPU0VEXCJdID0gM10gPSBcIkNMT1NFRFwiO1xufSkoU3RhdGUgfHwgKFN0YXRlID0ge30pKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN0YXRlID0gKFN0YXRlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9odHRwL2h0dHBfc29ja2V0LnRzXG5cblxuXG52YXIgYXV0b0luY3JlbWVudCA9IDE7XG5jbGFzcyBodHRwX3NvY2tldF9IVFRQU29ja2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihob29rcywgdXJsKSB7XG4gICAgICAgIHRoaXMuaG9va3MgPSBob29rcztcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gcmFuZG9tTnVtYmVyKDEwMDApICsgJy8nICsgcmFuZG9tU3RyaW5nKDgpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gZ2V0TG9jYXRpb24odXJsKTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGUuQ09OTkVDVElORztcbiAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XG4gICAgfVxuICAgIHNlbmQocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmF3KEpTT04uc3RyaW5naWZ5KFtwYXlsb2FkXSkpO1xuICAgIH1cbiAgICBwaW5nKCkge1xuICAgICAgICB0aGlzLmhvb2tzLnNlbmRIZWFydGJlYXQodGhpcyk7XG4gICAgfVxuICAgIGNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLm9uQ2xvc2UoY29kZSwgcmVhc29uLCB0cnVlKTtcbiAgICB9XG4gICAgc2VuZFJhdyhwYXlsb2FkKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLk9QRU4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9kZV9ydW50aW1lLmNyZWF0ZVNvY2tldFJlcXVlc3QoJ1BPU1QnLCBnZXRVbmlxdWVVUkwoZ2V0U2VuZFVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLnNlc3Npb24pKSkuc3RhcnQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XG4gICAgfVxuICAgIG9uQ2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICAgICAgICB0aGlzLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlLkNMT1NFRDtcbiAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgIHdhc0NsZWFuOiB3YXNDbGVhblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DaHVuayhjaHVuaykge1xuICAgICAgICBpZiAoY2h1bmsuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF5bG9hZDtcbiAgICAgICAgdmFyIHR5cGUgPSBjaHVuay5kYXRhLnNsaWNlKDAsIDEpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ3t9Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk9wZW4ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICdbXScpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF5bG9hZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXZlbnQocGF5bG9hZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY2h1bmsuZGF0YS5zbGljZSgxKSB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIHRoaXMub25FdmVudChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgIHRoaXMuaG9va3Mub25IZWFydGJlYXQodGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICdbXScpO1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW4ob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi5iYXNlID0gcmVwbGFjZUhvc3QodGhpcy5sb2NhdGlvbi5iYXNlLCBvcHRpb25zLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlLk9QRU47XG4gICAgICAgICAgICBpZiAodGhpcy5vbm9wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5PUEVOICYmIHRoaXMub25tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm9ubWVzc2FnZSh7IGRhdGE6IGV2ZW50IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQWN0aXZpdHkoKSB7XG4gICAgICAgIGlmICh0aGlzLm9uYWN0aXZpdHkpIHtcbiAgICAgICAgICAgIHRoaXMub25hY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMub25lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuU3RyZWFtKCkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG5vZGVfcnVudGltZS5jcmVhdGVTb2NrZXRSZXF1ZXN0KCdQT1NUJywgZ2V0VW5pcXVlVVJMKHRoaXMuaG9va3MuZ2V0UmVjZWl2ZVVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLnNlc3Npb24pKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmJpbmQoJ2NodW5rJywgY2h1bmsgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNodW5rKGNodW5rKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmJpbmQoJ2ZpbmlzaGVkJywgc3RhdHVzID0+IHtcbiAgICAgICAgICAgIHRoaXMuaG9va3Mub25GaW5pc2hlZCh0aGlzLCBzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnYnVmZmVyX3Rvb19sb25nJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdXRpbC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoMTAwNiwgJ0NvdWxkIG5vdCBzdGFydCBzdHJlYW1pbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZVN0cmVhbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS51bmJpbmRfYWxsKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TG9jYXRpb24odXJsKSB7XG4gICAgdmFyIHBhcnRzID0gLyhbXlxcP10qKVxcLyooXFw/Py4qKS8uZXhlYyh1cmwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IHBhcnRzWzFdLFxuICAgICAgICBxdWVyeVN0cmluZzogcGFydHNbMl1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VuZFVSTCh1cmwsIHNlc3Npb24pIHtcbiAgICByZXR1cm4gdXJsLmJhc2UgKyAnLycgKyBzZXNzaW9uICsgJy94aHJfc2VuZCc7XG59XG5mdW5jdGlvbiBnZXRVbmlxdWVVUkwodXJsKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnO1xuICAgIHJldHVybiB1cmwgKyBzZXBhcmF0b3IgKyAndD0nICsgK25ldyBEYXRlKCkgKyAnJm49JyArIGF1dG9JbmNyZW1lbnQrKztcbn1cbmZ1bmN0aW9uIHJlcGxhY2VIb3N0KHVybCwgaG9zdG5hbWUpIHtcbiAgICB2YXIgdXJsUGFydHMgPSAvKGh0dHBzPzpcXC9cXC8pKFteXFwvOl0rKSgoXFwvfDopPy4qKS8uZXhlYyh1cmwpO1xuICAgIHJldHVybiB1cmxQYXJ0c1sxXSArIGhvc3RuYW1lICsgdXJsUGFydHNbM107XG59XG5mdW5jdGlvbiByYW5kb21OdW1iZXIobWF4KSB7XG4gICAgcmV0dXJuIG5vZGVfcnVudGltZS5yYW5kb21JbnQobWF4KTtcbn1cbmZ1bmN0aW9uIHJhbmRvbVN0cmluZyhsZW5ndGgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChyYW5kb21OdW1iZXIoMzIpLnRvU3RyaW5nKDMyKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3NvY2tldCA9IChodHRwX3NvY2tldF9IVFRQU29ja2V0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9odHRwL2h0dHBfc3RyZWFtaW5nX3NvY2tldC50c1xudmFyIGh0dHBfc3RyZWFtaW5nX3NvY2tldF9ob29rcyA9IHtcbiAgICBnZXRSZWNlaXZlVVJMOiBmdW5jdGlvbiAodXJsLCBzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB1cmwuYmFzZSArICcvJyArIHNlc3Npb24gKyAnL3hocl9zdHJlYW1pbmcnICsgdXJsLnF1ZXJ5U3RyaW5nO1xuICAgIH0sXG4gICAgb25IZWFydGJlYXQ6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0LnNlbmRSYXcoJ1tdJyk7XG4gICAgfSxcbiAgICBzZW5kSGVhcnRiZWF0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHNvY2tldC5zZW5kUmF3KCdbXScpO1xuICAgIH0sXG4gICAgb25GaW5pc2hlZDogZnVuY3Rpb24gKHNvY2tldCwgc3RhdHVzKSB7XG4gICAgICAgIHNvY2tldC5vbkNsb3NlKDEwMDYsICdDb25uZWN0aW9uIGludGVycnVwdGVkICgnICsgc3RhdHVzICsgJyknLCBmYWxzZSk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfc3RyZWFtaW5nX3NvY2tldCA9IChodHRwX3N0cmVhbWluZ19zb2NrZXRfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9wb2xsaW5nX3NvY2tldC50c1xudmFyIGh0dHBfcG9sbGluZ19zb2NrZXRfaG9va3MgPSB7XG4gICAgZ2V0UmVjZWl2ZVVSTDogZnVuY3Rpb24gKHVybCwgc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gdXJsLmJhc2UgKyAnLycgKyBzZXNzaW9uICsgJy94aHInICsgdXJsLnF1ZXJ5U3RyaW5nO1xuICAgIH0sXG4gICAgb25IZWFydGJlYXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB9LFxuICAgIHNlbmRIZWFydGJlYXQ6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0LnNlbmRSYXcoJ1tdJyk7XG4gICAgfSxcbiAgICBvbkZpbmlzaGVkOiBmdW5jdGlvbiAoc29ja2V0LCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICBzb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb2NrZXQub25DbG9zZSgxMDA2LCAnQ29ubmVjdGlvbiBpbnRlcnJ1cHRlZCAoJyArIHN0YXR1cyArICcpJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfcG9sbGluZ19zb2NrZXQgPSAoaHR0cF9wb2xsaW5nX3NvY2tldF9ob29rcyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL2lzb21vcnBoaWMvaHR0cC9odHRwX3hocl9yZXF1ZXN0LnRzXG5cbnZhciBodHRwX3hocl9yZXF1ZXN0X2hvb2tzID0ge1xuICAgIGdldFJlcXVlc3Q6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gbm9kZV9ydW50aW1lLmdldFhIUkFQSSgpO1xuICAgICAgICB2YXIgeGhyID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoeGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUZXh0ICYmIHhoci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uQ2h1bmsoeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVGV4dCAmJiB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbkNodW5rKHhoci5zdGF0dXMsIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KCdmaW5pc2hlZCcsIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcbiAgICBhYm9ydFJlcXVlc3Q6IGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3hocl9yZXF1ZXN0ID0gKGh0dHBfeGhyX3JlcXVlc3RfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2h0dHAvaHR0cC50c1xuXG5cblxuXG5cbnZhciBIVFRQID0ge1xuICAgIGNyZWF0ZVN0cmVhbWluZ1NvY2tldCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29ja2V0KGh0dHBfc3RyZWFtaW5nX3NvY2tldCwgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVBvbGxpbmdTb2NrZXQodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvY2tldChodHRwX3BvbGxpbmdfc29ja2V0LCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlU29ja2V0KGhvb2tzLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwX3NvY2tldChob29rcywgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVhIUihtZXRob2QsIHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXF1ZXN0KGh0dHBfeGhyX3JlcXVlc3QsIG1ldGhvZCwgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVJlcXVlc3QoaG9va3MsIG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgaHR0cF9yZXF1ZXN0X0hUVFBSZXF1ZXN0KGhvb2tzLCBtZXRob2QsIHVybCk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfaHR0cCA9IChIVFRQKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy9ydW50aW1lLnRzXG5cblxuXG5cblxudmFyIElzb21vcnBoaWMgPSB7XG4gICAgZ2V0RGVmYXVsdFN0cmF0ZWd5OiBkZWZhdWx0X3N0cmF0ZWd5LFxuICAgIFRyYW5zcG9ydHM6IHRyYW5zcG9ydHMsXG4gICAgdHJhbnNwb3J0Q29ubmVjdGlvbkluaXRpYWxpemVyOiB0cmFuc3BvcnRfY29ubmVjdGlvbl9pbml0aWFsaXplcixcbiAgICBIVFRQRmFjdG9yeTogaHR0cF9odHRwLFxuICAgIHNldHVwKFB1c2hlckNsYXNzKSB7XG4gICAgICAgIFB1c2hlckNsYXNzLnJlYWR5KCk7XG4gICAgfSxcbiAgICBnZXRMb2NhbFN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBnZXRDbGllbnRGZWF0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMoZmlsdGVyT2JqZWN0KHsgd3M6IHRyYW5zcG9ydHMud3MgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmlzU3VwcG9ydGVkKHt9KTtcbiAgICAgICAgfSkpO1xuICAgIH0sXG4gICAgZ2V0UHJvdG9jb2woKSB7XG4gICAgICAgIHJldHVybiAnaHR0cDonO1xuICAgIH0sXG4gICAgaXNYSFJTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgY3JlYXRlU29ja2V0UmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgICAgICBpZiAodGhpcy5pc1hIUlN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5IVFRQRmFjdG9yeS5jcmVhdGVYSFIobWV0aG9kLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0Nyb3NzLW9yaWdpbiBIVFRQIHJlcXVlc3RzIGFyZSBub3Qgc3VwcG9ydGVkJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlWEhSKCkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzLmdldFhIUkFQSSgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgfSxcbiAgICBjcmVhdGVXZWJTb2NrZXQodXJsKSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0V2ViU29ja2V0QVBJKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IodXJsKTtcbiAgICB9LFxuICAgIGFkZFVubG9hZExpc3RlbmVyKGxpc3RlbmVyKSB7IH0sXG4gICAgcmVtb3ZlVW5sb2FkTGlzdGVuZXIobGlzdGVuZXIpIHsgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJ1bnRpbWUgPSAoSXNvbW9ycGhpYyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZmF5ZS13ZWJzb2NrZXQvbGliL2ZheWUvd2Vic29ja2V0LmpzXG52YXIgd2Vic29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMveG1saHR0cHJlcXVlc3QvbGliL1hNTEh0dHBSZXF1ZXN0LmpzXG52YXIgWE1MSHR0cFJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvbm9kZS9uZXRfaW5mby50c1xuXG5jbGFzcyBuZXRfaW5mb19OZXRJbmZvIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBpc09ubGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxudmFyIG5ldF9pbmZvX05ldHdvcmsgPSBuZXcgbmV0X2luZm9fTmV0SW5mbygpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvb3B0aW9ucy50c1xudmFyIEF1dGhSZXF1ZXN0VHlwZTtcbihmdW5jdGlvbiAoQXV0aFJlcXVlc3RUeXBlKSB7XG4gICAgQXV0aFJlcXVlc3RUeXBlW1wiVXNlckF1dGhlbnRpY2F0aW9uXCJdID0gXCJ1c2VyLWF1dGhlbnRpY2F0aW9uXCI7XG4gICAgQXV0aFJlcXVlc3RUeXBlW1wiQ2hhbm5lbEF1dGhvcml6YXRpb25cIl0gPSBcImNoYW5uZWwtYXV0aG9yaXphdGlvblwiO1xufSkoQXV0aFJlcXVlc3RUeXBlIHx8IChBdXRoUmVxdWVzdFR5cGUgPSB7fSkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2F1dGgveGhyX2F1dGgudHNcblxuXG5cblxuY29uc3QgYWpheCA9IGZ1bmN0aW9uIChjb250ZXh0LCBxdWVyeSwgYXV0aE9wdGlvbnMsIGF1dGhSZXF1ZXN0VHlwZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB4aHIgPSBub2RlX3J1bnRpbWUuY3JlYXRlWEhSKCk7XG4gICAgeGhyLm9wZW4oJ1BPU1QnLCBhdXRoT3B0aW9ucy5lbmRwb2ludCwgdHJ1ZSk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICBmb3IgKHZhciBoZWFkZXJOYW1lIGluIGF1dGhPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgYXV0aE9wdGlvbnMuaGVhZGVyc1toZWFkZXJOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZHluYW1pY0hlYWRlcnMgPSBhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIoKTtcbiAgICAgICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBkeW5hbWljSGVhZGVycykge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgZHluYW1pY0hlYWRlcnNbaGVhZGVyTmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEhUVFBBdXRoRXJyb3IoMjAwLCBgSlNPTiByZXR1cm5lZCBmcm9tICR7YXV0aFJlcXVlc3RUeXBlLnRvU3RyaW5nKCl9IGVuZHBvaW50IHdhcyBpbnZhbGlkLCB5ZXQgc3RhdHVzIGNvZGUgd2FzIDIwMC4gRGF0YSB3YXM6ICR7eGhyLnJlc3BvbnNlVGV4dH1gKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXV0aFJlcXVlc3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0aFJlcXVlc3RUeXBlLlVzZXJBdXRoZW50aWNhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnYXV0aGVudGljYXRpb25FbmRwb2ludCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0aFJlcXVlc3RUeXBlLkNoYW5uZWxBdXRob3JpemF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gYENsaWVudHMgbXVzdCBiZSBhdXRob3JpemVkIHRvIGpvaW4gcHJpdmF0ZSBvciBwcmVzZW5jZSBjaGFubmVscy4gJHt1cmxfc3RvcmUuYnVpbGRMb2dTdWZmaXgoJ2F1dGhvcml6YXRpb25FbmRwb2ludCcpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEhUVFBBdXRoRXJyb3IoeGhyLnN0YXR1cywgYFVuYWJsZSB0byByZXRyaWV2ZSBhdXRoIHN0cmluZyBmcm9tICR7YXV0aFJlcXVlc3RUeXBlLnRvU3RyaW5nKCl9IGVuZHBvaW50IC0gYCArXG4gICAgICAgICAgICAgICAgICAgIGByZWNlaXZlZCBzdGF0dXM6ICR7eGhyLnN0YXR1c30gZnJvbSAke2F1dGhPcHRpb25zLmVuZHBvaW50fS4gJHtzdWZmaXh9YCksIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChxdWVyeSk7XG4gICAgcmV0dXJuIHhocjtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfYXV0aCA9IChhamF4KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy90aW1lbGluZS94aHJfdGltZWxpbmUudHNcblxuXG5cbnZhciBnZXRBZ2VudCA9IGZ1bmN0aW9uIChzZW5kZXIsIHVzZVRMUykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICdodHRwJyArICh1c2VUTFMgPyAncycgOiAnJykgKyAnOi8vJztcbiAgICAgICAgdmFyIHVybCA9IHNjaGVtZSArIChzZW5kZXIuaG9zdCB8fCBzZW5kZXIub3B0aW9ucy5ob3N0KSArIHNlbmRlci5vcHRpb25zLnBhdGg7XG4gICAgICAgIHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSk7XG4gICAgICAgIHVybCArPSAnLycgKyAyICsgJz8nICsgcXVlcnk7XG4gICAgICAgIHZhciB4aHIgPSBub2RlX3J1bnRpbWUuY3JlYXRlWEhSKCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgc3RhdHVzLCByZXNwb25zZVRleHQgfSA9IHhocjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaW1lbGluZVNlbmRlciBFcnJvcjogcmVjZWl2ZWQgJHtzdGF0dXN9IGZyb20gc3RhdHMucHVzaGVyLmNvbWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB7IGhvc3QgfSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaW1lbGluZVNlbmRlckVycm9yOiBpbnZhbGlkIHJlc3BvbnNlICR7cmVzcG9uc2VUZXh0fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaG9zdCkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kZXIuaG9zdCA9IGhvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH07XG59O1xudmFyIHhocl90aW1lbGluZV94aHIgPSB7XG4gICAgbmFtZTogJ3hocicsXG4gICAgZ2V0QWdlbnRcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfdGltZWxpbmUgPSAoeGhyX3RpbWVsaW5lX3hocik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJjcnlwdG9cIlxudmFyIGV4dGVybmFsX2NyeXB0b18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9ub2RlL3J1bnRpbWUudHNcblxuXG5cblxuXG5cblxuY29uc3QgeyBnZXREZWZhdWx0U3RyYXRlZ3k6IHJ1bnRpbWVfZ2V0RGVmYXVsdFN0cmF0ZWd5LCBUcmFuc3BvcnRzOiBydW50aW1lX1RyYW5zcG9ydHMsIHNldHVwLCBnZXRQcm90b2NvbCwgaXNYSFJTdXBwb3J0ZWQsIGdldExvY2FsU3RvcmFnZSwgY3JlYXRlWEhSLCBjcmVhdGVXZWJTb2NrZXQsIGFkZFVubG9hZExpc3RlbmVyLCByZW1vdmVVbmxvYWRMaXN0ZW5lciwgdHJhbnNwb3J0Q29ubmVjdGlvbkluaXRpYWxpemVyLCBjcmVhdGVTb2NrZXRSZXF1ZXN0LCBIVFRQRmFjdG9yeSB9ID0gcnVudGltZTtcbmNvbnN0IE5vZGVKUyA9IHtcbiAgICBnZXREZWZhdWx0U3RyYXRlZ3k6IHJ1bnRpbWVfZ2V0RGVmYXVsdFN0cmF0ZWd5LFxuICAgIFRyYW5zcG9ydHM6IHJ1bnRpbWVfVHJhbnNwb3J0cyxcbiAgICBzZXR1cCxcbiAgICBnZXRQcm90b2NvbCxcbiAgICBpc1hIUlN1cHBvcnRlZCxcbiAgICBjcmVhdGVTb2NrZXRSZXF1ZXN0LFxuICAgIGdldExvY2FsU3RvcmFnZSxcbiAgICBjcmVhdGVYSFIsXG4gICAgY3JlYXRlV2ViU29ja2V0LFxuICAgIGFkZFVubG9hZExpc3RlbmVyLFxuICAgIHJlbW92ZVVubG9hZExpc3RlbmVyLFxuICAgIHRyYW5zcG9ydENvbm5lY3Rpb25Jbml0aWFsaXplcixcbiAgICBIVFRQRmFjdG9yeSxcbiAgICBUaW1lbGluZVRyYW5zcG9ydDogeGhyX3RpbWVsaW5lLFxuICAgIGdldEF1dGhvcml6ZXJzKCkge1xuICAgICAgICByZXR1cm4geyBhamF4OiB4aHJfYXV0aCB9O1xuICAgIH0sXG4gICAgZ2V0V2ViU29ja2V0QVBJKCkge1xuICAgICAgICByZXR1cm4gd2Vic29ja2V0W1wiQ2xpZW50XCJdO1xuICAgIH0sXG4gICAgZ2V0WEhSQVBJKCkge1xuICAgICAgICByZXR1cm4gWE1MSHR0cFJlcXVlc3RbXCJYTUxIdHRwUmVxdWVzdFwiXTtcbiAgICB9LFxuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXRfaW5mb19OZXR3b3JrO1xuICAgIH0sXG4gICAgcmFuZG9tSW50KG1heCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX2NyeXB0b19bXCJyYW5kb21JbnRcIl0pKG1heCk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG5vZGVfcnVudGltZSA9IChOb2RlSlMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RpbWVsaW5lL2xldmVsLnRzXG52YXIgVGltZWxpbmVMZXZlbDtcbihmdW5jdGlvbiAoVGltZWxpbmVMZXZlbCkge1xuICAgIFRpbWVsaW5lTGV2ZWxbVGltZWxpbmVMZXZlbFtcIkVSUk9SXCJdID0gM10gPSBcIkVSUk9SXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiSU5GT1wiXSA9IDZdID0gXCJJTkZPXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiREVCVUdcIl0gPSA3XSA9IFwiREVCVUdcIjtcbn0pKFRpbWVsaW5lTGV2ZWwgfHwgKFRpbWVsaW5lTGV2ZWwgPSB7fSkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGltZWxpbmVfbGV2ZWwgPSAoVGltZWxpbmVMZXZlbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdGltZWxpbmUvdGltZWxpbmUudHNcblxuXG5cbmNsYXNzIHRpbWVsaW5lX1RpbWVsaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuc2VudCA9IDA7XG4gICAgICAgIHRoaXMudW5pcXVlSUQgPSAwO1xuICAgIH1cbiAgICBsb2cobGV2ZWwsIGV2ZW50KSB7XG4gICAgICAgIGlmIChsZXZlbCA8PSB0aGlzLm9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXh0ZW5kKHt9LCBldmVudCwgeyB0aW1lc3RhbXA6IHV0aWwubm93KCkgfSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW1pdCAmJiB0aGlzLmV2ZW50cy5sZW5ndGggPiB0aGlzLm9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVycm9yKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nKHRpbWVsaW5lX2xldmVsLkVSUk9SLCBldmVudCk7XG4gICAgfVxuICAgIGluZm8oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2codGltZWxpbmVfbGV2ZWwuSU5GTywgZXZlbnQpO1xuICAgIH1cbiAgICBkZWJ1ZyhldmVudCkge1xuICAgICAgICB0aGlzLmxvZyh0aW1lbGluZV9sZXZlbC5ERUJVRywgZXZlbnQpO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBzZW5kKHNlbmRmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGEgPSBleHRlbmQoe1xuICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5zZXNzaW9uLFxuICAgICAgICAgICAgYnVuZGxlOiB0aGlzLnNlbnQgKyAxLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGxpYjogJ2pzJyxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMub3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5vcHRpb25zLmNsdXN0ZXIsXG4gICAgICAgICAgICBmZWF0dXJlczogdGhpcy5vcHRpb25zLmZlYXR1cmVzLFxuICAgICAgICAgICAgdGltZWxpbmU6IHRoaXMuZXZlbnRzXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICBzZW5kZm4oZGF0YSwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdlbmVyYXRlVW5pcXVlSUQoKSB7XG4gICAgICAgIHRoaXMudW5pcXVlSUQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pcXVlSUQ7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvdHJhbnNwb3J0X3N0cmF0ZWd5LnRzXG5cblxuXG5cbmNsYXNzIHRyYW5zcG9ydF9zdHJhdGVneV9UcmFuc3BvcnRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcHJpb3JpdHksIHRyYW5zcG9ydCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmlzU3VwcG9ydGVkKHtcbiAgICAgICAgICAgIHVzZVRMUzogdGhpcy5vcHRpb25zLnVzZVRMU1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsQXR0ZW1wdChuZXcgVW5zdXBwb3J0ZWRTdHJhdGVneSgpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcmlvcml0eSA8IG1pblByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbEF0dGVtcHQobmV3IFRyYW5zcG9ydFByaW9yaXR5VG9vTG93KCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydC5jcmVhdGVDb25uZWN0aW9uKHRoaXMubmFtZSwgdGhpcy5wcmlvcml0eSwgdGhpcy5vcHRpb25zLmtleSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdmFyIGhhbmRzaGFrZSA9IG51bGw7XG4gICAgICAgIHZhciBvbkluaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnaW5pdGlhbGl6ZWQnLCBvbkluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5jb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoYW5kc2hha2UgPSBmYWN0b3J5LmNyZWF0ZUhhbmRzaGFrZSh0cmFuc3BvcnQsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25DbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkVHJhbnNwb3J0O1xuICAgICAgICAgICAgc2VyaWFsaXplZFRyYW5zcG9ydCA9IHNhZmVKU09OU3RyaW5naWZ5KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgVHJhbnNwb3J0Q2xvc2VkKHNlcmlhbGl6ZWRUcmFuc3BvcnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVuYmluZExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2luaXRpYWxpemVkJywgb25Jbml0aWFsaXplZCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdpbml0aWFsaXplZCcsIG9uSW5pdGlhbGl6ZWQpO1xuICAgICAgICB0cmFuc3BvcnQuYmluZCgnb3BlbicsIG9uT3Blbik7XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICB0cmFuc3BvcnQuYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICB0cmFuc3BvcnQuaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBwID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJpb3JpdHkgPCBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZmFpbEF0dGVtcHQoZXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgdXRpbC5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAoKSB7IH1cbiAgICB9O1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvc3RyYXRlZ3lfYnVpbGRlci50c1xuXG5cblxuXG5cbmNvbnN0IHsgVHJhbnNwb3J0czogc3RyYXRlZ3lfYnVpbGRlcl9UcmFuc3BvcnRzIH0gPSBub2RlX3J1bnRpbWU7XG52YXIgc3RyYXRlZ3lfYnVpbGRlcl9kZWZpbmVUcmFuc3BvcnQgPSBmdW5jdGlvbiAoY29uZmlnLCBuYW1lLCB0eXBlLCBwcmlvcml0eSwgb3B0aW9ucywgbWFuYWdlcikge1xuICAgIHZhciB0cmFuc3BvcnRDbGFzcyA9IHN0cmF0ZWd5X2J1aWxkZXJfVHJhbnNwb3J0c1t0eXBlXTtcbiAgICBpZiAoIXRyYW5zcG9ydENsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRyYW5zcG9ydCh0eXBlKTtcbiAgICB9XG4gICAgdmFyIGVuYWJsZWQgPSAoIWNvbmZpZy5lbmFibGVkVHJhbnNwb3J0cyB8fFxuICAgICAgICBhcnJheUluZGV4T2YoY29uZmlnLmVuYWJsZWRUcmFuc3BvcnRzLCBuYW1lKSAhPT0gLTEpICYmXG4gICAgICAgICghY29uZmlnLmRpc2FibGVkVHJhbnNwb3J0cyB8fFxuICAgICAgICAgICAgYXJyYXlJbmRleE9mKGNvbmZpZy5kaXNhYmxlZFRyYW5zcG9ydHMsIG5hbWUpID09PSAtMSk7XG4gICAgdmFyIHRyYW5zcG9ydDtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGlnbm9yZU51bGxPcmlnaW46IGNvbmZpZy5pZ25vcmVOdWxsT3JpZ2luIH0sIG9wdGlvbnMpO1xuICAgICAgICB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X3N0cmF0ZWd5X1RyYW5zcG9ydFN0cmF0ZWd5KG5hbWUsIHByaW9yaXR5LCBtYW5hZ2VyID8gbWFuYWdlci5nZXRBc3Npc3RhbnQodHJhbnNwb3J0Q2xhc3MpIDogdHJhbnNwb3J0Q2xhc3MsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJhbnNwb3J0ID0gc3RyYXRlZ3lfYnVpbGRlcl9VbnN1cHBvcnRlZFN0cmF0ZWd5O1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0O1xufTtcbnZhciBzdHJhdGVneV9idWlsZGVyX1Vuc3VwcG9ydGVkU3RyYXRlZ3kgPSB7XG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY29ubmVjdDogZnVuY3Rpb24gKF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFVuc3VwcG9ydGVkU3RyYXRlZ3koKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9vcHRpb25zLnRzXG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyAnWW91IG11c3QgcGFzcyBhbiBvcHRpb25zIG9iamVjdCc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNsdXN0ZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyAnT3B0aW9ucyBvYmplY3QgbXVzdCBwcm92aWRlIGEgY2x1c3Rlcic7XG4gICAgfVxuICAgIGlmICgnZGlzYWJsZVN0YXRzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdUaGUgZGlzYWJsZVN0YXRzIG9wdGlvbiBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGVuYWJsZVN0YXRzJyk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvdXNlcl9hdXRoZW50aWNhdG9yLnRzXG5cblxuY29uc3QgY29tcG9zZUNoYW5uZWxRdWVyeSA9IChwYXJhbXMsIGF1dGhPcHRpb25zKSA9PiB7XG4gICAgdmFyIHF1ZXJ5ID0gJ3NvY2tldF9pZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zb2NrZXRJZCk7XG4gICAgZm9yICh2YXIga2V5IGluIGF1dGhPcHRpb25zLnBhcmFtcykge1xuICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoYXV0aE9wdGlvbnMucGFyYW1zW2tleV0pO1xuICAgIH1cbiAgICBpZiAoYXV0aE9wdGlvbnMucGFyYW1zUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZHluYW1pY1BhcmFtcyA9IGF1dGhPcHRpb25zLnBhcmFtc1Byb3ZpZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkeW5hbWljUGFyYW1zKSB7XG4gICAgICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGR5bmFtaWNQYXJhbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xufTtcbmNvbnN0IFVzZXJBdXRoZW50aWNhdG9yID0gKGF1dGhPcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBub2RlX3J1bnRpbWUuZ2V0QXV0aG9yaXplcnMoKVthdXRoT3B0aW9ucy50cmFuc3BvcnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBgJyR7YXV0aE9wdGlvbnMudHJhbnNwb3J0fScgaXMgbm90IGEgcmVjb2duaXplZCBhdXRoIHRyYW5zcG9ydGA7XG4gICAgfVxuICAgIHJldHVybiAocGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCBxdWVyeSA9IGNvbXBvc2VDaGFubmVsUXVlcnkocGFyYW1zLCBhdXRoT3B0aW9ucyk7XG4gICAgICAgIG5vZGVfcnVudGltZS5nZXRBdXRob3JpemVycygpW2F1dGhPcHRpb25zLnRyYW5zcG9ydF0obm9kZV9ydW50aW1lLCBxdWVyeSwgYXV0aE9wdGlvbnMsIEF1dGhSZXF1ZXN0VHlwZS5Vc2VyQXV0aGVudGljYXRpb24sIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHVzZXJfYXV0aGVudGljYXRvciA9IChVc2VyQXV0aGVudGljYXRvcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvYXV0aC9jaGFubmVsX2F1dGhvcml6ZXIudHNcblxuXG5jb25zdCBjaGFubmVsX2F1dGhvcml6ZXJfY29tcG9zZUNoYW5uZWxRdWVyeSA9IChwYXJhbXMsIGF1dGhPcHRpb25zKSA9PiB7XG4gICAgdmFyIHF1ZXJ5ID0gJ3NvY2tldF9pZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zb2NrZXRJZCk7XG4gICAgcXVlcnkgKz0gJyZjaGFubmVsX25hbWU9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY2hhbm5lbE5hbWUpO1xuICAgIGZvciAodmFyIGtleSBpbiBhdXRoT3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgcXVlcnkgKz1cbiAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgK1xuICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGF1dGhPcHRpb25zLnBhcmFtc1trZXldKTtcbiAgICB9XG4gICAgaWYgKGF1dGhPcHRpb25zLnBhcmFtc1Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGR5bmFtaWNQYXJhbXMgPSBhdXRoT3B0aW9ucy5wYXJhbXNQcm92aWRlcigpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZHluYW1pY1BhcmFtcykge1xuICAgICAgICAgICAgcXVlcnkgKz1cbiAgICAgICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChkeW5hbWljUGFyYW1zW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbn07XG5jb25zdCBDaGFubmVsQXV0aG9yaXplciA9IChhdXRoT3B0aW9ucykgPT4ge1xuICAgIGlmICh0eXBlb2Ygbm9kZV9ydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgYCcke2F1dGhPcHRpb25zLnRyYW5zcG9ydH0nIGlzIG5vdCBhIHJlY29nbml6ZWQgYXV0aCB0cmFuc3BvcnRgO1xuICAgIH1cbiAgICByZXR1cm4gKHBhcmFtcywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjaGFubmVsX2F1dGhvcml6ZXJfY29tcG9zZUNoYW5uZWxRdWVyeShwYXJhbXMsIGF1dGhPcHRpb25zKTtcbiAgICAgICAgbm9kZV9ydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XShub2RlX3J1bnRpbWUsIHF1ZXJ5LCBhdXRoT3B0aW9ucywgQXV0aFJlcXVlc3RUeXBlLkNoYW5uZWxBdXRob3JpemF0aW9uLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjaGFubmVsX2F1dGhvcml6ZXIgPSAoQ2hhbm5lbEF1dGhvcml6ZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvZGVwcmVjYXRlZF9jaGFubmVsX2F1dGhvcml6ZXIudHNcbmNvbnN0IENoYW5uZWxBdXRob3JpemVyUHJveHkgPSAocHVzaGVyLCBhdXRoT3B0aW9ucywgY2hhbm5lbEF1dGhvcml6ZXJHZW5lcmF0b3IpID0+IHtcbiAgICBjb25zdCBkZXByZWNhdGVkQXV0aG9yaXplck9wdGlvbnMgPSB7XG4gICAgICAgIGF1dGhUcmFuc3BvcnQ6IGF1dGhPcHRpb25zLnRyYW5zcG9ydCxcbiAgICAgICAgYXV0aEVuZHBvaW50OiBhdXRoT3B0aW9ucy5lbmRwb2ludCxcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgcGFyYW1zOiBhdXRoT3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICBoZWFkZXJzOiBhdXRoT3B0aW9ucy5oZWFkZXJzXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAocGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCBjaGFubmVsID0gcHVzaGVyLmNoYW5uZWwocGFyYW1zLmNoYW5uZWxOYW1lKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbEF1dGhvcml6ZXIgPSBjaGFubmVsQXV0aG9yaXplckdlbmVyYXRvcihjaGFubmVsLCBkZXByZWNhdGVkQXV0aG9yaXplck9wdGlvbnMpO1xuICAgICAgICBjaGFubmVsQXV0aG9yaXplci5hdXRob3JpemUocGFyYW1zLnNvY2tldElkLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29uZmlnLnRzXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0Q29uZmlnKG9wdHMsIHB1c2hlcikge1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgIGFjdGl2aXR5VGltZW91dDogb3B0cy5hY3Rpdml0eVRpbWVvdXQgfHwgZGVmYXVsdHMuYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICBjbHVzdGVyOiBvcHRzLmNsdXN0ZXIsXG4gICAgICAgIGh0dHBQYXRoOiBvcHRzLmh0dHBQYXRoIHx8IGRlZmF1bHRzLmh0dHBQYXRoLFxuICAgICAgICBodHRwUG9ydDogb3B0cy5odHRwUG9ydCB8fCBkZWZhdWx0cy5odHRwUG9ydCxcbiAgICAgICAgaHR0cHNQb3J0OiBvcHRzLmh0dHBzUG9ydCB8fCBkZWZhdWx0cy5odHRwc1BvcnQsXG4gICAgICAgIHBvbmdUaW1lb3V0OiBvcHRzLnBvbmdUaW1lb3V0IHx8IGRlZmF1bHRzLnBvbmdUaW1lb3V0LFxuICAgICAgICBzdGF0c0hvc3Q6IG9wdHMuc3RhdHNIb3N0IHx8IGRlZmF1bHRzLnN0YXRzX2hvc3QsXG4gICAgICAgIHVuYXZhaWxhYmxlVGltZW91dDogb3B0cy51bmF2YWlsYWJsZVRpbWVvdXQgfHwgZGVmYXVsdHMudW5hdmFpbGFibGVUaW1lb3V0LFxuICAgICAgICB3c1BhdGg6IG9wdHMud3NQYXRoIHx8IGRlZmF1bHRzLndzUGF0aCxcbiAgICAgICAgd3NQb3J0OiBvcHRzLndzUG9ydCB8fCBkZWZhdWx0cy53c1BvcnQsXG4gICAgICAgIHdzc1BvcnQ6IG9wdHMud3NzUG9ydCB8fCBkZWZhdWx0cy53c3NQb3J0LFxuICAgICAgICBlbmFibGVTdGF0czogZ2V0RW5hYmxlU3RhdHNDb25maWcob3B0cyksXG4gICAgICAgIGh0dHBIb3N0OiBnZXRIdHRwSG9zdChvcHRzKSxcbiAgICAgICAgdXNlVExTOiBzaG91bGRVc2VUTFMob3B0cyksXG4gICAgICAgIHdzSG9zdDogZ2V0V2Vic29ja2V0SG9zdChvcHRzKSxcbiAgICAgICAgdXNlckF1dGhlbnRpY2F0b3I6IGJ1aWxkVXNlckF1dGhlbnRpY2F0b3Iob3B0cyksXG4gICAgICAgIGNoYW5uZWxBdXRob3JpemVyOiBidWlsZENoYW5uZWxBdXRob3JpemVyKG9wdHMsIHB1c2hlcilcbiAgICB9O1xuICAgIGlmICgnZGlzYWJsZWRUcmFuc3BvcnRzJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcuZGlzYWJsZWRUcmFuc3BvcnRzID0gb3B0cy5kaXNhYmxlZFRyYW5zcG9ydHM7XG4gICAgaWYgKCdlbmFibGVkVHJhbnNwb3J0cycgaW4gb3B0cylcbiAgICAgICAgY29uZmlnLmVuYWJsZWRUcmFuc3BvcnRzID0gb3B0cy5lbmFibGVkVHJhbnNwb3J0cztcbiAgICBpZiAoJ2lnbm9yZU51bGxPcmlnaW4nIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy5pZ25vcmVOdWxsT3JpZ2luID0gb3B0cy5pZ25vcmVOdWxsT3JpZ2luO1xuICAgIGlmICgndGltZWxpbmVQYXJhbXMnIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy50aW1lbGluZVBhcmFtcyA9IG9wdHMudGltZWxpbmVQYXJhbXM7XG4gICAgaWYgKCduYWNsJyBpbiBvcHRzKSB7XG4gICAgICAgIGNvbmZpZy5uYWNsID0gb3B0cy5uYWNsO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gZ2V0SHR0cEhvc3Qob3B0cykge1xuICAgIGlmIChvcHRzLmh0dHBIb3N0KSB7XG4gICAgICAgIHJldHVybiBvcHRzLmh0dHBIb3N0O1xuICAgIH1cbiAgICBpZiAob3B0cy5jbHVzdGVyKSB7XG4gICAgICAgIHJldHVybiBgc29ja2pzLSR7b3B0cy5jbHVzdGVyfS5wdXNoZXIuY29tYDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzLmh0dHBIb3N0O1xufVxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0SG9zdChvcHRzKSB7XG4gICAgaWYgKG9wdHMud3NIb3N0KSB7XG4gICAgICAgIHJldHVybiBvcHRzLndzSG9zdDtcbiAgICB9XG4gICAgcmV0dXJuIGdldFdlYnNvY2tldEhvc3RGcm9tQ2x1c3RlcihvcHRzLmNsdXN0ZXIpO1xufVxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0SG9zdEZyb21DbHVzdGVyKGNsdXN0ZXIpIHtcbiAgICByZXR1cm4gYHdzLSR7Y2x1c3Rlcn0ucHVzaGVyLmNvbWA7XG59XG5mdW5jdGlvbiBzaG91bGRVc2VUTFMob3B0cykge1xuICAgIGlmIChub2RlX3J1bnRpbWUuZ2V0UHJvdG9jb2woKSA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdHMuZm9yY2VUTFMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRFbmFibGVTdGF0c0NvbmZpZyhvcHRzKSB7XG4gICAgaWYgKCdlbmFibGVTdGF0cycgaW4gb3B0cykge1xuICAgICAgICByZXR1cm4gb3B0cy5lbmFibGVTdGF0cztcbiAgICB9XG4gICAgaWYgKCdkaXNhYmxlU3RhdHMnIGluIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuICFvcHRzLmRpc2FibGVTdGF0cztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYnVpbGRVc2VyQXV0aGVudGljYXRvcihvcHRzKSB7XG4gICAgY29uc3QgdXNlckF1dGhlbnRpY2F0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cy51c2VyQXV0aGVudGljYXRpb24pLCBvcHRzLnVzZXJBdXRoZW50aWNhdGlvbik7XG4gICAgaWYgKCdjdXN0b21IYW5kbGVyJyBpbiB1c2VyQXV0aGVudGljYXRpb24gJiZcbiAgICAgICAgdXNlckF1dGhlbnRpY2F0aW9uWydjdXN0b21IYW5kbGVyJ10gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdXNlckF1dGhlbnRpY2F0aW9uWydjdXN0b21IYW5kbGVyJ107XG4gICAgfVxuICAgIHJldHVybiB1c2VyX2F1dGhlbnRpY2F0b3IodXNlckF1dGhlbnRpY2F0aW9uKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hhbm5lbEF1dGgob3B0cywgcHVzaGVyKSB7XG4gICAgbGV0IGNoYW5uZWxBdXRob3JpemF0aW9uO1xuICAgIGlmICgnY2hhbm5lbEF1dGhvcml6YXRpb24nIGluIG9wdHMpIHtcbiAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLmNoYW5uZWxBdXRob3JpemF0aW9uKSwgb3B0cy5jaGFubmVsQXV0aG9yaXphdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbiA9IHtcbiAgICAgICAgICAgIHRyYW5zcG9ydDogb3B0cy5hdXRoVHJhbnNwb3J0IHx8IGRlZmF1bHRzLmF1dGhUcmFuc3BvcnQsXG4gICAgICAgICAgICBlbmRwb2ludDogb3B0cy5hdXRoRW5kcG9pbnQgfHwgZGVmYXVsdHMuYXV0aEVuZHBvaW50XG4gICAgICAgIH07XG4gICAgICAgIGlmICgnYXV0aCcgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKCdwYXJhbXMnIGluIG9wdHMuYXV0aClcbiAgICAgICAgICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbi5wYXJhbXMgPSBvcHRzLmF1dGgucGFyYW1zO1xuICAgICAgICAgICAgaWYgKCdoZWFkZXJzJyBpbiBvcHRzLmF1dGgpXG4gICAgICAgICAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24uaGVhZGVycyA9IG9wdHMuYXV0aC5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnYXV0aG9yaXplcicgaW4gb3B0cylcbiAgICAgICAgICAgIGNoYW5uZWxBdXRob3JpemF0aW9uLmN1c3RvbUhhbmRsZXIgPSBDaGFubmVsQXV0aG9yaXplclByb3h5KHB1c2hlciwgY2hhbm5lbEF1dGhvcml6YXRpb24sIG9wdHMuYXV0aG9yaXplcik7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsQXV0aG9yaXphdGlvbjtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hhbm5lbEF1dGhvcml6ZXIob3B0cywgcHVzaGVyKSB7XG4gICAgY29uc3QgY2hhbm5lbEF1dGhvcml6YXRpb24gPSBidWlsZENoYW5uZWxBdXRoKG9wdHMsIHB1c2hlcik7XG4gICAgaWYgKCdjdXN0b21IYW5kbGVyJyBpbiBjaGFubmVsQXV0aG9yaXphdGlvbiAmJlxuICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvblsnY3VzdG9tSGFuZGxlciddICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWxBdXRob3JpemF0aW9uWydjdXN0b21IYW5kbGVyJ107XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsX2F1dGhvcml6ZXIoY2hhbm5lbEF1dGhvcml6YXRpb24pO1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3dhdGNobGlzdC50c1xuXG5cbmNsYXNzIHdhdGNobGlzdF9XYXRjaGxpc3RGYWNhZGUgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIGNhbGxiYWNrcyBvbiB3YXRjaGxpc3QgZXZlbnRzIGZvciAke2V2ZW50TmFtZX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICB0aGlzLmJpbmRXYXRjaGxpc3RJbnRlcm5hbEV2ZW50KCk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KHB1c2hlckV2ZW50KSB7XG4gICAgICAgIHB1c2hlckV2ZW50LmRhdGEuZXZlbnRzLmZvckVhY2god2F0Y2hsaXN0RXZlbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHdhdGNobGlzdEV2ZW50Lm5hbWUsIHdhdGNobGlzdEV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmRXYXRjaGxpc3RJbnRlcm5hbEV2ZW50KCkge1xuICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ21lc3NhZ2UnLCBwdXNoZXJFdmVudCA9PiB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gcHVzaGVyRXZlbnQuZXZlbnQ7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncHVzaGVyX2ludGVybmFsOndhdGNobGlzdF9ldmVudHMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudChwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy9mbGF0X3Byb21pc2UudHNcbmZ1bmN0aW9uIGZsYXRQcm9taXNlKCkge1xuICAgIGxldCByZXNvbHZlLCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmbGF0X3Byb21pc2UgPSAoZmxhdFByb21pc2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3VzZXIudHNcblxuXG5cblxuXG5jbGFzcyB1c2VyX1VzZXJGYWNhZGUgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiB1c2VyIGZvciAnICsgZXZlbnROYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZXJfZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2lnbmluRG9uZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zaWduaW5Eb25lUmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uQXV0aG9yaXplID0gKGVyciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3IgZHVyaW5nIHNpZ25pbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjpzaWduaW4nLCB7XG4gICAgICAgICAgICAgICAgYXV0aDogYXV0aERhdGEuYXV0aCxcbiAgICAgICAgICAgICAgICB1c2VyX2RhdGE6IGF1dGhEYXRhLnVzZXJfZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ3N0YXRlX2NoYW5nZScsICh7IHByZXZpb3VzLCBjdXJyZW50IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAhPT0gJ2Nvbm5lY3RlZCcgJiYgY3VycmVudCA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWduaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ2Nvbm5lY3RlZCcgJiYgY3VycmVudCAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV3U2lnbmluUHJvbWlzZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndhdGNobGlzdCA9IG5ldyB3YXRjaGxpc3RfV2F0Y2hsaXN0RmFjYWRlKHB1c2hlcik7XG4gICAgICAgIHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uYmluZCgnbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXI6c2lnbmluX3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TaWduaW5TdWNjZXNzKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5uYW1lID09PSBldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25pbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NpZ25pbigpO1xuICAgIH1cbiAgICBfc2lnbmluKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpO1xuICAgICAgICBpZiAodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hlci5jb25maWcudXNlckF1dGhlbnRpY2F0b3Ioe1xuICAgICAgICAgICAgc29ja2V0SWQ6IHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkXG4gICAgICAgIH0sIHRoaXMuX29uQXV0aG9yaXplKTtcbiAgICB9XG4gICAgX29uU2lnbmluU3VjY2VzcyhkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJfZGF0YSA9IEpTT04ucGFyc2UoZGF0YS51c2VyX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCBwYXJzaW5nIHVzZXIgZGF0YSBhZnRlciBzaWduaW46ICR7ZGF0YS51c2VyX2RhdGF9YCk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnVzZXJfZGF0YS5pZCAhPT0gJ3N0cmluZycgfHwgdGhpcy51c2VyX2RhdGEuaWQgPT09ICcnKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYHVzZXJfZGF0YSBkb2Vzbid0IGNvbnRhaW4gYW4gaWQuIHVzZXJfZGF0YTogJHt0aGlzLnVzZXJfZGF0YX1gKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduaW5Eb25lUmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVDaGFubmVscygpO1xuICAgIH1cbiAgICBfc3Vic2NyaWJlQ2hhbm5lbHMoKSB7XG4gICAgICAgIGNvbnN0IGVuc3VyZV9zdWJzY3JpYmVkID0gY2hhbm5lbCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5yZWluc3RhdGVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG5ldyBjaGFubmVsX0NoYW5uZWwoYCNzZXJ2ZXItdG8tdXNlci0ke3RoaXMudXNlcl9kYXRhLmlkfWAsIHRoaXMucHVzaGVyKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmJpbmRfZ2xvYmFsKChldmVudE5hbWUsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwIHx8XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZW5zdXJlX3N1YnNjcmliZWQodGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsKTtcbiAgICB9XG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIHRoaXMudXNlcl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLnVuYmluZF9hbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlclRvVXNlckNoYW5uZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaWduaW5Eb25lUHJvbWlzZSAmJiAhdGhpcy5zaWduaW5Eb25lUHJvbWlzZS5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3Q6IF8gfSA9IGZsYXRfcHJvbWlzZSgpO1xuICAgICAgICBwcm9taXNlLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc2V0RG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UuZG9uZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHByb21pc2UudGhlbihzZXREb25lKS5jYXRjaChzZXREb25lKTtcbiAgICAgICAgdGhpcy5zaWduaW5Eb25lUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvcHVzaGVyLnRzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIHB1c2hlcl9QdXNoZXIge1xuICAgIHN0YXRpYyByZWFkeSgpIHtcbiAgICAgICAgcHVzaGVyX1B1c2hlci5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwdXNoZXJfUHVzaGVyLmluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzW2ldLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2xpZW50RmVhdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGZpbHRlck9iamVjdCh7IHdzOiBub2RlX3J1bnRpbWUuVHJhbnNwb3J0cy53cyB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuaXNTdXBwb3J0ZWQoe30pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGFwcF9rZXksIG9wdGlvbnMpIHtcbiAgICAgICAgY2hlY2tBcHBLZXkoYXBwX2tleSk7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5rZXkgPSBhcHBfa2V5O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGdldENvbmZpZyhvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IGZhY3RvcnkuY3JlYXRlQ2hhbm5lbHMoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlciA9IG5ldyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uSUQgPSBub2RlX3J1bnRpbWUucmFuZG9tSW50KDEwMDAwMDAwMDApO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gbmV3IHRpbWVsaW5lX1RpbWVsaW5lKHRoaXMua2V5LCB0aGlzLnNlc3Npb25JRCwge1xuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5jb25maWcuY2x1c3RlcixcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwdXNoZXJfUHVzaGVyLmdldENsaWVudEZlYXR1cmVzKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuY29uZmlnLnRpbWVsaW5lUGFyYW1zIHx8IHt9LFxuICAgICAgICAgICAgbGltaXQ6IDUwLFxuICAgICAgICAgICAgbGV2ZWw6IHRpbWVsaW5lX2xldmVsLklORk8sXG4gICAgICAgICAgICB2ZXJzaW9uOiBkZWZhdWx0cy5WRVJTSU9OXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlU3RhdHMpIHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXIgPSBmYWN0b3J5LmNyZWF0ZVRpbWVsaW5lU2VuZGVyKHRoaXMudGltZWxpbmUsIHtcbiAgICAgICAgICAgICAgICBob3N0OiB0aGlzLmNvbmZpZy5zdGF0c0hvc3QsXG4gICAgICAgICAgICAgICAgcGF0aDogJy90aW1lbGluZS92Mi8nICsgbm9kZV9ydW50aW1lLlRpbWVsaW5lVHJhbnNwb3J0Lm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRTdHJhdGVneSA9IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZV9ydW50aW1lLmdldERlZmF1bHRTdHJhdGVneSh0aGlzLmNvbmZpZywgb3B0aW9ucywgc3RyYXRlZ3lfYnVpbGRlcl9kZWZpbmVUcmFuc3BvcnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBmYWN0b3J5LmNyZWF0ZUNvbm5lY3Rpb25NYW5hZ2VyKHRoaXMua2V5LCB7XG4gICAgICAgICAgICBnZXRTdHJhdGVneTogZ2V0U3RyYXRlZ3ksXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogdGhpcy5jb25maWcuYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICAgICAgcG9uZ1RpbWVvdXQ6IHRoaXMuY29uZmlnLnBvbmdUaW1lb3V0LFxuICAgICAgICAgICAgdW5hdmFpbGFibGVUaW1lb3V0OiB0aGlzLmNvbmZpZy51bmF2YWlsYWJsZVRpbWVvdXQsXG4gICAgICAgICAgICB1c2VUTFM6IEJvb2xlYW4odGhpcy5jb25maWcudXNlVExTKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlQWxsKCk7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXIuc2VuZCh0aGlzLmNvbm5lY3Rpb24uaXNVc2luZ1RMUygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5iaW5kKCdtZXNzYWdlJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICAgICAgdmFyIGludGVybmFsID0gZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMDtcbiAgICAgICAgICAgIGlmIChldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIuZW1pdChldmVudC5ldmVudCwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnY29ubmVjdGluZycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Rpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICBwdXNoZXJfUHVzaGVyLmluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBpbnN0YW5jZXM6IHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzLmxlbmd0aCB9KTtcbiAgICAgICAgdGhpcy51c2VyID0gbmV3IHVzZXJfVXNlckZhY2FkZSh0aGlzKTtcbiAgICAgICAgaWYgKHB1c2hlcl9QdXNoZXIuaXNSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hhbm5lbChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzLmZpbmQobmFtZSk7XG4gICAgfVxuICAgIGFsbENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVscy5hbGwoKTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmVTZW5kZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50aW1lbGluZVNlbmRlclRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVzaW5nVExTID0gdGhpcy5jb25uZWN0aW9uLmlzVXNpbmdUTFMoKTtcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVTZW5kZXIgPSB0aGlzLnRpbWVsaW5lU2VuZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXJUaW1lciA9IG5ldyB0aW1lcnNfUGVyaW9kaWNUaW1lcig2MDAwMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZVNlbmRlci5zZW5kKHVzaW5nVExTKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlclRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlclRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kKGV2ZW50X25hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIuYmluZChldmVudF9uYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci51bmJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmluZF9nbG9iYWwoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci5iaW5kX2dsb2JhbChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmRfZ2xvYmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIudW5iaW5kX2dsb2JhbChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmRfYWxsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIudW5iaW5kX2FsbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3Vic2NyaWJlQWxsKCkge1xuICAgICAgICB2YXIgY2hhbm5lbE5hbWU7XG4gICAgICAgIGZvciAoY2hhbm5lbE5hbWUgaW4gdGhpcy5jaGFubmVscy5jaGFubmVscykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHMuY2hhbm5lbHMuaGFzT3duUHJvcGVydHkoY2hhbm5lbE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoY2hhbm5lbE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShjaGFubmVsX25hbWUpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmFkZChjaGFubmVsX25hbWUsIHRoaXMpO1xuICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjaGFubmVsLnJlaW5zdGF0ZVN1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKGNoYW5uZWxfbmFtZSkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChjaGFubmVsX25hbWUpO1xuICAgICAgICBpZiAoY2hhbm5lbCAmJiBjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuY2FuY2VsU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVscy5yZW1vdmUoY2hhbm5lbF9uYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsICYmIGNoYW5uZWwuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kX2V2ZW50KGV2ZW50X25hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kX2V2ZW50KGV2ZW50X25hbWUsIGRhdGEsIGNoYW5uZWwpO1xuICAgIH1cbiAgICBzaG91bGRVc2VUTFMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy51c2VUTFM7XG4gICAgfVxuICAgIHNpZ25pbigpIHtcbiAgICAgICAgdGhpcy51c2VyLnNpZ25pbigpO1xuICAgIH1cbn1cbnB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzID0gW107XG5wdXNoZXJfUHVzaGVyLmlzUmVhZHkgPSBmYWxzZTtcbnB1c2hlcl9QdXNoZXIubG9nVG9Db25zb2xlID0gZmFsc2U7XG5wdXNoZXJfUHVzaGVyLlJ1bnRpbWUgPSBub2RlX3J1bnRpbWU7XG5wdXNoZXJfUHVzaGVyLlNjcmlwdFJlY2VpdmVycyA9IG5vZGVfcnVudGltZS5TY3JpcHRSZWNlaXZlcnM7XG5wdXNoZXJfUHVzaGVyLkRlcGVuZGVuY2llc1JlY2VpdmVycyA9IG5vZGVfcnVudGltZS5EZXBlbmRlbmNpZXNSZWNlaXZlcnM7XG5wdXNoZXJfUHVzaGVyLmF1dGhfY2FsbGJhY2tzID0gbm9kZV9ydW50aW1lLmF1dGhfY2FsbGJhY2tzO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29yZV9wdXNoZXIgPSAocHVzaGVyX1B1c2hlcik7XG5mdW5jdGlvbiBjaGVja0FwcEtleShrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93ICdZb3UgbXVzdCBwYXNzIHlvdXIgYXBwIGtleSB3aGVuIHlvdSBpbnN0YW50aWF0ZSBQdXNoZXIuJztcbiAgICB9XG59XG5ub2RlX3J1bnRpbWUuc2V0dXAocHVzaGVyX1B1c2hlcik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdHdlZXRuYWNsL25hY2wtZmFzdC5qc1xudmFyIG5hY2xfZmFzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3B1c2hlci13aXRoLWVuY3J5cHRpb24udHNcblxuXG5cbmNsYXNzIHB1c2hlcl93aXRoX2VuY3J5cHRpb25fUHVzaGVyV2l0aEVuY3J5cHRpb24gZXh0ZW5kcyBjb3JlX3B1c2hlciB7XG4gICAgY29uc3RydWN0b3IoYXBwX2tleSwgb3B0aW9ucykge1xuICAgICAgICBjb3JlX3B1c2hlci5sb2dUb0NvbnNvbGUgPSBwdXNoZXJfd2l0aF9lbmNyeXB0aW9uX1B1c2hlcldpdGhFbmNyeXB0aW9uLmxvZ1RvQ29uc29sZTtcbiAgICAgICAgY29yZV9wdXNoZXIubG9nID0gcHVzaGVyX3dpdGhfZW5jcnlwdGlvbl9QdXNoZXJXaXRoRW5jcnlwdGlvbi5sb2c7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5uYWNsID0gbmFjbF9mYXN0O1xuICAgICAgICBzdXBlcihhcHBfa2V5LCBvcHRpb25zKTtcbiAgICB9XG59XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwicmVxdWlyZSIsImJ1ZmZlciIsIkJ1ZmZlciIsImNvcHlQcm9wcyIsInNyYyIsImRzdCIsImZyb20iLCJhbGxvYyIsImFsbG9jVW5zYWZlIiwiYWxsb2NVbnNhZmVTbG93IiwiU2FmZUJ1ZmZlciIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJzaXplIiwiZmlsbCIsImVuY29kaW5nIiwiYnVmIiwidW5kZWZpbmVkIiwiU2xvd0J1ZmZlciIsIkVtaXR0ZXIiLCJFdmVudEVtaXR0ZXIiLCJ1dGlsIiwic3RyZWFtcyIsIkhlYWRlcnMiLCJSZWFkZXIiLCJCYXNlIiwicmVxdWVzdCIsInVybCIsIm9wdGlvbnMiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJfcmVxdWVzdCIsIl9yZWFkZXIiLCJfb3B0aW9ucyIsIl9tYXhMZW5ndGgiLCJtYXhMZW5ndGgiLCJNQVhfTEVOR1RIIiwiX2hlYWRlcnMiLCJfX3F1ZXVlIiwicmVhZHlTdGF0ZSIsImlvIiwiSU8iLCJtZXNzYWdlcyIsIk1lc3NhZ2VzIiwiX2JpbmRFdmVudExpc3RlbmVycyIsImluaGVyaXRzIiwiaXNXZWJTb2NrZXQiLCJjb25uZWN0aW9uIiwiaGVhZGVycyIsInVwZ3JhZGUiLCJtZXRob2QiLCJ0b0xvd2VyQ2FzZSIsInNwbGl0IiwiaW5kZXhPZiIsInZhbGlkS2V5cyIsIkVycm9yIiwiaW5zdGFuY2UiLCJTVEFURVMiLCJzZWxmIiwib24iLCJldmVudCIsInJlYWRhYmxlIiwiZW1pdCIsImRhdGEiLCJlcnJvciIsIndyaXRhYmxlIiwiZ2V0U3RhdGUiLCJhZGRFeHRlbnNpb24iLCJleHRlbnNpb24iLCJzZXRIZWFkZXIiLCJzZXQiLCJzdGFydCIsIl9mYWlsSGFuZHNoYWtlIiwicmVzcG9uc2UiLCJfaGFuZHNoYWtlUmVzcG9uc2UiLCJfd3JpdGUiLCJfc3RhZ2UiLCJfb3BlbiIsImJ5dGVMZW5ndGgiLCJtZXNzYWdlIiwidG9TdHJpbmciLCJqb2luIiwiX2ZhaWwiLCJ0ZXh0IiwiZnJhbWUiLCJiaW5hcnkiLCJwaW5nIiwicG9uZyIsImNsb3NlIiwicmVhc29uIiwiY29kZSIsIkNsb3NlRXZlbnQiLCJmb3JFYWNoIiwiYXJncyIsImFwcGx5IiwiT3BlbkV2ZW50IiwiX3F1ZXVlIiwicHVzaCIsImNodW5rIiwidHlwZSIsIkNvbm5lY3RFdmVudCIsIk1lc3NhZ2VFdmVudCIsIlBpbmdFdmVudCIsIlBvbmdFdmVudCIsIkNsaWVudCIsIlNlcnZlciIsIkRyaXZlciIsImNsaWVudCIsIm1hc2tpbmciLCJzZXJ2ZXIiLCJyZXF1aXJlTWFza2luZyIsImh0dHAiLCJhcmd1bWVudHMiLCJpc1NlY3VyZVJlcXVlc3QiLCJFdmVudCIsImV2ZW50VHlwZSIsImluaXRFdmVudCIsImNhbkJ1YmJsZSIsImNhbmNlbGFibGUiLCJidWJibGVzIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJDQVBUVVJJTkdfUEhBU0UiLCJBVF9UQVJHRVQiLCJCVUJCTElOR19QSEFTRSIsIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJiIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJBcnJheSIsIl9fIiwiY29uc3RydWN0b3IiLCJJTlZBTElEX0JZVEUiLCJDb2RlciIsIl9wYWRkaW5nQ2hhcmFjdGVyIiwiZW5jb2RlZExlbmd0aCIsImVuY29kZSIsIm91dCIsIl9lbmNvZGVCeXRlIiwibGVmdCIsIm1heERlY29kZWRMZW5ndGgiLCJkZWNvZGVkTGVuZ3RoIiwiX2dldFBhZGRpbmdMZW5ndGgiLCJkZWNvZGUiLCJVaW50OEFycmF5IiwicGFkZGluZ0xlbmd0aCIsIm9wIiwiaGF2ZUJhZCIsInYwIiwidjEiLCJ2MiIsInYzIiwiX2RlY29kZUNoYXIiLCJjaGFyQ29kZUF0IiwicmVzdWx0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic3RkQ29kZXIiLCJVUkxTYWZlQ29kZXIiLCJfc3VwZXIiLCJ1cmxTYWZlQ29kZXIiLCJlbmNvZGVVUkxTYWZlIiwiZGVjb2RlVVJMU2FmZSIsImNsZWFyIiwiQUxMT1dFRF9EVVBMSUNBVEVTIiwiX3NlbnQiLCJfbGluZXMiLCJfc3RyaXAiLCJzdHJpbmciLCJyZXBsYWNlIiwiTm9kZUhUVFBQYXJzZXIiLCJIVFRQUGFyc2VyIiwiVFlQRVMiLCJSRVFVRVNUIiwiUkVTUE9OU0UiLCJIdHRwUGFyc2VyIiwiX3R5cGUiLCJfcGFyc2VyIiwiX2NvbXBsZXRlIiwiY3VycmVudCIsIm9uSGVhZGVyRmllbGQiLCJvbkhlYWRlclZhbHVlIiwib25IZWFkZXJzQ29tcGxldGUiLCJrT25IZWFkZXJzQ29tcGxldGUiLCJtYWpvclZlcnNpb24iLCJtaW5vclZlcnNpb24iLCJwYXRobmFtZSIsInN0YXR1c0NvZGUiLCJpbmZvIiwiTUVUSE9EUyIsIlZFUlNJT04iLCJwcm9jZXNzIiwidmVyc2lvbiIsIm1hdGNoIiwibWFwIiwicGFyc2VJbnQiLCJpc0NvbXBsZXRlIiwicGFyc2UiLCJjb25zdW1lZCIsImV4ZWN1dGUiLCJib2R5Iiwic2xpY2UiLCJTdHJlYW0iLCJkcml2ZXIiLCJFdmVudFRhcmdldCIsIkFQSSIsIl9kcml2ZXIiLCJleHRlbnNpb25zIiwiY29uY2F0IiwiX3BpbmciLCJfcGluZ0lkIiwiQ09OTkVDVElORyIsImJ1ZmZlcmVkQW1vdW50IiwicHJvdG9jb2wiLCJlIiwiX3JlY2VpdmVNZXNzYWdlIiwiX2JlZ2luQ2xvc2UiLCJfZW1pdEVycm9yIiwiX3BpbmdUaW1lciIsInNldEludGVydmFsIiwiX2NvbmZpZ3VyZVN0cmVhbSIsIl9wcm94eSIsIl9zdHJlYW0iLCJwaXBlIiwiT1BFTiIsIkNMT1NJTkciLCJDTE9TRUQiLCJDTE9TRV9USU1FT1VUIiwid3JpdGUiLCJzZW5kIiwiZW5kIiwicGF1c2UiLCJyZXN1bWUiLCJjYWxsYmFjayIsIl9jbG9zZVRpbWVyIiwic2V0VGltZW91dCIsInNldE5vRGVsYXkiLCJfZmluYWxpemVDbG9zZSIsImRpc3BhdGNoRXZlbnQiLCJfY2xvc2VQYXJhbXMiLCJkZXN0cm95IiwiY2xlYXJUaW1lb3V0IiwiY2xlYXJJbnRlcnZhbCIsImNyeXB0byIsIkV4dGVuc2lvbnMiLCJGcmFtZSIsIk1lc3NhZ2UiLCJIeWJpIiwiX2V4dGVuc2lvbnMiLCJfbWFza2luZyIsIl9wcm90b2NvbHMiLCJwcm90b2NvbHMiLCJfcmVxdWlyZU1hc2tpbmciLCJfcGluZ0NhbGxiYWNrcyIsInByb3RvcyIsInN1cHBvcnRlZCIsImZpbHRlciIsIm1hc2siLCJwYXlsb2FkIiwib2Zmc2V0IiwiZ2VuZXJhdGVBY2NlcHQiLCJzaGExIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsIkdVSUQiLCJkaWdlc3QiLCJGSU4iLCJNQVNLIiwiUlNWMSIsIlJTVjIiLCJSU1YzIiwiT1BDT0RFIiwiTEVOR1RIIiwiT1BDT0RFUyIsImNvbnRpbnVhdGlvbiIsIk9QQ09ERV9DT0RFUyIsIk1FU1NBR0VfT1BDT0RFUyIsIk9QRU5JTkdfT1BDT0RFUyIsIkVSUk9SUyIsIm5vcm1hbF9jbG9zdXJlIiwiZ29pbmdfYXdheSIsInByb3RvY29sX2Vycm9yIiwidW5hY2NlcHRhYmxlIiwiZW5jb2RpbmdfZXJyb3IiLCJwb2xpY3lfdmlvbGF0aW9uIiwidG9vX2xhcmdlIiwiZXh0ZW5zaW9uX2Vycm9yIiwidW5leHBlY3RlZF9jb25kaXRpb24iLCJFUlJPUl9DT0RFUyIsIkRFRkFVTFRfRVJST1JfQ09ERSIsIk1JTl9SRVNFUlZFRF9FUlJPUiIsIk1BWF9SRVNFUlZFRF9FUlJPUiIsIlVURjhfTUFUQ0giLCJhZGQiLCJwdXQiLCJyZWFkIiwiX3BhcnNlT3Bjb2RlIiwiX3BhcnNlTGVuZ3RoIiwiX2ZyYW1lIiwibGVuZ3RoQnl0ZXMiLCJfcGFyc2VFeHRlbmRlZExlbmd0aCIsIm1hc2tpbmdLZXkiLCJfZW1pdEZyYW1lIiwiaXNUZXh0IiwiY29weSIsInJzdjEiLCJyc3YyIiwicnN2MyIsIm9wY29kZSIsIndyaXRlVUludDE2QkUiLCJvbk1lc3NhZ2VSZWFkeSIsImZpbmFsIiwibWFza2VkIiwicmFuZG9tQnl0ZXMiLCJfc2VuZEZyYW1lIiwicHJvY2Vzc091dGdvaW5nTWVzc2FnZSIsImhlYWRlciIsIndyaXRlVUludDMyQkUiLCJNYXRoIiwiZmxvb3IiLCJzZWNLZXkiLCJnZW5lcmF0ZVJlc3BvbnNlIiwiX3NodXRkb3duIiwiX21lc3NhZ2UiLCJzZW5kQ2xvc2VGcmFtZSIsIm9jdGV0IiwicnN2cyIsInJzdiIsInZhbGlkRnJhbWVSc3YiLCJfY2hlY2tGcmFtZUxlbmd0aCIsIl9yZWFkVUludCIsImNhbGxiYWNrcyIsInB1c2hGcmFtZSIsIl9lbWl0TWVzc2FnZSIsInJlYWRVSW50MTZCRSIsIl9lbmNvZGUiLCJwcm9jZXNzSW5jb21pbmdNZXNzYWdlIiwidGVzdCIsInJlYWRVSW50MzJCRSIsIlJpbmdCdWZmZXIiLCJidWZmZXJTaXplIiwiX2J1ZmZlclNpemUiLCJfYnVmZmVyIiwiX3JpbmdPZmZzZXQiLCJfcmluZ1NpemUiLCJfaGVhZCIsIl90YWlsIiwiZXhwYW5kQnVmZmVyIiwiZXhwYW5kUmluZyIsInBlZWsiLCJzaGlmdCIsIlBsZWRnZSIsIl9jYWxsYmFja3MiLCJRVUVVRV9TSVpFIiwiYWxsIiwibGlzdCIsInBsZWRnZSIsInBlbmRpbmciLCJkb25lIiwidGhlbiIsIkRyYWZ0NzUiLCJvcmlnaW4iLCJlYWNoQnl0ZSIsIl9ib2R5IiwiX3NlbmRIYW5kc2hha2VCb2R5IiwiX3BhcnNlTGVhZGluZ0J5dGUiLCJfbGVuZ3RoIiwiX2Nsb3NpbmciLCJfc2tpcHBlZCIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwidXNlQ2FwdHVyZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJldmVudFBoYXNlIiwiSU5WQUxJRF9VVEYxNiIsIklOVkFMSURfVVRGOCIsImFyciIsInBvcyIsImNoYXJzIiwibWluIiwibjEiLCJuMiIsIm4zIiwiV2ViU29ja2V0Iiwic29ja2V0IiwiY2F0Y2h1cCIsIm5leHRUaWNrIiwiRXZlbnRTb3VyY2UiLCJVcmwiLCJzcGF3biIsImZzIiwiWE1MSHR0cFJlcXVlc3QiLCJodHRwcyIsInNldHRpbmdzIiwiZGlzYWJsZUhlYWRlckNoZWNrIiwiZGVmYXVsdEhlYWRlcnMiLCJoZWFkZXJzQ2FzZSIsImZvcmJpZGRlblJlcXVlc3RIZWFkZXJzIiwiZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMiLCJzZW5kRmxhZyIsImVycm9yRmxhZyIsImxpc3RlbmVycyIsIlVOU0VOVCIsIk9QRU5FRCIsIkhFQURFUlNfUkVDRUlWRUQiLCJMT0FESU5HIiwiRE9ORSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlWE1MIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIndpdGhDcmVkZW50aWFscyIsImlzQWxsb3dlZEh0dHBIZWFkZXIiLCJpc0FsbG93ZWRIdHRwTWV0aG9kIiwib3BlbiIsImFzeW5jIiwidXNlciIsInBhc3N3b3JkIiwiYWJvcnQiLCJzZXRTdGF0ZSIsInNldERpc2FibGVIZWFkZXJDaGVjayIsInN0YXRlIiwic2V0UmVxdWVzdEhlYWRlciIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzdWJzdHIiLCJnZXRSZXF1ZXN0SGVhZGVyIiwic3NsIiwibG9jYWwiLCJob3N0IiwiaG9zdG5hbWUiLCJyZWFkRmlsZSIsImhhbmRsZUVycm9yIiwicmVhZEZpbGVTeW5jIiwicG9ydCIsInVyaSIsInNlYXJjaCIsIkhvc3QiLCJhdXRoQnVmIiwiQXV0aG9yaXphdGlvbiIsImlzQnVmZmVyIiwicGF0aCIsImFnZW50IiwiZG9SZXF1ZXN0IiwicmVzcG9uc2VIYW5kbGVyIiwicmVzcCIsImxvY2F0aW9uIiwibmV3T3B0aW9ucyIsImVycm9ySGFuZGxlciIsInNldEVuY29kaW5nIiwiY29udGVudEZpbGUiLCJwaWQiLCJzeW5jRmlsZSIsIndyaXRlRmlsZVN5bmMiLCJleGVjU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInN5bmNQcm9jIiwiYXJndiIsImV4aXN0c1N5bmMiLCJzdGRpbiIsInVubGlua1N5bmMiLCJlcnIiLCJzdGFjayIsImV2IiwibGVuIiwibmFjbCIsImdmIiwiaW5pdCIsIkZsb2F0NjRBcnJheSIsInJhbmRvbWJ5dGVzIiwiXzAiLCJfOSIsImdmMCIsImdmMSIsIl8xMjE2NjUiLCJEIiwiRDIiLCJYIiwiWSIsIkkiLCJ0czY0IiwieCIsImgiLCJ2biIsInhpIiwieSIsInlpIiwiY3J5cHRvX3ZlcmlmeV8xNiIsImNyeXB0b192ZXJpZnlfMzIiLCJjb3JlX3NhbHNhMjAiLCJrIiwiajAiLCJqMSIsImoyIiwiajMiLCJqNCIsImo1IiwiajYiLCJqNyIsImo4IiwiajkiLCJqMTAiLCJqMTEiLCJqMTIiLCJqMTMiLCJqMTQiLCJqMTUiLCJ4MCIsIngxIiwieDIiLCJ4MyIsIng0IiwieDUiLCJ4NiIsIng3IiwieDgiLCJ4OSIsIngxMCIsIngxMSIsIngxMiIsIngxMyIsIngxNCIsIngxNSIsInUiLCJjb3JlX2hzYWxzYTIwIiwiY3J5cHRvX2NvcmVfc2Fsc2EyMCIsImlucCIsImNyeXB0b19jb3JlX2hzYWxzYTIwIiwic2lnbWEiLCJjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yIiwiY3BvcyIsIm1wb3MiLCJ6IiwiY3J5cHRvX3N0cmVhbV9zYWxzYTIwIiwiY3J5cHRvX3N0cmVhbSIsInNuIiwiY3J5cHRvX3N0cmVhbV94b3IiLCJwb2x5MTMwNSIsIlVpbnQxNkFycmF5IiwicGFkIiwibGVmdG92ZXIiLCJmaW4iLCJ0MCIsInQxIiwidDIiLCJ0MyIsInQ0IiwidDUiLCJ0NiIsInQ3IiwiYmxvY2tzIiwiYnl0ZXMiLCJoaWJpdCIsImQwIiwiZDEiLCJkMiIsImQzIiwiZDQiLCJkNSIsImQ2IiwiZDciLCJkOCIsImQ5IiwiaDAiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJoNyIsImg4IiwiaDkiLCJyMCIsInIxIiwicjIiLCJyMyIsInI0IiwicjUiLCJyNiIsInI3IiwicjgiLCJyOSIsImZpbmlzaCIsIm1hYyIsIm1hY3BvcyIsImciLCJmIiwid2FudCIsImNyeXB0b19vbmV0aW1lYXV0aCIsIm91dHBvcyIsImNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkiLCJocG9zIiwiY3J5cHRvX3NlY3JldGJveCIsImNyeXB0b19zZWNyZXRib3hfb3BlbiIsInNldDI1NTE5IiwiYSIsImNhcjI1NTE5IiwidiIsInNlbDI1NTE5IiwicSIsInBhY2syNTUxOSIsImoiLCJuZXEyNTUxOSIsInBhcjI1NTE5IiwidW5wYWNrMjU1MTkiLCJBIiwiWiIsIk0iLCJ0OCIsInQ5IiwidDEwIiwidDExIiwidDEyIiwidDEzIiwidDE0IiwidDE1IiwidDE2IiwidDE3IiwidDE4IiwidDE5IiwidDIwIiwidDIxIiwidDIyIiwidDIzIiwidDI0IiwidDI1IiwidDI2IiwidDI3IiwidDI4IiwidDI5IiwidDMwIiwiYjAiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiYjkiLCJiMTAiLCJiMTEiLCJiMTIiLCJiMTMiLCJiMTQiLCJiMTUiLCJTIiwiaW52MjU1MTkiLCJwb3cyNTIzIiwiY3J5cHRvX3NjYWxhcm11bHQiLCJ4MzIiLCJzdWJhcnJheSIsIngxNiIsImNyeXB0b19zY2FsYXJtdWx0X2Jhc2UiLCJjcnlwdG9fYm94X2tleXBhaXIiLCJjcnlwdG9fYm94X2JlZm9yZW5tIiwiY3J5cHRvX2JveF9hZnRlcm5tIiwiY3J5cHRvX2JveF9vcGVuX2FmdGVybm0iLCJjcnlwdG9fYm94IiwiY3J5cHRvX2JveF9vcGVuIiwiSyIsImNyeXB0b19oYXNoYmxvY2tzX2hsIiwiaGgiLCJobCIsIndoIiwiSW50MzJBcnJheSIsIndsIiwiYmgwIiwiYmgxIiwiYmgyIiwiYmgzIiwiYmg0IiwiYmg1IiwiYmg2IiwiYmg3IiwiYmwwIiwiYmwxIiwiYmwyIiwiYmwzIiwiYmw0IiwiYmw1IiwiYmw2IiwiYmw3IiwidGgiLCJ0bCIsImFoMCIsImFoMSIsImFoMiIsImFoMyIsImFoNCIsImFoNSIsImFoNiIsImFoNyIsImFsMCIsImFsMSIsImFsMiIsImFsMyIsImFsNCIsImFsNSIsImFsNiIsImFsNyIsImNyeXB0b19oYXNoIiwiY3N3YXAiLCJwYWNrIiwidHgiLCJ0eSIsInppIiwic2NhbGFybXVsdCIsInNjYWxhcmJhc2UiLCJjcnlwdG9fc2lnbl9rZXlwYWlyIiwicGsiLCJzayIsInNlZWRlZCIsIkwiLCJtb2RMIiwiY2FycnkiLCJyZWR1Y2UiLCJjcnlwdG9fc2lnbiIsInNtIiwic21sZW4iLCJ1bnBhY2tuZWciLCJjaGsiLCJudW0iLCJkZW4iLCJkZW4yIiwiZGVuNCIsImRlbjYiLCJjcnlwdG9fc2lnbl9vcGVuIiwiY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyIsImNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyIsImNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTIiwiY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMiLCJjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyIsImNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTIiwiY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyIsImNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMiLCJjcnlwdG9fYm94X0JFRk9SRU5NQllURVMiLCJjcnlwdG9fYm94X05PTkNFQllURVMiLCJjcnlwdG9fYm94X1pFUk9CWVRFUyIsImNyeXB0b19ib3hfQk9YWkVST0JZVEVTIiwiY3J5cHRvX3NpZ25fQllURVMiLCJjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyIsImNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTIiwiY3J5cHRvX3NpZ25fU0VFREJZVEVTIiwiY3J5cHRvX2hhc2hfQllURVMiLCJsb3dsZXZlbCIsImNoZWNrTGVuZ3RocyIsImNoZWNrQm94TGVuZ3RocyIsImNoZWNrQXJyYXlUeXBlcyIsImNsZWFudXAiLCJzZWNyZXRib3giLCJtc2ciLCJub25jZSIsImJveCIsImtleUxlbmd0aCIsIm5vbmNlTGVuZ3RoIiwib3ZlcmhlYWRMZW5ndGgiLCJzY2FsYXJNdWx0IiwiYmFzZSIsInNjYWxhckxlbmd0aCIsImdyb3VwRWxlbWVudExlbmd0aCIsInB1YmxpY0tleSIsInNlY3JldEtleSIsImJlZm9yZSIsImFmdGVyIiwia2V5UGFpciIsImZyb21TZWNyZXRLZXkiLCJwdWJsaWNLZXlMZW5ndGgiLCJzZWNyZXRLZXlMZW5ndGgiLCJzaGFyZWRLZXlMZW5ndGgiLCJzaWduIiwic2lnbmVkTXNnIiwidG1wIiwibWxlbiIsImRldGFjaGVkIiwic2lnIiwidmVyaWZ5IiwiZnJvbVNlZWQiLCJzZWVkIiwic2VlZExlbmd0aCIsInNpZ25hdHVyZUxlbmd0aCIsImhhc2giLCJoYXNoTGVuZ3RoIiwic2V0UFJORyIsImZuIiwibXNDcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJRVU9UQSIsImRlZmF1bHQiLCJfcGF1c2VkIiwiU3RyZWFtUmVhZGVyIiwiX3F1ZXVlU2l6ZSIsIl9vZmZzZXQiLCJxdWV1ZSIsInJlbWFpbiIsImZpcnN0IiwiYnVmZmVycyIsInNwbGljZSIsImNvbnRleHQiLCJpbmRleCIsIlByb3h5IiwiX3VybCIsIl9rZXkiLCJnZW5lcmF0ZUtleSIsIl9hY2NlcHQiLCJfaHR0cCIsImF1dGgiLCJWQUxJRF9QUk9UT0NPTFMiLCJfcGF0aG5hbWUiLCJwcm94eSIsIl9oYW5kc2hha2VSZXF1ZXN0IiwiX3ZhbGlkYXRlSGFuZHNoYWtlIiwiZ2VuZXJhdGVPZmZlciIsImFjY2VwdCIsImFjdGl2YXRlIiwiYXNzZXJ0Iiwib2siLCJpbml0aWFsaXplIiwibWF4SGVhZGVyU2l6ZSIsImFzeW5jX3Jlc291cmNlIiwidHJhaWxlcnMiLCJsaW5lIiwiaXNDaHVua2VkIiwiaGVhZGVyU2l6ZSIsImJvZHlfYnl0ZXMiLCJpc1VzZXJDYWxsIiwiaGFkRXJyb3IiLCJrT25IZWFkZXJzIiwia09uQm9keSIsImtPbk1lc3NhZ2VDb21wbGV0ZSIsImNvbXBhdE1vZGUwXzEyIiwibWV0aG9kcyIsIm1ldGhvZF9jb25uZWN0IiwicmVpbml0aWFsaXplIiwiZnJlZSIsIl9jb21wYXRNb2RlMF8xMSIsImdldEFzeW5jSWQiLCJoZWFkZXJTdGF0ZSIsIlJFUVVFU1RfTElORSIsIlJFU1BPTlNFX0xJTkUiLCJIRUFERVIiLCJzdGF0ZUZpbmlzaEFsbG93ZWQiLCJCT0RZX1JBVyIsInVzZXJDYWxsIiwiY29uc3VtZSIsInVuY29uc3VtZSIsImdldEN1cnJlbnRCdWZmZXIiLCJyZXQiLCJuZXh0UmVxdWVzdCIsImNvbnN1bWVMaW5lIiwiY2hhckF0IiwiaGVhZGVyRXhwIiwiaGVhZGVyQ29udGludWVFeHAiLCJwYXJzZUhlYWRlciIsInBhcnNlRXJyb3JDb2RlIiwiZXhlYyIsIm1hdGNoQ29udGludWUiLCJyZXF1ZXN0RXhwIiwidmVyc2lvbk1ham9yIiwidmVyc2lvbk1pbm9yIiwicmVzcG9uc2VFeHAiLCJzdGF0dXNNZXNzYWdlIiwic2hvdWxkS2VlcEFsaXZlIiwiaGFzQ29udGVudExlbmd0aCIsImN1cnJlbnRDb250ZW50TGVuZ3RoVmFsdWUiLCJoYXNVcGdyYWRlSGVhZGVyIiwic2tpcEJvZHkiLCJCT0RZX0NIVU5LSEVBRCIsIkJPRFlfQ0hVTksiLCJCT0RZX0NIVU5LRU1QVFlMSU5FIiwiZXF1YWwiLCJCT0RZX0NIVU5LVFJBSUxFUlMiLCJCT0RZX1NJWkVEIiwidG8iLCJQYXJzZXIiLCJQaXBlbGluZSIsIl9yc3YxIiwiX3JzdjIiLCJfcnN2MyIsIl9ieU5hbWUiLCJfaW5PcmRlciIsIl9zZXNzaW9ucyIsIl9pbmRleCIsImV4dCIsInNlc3Npb25zIiwib2ZmZXIiLCJzZXNzaW9uIiwiY3JlYXRlQ2xpZW50U2Vzc2lvbiIsInJlY29yZCIsIm9mZmVycyIsIm9mZiIsInNlcmlhbGl6ZVBhcmFtcyIsInJlc3BvbnNlcyIsImVhY2hPZmZlciIsInBhcmFtcyIsInJlc2VydmVkIiwiX3Jlc2VydmVkIiwiX3Jlc2VydmUiLCJfcGlwZWxpbmUiLCJieU5hbWUiLCJjcmVhdGVTZXJ2ZXJTZXNzaW9uIiwiYWxsb3dlZCIsIlRPS0VOIiwiTk9UT0tFTiIsIlFVT1RFRCIsIlBBUkFNIiwiUmVnRXhwIiwic291cmNlIiwiRVhUIiwiRVhUX0xJU1QiLCJOVU1CRVIiLCJPZmZlcnMiLCJTeW50YXhFcnJvciIsInZhbHVlcyIsInBhcmFtIiwicGFyc2VGbG9hdCIsInByaW50IiwidG9BcnJheSIsIkNlbGwiLCJfY2VsbHMiLCJfc3RvcHBlZCIsImluY29taW5nIiwib3V0Z29pbmciLCJfbG9vcCIsImNsb3NlZCIsImRpcmVjdGlvbiIsInN0ZXAiLCJjZWxscyIsIkZ1bmN0b3IiLCJ0dXBsZSIsIl9leHQiLCJfc2Vzc2lvbiIsIl9mdW5jdG9ycyIsImZ1bmN0b3IiLCJfZXhlYyIsIl9jbG9zZWQiLCJfZG9DbG9zZSIsImZvdXQiLCJfbWV0aG9kIiwiY2FsbGVkIiwiX3N0b3AiLCJfZmx1c2hRdWV1ZSIsImhhbmRsZXIiLCJfY2h1bmtzIiwiUE9SVFMiLCJfY2xpZW50IiwiX29yaWdpbiIsIl9zdGF0ZSIsImhyZWYiLCJEcmFmdDc2IiwiRVZFTlRTIiwiX2RlbGVnYXRlIiwiYXV0aG9yaXplZCIsInNlY3VyZSIsImRldGVybWluZVVybCIsInNjaGVtZSIsImtleTEiLCJrZXkyIiwibnVtYmVyRnJvbUtleSIsInNwYWNlc0luS2V5IiwiQk9EWV9TSVpFIiwiX3N0YXJ0ZWQiLCJudW1iZXIxIiwic3BhY2VzMSIsIm51bWJlcjIiLCJzcGFjZXMyIiwiX2tleVZhbHVlcyIsIl9oYW5kc2hha2VTaWduYXR1cmUiLCJtZDUiLCJzaWduYXR1cmUiLCJuZXQiLCJ0bHMiLCJERUZBVUxUX1BPUlRTIiwiU0VDVVJFX1BST1RPQ09MUyIsImVuZHBvaW50Iiwib25Db25uZWN0IiwiX29uQ29ubmVjdCIsIm5ldE9wdGlvbnMiLCJvcmlnaW5UTFMiLCJzb2NrZXRUTFMiLCJjYSIsInNlcnZlcm5hbWUiLCJjb25uZWN0IiwiX2NvbmZpZ3VyZVByb3h5Iiwid29ya2VyIiwiREVGQVVMVF9QSU5HIiwiX3JldHJ5IiwicmV0cnkiLCJERUZBVUxUX1JFVFJZIiwibGFzdEV2ZW50SWQiLCJoYW5kc2hha2UiLCJpc0V2ZW50U291cmNlIiwiaWQiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwicHVzaGVyX3dpdGhfZW5jcnlwdGlvbl9QdXNoZXJXaXRoRW5jcnlwdGlvbiIsImJ0b2EiLCJ1dG9iIiwiYjY0Y2hhcnMiLCJiNjR0YWIiLCJiYXNlNjRfaSIsImNiX3V0b2IiLCJjYyIsImNiX2VuY29kZSIsImNjYyIsInBhZGxlbiIsIm9yZCIsImdsb2JhbCIsIlRpbWVyIiwiZGVsYXkiLCJ0aW1lciIsImlzUnVubmluZyIsImVuc3VyZUFib3J0ZWQiLCJhYnN0cmFjdF90aW1lciIsInRpbWVyc19jbGVhclRpbWVvdXQiLCJ0aW1lcnNfY2xlYXJJbnRlcnZhbCIsInRpbWVyc19PbmVPZmZUaW1lciIsInRpbWVyc19QZXJpb2RpY1RpbWVyIiwiVXRpbCIsIm5vdyIsIkRhdGUiLCJ2YWx1ZU9mIiwiZGVmZXIiLCJib3VuZEFyZ3VtZW50cyIsImV4dGVuZCIsInNvdXJjZXMiLCJzYWZlSlNPTlN0cmluZ2lmeSIsImFycmF5SW5kZXhPZiIsImFycmF5IiwiaXRlbSIsIm5hdGl2ZUluZGV4T2YiLCJvYmplY3RBcHBseSIsImtleXMiLCJfIiwibWFwT2JqZWN0IiwiZmlsdGVyT2JqZWN0IiwiQm9vbGVhbiIsImZsYXR0ZW4iLCJhbnkiLCJjb2xsZWN0aW9uc19hbGwiLCJlbmNvZGVQYXJhbXNPYmplY3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJidWlsZFF1ZXJ5U3RyaW5nIiwicXVlcnkiLCJkZWN5Y2xlT2JqZWN0Iiwib2JqZWN0cyIsInBhdGhzIiwiZGVyZXoiLCJudSIsIiRyZWYiLCJEZWZhdWx0cyIsIlBST1RPQ09MIiwid3NQb3J0Iiwid3NzUG9ydCIsIndzUGF0aCIsImh0dHBIb3N0IiwiaHR0cFBvcnQiLCJodHRwc1BvcnQiLCJodHRwUGF0aCIsInN0YXRzX2hvc3QiLCJhdXRoRW5kcG9pbnQiLCJhdXRoVHJhbnNwb3J0IiwiYWN0aXZpdHlUaW1lb3V0IiwicG9uZ1RpbWVvdXQiLCJ1bmF2YWlsYWJsZVRpbWVvdXQiLCJ1c2VyQXV0aGVudGljYXRpb24iLCJ0cmFuc3BvcnQiLCJjaGFubmVsQXV0aG9yaXphdGlvbiIsImNkbl9odHRwIiwiY2RuX2h0dHBzIiwiZGVwZW5kZW5jeV9zdWZmaXgiLCJkZWZhdWx0cyIsImdldEdlbmVyaWNVUkwiLCJiYXNlU2NoZW1lIiwidXNlVExTIiwiaG9zdFRMUyIsImhvc3ROb25UTFMiLCJnZXRHZW5lcmljUGF0aCIsInF1ZXJ5U3RyaW5nIiwid3MiLCJnZXRJbml0aWFsIiwic29ja2pzIiwiZ2V0UGF0aCIsImNhbGxiYWNrX3JlZ2lzdHJ5X0NhbGxiYWNrUmVnaXN0cnkiLCJwcmVmaXgiLCJwcmVmaXhlZEV2ZW50TmFtZSIsInJlbW92ZSIsIm5hbWVzIiwicmVtb3ZlQ2FsbGJhY2siLCJyZW1vdmVBbGxDYWxsYmFja3MiLCJiaW5kaW5nIiwiZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIiwiZmFpbFRocm91Z2giLCJnbG9iYWxfY2FsbGJhY2tzIiwiZXZlbnROYW1lIiwiYmluZF9nbG9iYWwiLCJ1bmJpbmQiLCJ1bmJpbmRfZ2xvYmFsIiwidW5iaW5kX2FsbCIsIm1ldGFkYXRhIiwibG9nZ2VyX0xvZ2dlciIsImdsb2JhbExvZyIsImxvZyIsImRlYnVnIiwiZ2xvYmFsTG9nV2FybiIsImdsb2JhbExvZ0Vycm9yIiwiZGVmYXVsdExvZ2dpbmdGdW5jdGlvbiIsImNvcmVfcHVzaGVyIiwibG9nVG9Db25zb2xlIiwibG9nZ2VyIiwidHJhbnNwb3J0X2Nvbm5lY3Rpb25fVHJhbnNwb3J0Q29ubmVjdGlvbiIsImhvb2tzIiwicHJpb3JpdHkiLCJub2RlX3J1bnRpbWUiLCJ0cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXIiLCJ0aW1lbGluZSIsImdlbmVyYXRlVW5pcXVlSUQiLCJoYW5kbGVzQWN0aXZpdHlDaGVja3MiLCJzdXBwb3J0c1BpbmciLCJ1cmxzIiwiZ2V0U29ja2V0Iiwib25FcnJvciIsImNoYW5nZVN0YXRlIiwiYmluZExpc3RlbmVycyIsIm9uT3BlbiIsImJlZm9yZU9wZW4iLCJidWlsZFRpbWVsaW5lTWVzc2FnZSIsIm9uQ2xvc2UiLCJjbG9zZUV2ZW50Iiwid2FzQ2xlYW4iLCJ1bmJpbmRMaXN0ZW5lcnMiLCJvbk1lc3NhZ2UiLCJvbkFjdGl2aXR5Iiwib25hY3Rpdml0eSIsImNpZCIsInRyYW5zcG9ydF9UcmFuc3BvcnQiLCJpc1N1cHBvcnRlZCIsImVudmlyb25tZW50IiwiY3JlYXRlQ29ubmVjdGlvbiIsIldTVHJhbnNwb3J0IiwiaXNJbml0aWFsaXplZCIsImdldFdlYlNvY2tldEFQSSIsImNyZWF0ZVdlYlNvY2tldCIsImh0dHBDb25maWd1cmF0aW9uIiwic3RyZWFtaW5nQ29uZmlndXJhdGlvbiIsIkhUVFBGYWN0b3J5IiwiY3JlYXRlU3RyZWFtaW5nU29ja2V0IiwicG9sbGluZ0NvbmZpZ3VyYXRpb24iLCJjcmVhdGVQb2xsaW5nU29ja2V0IiwieGhyQ29uZmlndXJhdGlvbiIsImlzWEhSU3VwcG9ydGVkIiwiWEhSU3RyZWFtaW5nVHJhbnNwb3J0IiwiWEhSUG9sbGluZ1RyYW5zcG9ydCIsIlRyYW5zcG9ydHMiLCJ4aHJfc3RyZWFtaW5nIiwieGhyX3BvbGxpbmciLCJ0cmFuc3BvcnRzIiwiYXNzaXN0YW50X3RvX3RoZV90cmFuc3BvcnRfbWFuYWdlcl9Bc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIiLCJtYW5hZ2VyIiwibWluUGluZ0RlbGF5IiwibWF4UGluZ0RlbGF5IiwicGluZ0RlbGF5Iiwib3BlblRpbWVzdGFtcCIsIm9uQ2xvc2VkIiwicmVwb3J0RGVhdGgiLCJsaWZlc3BhbiIsIm1heCIsImlzQWxpdmUiLCJQcm90b2NvbCIsImRlY29kZU1lc3NhZ2UiLCJtZXNzYWdlRXZlbnQiLCJtZXNzYWdlRGF0YSIsInB1c2hlckV2ZW50RGF0YSIsInB1c2hlckV2ZW50IiwiY2hhbm5lbCIsInVzZXJfaWQiLCJlbmNvZGVNZXNzYWdlIiwicHJvY2Vzc0hhbmRzaGFrZSIsImFjdGl2aXR5X3RpbWVvdXQiLCJhY3Rpb24iLCJzb2NrZXRfaWQiLCJnZXRDbG9zZUFjdGlvbiIsImdldENsb3NlRXJyb3IiLCJjb25uZWN0aW9uX0Nvbm5lY3Rpb24iLCJzZW5kX2V2ZW50IiwiYWN0aXZpdHkiLCJoYW5kbGVDbG9zZUV2ZW50IiwiaGFuZHNoYWtlX0hhbmRzaGFrZSIsInRpbWVsaW5lX3NlbmRlcl9UaW1lbGluZVNlbmRlciIsImlzRW1wdHkiLCJUaW1lbGluZVRyYW5zcG9ydCIsImdldEFnZW50IiwiQmFkRXZlbnROYW1lIiwiQmFkQ2hhbm5lbE5hbWUiLCJSZXF1ZXN0VGltZWRPdXQiLCJUcmFuc3BvcnRQcmlvcml0eVRvb0xvdyIsIlRyYW5zcG9ydENsb3NlZCIsIlVuc3VwcG9ydGVkRmVhdHVyZSIsIlVuc3VwcG9ydGVkVHJhbnNwb3J0IiwiVW5zdXBwb3J0ZWRTdHJhdGVneSIsIkhUVFBBdXRoRXJyb3IiLCJ1cmxTdG9yZSIsImJhc2VVcmwiLCJhdXRoZW50aWNhdGlvbkVuZHBvaW50IiwiYXV0aG9yaXphdGlvbkVuZHBvaW50IiwiamF2YXNjcmlwdFF1aWNrU3RhcnQiLCJ0cmlnZ2VyaW5nQ2xpZW50RXZlbnRzIiwiZW5jcnlwdGVkQ2hhbm5lbFN1cHBvcnQiLCJmdWxsVXJsIiwiYnVpbGRMb2dTdWZmaXgiLCJ1cmxQcmVmaXgiLCJ1cmxPYmoiLCJ1cmxfc3RvcmUiLCJjaGFubmVsX0NoYW5uZWwiLCJwdXNoZXIiLCJzdWJzY3JpYmVkIiwic3Vic2NyaXB0aW9uUGVuZGluZyIsInN1YnNjcmlwdGlvbkNhbmNlbGxlZCIsImF1dGhvcml6ZSIsInNvY2tldElkIiwidHJpZ2dlciIsInN1ZmZpeCIsImRpc2Nvbm5lY3QiLCJoYW5kbGVFdmVudCIsImhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50IiwiaGFuZGxlU3Vic2NyaXB0aW9uQ291bnRFdmVudCIsInVuc3Vic2NyaWJlIiwic3Vic2NyaXB0aW9uX2NvdW50Iiwic3Vic2NyaXB0aW9uQ291bnQiLCJzdWJzY3JpYmUiLCJhc3NpZ24iLCJjaGFubmVsX2RhdGEiLCJjYW5jZWxTdWJzY3JpcHRpb24iLCJyZWluc3RhdGVTdWJzY3JpcHRpb24iLCJwcml2YXRlX2NoYW5uZWxfUHJpdmF0ZUNoYW5uZWwiLCJjb25maWciLCJjaGFubmVsQXV0aG9yaXplciIsImNoYW5uZWxOYW1lIiwibWVtYmVyc19NZW1iZXJzIiwicmVzZXQiLCJtZW1iZXJzIiwiZWFjaCIsIm1lbWJlciIsInNldE15SUQiLCJteUlEIiwib25TdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb25EYXRhIiwicHJlc2VuY2UiLCJjb3VudCIsIm1lIiwiYWRkTWVtYmVyIiwibWVtYmVyRGF0YSIsInVzZXJfaW5mbyIsInJlbW92ZU1lbWJlciIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJuZXh0IiwicmVqZWN0ZWQiLCJwcmVzZW5jZV9jaGFubmVsX1ByZXNlbmNlQ2hhbm5lbCIsImF1dGhEYXRhIiwiY2hhbm5lbERhdGEiLCJzaWduaW5Eb25lUHJvbWlzZSIsInVzZXJfZGF0YSIsImhhbmRsZUludGVybmFsRXZlbnQiLCJhZGRlZE1lbWJlciIsInJlbW92ZWRNZW1iZXIiLCJ1dGY4IiwiYmFzZTY0IiwiZW5jcnlwdGVkX2NoYW5uZWxfRW5jcnlwdGVkQ2hhbm5lbCIsInNoYXJlZFNlY3JldCIsImhhbmRsZUVuY3J5cHRlZEV2ZW50IiwiY2lwaGVydGV4dCIsImNpcGhlclRleHQiLCJnZXREYXRhVG9FbWl0IiwicmF3IiwiX2EiLCJjb25uZWN0aW9uX21hbmFnZXJfQ29ubmVjdGlvbk1hbmFnZXIiLCJ1c2luZ1RMUyIsImVycm9yQ2FsbGJhY2tzIiwiYnVpbGRFcnJvckNhbGxiYWNrcyIsImNvbm5lY3Rpb25DYWxsYmFja3MiLCJidWlsZENvbm5lY3Rpb25DYWxsYmFja3MiLCJoYW5kc2hha2VDYWxsYmFja3MiLCJidWlsZEhhbmRzaGFrZUNhbGxiYWNrcyIsIk5ldHdvcmsiLCJnZXROZXR3b3JrIiwibmV0aW5mbyIsInJldHJ5SW4iLCJzZW5kQWN0aXZpdHlDaGVjayIsInVwZGF0ZVN0cmF0ZWd5IiwicnVubmVyIiwic3RyYXRlZ3kiLCJ1cGRhdGVTdGF0ZSIsInN0YXJ0Q29ubmVjdGluZyIsInNldFVuYXZhaWxhYmxlVGltZXIiLCJkaXNjb25uZWN0SW50ZXJuYWxseSIsImlzVXNpbmdUTFMiLCJoYW5kc2hha2VFcnJvciIsImFib3J0Q29ubmVjdGluZyIsImNsZWFyUmV0cnlUaW1lciIsImNsZWFyVW5hdmFpbGFibGVUaW1lciIsImFiYW5kb25Db25uZWN0aW9uIiwiZ2V0U3RyYXRlZ3kiLCJyb3VuZCIsInJldHJ5VGltZXIiLCJ1bmF2YWlsYWJsZVRpbWVyIiwic3RvcEFjdGl2aXR5Q2hlY2siLCJhY3Rpdml0eVRpbWVyIiwicG9uZ190aW1lZF9vdXQiLCJyZXNldEFjdGl2aXR5Q2hlY2siLCJzaG91bGRSZXRyeSIsImNvbm5lY3RlZCIsIkluZmluaXR5Iiwic2V0Q29ubmVjdGlvbiIsIndpdGhFcnJvckVtaXR0ZWQiLCJ0bHNfb25seSIsInJlZnVzZWQiLCJiYWNrb2ZmIiwibmV3U3RhdGUiLCJwcmV2aW91c1N0YXRlIiwibmV3U3RhdGVEZXNjcmlwdGlvbiIsInByZXZpb3VzIiwiY2hhbm5lbHNfQ2hhbm5lbHMiLCJjaGFubmVscyIsImNyZWF0ZUNoYW5uZWwiLCJmaW5kIiwiZmFjdG9yeSIsImNyZWF0ZUVuY3J5cHRlZENoYW5uZWwiLCJlcnJNc2ciLCJjcmVhdGVQcml2YXRlQ2hhbm5lbCIsImNyZWF0ZVByZXNlbmNlQ2hhbm5lbCIsIkZhY3RvcnkiLCJjcmVhdGVDaGFubmVscyIsImNyZWF0ZUNvbm5lY3Rpb25NYW5hZ2VyIiwiY3JlYXRlVGltZWxpbmVTZW5kZXIiLCJjcmVhdGVIYW5kc2hha2UiLCJjcmVhdGVBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIiLCJ0cmFuc3BvcnRfbWFuYWdlcl9UcmFuc3BvcnRNYW5hZ2VyIiwibGl2ZXNMZWZ0IiwibGl2ZXMiLCJnZXRBc3Npc3RhbnQiLCJzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneSIsInN0cmF0ZWdpZXMiLCJsb29wIiwiZmFpbEZhc3QiLCJ0aW1lb3V0IiwidGltZW91dExpbWl0IiwibWluUHJpb3JpdHkiLCJ0cnlOZXh0U3RyYXRlZ3kiLCJ0cnlTdHJhdGVneSIsImZvcmNlTWluUHJpb3JpdHkiLCJiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5X0Jlc3RDb25uZWN0ZWRFdmVyU3RyYXRlZ3kiLCJydW5uZXJzIiwiYWxsUnVubmVyc0ZhaWxlZCIsImNhbGxiYWNrQnVpbGRlciIsInJzIiwiYWJvcnRSdW5uZXIiLCJhYm9ydGVkIiwid2Vic29ja2V0X3ByaW9yaXRpemVkX2NhY2hlZF9zdHJhdGVneV9XZWJTb2NrZXRQcmlvcml0aXplZENhY2hlZFN0cmF0ZWd5IiwidHRsIiwiZmV0Y2hUcmFuc3BvcnRDYWNoZSIsImNhY2hlU2tpcENvdW50IiwidGltZXN0YW1wIiwiaW5jbHVkZXMiLCJjYWNoZWQiLCJsYXRlbmN5Iiwic3RhcnRUaW1lc3RhbXAiLCJwb3AiLCJjYiIsImZsdXNoVHJhbnNwb3J0Q2FjaGUiLCJzdG9yZVRyYW5zcG9ydENhY2hlIiwiZ2V0VHJhbnNwb3J0Q2FjaGVLZXkiLCJzdG9yYWdlIiwiZ2V0TG9jYWxTdG9yYWdlIiwic2VyaWFsaXplZENhY2hlIiwiZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3kiLCJudW1iZXIiLCJJZlN0cmF0ZWd5IiwidHJ1ZUJyYW5jaCIsImZhbHNlQnJhbmNoIiwiYnJhbmNoIiwiRmlyc3RDb25uZWN0ZWRTdHJhdGVneSIsInRlc3RTdXBwb3J0c1N0cmF0ZWd5IiwiZ2V0RGVmYXVsdFN0cmF0ZWd5IiwiYmFzZU9wdGlvbnMiLCJkZWZpbmVUcmFuc3BvcnQiLCJkZWZpbmVkVHJhbnNwb3J0cyIsImRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5Iiwid3Nfb3B0aW9ucyIsIndzSG9zdCIsIndzc19vcHRpb25zIiwiaHR0cF9vcHRpb25zIiwidGltZW91dHMiLCJ3c19tYW5hZ2VyIiwic3RyZWFtaW5nX21hbmFnZXIiLCJ3c190cmFuc3BvcnQiLCJ3c3NfdHJhbnNwb3J0IiwieGhyX3N0cmVhbWluZ190cmFuc3BvcnQiLCJ4aHJfcG9sbGluZ190cmFuc3BvcnQiLCJ3c19sb29wIiwid3NzX2xvb3AiLCJzdHJlYW1pbmdfbG9vcCIsInBvbGxpbmdfbG9vcCIsImh0dHBfbG9vcCIsIndzU3RyYXRlZ3kiLCJkZWZhdWx0X3N0cmF0ZWd5IiwidHJhbnNwb3J0X2Nvbm5lY3Rpb25faW5pdGlhbGl6ZXIiLCJNQVhfQlVGRkVSX0xFTkdUSCIsImh0dHBfcmVxdWVzdF9IVFRQUmVxdWVzdCIsInBvc2l0aW9uIiwieGhyIiwiZ2V0UmVxdWVzdCIsInVubG9hZGVyIiwiYWRkVW5sb2FkTGlzdGVuZXIiLCJyZW1vdmVVbmxvYWRMaXN0ZW5lciIsImFib3J0UmVxdWVzdCIsIm9uQ2h1bmsiLCJhZHZhbmNlQnVmZmVyIiwiaXNCdWZmZXJUb29Mb25nIiwidW5yZWFkRGF0YSIsImVuZE9mTGluZVBvc2l0aW9uIiwiU3RhdGUiLCJhdXRvSW5jcmVtZW50IiwiaHR0cF9zb2NrZXRfSFRUUFNvY2tldCIsInJhbmRvbU51bWJlciIsInJhbmRvbVN0cmluZyIsImdldExvY2F0aW9uIiwib3BlblN0cmVhbSIsInNlbmRSYXciLCJzZW5kSGVhcnRiZWF0IiwiY3JlYXRlU29ja2V0UmVxdWVzdCIsImdldFVuaXF1ZVVSTCIsImdldFNlbmRVUkwiLCJyZWNvbm5lY3QiLCJjbG9zZVN0cmVhbSIsIm9uRXZlbnQiLCJvbkhlYXJ0YmVhdCIsInJlcGxhY2VIb3N0Iiwic3RyZWFtIiwiZ2V0UmVjZWl2ZVVSTCIsIm9uRmluaXNoZWQiLCJwYXJ0cyIsInNlcGFyYXRvciIsInVybFBhcnRzIiwicmFuZG9tSW50IiwiaHR0cF9zb2NrZXQiLCJodHRwX3N0cmVhbWluZ19zb2NrZXRfaG9va3MiLCJodHRwX3N0cmVhbWluZ19zb2NrZXQiLCJodHRwX3BvbGxpbmdfc29ja2V0X2hvb2tzIiwiaHR0cF9wb2xsaW5nX3NvY2tldCIsImh0dHBfeGhyX3JlcXVlc3RfaG9va3MiLCJDb25zdHJ1Y3RvciIsImdldFhIUkFQSSIsIm9ucHJvZ3Jlc3MiLCJodHRwX3hocl9yZXF1ZXN0IiwiSFRUUCIsImNyZWF0ZVNvY2tldCIsImNyZWF0ZVhIUiIsImNyZWF0ZVJlcXVlc3QiLCJodHRwX2h0dHAiLCJJc29tb3JwaGljIiwic2V0dXAiLCJQdXNoZXJDbGFzcyIsInJlYWR5IiwiZ2V0Q2xpZW50RmVhdHVyZXMiLCJnZXRQcm90b2NvbCIsInJ1bnRpbWUiLCJ3ZWJzb2NrZXQiLCJuZXRfaW5mb19OZXRJbmZvIiwiaXNPbmxpbmUiLCJuZXRfaW5mb19OZXR3b3JrIiwiQXV0aFJlcXVlc3RUeXBlIiwiYWpheCIsImF1dGhPcHRpb25zIiwiYXV0aFJlcXVlc3RUeXBlIiwiaGVhZGVyTmFtZSIsImhlYWRlcnNQcm92aWRlciIsImR5bmFtaWNIZWFkZXJzIiwicGFyc2VkIiwiVXNlckF1dGhlbnRpY2F0aW9uIiwiQ2hhbm5lbEF1dGhvcml6YXRpb24iLCJ4aHJfYXV0aCIsInNlbmRlciIsInhocl90aW1lbGluZV94aHIiLCJ4aHJfdGltZWxpbmUiLCJleHRlcm5hbF9jcnlwdG9fIiwicnVudGltZV9nZXREZWZhdWx0U3RyYXRlZ3kiLCJydW50aW1lX1RyYW5zcG9ydHMiLCJOb2RlSlMiLCJnZXRBdXRob3JpemVycyIsIlRpbWVsaW5lTGV2ZWwiLCJ0aW1lbGluZV9sZXZlbCIsInRpbWVsaW5lX1RpbWVsaW5lIiwiZXZlbnRzIiwic2VudCIsInVuaXF1ZUlEIiwibGV2ZWwiLCJsaW1pdCIsIkVSUk9SIiwiSU5GTyIsIkRFQlVHIiwic2VuZGZuIiwiYnVuZGxlIiwibGliIiwiY2x1c3RlciIsImZlYXR1cmVzIiwidHJhbnNwb3J0X3N0cmF0ZWd5X1RyYW5zcG9ydFN0cmF0ZWd5IiwiZmFpbEF0dGVtcHQiLCJvbkluaXRpYWxpemVkIiwic2VyaWFsaXplZFRyYW5zcG9ydCIsInN0cmF0ZWd5X2J1aWxkZXJfVHJhbnNwb3J0cyIsInN0cmF0ZWd5X2J1aWxkZXJfZGVmaW5lVHJhbnNwb3J0IiwidHJhbnNwb3J0Q2xhc3MiLCJlbmFibGVkIiwiZW5hYmxlZFRyYW5zcG9ydHMiLCJkaXNhYmxlZFRyYW5zcG9ydHMiLCJpZ25vcmVOdWxsT3JpZ2luIiwic3RyYXRlZ3lfYnVpbGRlcl9VbnN1cHBvcnRlZFN0cmF0ZWd5IiwiZGVmZXJyZWQiLCJjb21wb3NlQ2hhbm5lbFF1ZXJ5IiwicGFyYW1zUHJvdmlkZXIiLCJkeW5hbWljUGFyYW1zIiwiVXNlckF1dGhlbnRpY2F0b3IiLCJ1c2VyX2F1dGhlbnRpY2F0b3IiLCJjaGFubmVsX2F1dGhvcml6ZXJfY29tcG9zZUNoYW5uZWxRdWVyeSIsIkNoYW5uZWxBdXRob3JpemVyIiwiY2hhbm5lbF9hdXRob3JpemVyIiwiQ2hhbm5lbEF1dGhvcml6ZXJQcm94eSIsImNoYW5uZWxBdXRob3JpemVyR2VuZXJhdG9yIiwiZGVwcmVjYXRlZEF1dGhvcml6ZXJPcHRpb25zIiwiZ2V0Q29uZmlnIiwib3B0cyIsInN0YXRzSG9zdCIsImVuYWJsZVN0YXRzIiwiZ2V0RW5hYmxlU3RhdHNDb25maWciLCJnZXRIdHRwSG9zdCIsInNob3VsZFVzZVRMUyIsImdldFdlYnNvY2tldEhvc3QiLCJ1c2VyQXV0aGVudGljYXRvciIsImJ1aWxkVXNlckF1dGhlbnRpY2F0b3IiLCJidWlsZENoYW5uZWxBdXRob3JpemVyIiwidGltZWxpbmVQYXJhbXMiLCJnZXRXZWJzb2NrZXRIb3N0RnJvbUNsdXN0ZXIiLCJmb3JjZVRMUyIsImRpc2FibGVTdGF0cyIsImJ1aWxkQ2hhbm5lbEF1dGgiLCJjdXN0b21IYW5kbGVyIiwiYXV0aG9yaXplciIsIndhdGNobGlzdF9XYXRjaGxpc3RGYWNhZGUiLCJiaW5kV2F0Y2hsaXN0SW50ZXJuYWxFdmVudCIsIndhdGNobGlzdEV2ZW50IiwiZmxhdFByb21pc2UiLCJwcm9taXNlIiwicmVzIiwicmVqIiwiZmxhdF9wcm9taXNlIiwidXNlcl9Vc2VyRmFjYWRlIiwic2lnbmluX3JlcXVlc3RlZCIsInNlcnZlclRvVXNlckNoYW5uZWwiLCJfc2lnbmluRG9uZVJlc29sdmUiLCJfb25BdXRob3JpemUiLCJfY2xlYW51cCIsIl9zaWduaW4iLCJfbmV3U2lnbmluUHJvbWlzZUlmTmVlZGVkIiwid2F0Y2hsaXN0IiwiX29uU2lnbmluU3VjY2VzcyIsInNpZ25pbiIsIl9zdWJzY3JpYmVDaGFubmVscyIsImVuc3VyZV9zdWJzY3JpYmVkIiwic2V0RG9uZSIsImNhdGNoIiwicHVzaGVyX1B1c2hlciIsImlzUmVhZHkiLCJpbnN0YW5jZXMiLCJhcHBfa2V5IiwiY2hlY2tBcHBLZXkiLCJnbG9iYWxfZW1pdHRlciIsInNlc3Npb25JRCIsInRpbWVsaW5lU2VuZGVyIiwic3Vic2NyaWJlQWxsIiwiaW50ZXJuYWwiLCJhbGxDaGFubmVscyIsInRpbWVsaW5lU2VuZGVyVGltZXIiLCJldmVudF9uYW1lIiwiY2hhbm5lbF9uYW1lIiwiUnVudGltZSIsIlNjcmlwdFJlY2VpdmVycyIsIkRlcGVuZGVuY2llc1JlY2VpdmVycyIsImF1dGhfY2FsbGJhY2tzIiwibmFjbF9mYXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pusher-js/dist/node/pusher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pusher-js/dist/node/pusher.js":
/*!****************************************************!*\
  !*** ./node_modules/pusher-js/dist/node/pusher.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Pusher JavaScript Library v8.3.0\n * https://pusher.com/\n *\n * Copyright 2020, Pusher\n * Released under the MIT licence.\n */\n\nmodule.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_319__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_319__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_319__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_319__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_319__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_319__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_319__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_319__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_319__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_319__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_319__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_319__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_319__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_319__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_319__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_319__(__nested_webpack_require_319__.s = 21);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! util */ \"util\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_3873__) {\n\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __nested_webpack_require_3873__(22)\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_5485__) {\n\n\"use strict\";\n\n\nvar Buffer  = __nested_webpack_require_5485__(1).Buffer,\n    Emitter = __nested_webpack_require_5485__(23).EventEmitter,\n    util    = __nested_webpack_require_5485__(0),\n    streams = __nested_webpack_require_5485__(24),\n    Headers = __nested_webpack_require_5485__(9),\n    Reader  = __nested_webpack_require_5485__(25);\n\nvar Base = function(request, url, options) {\n  Emitter.call(this);\n  Base.validateOptions(options || {}, ['maxLength', 'masking', 'requireMasking', 'protocols']);\n\n  this._request   = request;\n  this._reader    = new Reader();\n  this._options   = options || {};\n  this._maxLength = this._options.maxLength || this.MAX_LENGTH;\n  this._headers   = new Headers();\n  this.__queue    = [];\n  this.readyState = 0;\n  this.url        = url;\n\n  this.io = new streams.IO(this);\n  this.messages = new streams.Messages(this);\n  this._bindEventListeners();\n};\nutil.inherits(Base, Emitter);\n\nBase.isWebSocket = function(request) {\n  var connection = request.headers.connection || '',\n      upgrade    = request.headers.upgrade || '';\n\n  return request.method === 'GET' &&\n         connection.toLowerCase().split(/ *, */).indexOf('upgrade') >= 0 &&\n         upgrade.toLowerCase() === 'websocket';\n};\n\nBase.validateOptions = function(options, validKeys) {\n  for (var key in options) {\n    if (validKeys.indexOf(key) < 0)\n      throw new Error('Unrecognized option: ' + key);\n  }\n};\n\nvar instance = {\n  // This is 64MB, small enough for an average VPS to handle without\n  // crashing from process out of memory\n  MAX_LENGTH: 0x3ffffff,\n\n  STATES: ['connecting', 'open', 'closing', 'closed'],\n\n  _bindEventListeners: function() {\n    var self = this;\n\n    // Protocol errors are informational and do not have to be handled\n    this.messages.on('error', function() {});\n\n    this.on('message', function(event) {\n      var messages = self.messages;\n      if (messages.readable) messages.emit('data', event.data);\n    });\n\n    this.on('error', function(error) {\n      var messages = self.messages;\n      if (messages.readable) messages.emit('error', error);\n    });\n\n    this.on('close', function() {\n      var messages = self.messages;\n      if (!messages.readable) return;\n      messages.readable = messages.writable = false;\n      messages.emit('end');\n    });\n  },\n\n  getState: function() {\n    return this.STATES[this.readyState] || null;\n  },\n\n  addExtension: function(extension) {\n    return false;\n  },\n\n  setHeader: function(name, value) {\n    if (this.readyState > 0) return false;\n    this._headers.set(name, value);\n    return true;\n  },\n\n  start: function() {\n    if (this.readyState !== 0) return false;\n\n    if (!Base.isWebSocket(this._request))\n      return this._failHandshake(new Error('Not a WebSocket request'));\n\n    var response;\n\n    try {\n      response = this._handshakeResponse();\n    } catch (error) {\n      return this._failHandshake(error);\n    }\n\n    this._write(response);\n    if (this._stage !== -1) this._open();\n    return true;\n  },\n\n  _failHandshake: function(error) {\n    var headers = new Headers();\n    headers.set('Content-Type', 'text/plain');\n    headers.set('Content-Length', Buffer.byteLength(error.message, 'utf8'));\n\n    headers = ['HTTP/1.1 400 Bad Request', headers.toString(), error.message];\n    this._write(Buffer.from(headers.join('\\r\\n'), 'utf8'));\n    this._fail('protocol_error', error.message);\n\n    return false;\n  },\n\n  text: function(message) {\n    return this.frame(message);\n  },\n\n  binary: function(message) {\n    return false;\n  },\n\n  ping: function() {\n    return false;\n  },\n\n  pong: function() {\n      return false;\n  },\n\n  close: function(reason, code) {\n    if (this.readyState !== 1) return false;\n    this.readyState = 3;\n    this.emit('close', new Base.CloseEvent(null, null));\n    return true;\n  },\n\n  _open: function() {\n    this.readyState = 1;\n    this.__queue.forEach(function(args) { this.frame.apply(this, args) }, this);\n    this.__queue = [];\n    this.emit('open', new Base.OpenEvent());\n  },\n\n  _queue: function(message) {\n    this.__queue.push(message);\n    return true;\n  },\n\n  _write: function(chunk) {\n    var io = this.io;\n    if (io.readable) io.emit('data', chunk);\n  },\n\n  _fail: function(type, message) {\n    this.readyState = 2;\n    this.emit('error', new Error(message));\n    this.close();\n  }\n};\n\nfor (var key in instance)\n  Base.prototype[key] = instance[key];\n\n\nBase.ConnectEvent = function() {};\n\nBase.OpenEvent = function() {};\n\nBase.CloseEvent = function(code, reason) {\n  this.code   = code;\n  this.reason = reason;\n};\n\nBase.MessageEvent = function(data) {\n  this.data = data;\n};\n\nBase.PingEvent = function(data) {\n  this.data = data;\n};\n\nBase.PongEvent = function(data) {\n  this.data = data;\n};\n\nmodule.exports = Base;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! crypto */ \"crypto\");\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_10319__) {\n\n\"use strict\";\n\n\n// Protocol references:\n//\n// * http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75\n// * http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76\n// * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17\n\nvar Base   = __nested_webpack_require_10319__(2),\n    Client = __nested_webpack_require_10319__(26),\n    Server = __nested_webpack_require_10319__(37);\n\nvar Driver = {\n  client: function(url, options) {\n    options = options || {};\n    if (options.masking === undefined) options.masking = true;\n    return new Client(url, options);\n  },\n\n  server: function(options) {\n    options = options || {};\n    if (options.requireMasking === undefined) options.requireMasking = true;\n    return new Server(options);\n  },\n\n  http: function() {\n    return Server.http.apply(Server, arguments);\n  },\n\n  isSecureRequest: function(request) {\n    return Server.isSecureRequest(request);\n  },\n\n  isWebSocket: function(request) {\n    return Base.isWebSocket(request);\n  },\n\n  validateOptions: function(options, validKeys) {\n    Base.validateOptions(options, validKeys);\n  }\n};\n\nmodule.exports = Driver;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! stream */ \"stream\");\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! url */ \"url\");\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Event = function(eventType, options) {\n  this.type = eventType;\n  for (var key in options)\n    this[key] = options[key];\n};\n\nEvent.prototype.initEvent = function(eventType, canBubble, cancelable) {\n  this.type       = eventType;\n  this.bubbles    = canBubble;\n  this.cancelable = cancelable;\n};\n\nEvent.prototype.stopPropagation = function() {};\nEvent.prototype.preventDefault  = function() {};\n\nEvent.CAPTURING_PHASE = 1;\nEvent.AT_TARGET       = 2;\nEvent.BUBBLING_PHASE  = 3;\n\nmodule.exports = Event;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package base64 implements Base64 encoding and decoding.\n */\n// Invalid character used in decoding to indicate\n// that the character to decode is out of range of\n// alphabet and cannot be decoded.\nvar INVALID_BYTE = 256;\n/**\n * Implements standard Base64 encoding.\n *\n * Operates in constant time.\n */\nvar Coder = /** @class */ (function () {\n    // TODO(dchest): methods to encode chunk-by-chunk.\n    function Coder(_paddingCharacter) {\n        if (_paddingCharacter === void 0) { _paddingCharacter = \"=\"; }\n        this._paddingCharacter = _paddingCharacter;\n    }\n    Coder.prototype.encodedLength = function (length) {\n        if (!this._paddingCharacter) {\n            return (length * 8 + 5) / 6 | 0;\n        }\n        return (length + 2) / 3 * 4 | 0;\n    };\n    Coder.prototype.encode = function (data) {\n        var out = \"\";\n        var i = 0;\n        for (; i < data.length - 2; i += 3) {\n            var c = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            out += this._encodeByte((c >>> 1 * 6) & 63);\n            out += this._encodeByte((c >>> 0 * 6) & 63);\n        }\n        var left = data.length - i;\n        if (left > 0) {\n            var c = (data[i] << 16) | (left === 2 ? data[i + 1] << 8 : 0);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            if (left === 2) {\n                out += this._encodeByte((c >>> 1 * 6) & 63);\n            }\n            else {\n                out += this._paddingCharacter || \"\";\n            }\n            out += this._paddingCharacter || \"\";\n        }\n        return out;\n    };\n    Coder.prototype.maxDecodedLength = function (length) {\n        if (!this._paddingCharacter) {\n            return (length * 6 + 7) / 8 | 0;\n        }\n        return length / 4 * 3 | 0;\n    };\n    Coder.prototype.decodedLength = function (s) {\n        return this.maxDecodedLength(s.length - this._getPaddingLength(s));\n    };\n    Coder.prototype.decode = function (s) {\n        if (s.length === 0) {\n            return new Uint8Array(0);\n        }\n        var paddingLength = this._getPaddingLength(s);\n        var length = s.length - paddingLength;\n        var out = new Uint8Array(this.maxDecodedLength(length));\n        var op = 0;\n        var i = 0;\n        var haveBad = 0;\n        var v0 = 0, v1 = 0, v2 = 0, v3 = 0;\n        for (; i < length - 4; i += 4) {\n            v0 = this._decodeChar(s.charCodeAt(i + 0));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n            haveBad |= v2 & INVALID_BYTE;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (i < length - 1) {\n            v0 = this._decodeChar(s.charCodeAt(i));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n        }\n        if (i < length - 2) {\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            haveBad |= v2 & INVALID_BYTE;\n        }\n        if (i < length - 3) {\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (haveBad !== 0) {\n            throw new Error(\"Base64Coder: incorrect characters for decoding\");\n        }\n        return out;\n    };\n    // Standard encoding have the following encoded/decoded ranges,\n    // which we need to convert between.\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   43  47\n    //\n    // Encode 6 bits in b into a new character.\n    Coder.prototype._encodeByte = function (b) {\n        // Encoding uses constant time operations as follows:\n        //\n        // 1. Define comparison of A with B using (A - B) >>> 8:\n        //          if A > B, then result is positive integer\n        //          if A <= B, then result is 0\n        //\n        // 2. Define selection of C or 0 using bitwise AND: X & C:\n        //          if X == 0, then result is 0\n        //          if X != 0, then result is C\n        //\n        // 3. Start with the smallest comparison (b >= 0), which is always\n        //    true, so set the result to the starting ASCII value (65).\n        //\n        // 4. Continue comparing b to higher ASCII values, and selecting\n        //    zero if comparison isn't true, otherwise selecting a value\n        //    to add to result, which:\n        //\n        //          a) undoes the previous addition\n        //          b) provides new value to add\n        //\n        var result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 43);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 43) - 63 + 47);\n        return String.fromCharCode(result);\n    };\n    // Decode a character code into a byte.\n    // Must return 256 if character is out of alphabet range.\n    Coder.prototype._decodeChar = function (c) {\n        // Decoding works similar to encoding: using the same comparison\n        // function, but now it works on ranges: result is always incremented\n        // by value, but this value becomes zero if the range is not\n        // satisfied.\n        //\n        // Decoding starts with invalid value, 256, which is then\n        // subtracted when the range is satisfied. If none of the ranges\n        // apply, the function returns 256, which is then checked by\n        // the caller to throw error.\n        var result = INVALID_BYTE; // start with invalid character\n        // c == 43 (c > 42 and c < 44)\n        result += (((42 - c) & (c - 44)) >>> 8) & (-INVALID_BYTE + c - 43 + 62);\n        // c == 47 (c > 46 and c < 48)\n        result += (((46 - c) & (c - 48)) >>> 8) & (-INVALID_BYTE + c - 47 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n        return result;\n    };\n    Coder.prototype._getPaddingLength = function (s) {\n        var paddingLength = 0;\n        if (this._paddingCharacter) {\n            for (var i = s.length - 1; i >= 0; i--) {\n                if (s[i] !== this._paddingCharacter) {\n                    break;\n                }\n                paddingLength++;\n            }\n            if (s.length < 4 || paddingLength > 2) {\n                throw new Error(\"Base64Coder: incorrect padding\");\n            }\n        }\n        return paddingLength;\n    };\n    return Coder;\n}());\nexports.Coder = Coder;\nvar stdCoder = new Coder();\nfunction encode(data) {\n    return stdCoder.encode(data);\n}\nexports.encode = encode;\nfunction decode(s) {\n    return stdCoder.decode(s);\n}\nexports.decode = decode;\n/**\n * Implements URL-safe Base64 encoding.\n * (Same as Base64, but '+' is replaced with '-', and '/' with '_').\n *\n * Operates in constant time.\n */\nvar URLSafeCoder = /** @class */ (function (_super) {\n    __extends(URLSafeCoder, _super);\n    function URLSafeCoder() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // URL-safe encoding have the following encoded/decoded ranges:\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   45  95\n    //\n    URLSafeCoder.prototype._encodeByte = function (b) {\n        var result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 45);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 45) - 63 + 95);\n        return String.fromCharCode(result);\n    };\n    URLSafeCoder.prototype._decodeChar = function (c) {\n        var result = INVALID_BYTE;\n        // c == 45 (c > 44 and c < 46)\n        result += (((44 - c) & (c - 46)) >>> 8) & (-INVALID_BYTE + c - 45 + 62);\n        // c == 95 (c > 94 and c < 96)\n        result += (((94 - c) & (c - 96)) >>> 8) & (-INVALID_BYTE + c - 95 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n        return result;\n    };\n    return URLSafeCoder;\n}(Coder));\nexports.URLSafeCoder = URLSafeCoder;\nvar urlSafeCoder = new URLSafeCoder();\nfunction encodeURLSafe(data) {\n    return urlSafeCoder.encode(data);\n}\nexports.encodeURLSafe = encodeURLSafe;\nfunction decodeURLSafe(s) {\n    return urlSafeCoder.decode(s);\n}\nexports.decodeURLSafe = decodeURLSafe;\nexports.encodedLength = function (length) {\n    return stdCoder.encodedLength(length);\n};\nexports.maxDecodedLength = function (length) {\n    return stdCoder.maxDecodedLength(length);\n};\nexports.decodedLength = function (s) {\n    return stdCoder.decodedLength(s);\n};\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Headers = function() {\n  this.clear();\n};\n\nHeaders.prototype.ALLOWED_DUPLICATES = ['set-cookie', 'set-cookie2', 'warning', 'www-authenticate'];\n\nHeaders.prototype.clear = function() {\n  this._sent  = {};\n  this._lines = [];\n};\n\nHeaders.prototype.set = function(name, value) {\n  if (value === undefined) return;\n\n  name = this._strip(name);\n  value = this._strip(value);\n\n  var key = name.toLowerCase();\n  if (!this._sent.hasOwnProperty(key) || this.ALLOWED_DUPLICATES.indexOf(key) >= 0) {\n    this._sent[key] = true;\n    this._lines.push(name + ': ' + value + '\\r\\n');\n  }\n};\n\nHeaders.prototype.toString = function() {\n  return this._lines.join('');\n};\n\nHeaders.prototype._strip = function(string) {\n  return string.toString().replace(/^ */, '').replace(/ *$/, '');\n};\n\nmodule.exports = Headers;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __nested_webpack_require_24116__) {\n\n\"use strict\";\n\n\nvar NodeHTTPParser = __nested_webpack_require_24116__(27).HTTPParser,\n    Buffer         = __nested_webpack_require_24116__(1).Buffer;\n\nvar TYPES = {\n  request:  NodeHTTPParser.REQUEST  || 'request',\n  response: NodeHTTPParser.RESPONSE || 'response'\n};\n\nvar HttpParser = function(type) {\n  this._type     = type;\n  this._parser   = new NodeHTTPParser(TYPES[type]);\n  this._complete = false;\n  this.headers   = {};\n\n  var current = null,\n      self    = this;\n\n  this._parser.onHeaderField = function(b, start, length) {\n    current = b.toString('utf8', start, start + length).toLowerCase();\n  };\n\n  this._parser.onHeaderValue = function(b, start, length) {\n    var value = b.toString('utf8', start, start + length);\n\n    if (self.headers.hasOwnProperty(current))\n      self.headers[current] += ', ' + value;\n    else\n      self.headers[current] = value;\n  };\n\n  this._parser.onHeadersComplete = this._parser[NodeHTTPParser.kOnHeadersComplete] =\n  function(majorVersion, minorVersion, headers, method, pathname, statusCode) {\n    var info = arguments[0];\n\n    if (typeof info === 'object') {\n      method     = info.method;\n      pathname   = info.url;\n      statusCode = info.statusCode;\n      headers    = info.headers;\n    }\n\n    self.method     = (typeof method === 'number') ? HttpParser.METHODS[method] : method;\n    self.statusCode = statusCode;\n    self.url        = pathname;\n\n    if (!headers) return;\n\n    for (var i = 0, n = headers.length, key, value; i < n; i += 2) {\n      key   = headers[i].toLowerCase();\n      value = headers[i+1];\n      if (self.headers.hasOwnProperty(key))\n        self.headers[key] += ', ' + value;\n      else\n        self.headers[key] = value;\n    }\n\n    self._complete = true;\n  };\n};\n\nHttpParser.METHODS = {\n  0:  'DELETE',\n  1:  'GET',\n  2:  'HEAD',\n  3:  'POST',\n  4:  'PUT',\n  5:  'CONNECT',\n  6:  'OPTIONS',\n  7:  'TRACE',\n  8:  'COPY',\n  9:  'LOCK',\n  10: 'MKCOL',\n  11: 'MOVE',\n  12: 'PROPFIND',\n  13: 'PROPPATCH',\n  14: 'SEARCH',\n  15: 'UNLOCK',\n  16: 'BIND',\n  17: 'REBIND',\n  18: 'UNBIND',\n  19: 'ACL',\n  20: 'REPORT',\n  21: 'MKACTIVITY',\n  22: 'CHECKOUT',\n  23: 'MERGE',\n  24: 'M-SEARCH',\n  25: 'NOTIFY',\n  26: 'SUBSCRIBE',\n  27: 'UNSUBSCRIBE',\n  28: 'PATCH',\n  29: 'PURGE',\n  30: 'MKCALENDAR',\n  31: 'LINK',\n  32: 'UNLINK'\n};\n\nvar VERSION = process.version\n  ? process.version.match(/[0-9]+/g).map(function(n) { return parseInt(n, 10) })\n  : [];\n\nif (VERSION[0] === 0 && VERSION[1] === 12) {\n  HttpParser.METHODS[16] = 'REPORT';\n  HttpParser.METHODS[17] = 'MKACTIVITY';\n  HttpParser.METHODS[18] = 'CHECKOUT';\n  HttpParser.METHODS[19] = 'MERGE';\n  HttpParser.METHODS[20] = 'M-SEARCH';\n  HttpParser.METHODS[21] = 'NOTIFY';\n  HttpParser.METHODS[22] = 'SUBSCRIBE';\n  HttpParser.METHODS[23] = 'UNSUBSCRIBE';\n  HttpParser.METHODS[24] = 'PATCH';\n  HttpParser.METHODS[25] = 'PURGE';\n}\n\nHttpParser.prototype.isComplete = function() {\n  return this._complete;\n};\n\nHttpParser.prototype.parse = function(chunk) {\n  var consumed = this._parser.execute(chunk, 0, chunk.length);\n\n  if (typeof consumed !== 'number') {\n    this.error     = consumed;\n    this._complete = true;\n    return;\n  }\n\n  if (this._complete)\n    this.body = (consumed < chunk.length)\n              ? chunk.slice(consumed)\n              : Buffer.alloc(0);\n};\n\nmodule.exports = HttpParser;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __nested_webpack_require_27481__) {\n\n\"use strict\";\n\n\nvar Stream      = __nested_webpack_require_27481__(5).Stream,\n    util        = __nested_webpack_require_27481__(0),\n    driver      = __nested_webpack_require_27481__(4),\n    EventTarget = __nested_webpack_require_27481__(16),\n    Event       = __nested_webpack_require_27481__(7);\n\nvar API = function(options) {\n  options = options || {};\n  driver.validateOptions(options, ['headers', 'extensions', 'maxLength', 'ping', 'proxy', 'tls', 'ca']);\n\n  this.readable = this.writable = true;\n\n  var headers = options.headers;\n  if (headers) {\n    for (var name in headers) this._driver.setHeader(name, headers[name]);\n  }\n\n  var extensions = options.extensions;\n  if (extensions) {\n    [].concat(extensions).forEach(this._driver.addExtension, this._driver);\n  }\n\n  this._ping          = options.ping;\n  this._pingId        = 0;\n  this.readyState     = API.CONNECTING;\n  this.bufferedAmount = 0;\n  this.protocol       = '';\n  this.url            = this._driver.url;\n  this.version        = this._driver.version;\n\n  var self = this;\n\n  this._driver.on('open',    function(e) { self._open() });\n  this._driver.on('message', function(e) { self._receiveMessage(e.data) });\n  this._driver.on('close',   function(e) { self._beginClose(e.reason, e.code) });\n\n  this._driver.on('error', function(error) {\n    self._emitError(error.message);\n  });\n  this.on('error', function() {});\n\n  this._driver.messages.on('drain', function() {\n    self.emit('drain');\n  });\n\n  if (this._ping)\n    this._pingTimer = setInterval(function() {\n      self._pingId += 1;\n      self.ping(self._pingId.toString());\n    }, this._ping * 1000);\n\n  this._configureStream();\n\n  if (!this._proxy) {\n    this._stream.pipe(this._driver.io);\n    this._driver.io.pipe(this._stream);\n  }\n};\nutil.inherits(API, Stream);\n\nAPI.CONNECTING = 0;\nAPI.OPEN       = 1;\nAPI.CLOSING    = 2;\nAPI.CLOSED     = 3;\n\nAPI.CLOSE_TIMEOUT = 30000;\n\nvar instance = {\n  write: function(data) {\n    return this.send(data);\n  },\n\n  end: function(data) {\n    if (data !== undefined) this.send(data);\n    this.close();\n  },\n\n  pause: function() {\n    return this._driver.messages.pause();\n  },\n\n  resume: function() {\n    return this._driver.messages.resume();\n  },\n\n  send: function(data) {\n    if (this.readyState > API.OPEN) return false;\n    if (!(data instanceof Buffer)) data = String(data);\n    return this._driver.messages.write(data);\n  },\n\n  ping: function(message, callback) {\n    if (this.readyState > API.OPEN) return false;\n    return this._driver.ping(message, callback);\n  },\n\n  close: function(code, reason) {\n    if (code === undefined) code = 1000;\n    if (reason === undefined) reason = '';\n\n    if (code !== 1000 && (code < 3000 || code > 4999))\n      throw new Error(\"Failed to execute 'close' on WebSocket: \" +\n                      \"The code must be either 1000, or between 3000 and 4999. \" +\n                      code + \" is neither.\");\n\n    if (this.readyState !== API.CLOSED) this.readyState = API.CLOSING;\n    var self = this;\n\n    this._closeTimer = setTimeout(function() {\n      self._beginClose('', 1006);\n    }, API.CLOSE_TIMEOUT);\n\n    this._driver.close(reason, code);\n  },\n\n  _configureStream: function() {\n    var self = this;\n\n    this._stream.setTimeout(0);\n    this._stream.setNoDelay(true);\n\n    ['close', 'end'].forEach(function(event) {\n      this._stream.on(event, function() { self._finalizeClose() });\n    }, this);\n\n    this._stream.on('error', function(error) {\n      self._emitError('Network error: ' + self.url + ': ' + error.message);\n      self._finalizeClose();\n    });\n  },\n\n  _open: function() {\n    if (this.readyState !== API.CONNECTING) return;\n\n    this.readyState = API.OPEN;\n    this.protocol = this._driver.protocol || '';\n\n    var event = new Event('open');\n    event.initEvent('open', false, false);\n    this.dispatchEvent(event);\n  },\n\n  _receiveMessage: function(data) {\n    if (this.readyState > API.OPEN) return false;\n\n    if (this.readable) this.emit('data', data);\n\n    var event = new Event('message', {data: data});\n    event.initEvent('message', false, false);\n    this.dispatchEvent(event);\n  },\n\n  _emitError: function(message) {\n    if (this.readyState >= API.CLOSING) return;\n\n    var event = new Event('error', {message: message});\n    event.initEvent('error', false, false);\n    this.dispatchEvent(event);\n  },\n\n  _beginClose: function(reason, code) {\n    if (this.readyState === API.CLOSED) return;\n    this.readyState = API.CLOSING;\n    this._closeParams = [reason, code];\n\n    if (this._stream) {\n      this._stream.destroy();\n      if (!this._stream.readable) this._finalizeClose();\n    }\n  },\n\n  _finalizeClose: function() {\n    if (this.readyState === API.CLOSED) return;\n    this.readyState = API.CLOSED;\n\n    if (this._closeTimer) clearTimeout(this._closeTimer);\n    if (this._pingTimer) clearInterval(this._pingTimer);\n    if (this._stream) this._stream.end();\n\n    if (this.readable) this.emit('end');\n    this.readable = this.writable = false;\n\n    var reason = this._closeParams ? this._closeParams[0] : '',\n        code   = this._closeParams ? this._closeParams[1] : 1006;\n\n    var event = new Event('close', {code: code, reason: reason});\n    event.initEvent('close', false, false);\n    this.dispatchEvent(event);\n  }\n};\n\nfor (var method in instance) API.prototype[method] = instance[method];\nfor (var key in EventTarget) API.prototype[key] = EventTarget[key];\n\nmodule.exports = API;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __nested_webpack_require_32917__) {\n\n\"use strict\";\n\n\nvar Buffer     = __nested_webpack_require_32917__(1).Buffer,\n    crypto     = __nested_webpack_require_32917__(3),\n    util       = __nested_webpack_require_32917__(0),\n    Extensions = __nested_webpack_require_32917__(29),\n    Base       = __nested_webpack_require_32917__(2),\n    Frame      = __nested_webpack_require_32917__(34),\n    Message    = __nested_webpack_require_32917__(35);\n\nvar Hybi = function(request, url, options) {\n  Base.apply(this, arguments);\n\n  this._extensions     = new Extensions();\n  this._stage          = 0;\n  this._masking        = this._options.masking;\n  this._protocols      = this._options.protocols || [];\n  this._requireMasking = this._options.requireMasking;\n  this._pingCallbacks  = {};\n\n  if (typeof this._protocols === 'string')\n    this._protocols = this._protocols.split(/ *, */);\n\n  if (!this._request) return;\n\n  var protos    = this._request.headers['sec-websocket-protocol'],\n      supported = this._protocols;\n\n  if (protos !== undefined) {\n    if (typeof protos === 'string') protos = protos.split(/ *, */);\n    this.protocol = protos.filter(function(p) { return supported.indexOf(p) >= 0 })[0];\n  }\n\n  this.version = 'hybi-' + Hybi.VERSION;\n};\nutil.inherits(Hybi, Base);\n\nHybi.VERSION = '13';\n\nHybi.mask = function(payload, mask, offset) {\n  if (!mask || mask.length === 0) return payload;\n  offset = offset || 0;\n\n  for (var i = 0, n = payload.length - offset; i < n; i++) {\n    payload[offset + i] = payload[offset + i] ^ mask[i % 4];\n  }\n  return payload;\n};\n\nHybi.generateAccept = function(key) {\n  var sha1 = crypto.createHash('sha1');\n  sha1.update(key + Hybi.GUID);\n  return sha1.digest('base64');\n};\n\nHybi.GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\n\nvar instance = {\n  FIN:    0x80,\n  MASK:   0x80,\n  RSV1:   0x40,\n  RSV2:   0x20,\n  RSV3:   0x10,\n  OPCODE: 0x0F,\n  LENGTH: 0x7F,\n\n  OPCODES: {\n    continuation: 0,\n    text:         1,\n    binary:       2,\n    close:        8,\n    ping:         9,\n    pong:         10\n  },\n\n  OPCODE_CODES:    [0, 1, 2, 8, 9, 10],\n  MESSAGE_OPCODES: [0, 1, 2],\n  OPENING_OPCODES: [1, 2],\n\n  ERRORS: {\n    normal_closure:       1000,\n    going_away:           1001,\n    protocol_error:       1002,\n    unacceptable:         1003,\n    encoding_error:       1007,\n    policy_violation:     1008,\n    too_large:            1009,\n    extension_error:      1010,\n    unexpected_condition: 1011\n  },\n\n  ERROR_CODES:        [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011],\n  DEFAULT_ERROR_CODE: 1000,\n  MIN_RESERVED_ERROR: 3000,\n  MAX_RESERVED_ERROR: 4999,\n\n  // http://www.w3.org/International/questions/qa-forms-utf-8.en.php\n  UTF8_MATCH: /^([\\x00-\\x7F]|[\\xC2-\\xDF][\\x80-\\xBF]|\\xE0[\\xA0-\\xBF][\\x80-\\xBF]|[\\xE1-\\xEC\\xEE\\xEF][\\x80-\\xBF]{2}|\\xED[\\x80-\\x9F][\\x80-\\xBF]|\\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}|[\\xF1-\\xF3][\\x80-\\xBF]{3}|\\xF4[\\x80-\\x8F][\\x80-\\xBF]{2})*$/,\n\n  addExtension: function(extension) {\n    this._extensions.add(extension);\n    return true;\n  },\n\n  parse: function(chunk) {\n    this._reader.put(chunk);\n    var buffer = true;\n    while (buffer) {\n      switch (this._stage) {\n        case 0:\n          buffer = this._reader.read(1);\n          if (buffer) this._parseOpcode(buffer[0]);\n          break;\n\n        case 1:\n          buffer = this._reader.read(1);\n          if (buffer) this._parseLength(buffer[0]);\n          break;\n\n        case 2:\n          buffer = this._reader.read(this._frame.lengthBytes);\n          if (buffer) this._parseExtendedLength(buffer);\n          break;\n\n        case 3:\n          buffer = this._reader.read(4);\n          if (buffer) {\n            this._stage = 4;\n            this._frame.maskingKey = buffer;\n          }\n          break;\n\n        case 4:\n          buffer = this._reader.read(this._frame.length);\n          if (buffer) {\n            this._stage = 0;\n            this._emitFrame(buffer);\n          }\n          break;\n\n        default:\n          buffer = null;\n      }\n    }\n  },\n\n  text: function(message) {\n    if (this.readyState > 1) return false;\n    return this.frame(message, 'text');\n  },\n\n  binary: function(message) {\n    if (this.readyState > 1) return false;\n    return this.frame(message, 'binary');\n  },\n\n  ping: function(message, callback) {\n    if (this.readyState > 1) return false;\n    message = message || '';\n    if (callback) this._pingCallbacks[message] = callback;\n    return this.frame(message, 'ping');\n  },\n\n  pong: function(message) {\n      if (this.readyState > 1) return false;\n      message = message ||'';\n      return this.frame(message, 'pong');\n  },\n\n  close: function(reason, code) {\n    reason = reason || '';\n    code   = code   || this.ERRORS.normal_closure;\n\n    if (this.readyState <= 0) {\n      this.readyState = 3;\n      this.emit('close', new Base.CloseEvent(code, reason));\n      return true;\n    } else if (this.readyState === 1) {\n      this.readyState = 2;\n      this._extensions.close(function() { this.frame(reason, 'close', code) }, this);\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  frame: function(buffer, type, code) {\n    if (this.readyState <= 0) return this._queue([buffer, type, code]);\n    if (this.readyState > 2) return false;\n\n    if (buffer instanceof Array)    buffer = Buffer.from(buffer);\n    if (typeof buffer === 'number') buffer = buffer.toString();\n\n    var message = new Message(),\n        isText  = (typeof buffer === 'string'),\n        payload, copy;\n\n    message.rsv1   = message.rsv2 = message.rsv3 = false;\n    message.opcode = this.OPCODES[type || (isText ? 'text' : 'binary')];\n\n    payload = isText ? Buffer.from(buffer, 'utf8') : buffer;\n\n    if (code) {\n      copy = payload;\n      payload = Buffer.allocUnsafe(2 + copy.length);\n      payload.writeUInt16BE(code, 0);\n      copy.copy(payload, 2);\n    }\n    message.data = payload;\n\n    var onMessageReady = function(message) {\n      var frame = new Frame();\n\n      frame.final   = true;\n      frame.rsv1    = message.rsv1;\n      frame.rsv2    = message.rsv2;\n      frame.rsv3    = message.rsv3;\n      frame.opcode  = message.opcode;\n      frame.masked  = !!this._masking;\n      frame.length  = message.data.length;\n      frame.payload = message.data;\n\n      if (frame.masked) frame.maskingKey = crypto.randomBytes(4);\n\n      this._sendFrame(frame);\n    };\n\n    if (this.MESSAGE_OPCODES.indexOf(message.opcode) >= 0)\n      this._extensions.processOutgoingMessage(message, function(error, message) {\n        if (error) return this._fail('extension_error', error.message);\n        onMessageReady.call(this, message);\n      }, this);\n    else\n      onMessageReady.call(this, message);\n\n    return true;\n  },\n\n  _sendFrame: function(frame) {\n    var length = frame.length,\n        header = (length <= 125) ? 2 : (length <= 65535 ? 4 : 10),\n        offset = header + (frame.masked ? 4 : 0),\n        buffer = Buffer.allocUnsafe(offset + length),\n        masked = frame.masked ? this.MASK : 0;\n\n    buffer[0] = (frame.final ? this.FIN : 0) |\n                (frame.rsv1 ? this.RSV1 : 0) |\n                (frame.rsv2 ? this.RSV2 : 0) |\n                (frame.rsv3 ? this.RSV3 : 0) |\n                frame.opcode;\n\n    if (length <= 125) {\n      buffer[1] = masked | length;\n    } else if (length <= 65535) {\n      buffer[1] = masked | 126;\n      buffer.writeUInt16BE(length, 2);\n    } else {\n      buffer[1] = masked | 127;\n      buffer.writeUInt32BE(Math.floor(length / 0x100000000), 2);\n      buffer.writeUInt32BE(length % 0x100000000, 6);\n    }\n\n    frame.payload.copy(buffer, offset);\n\n    if (frame.masked) {\n      frame.maskingKey.copy(buffer, header);\n      Hybi.mask(buffer, frame.maskingKey, offset);\n    }\n\n    this._write(buffer);\n  },\n\n  _handshakeResponse: function() {\n    var secKey  = this._request.headers['sec-websocket-key'],\n        version = this._request.headers['sec-websocket-version'];\n\n    if (version !== Hybi.VERSION)\n      throw new Error('Unsupported WebSocket version: ' + version);\n\n    if (typeof secKey !== 'string')\n      throw new Error('Missing handshake request header: Sec-WebSocket-Key');\n\n    this._headers.set('Upgrade', 'websocket');\n    this._headers.set('Connection', 'Upgrade');\n    this._headers.set('Sec-WebSocket-Accept', Hybi.generateAccept(secKey));\n\n    if (this.protocol) this._headers.set('Sec-WebSocket-Protocol', this.protocol);\n\n    var extensions = this._extensions.generateResponse(this._request.headers['sec-websocket-extensions']);\n    if (extensions) this._headers.set('Sec-WebSocket-Extensions', extensions);\n\n    var start   = 'HTTP/1.1 101 Switching Protocols',\n        headers = [start, this._headers.toString(), ''];\n\n    return Buffer.from(headers.join('\\r\\n'), 'utf8');\n  },\n\n  _shutdown: function(code, reason, error) {\n    delete this._frame;\n    delete this._message;\n    this._stage = 5;\n\n    var sendCloseFrame = (this.readyState === 1);\n    this.readyState = 2;\n\n    this._extensions.close(function() {\n      if (sendCloseFrame) this.frame(reason, 'close', code);\n      this.readyState = 3;\n      if (error) this.emit('error', new Error(reason));\n      this.emit('close', new Base.CloseEvent(code, reason));\n    }, this);\n  },\n\n  _fail: function(type, message) {\n    if (this.readyState > 1) return;\n    this._shutdown(this.ERRORS[type], message, true);\n  },\n\n  _parseOpcode: function(octet) {\n    var rsvs = [this.RSV1, this.RSV2, this.RSV3].map(function(rsv) {\n      return (octet & rsv) === rsv;\n    });\n\n    var frame = this._frame = new Frame();\n\n    frame.final  = (octet & this.FIN) === this.FIN;\n    frame.rsv1   = rsvs[0];\n    frame.rsv2   = rsvs[1];\n    frame.rsv3   = rsvs[2];\n    frame.opcode = (octet & this.OPCODE);\n\n    this._stage = 1;\n\n    if (!this._extensions.validFrameRsv(frame))\n      return this._fail('protocol_error',\n          'One or more reserved bits are on: reserved1 = ' + (frame.rsv1 ? 1 : 0) +\n          ', reserved2 = ' + (frame.rsv2 ? 1 : 0) +\n          ', reserved3 = ' + (frame.rsv3 ? 1 : 0));\n\n    if (this.OPCODE_CODES.indexOf(frame.opcode) < 0)\n      return this._fail('protocol_error', 'Unrecognized frame opcode: ' + frame.opcode);\n\n    if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && !frame.final)\n      return this._fail('protocol_error', 'Received fragmented control frame: opcode = ' + frame.opcode);\n\n    if (this._message && this.OPENING_OPCODES.indexOf(frame.opcode) >= 0)\n      return this._fail('protocol_error', 'Received new data frame but previous continuous frame is unfinished');\n  },\n\n  _parseLength: function(octet) {\n    var frame = this._frame;\n    frame.masked = (octet & this.MASK) === this.MASK;\n    frame.length = (octet & this.LENGTH);\n\n    if (frame.length >= 0 && frame.length <= 125) {\n      this._stage = frame.masked ? 3 : 4;\n      if (!this._checkFrameLength()) return;\n    } else {\n      this._stage = 2;\n      frame.lengthBytes = (frame.length === 126 ? 2 : 8);\n    }\n\n    if (this._requireMasking && !frame.masked)\n      return this._fail('unacceptable', 'Received unmasked frame but masking is required');\n  },\n\n  _parseExtendedLength: function(buffer) {\n    var frame = this._frame;\n    frame.length = this._readUInt(buffer);\n\n    this._stage = frame.masked ? 3 : 4;\n\n    if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && frame.length > 125)\n      return this._fail('protocol_error', 'Received control frame having too long payload: ' + frame.length);\n\n    if (!this._checkFrameLength()) return;\n  },\n\n  _checkFrameLength: function() {\n    var length = this._message ? this._message.length : 0;\n\n    if (length + this._frame.length > this._maxLength) {\n      this._fail('too_large', 'WebSocket frame length too large');\n      return false;\n    } else {\n      return true;\n    }\n  },\n\n  _emitFrame: function(buffer) {\n    var frame   = this._frame,\n        payload = frame.payload = Hybi.mask(buffer, frame.maskingKey),\n        opcode  = frame.opcode,\n        message,\n        code, reason,\n        callbacks, callback;\n\n    delete this._frame;\n\n    if (opcode === this.OPCODES.continuation) {\n      if (!this._message) return this._fail('protocol_error', 'Received unexpected continuation frame');\n      this._message.pushFrame(frame);\n    }\n\n    if (opcode === this.OPCODES.text || opcode === this.OPCODES.binary) {\n      this._message = new Message();\n      this._message.pushFrame(frame);\n    }\n\n    if (frame.final && this.MESSAGE_OPCODES.indexOf(opcode) >= 0)\n      return this._emitMessage(this._message);\n\n    if (opcode === this.OPCODES.close) {\n      code   = (payload.length >= 2) ? payload.readUInt16BE(0) : null;\n      reason = (payload.length > 2) ? this._encode(payload.slice(2)) : null;\n\n      if (!(payload.length === 0) &&\n          !(code !== null && code >= this.MIN_RESERVED_ERROR && code <= this.MAX_RESERVED_ERROR) &&\n          this.ERROR_CODES.indexOf(code) < 0)\n        code = this.ERRORS.protocol_error;\n\n      if (payload.length > 125 || (payload.length > 2 && !reason))\n        code = this.ERRORS.protocol_error;\n\n      this._shutdown(code || this.DEFAULT_ERROR_CODE, reason || '');\n    }\n\n    if (opcode === this.OPCODES.ping) {\n      this.frame(payload, 'pong');\n      this.emit('ping', new Base.PingEvent(payload.toString()))\n    }\n\n    if (opcode === this.OPCODES.pong) {\n      callbacks = this._pingCallbacks;\n      message   = this._encode(payload);\n      callback  = callbacks[message];\n\n      delete callbacks[message];\n      if (callback) callback()\n\n      this.emit('pong', new Base.PongEvent(payload.toString()))\n    }\n  },\n\n  _emitMessage: function(message) {\n    var message = this._message;\n    message.read();\n\n    delete this._message;\n\n    this._extensions.processIncomingMessage(message, function(error, message) {\n      if (error) return this._fail('extension_error', error.message);\n\n      var payload = message.data;\n      if (message.opcode === this.OPCODES.text) payload = this._encode(payload);\n\n      if (payload === null)\n        return this._fail('encoding_error', 'Could not decode a text frame as UTF-8');\n      else\n        this.emit('message', new Base.MessageEvent(payload));\n    }, this);\n  },\n\n  _encode: function(buffer) {\n    try {\n      var string = buffer.toString('binary', 0, buffer.length);\n      if (!this.UTF8_MATCH.test(string)) return null;\n    } catch (e) {}\n    return buffer.toString('utf8', 0, buffer.length);\n  },\n\n  _readUInt: function(buffer) {\n    if (buffer.length === 2) return buffer.readUInt16BE(0);\n\n    return buffer.readUInt32BE(0) * 0x100000000 +\n           buffer.readUInt32BE(4);\n  }\n};\n\nfor (var key in instance)\n  Hybi.prototype[key] = instance[key];\n\nmodule.exports = Hybi;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar RingBuffer = function(bufferSize) {\n  this._bufferSize = bufferSize;\n  this.clear();\n};\n\nRingBuffer.prototype.clear = function() {\n  this._buffer     = new Array(this._bufferSize);\n  this._ringOffset = 0;\n  this._ringSize   = this._bufferSize;\n  this._head       = 0;\n  this._tail       = 0;\n  this.length      = 0;\n};\n\nRingBuffer.prototype.push = function(value) {\n  var expandBuffer = false,\n      expandRing   = false;\n\n  if (this._ringSize < this._bufferSize) {\n    expandBuffer = (this._tail === 0);\n  } else if (this._ringOffset === this._ringSize) {\n    expandBuffer = true;\n    expandRing   = (this._tail === 0);\n  }\n\n  if (expandBuffer) {\n    this._tail       = this._bufferSize;\n    this._buffer     = this._buffer.concat(new Array(this._bufferSize));\n    this._bufferSize = this._buffer.length;\n\n    if (expandRing)\n      this._ringSize = this._bufferSize;\n  }\n\n  this._buffer[this._tail] = value;\n  this.length += 1;\n  if (this._tail < this._ringSize) this._ringOffset += 1;\n  this._tail = (this._tail + 1) % this._bufferSize;\n};\n\nRingBuffer.prototype.peek = function() {\n  if (this.length === 0) return void 0;\n  return this._buffer[this._head];\n};\n\nRingBuffer.prototype.shift = function() {\n  if (this.length === 0) return void 0;\n\n  var value = this._buffer[this._head];\n  this._buffer[this._head] = void 0;\n  this.length -= 1;\n  this._ringOffset -= 1;\n\n  if (this._ringOffset === 0 && this.length > 0) {\n    this._head       = this._ringSize;\n    this._ringOffset = this.length;\n    this._ringSize   = this._bufferSize;\n  } else {\n    this._head = (this._head + 1) % this._ringSize;\n  }\n  return value;\n};\n\nmodule.exports = RingBuffer;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __nested_webpack_require_49189__) {\n\n\"use strict\";\n\n\nvar RingBuffer = __nested_webpack_require_49189__(13);\n\nvar Pledge = function() {\n  this._complete  = false;\n  this._callbacks = new RingBuffer(Pledge.QUEUE_SIZE);\n};\n\nPledge.QUEUE_SIZE = 4;\n\nPledge.all = function(list) {\n  var pledge  = new Pledge(),\n      pending = list.length,\n      n       = pending;\n\n  if (pending === 0) pledge.done();\n\n  while (n--) list[n].then(function() {\n    pending -= 1;\n    if (pending === 0) pledge.done();\n  });\n  return pledge;\n};\n\nPledge.prototype.then = function(callback) {\n  if (this._complete) callback();\n  else this._callbacks.push(callback);\n};\n\nPledge.prototype.done = function() {\n  this._complete = true;\n  var callbacks = this._callbacks, callback;\n  while (callback = callbacks.shift()) callback();\n};\n\nmodule.exports = Pledge;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_50046__) {\n\n\"use strict\";\n\n\nvar Buffer = __nested_webpack_require_50046__(1).Buffer,\n    Base   = __nested_webpack_require_50046__(2),\n    util   = __nested_webpack_require_50046__(0);\n\nvar Draft75 = function(request, url, options) {\n  Base.apply(this, arguments);\n  this._stage  = 0;\n  this.version = 'hixie-75';\n\n  this._headers.set('Upgrade', 'WebSocket');\n  this._headers.set('Connection', 'Upgrade');\n  this._headers.set('WebSocket-Origin', this._request.headers.origin);\n  this._headers.set('WebSocket-Location', this.url);\n};\nutil.inherits(Draft75, Base);\n\nvar instance = {\n  close: function() {\n    if (this.readyState === 3) return false;\n    this.readyState = 3;\n    this.emit('close', new Base.CloseEvent(null, null));\n    return true;\n  },\n\n  parse: function(chunk) {\n    if (this.readyState > 1) return;\n\n    this._reader.put(chunk);\n\n    this._reader.eachByte(function(octet) {\n      var message;\n\n      switch (this._stage) {\n        case -1:\n          this._body.push(octet);\n          this._sendHandshakeBody();\n          break;\n\n        case 0:\n          this._parseLeadingByte(octet);\n          break;\n\n        case 1:\n          this._length = (octet & 0x7F) + 128 * this._length;\n\n          if (this._closing && this._length === 0) {\n            return this.close();\n          }\n          else if ((octet & 0x80) !== 0x80) {\n            if (this._length === 0) {\n              this._stage = 0;\n            }\n            else {\n              this._skipped = 0;\n              this._stage   = 2;\n            }\n          }\n          break;\n\n        case 2:\n          if (octet === 0xFF) {\n            this._stage = 0;\n            message = Buffer.from(this._buffer).toString('utf8', 0, this._buffer.length);\n            this.emit('message', new Base.MessageEvent(message));\n          }\n          else {\n            if (this._length) {\n              this._skipped += 1;\n              if (this._skipped === this._length)\n                this._stage = 0;\n            } else {\n              this._buffer.push(octet);\n              if (this._buffer.length > this._maxLength) return this.close();\n            }\n          }\n          break;\n      }\n    }, this);\n  },\n\n  frame: function(buffer) {\n    if (this.readyState === 0) return this._queue([buffer]);\n    if (this.readyState > 1) return false;\n\n    if (typeof buffer !== 'string') buffer = buffer.toString();\n\n    var length = Buffer.byteLength(buffer),\n        frame  = Buffer.allocUnsafe(length + 2);\n\n    frame[0] = 0x00;\n    frame.write(buffer, 1);\n    frame[frame.length - 1] = 0xFF;\n\n    this._write(frame);\n    return true;\n  },\n\n  _handshakeResponse: function() {\n    var start   = 'HTTP/1.1 101 Web Socket Protocol Handshake',\n        headers = [start, this._headers.toString(), ''];\n\n    return Buffer.from(headers.join('\\r\\n'), 'utf8');\n  },\n\n  _parseLeadingByte: function(octet) {\n    if ((octet & 0x80) === 0x80) {\n      this._length = 0;\n      this._stage  = 1;\n    } else {\n      delete this._length;\n      delete this._skipped;\n      this._buffer = [];\n      this._stage  = 2;\n    }\n  }\n};\n\nfor (var key in instance)\n  Draft75.prototype[key] = instance[key];\n\nmodule.exports = Draft75;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __nested_webpack_require_53241__) {\n\n\"use strict\";\n\n\nvar Event = __nested_webpack_require_53241__(7);\n\nvar EventTarget = {\n  onopen:     null,\n  onmessage:  null,\n  onerror:    null,\n  onclose:    null,\n\n  addEventListener: function(eventType, listener, useCapture) {\n    this.on(eventType, listener);\n  },\n\n  removeEventListener: function(eventType, listener, useCapture) {\n    this.removeListener(eventType, listener);\n  },\n\n  dispatchEvent: function(event) {\n    event.target = event.currentTarget = this;\n    event.eventPhase = Event.AT_TARGET;\n\n    if (this['on' + event.type])\n      this['on' + event.type](event);\n\n    this.emit(event.type, event);\n  }\n};\n\nmodule.exports = EventTarget;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package utf8 implements UTF-8 encoding and decoding.\n */\nvar INVALID_UTF16 = \"utf8: invalid string\";\nvar INVALID_UTF8 = \"utf8: invalid source encoding\";\n/**\n * Encodes the given string into UTF-8 byte array.\n * Throws if the source string has invalid UTF-16 encoding.\n */\nfunction encode(s) {\n    // Calculate result length and allocate output array.\n    // encodedLength() also validates string and throws errors,\n    // so we don't need repeat validation here.\n    var arr = new Uint8Array(encodedLength(s));\n    var pos = 0;\n    for (var i = 0; i < s.length; i++) {\n        var c = s.charCodeAt(i);\n        if (c < 0x80) {\n            arr[pos++] = c;\n        }\n        else if (c < 0x800) {\n            arr[pos++] = 0xc0 | c >> 6;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n        else if (c < 0xd800) {\n            arr[pos++] = 0xe0 | c >> 12;\n            arr[pos++] = 0x80 | (c >> 6) & 0x3f;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n        else {\n            i++; // get one more character\n            c = (c & 0x3ff) << 10;\n            c |= s.charCodeAt(i) & 0x3ff;\n            c += 0x10000;\n            arr[pos++] = 0xf0 | c >> 18;\n            arr[pos++] = 0x80 | (c >> 12) & 0x3f;\n            arr[pos++] = 0x80 | (c >> 6) & 0x3f;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n    }\n    return arr;\n}\nexports.encode = encode;\n/**\n * Returns the number of bytes required to encode the given string into UTF-8.\n * Throws if the source string has invalid UTF-16 encoding.\n */\nfunction encodedLength(s) {\n    var result = 0;\n    for (var i = 0; i < s.length; i++) {\n        var c = s.charCodeAt(i);\n        if (c < 0x80) {\n            result += 1;\n        }\n        else if (c < 0x800) {\n            result += 2;\n        }\n        else if (c < 0xd800) {\n            result += 3;\n        }\n        else if (c <= 0xdfff) {\n            if (i >= s.length - 1) {\n                throw new Error(INVALID_UTF16);\n            }\n            i++; // \"eat\" next character\n            result += 4;\n        }\n        else {\n            throw new Error(INVALID_UTF16);\n        }\n    }\n    return result;\n}\nexports.encodedLength = encodedLength;\n/**\n * Decodes the given byte array from UTF-8 into a string.\n * Throws if encoding is invalid.\n */\nfunction decode(arr) {\n    var chars = [];\n    for (var i = 0; i < arr.length; i++) {\n        var b = arr[i];\n        if (b & 0x80) {\n            var min = void 0;\n            if (b < 0xe0) {\n                // Need 1 more byte.\n                if (i >= arr.length) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x1f) << 6 | (n1 & 0x3f);\n                min = 0x80;\n            }\n            else if (b < 0xf0) {\n                // Need 2 more bytes.\n                if (i >= arr.length - 1) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                var n2 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | (n2 & 0x3f);\n                min = 0x800;\n            }\n            else if (b < 0xf8) {\n                // Need 3 more bytes.\n                if (i >= arr.length - 2) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                var n2 = arr[++i];\n                var n3 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | (n3 & 0x3f);\n                min = 0x10000;\n            }\n            else {\n                throw new Error(INVALID_UTF8);\n            }\n            if (b < min || (b >= 0xd800 && b <= 0xdfff)) {\n                throw new Error(INVALID_UTF8);\n            }\n            if (b >= 0x10000) {\n                // Surrogate pair.\n                if (b > 0x10ffff) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b -= 0x10000;\n                chars.push(String.fromCharCode(0xd800 | (b >> 10)));\n                b = 0xdc00 | (b & 0x3ff);\n            }\n        }\n        chars.push(String.fromCharCode(b));\n    }\n    return chars.join(\"\");\n}\nexports.decode = decode;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __nested_webpack_require_58781__) {\n\n\"use strict\";\n// API references:\n//\n// * https://html.spec.whatwg.org/multipage/comms.html#network\n// * https://dom.spec.whatwg.org/#interface-eventtarget\n// * https://dom.spec.whatwg.org/#interface-event\n\n\n\nvar util   = __nested_webpack_require_58781__(0),\n    driver = __nested_webpack_require_58781__(4),\n    API    = __nested_webpack_require_58781__(11);\n\nvar WebSocket = function(request, socket, body, protocols, options) {\n  options = options || {};\n\n  this._stream = socket;\n  this._driver = driver.http(request, {maxLength: options.maxLength, protocols: protocols});\n\n  var self = this;\n  if (!this._stream || !this._stream.writable) return;\n  if (!this._stream.readable) return this._stream.end();\n\n  var catchup = function() { self._stream.removeListener('data', catchup) };\n  this._stream.on('data', catchup);\n\n  API.call(this, options);\n\n  process.nextTick(function() {\n    self._driver.start();\n    self._driver.io.write(body);\n  });\n};\nutil.inherits(WebSocket, API);\n\nWebSocket.isWebSocket = function(request) {\n  return driver.isWebSocket(request);\n};\n\nWebSocket.validateOptions = function(options, validKeys) {\n  driver.validateOptions(options, validKeys);\n};\n\nWebSocket.WebSocket   = WebSocket;\nWebSocket.Client      = __nested_webpack_require_58781__(39);\nWebSocket.EventSource = __nested_webpack_require_58781__(42);\n\nmodule.exports        = WebSocket;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_60167__) {\n\n/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\n\nvar Url = __nested_webpack_require_60167__(6);\nvar spawn = __nested_webpack_require_60167__(43).spawn;\nvar fs = __nested_webpack_require_60167__(44);\n\nexports.XMLHttpRequest = function() {\n  \"use strict\";\n\n  /**\n   * Private variables\n   */\n  var self = this;\n  var http = __nested_webpack_require_60167__(45);\n  var https = __nested_webpack_require_60167__(46);\n\n  // Holds http.js objects\n  var request;\n  var response;\n\n  // Request settings\n  var settings = {};\n\n  // Disable header blacklist.\n  // Not part of XHR specs.\n  var disableHeaderCheck = false;\n\n  // Set some default headers\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\",\n  };\n\n  var headers = {};\n  var headersCase = {};\n\n  // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n  var forbiddenRequestHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"content-transfer-encoding\",\n    \"cookie\",\n    \"cookie2\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"via\"\n  ];\n\n  // These request methods are not allowed\n  var forbiddenRequestMethods = [\n    \"TRACE\",\n    \"TRACK\",\n    \"CONNECT\"\n  ];\n\n  // Send flag\n  var sendFlag = false;\n  // Error flag, used when errors occur or abort is called\n  var errorFlag = false;\n\n  // Event listeners\n  var listeners = {};\n\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n\n  /**\n   * Public vars\n   */\n\n  // Current state\n  this.readyState = this.UNSENT;\n\n  // default ready state change handler in case one is not set or is set late\n  this.onreadystatechange = null;\n\n  // Result & response\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n  \n  // Whether cross-site Access-Control requests should be made using\n  // credentials such as cookies or authorization headers\n  this.withCredentials = false;\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpHeader = function(header) {\n    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);\n  };\n\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpMethod = function(method) {\n    return (method && forbiddenRequestMethods.indexOf(method) === -1);\n  };\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n  this.open = function(method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n\n    // Check for valid request method\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error(\"SecurityError: Request method not allowed\");\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": (typeof async !== \"boolean\" ? true : async),\n      \"user\": user || null,\n      \"password\": password || null\n    };\n\n    setState(this.OPENED);\n  };\n\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n  this.setDisableHeaderCheck = function(state) {\n    disableHeaderCheck = state;\n  };\n\n  /**\n   * Sets a header for the request or appends the value if one is already set.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   */\n  this.setRequestHeader = function(header, value) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n    }\n    if (!isAllowedHttpHeader(header)) {\n      console.warn(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n      return;\n    }\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n    }\n    header = headersCase[header.toLowerCase()] || header;\n    headersCase[header.toLowerCase()] = header;\n    headers[header] = headers[header] ? headers[header] + ', ' + value : value;\n  };\n\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n  this.getResponseHeader = function(header) {\n    if (typeof header === \"string\"\n      && this.readyState > this.OPENED\n      && response\n      && response.headers\n      && response.headers[header.toLowerCase()]\n      && !errorFlag\n    ) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n  this.getAllResponseHeaders = function() {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n    return result.substr(0, result.length - 2);\n  };\n\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n  this.getRequestHeader = function(name) {\n    if (typeof name === \"string\" && headersCase[name.toLowerCase()]) {\n      return headers[headersCase[name.toLowerCase()]];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n  this.send = function(data) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n    }\n\n    var ssl = false, local = false;\n    var url = Url.parse(settings.url);\n    var host;\n    // Determine the server\n    switch (url.protocol) {\n      case \"https:\":\n        ssl = true;\n        // SSL & non-SSL both need host, no break here.\n      case \"http:\":\n        host = url.hostname;\n        break;\n\n      case \"file:\":\n        local = true;\n        break;\n\n      case undefined:\n      case null:\n      case \"\":\n        host = \"localhost\";\n        break;\n\n      default:\n        throw new Error(\"Protocol not supported.\");\n    }\n\n    // Load files off the local filesystem (file://)\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n      }\n\n      if (settings.async) {\n        fs.readFile(url.pathname, \"utf8\", function(error, data) {\n          if (error) {\n            self.handleError(error);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(url.pathname, \"utf8\");\n          this.status = 200;\n          setState(self.DONE);\n        } catch(e) {\n          this.handleError(e);\n        }\n      }\n\n      return;\n    }\n\n    // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n    var port = url.port || (ssl ? 443 : 80);\n    // Add query string if one is used\n    var uri = url.pathname + (url.search ? url.search : \"\");\n\n    // Set the defaults if they haven't been set\n    for (var name in defaultHeaders) {\n      if (!headersCase[name.toLowerCase()]) {\n        headers[name] = defaultHeaders[name];\n      }\n    }\n\n    // Set the Host header or the server may reject the request\n    headers.Host = host;\n    if (!((ssl && port === 443) || port === 80)) {\n      headers.Host += \":\" + url.port;\n    }\n\n    // Set Basic Auth if necessary\n    if (settings.user) {\n      if (typeof settings.password === \"undefined\") {\n        settings.password = \"\";\n      }\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers.Authorization = \"Basic \" + authBuf.toString(\"base64\");\n    }\n\n    // Set content length header\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: false,\n      withCredentials: self.withCredentials\n    };\n\n    // Reset error flag\n    errorFlag = false;\n\n    // Handle async requests\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request;\n\n      // Request is being sent, set send flag\n      sendFlag = true;\n\n      // As per spec, this is called here for historical reasons.\n      self.dispatchEvent(\"readystatechange\");\n\n      // Handler for the response\n      var responseHandler = function responseHandler(resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp;\n        // Check for redirect\n        // @TODO Prevent looped redirects\n        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location;\n          var url = Url.parse(settings.url);\n          // Set host var in case it's used later\n          host = url.hostname;\n          // Options for the new request\n          var newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? \"GET\" : settings.method,\n            headers: headers,\n            withCredentials: self.withCredentials\n          };\n\n          // Issue the new request\n          request = doRequest(newOptions, responseHandler).on(\"error\", errorHandler);\n          request.end();\n          // @TODO Check if an XHR event needs to be fired here\n          return;\n        }\n\n        response.setEncoding(\"utf8\");\n\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n\n        response.on(\"data\", function(chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          }\n          // Don't emit state changes if the connection has been aborted.\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n\n        response.on(\"end\", function() {\n          if (sendFlag) {\n            // Discard the end event if the connection has been aborted\n            setState(self.DONE);\n            sendFlag = false;\n          }\n        });\n\n        response.on(\"error\", function(error) {\n          self.handleError(error);\n        });\n      };\n\n      // Error handler for the request\n      var errorHandler = function errorHandler(error) {\n        self.handleError(error);\n      };\n\n      // Create the request\n      request = doRequest(options, responseHandler).on(\"error\", errorHandler);\n\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n\n      self.dispatchEvent(\"loadstart\");\n    } else { // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\n      // The async request the other Node process executes\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\"\n        + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\"\n        + \"var options = \" + JSON.stringify(options) + \";\"\n        + \"var responseText = '';\"\n        + \"var req = doRequest(options, function(response) {\"\n        + \"response.setEncoding('utf8');\"\n        + \"response.on('data', function(chunk) {\"\n        + \"  responseText += chunk;\"\n        + \"});\"\n        + \"response.on('end', function() {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"response.on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"}).on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + (data ? \"req.write('\" + JSON.stringify(data).slice(1,-1).replace(/'/g, \"\\\\'\") + \"');\":\"\")\n        + \"req.end();\";\n      // Start the other Node Process, executing this string\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      while(fs.existsSync(syncFile)) {\n        // Wait while the sync file is empty\n      }\n      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));\n      // Kill the child process once the file has data\n      syncProc.stdin.end();\n      // Remove the temporary file\n      fs.unlinkSync(contentFile);\n\n      if (resp.err) {\n        self.handleError(resp.err);\n      } else {\n        response = resp.data;\n        self.status = resp.data.statusCode;\n        self.responseText = resp.data.text;\n        setState(self.DONE);\n      }\n    }\n  };\n\n  /**\n   * Called when an error is encountered to deal with it.\n   */\n  this.handleError = function(error) {\n    this.status = 0;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n    this.dispatchEvent('error');\n  };\n\n  /**\n   * Aborts a request.\n   */\n  this.abort = function() {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = defaultHeaders;\n    this.status = 0;\n    this.responseText = \"\";\n    this.responseXML = \"\";\n\n    errorFlag = true;\n\n    if (this.readyState !== this.UNSENT\n        && (this.readyState !== this.OPENED || sendFlag)\n        && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n    this.readyState = this.UNSENT;\n    this.dispatchEvent('abort');\n  };\n\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n  this.addEventListener = function(event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    }\n    // Currently allows duplicate callbacks. Should it?\n    listeners[event].push(callback);\n  };\n\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n  this.removeEventListener = function(event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function(ev) {\n        return ev !== callback;\n      });\n    }\n  };\n\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n  this.dispatchEvent = function(event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      self[\"on\" + event]();\n    }\n    if (event in listeners) {\n      for (var i = 0, len = listeners[event].length; i < len; i++) {\n        listeners[event][i].call(self);\n      }\n    }\n  };\n\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n  var setState = function(state) {\n    if (state == self.LOADING || self.readyState !== state) {\n      self.readyState = state;\n\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n        self.dispatchEvent(\"readystatechange\");\n      }\n\n      if (self.readyState === self.DONE && !errorFlag) {\n        self.dispatchEvent(\"load\");\n        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n        self.dispatchEvent(\"loadend\");\n      }\n    }\n  };\n};\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_77865__) {\n\n(function(nacl) {\n'use strict';\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetnacl.cr.yp.to/\n\nvar gf = function(init) {\n  var i, r = new Float64Array(16);\n  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n  return r;\n};\n\n//  Pluggable, initialized in high-level API below.\nvar randombytes = function(/* x, n */) { throw new Error('no PRNG'); };\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction ts64(x, i, h, l) {\n  x[i]   = (h >> 24) & 0xff;\n  x[i+1] = (h >> 16) & 0xff;\n  x[i+2] = (h >>  8) & 0xff;\n  x[i+3] = h & 0xff;\n  x[i+4] = (l >> 24)  & 0xff;\n  x[i+5] = (l >> 16)  & 0xff;\n  x[i+6] = (l >>  8)  & 0xff;\n  x[i+7] = l & 0xff;\n}\n\nfunction vn(x, xi, y, yi, n) {\n  var i,d = 0;\n  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16(x, xi, y, yi) {\n  return vn(x,xi,y,yi,16);\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n  return vn(x,xi,y,yi,32);\n}\n\nfunction core_salsa20(o, p, k, c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n   x0 =  x0 +  j0 | 0;\n   x1 =  x1 +  j1 | 0;\n   x2 =  x2 +  j2 | 0;\n   x3 =  x3 +  j3 | 0;\n   x4 =  x4 +  j4 | 0;\n   x5 =  x5 +  j5 | 0;\n   x6 =  x6 +  j6 | 0;\n   x7 =  x7 +  j7 | 0;\n   x8 =  x8 +  j8 | 0;\n   x9 =  x9 +  j9 | 0;\n  x10 = x10 + j10 | 0;\n  x11 = x11 + j11 | 0;\n  x12 = x12 + j12 | 0;\n  x13 = x13 + j13 | 0;\n  x14 = x14 + j14 | 0;\n  x15 = x15 + j15 | 0;\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x1 >>>  0 & 0xff;\n  o[ 5] = x1 >>>  8 & 0xff;\n  o[ 6] = x1 >>> 16 & 0xff;\n  o[ 7] = x1 >>> 24 & 0xff;\n\n  o[ 8] = x2 >>>  0 & 0xff;\n  o[ 9] = x2 >>>  8 & 0xff;\n  o[10] = x2 >>> 16 & 0xff;\n  o[11] = x2 >>> 24 & 0xff;\n\n  o[12] = x3 >>>  0 & 0xff;\n  o[13] = x3 >>>  8 & 0xff;\n  o[14] = x3 >>> 16 & 0xff;\n  o[15] = x3 >>> 24 & 0xff;\n\n  o[16] = x4 >>>  0 & 0xff;\n  o[17] = x4 >>>  8 & 0xff;\n  o[18] = x4 >>> 16 & 0xff;\n  o[19] = x4 >>> 24 & 0xff;\n\n  o[20] = x5 >>>  0 & 0xff;\n  o[21] = x5 >>>  8 & 0xff;\n  o[22] = x5 >>> 16 & 0xff;\n  o[23] = x5 >>> 24 & 0xff;\n\n  o[24] = x6 >>>  0 & 0xff;\n  o[25] = x6 >>>  8 & 0xff;\n  o[26] = x6 >>> 16 & 0xff;\n  o[27] = x6 >>> 24 & 0xff;\n\n  o[28] = x7 >>>  0 & 0xff;\n  o[29] = x7 >>>  8 & 0xff;\n  o[30] = x7 >>> 16 & 0xff;\n  o[31] = x7 >>> 24 & 0xff;\n\n  o[32] = x8 >>>  0 & 0xff;\n  o[33] = x8 >>>  8 & 0xff;\n  o[34] = x8 >>> 16 & 0xff;\n  o[35] = x8 >>> 24 & 0xff;\n\n  o[36] = x9 >>>  0 & 0xff;\n  o[37] = x9 >>>  8 & 0xff;\n  o[38] = x9 >>> 16 & 0xff;\n  o[39] = x9 >>> 24 & 0xff;\n\n  o[40] = x10 >>>  0 & 0xff;\n  o[41] = x10 >>>  8 & 0xff;\n  o[42] = x10 >>> 16 & 0xff;\n  o[43] = x10 >>> 24 & 0xff;\n\n  o[44] = x11 >>>  0 & 0xff;\n  o[45] = x11 >>>  8 & 0xff;\n  o[46] = x11 >>> 16 & 0xff;\n  o[47] = x11 >>> 24 & 0xff;\n\n  o[48] = x12 >>>  0 & 0xff;\n  o[49] = x12 >>>  8 & 0xff;\n  o[50] = x12 >>> 16 & 0xff;\n  o[51] = x12 >>> 24 & 0xff;\n\n  o[52] = x13 >>>  0 & 0xff;\n  o[53] = x13 >>>  8 & 0xff;\n  o[54] = x13 >>> 16 & 0xff;\n  o[55] = x13 >>> 24 & 0xff;\n\n  o[56] = x14 >>>  0 & 0xff;\n  o[57] = x14 >>>  8 & 0xff;\n  o[58] = x14 >>> 16 & 0xff;\n  o[59] = x14 >>> 24 & 0xff;\n\n  o[60] = x15 >>>  0 & 0xff;\n  o[61] = x15 >>>  8 & 0xff;\n  o[62] = x15 >>> 16 & 0xff;\n  o[63] = x15 >>> 24 & 0xff;\n}\n\nfunction core_hsalsa20(o,p,k,c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x5 >>>  0 & 0xff;\n  o[ 5] = x5 >>>  8 & 0xff;\n  o[ 6] = x5 >>> 16 & 0xff;\n  o[ 7] = x5 >>> 24 & 0xff;\n\n  o[ 8] = x10 >>>  0 & 0xff;\n  o[ 9] = x10 >>>  8 & 0xff;\n  o[10] = x10 >>> 16 & 0xff;\n  o[11] = x10 >>> 24 & 0xff;\n\n  o[12] = x15 >>>  0 & 0xff;\n  o[13] = x15 >>>  8 & 0xff;\n  o[14] = x15 >>> 16 & 0xff;\n  o[15] = x15 >>> 24 & 0xff;\n\n  o[16] = x6 >>>  0 & 0xff;\n  o[17] = x6 >>>  8 & 0xff;\n  o[18] = x6 >>> 16 & 0xff;\n  o[19] = x6 >>> 24 & 0xff;\n\n  o[20] = x7 >>>  0 & 0xff;\n  o[21] = x7 >>>  8 & 0xff;\n  o[22] = x7 >>> 16 & 0xff;\n  o[23] = x7 >>> 24 & 0xff;\n\n  o[24] = x8 >>>  0 & 0xff;\n  o[25] = x8 >>>  8 & 0xff;\n  o[26] = x8 >>> 16 & 0xff;\n  o[27] = x8 >>> 24 & 0xff;\n\n  o[28] = x9 >>>  0 & 0xff;\n  o[29] = x9 >>>  8 & 0xff;\n  o[30] = x9 >>> 16 & 0xff;\n  o[31] = x9 >>> 24 & 0xff;\n}\n\nfunction crypto_core_salsa20(out,inp,k,c) {\n  core_salsa20(out,inp,k,c);\n}\n\nfunction crypto_core_hsalsa20(out,inp,k,c) {\n  core_hsalsa20(out,inp,k,c);\n}\n\nvar sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n            // \"expand 32-byte k\"\n\nfunction crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    mpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream_salsa20(c,cpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream(c,cpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20(c,cpos,d,sn,s);\n}\n\nfunction crypto_stream_xor(c,cpos,m,mpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);\n}\n\n/*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/\n\nvar poly1305 = function(key) {\n  this.buffer = new Uint8Array(16);\n  this.r = new Uint16Array(10);\n  this.h = new Uint16Array(10);\n  this.pad = new Uint16Array(8);\n  this.leftover = 0;\n  this.fin = 0;\n\n  var t0, t1, t2, t3, t4, t5, t6, t7;\n\n  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;\n  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;\n  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;\n  this.r[5] = ((t4 >>>  1)) & 0x1ffe;\n  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;\n  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n  this.r[9] = ((t7 >>>  5)) & 0x007f;\n\n  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n};\n\npoly1305.prototype.blocks = function(m, mpos, bytes) {\n  var hibit = this.fin ? 0 : (1 << 11);\n  var t0, t1, t2, t3, t4, t5, t6, t7, c;\n  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n\n  var h0 = this.h[0],\n      h1 = this.h[1],\n      h2 = this.h[2],\n      h3 = this.h[3],\n      h4 = this.h[4],\n      h5 = this.h[5],\n      h6 = this.h[6],\n      h7 = this.h[7],\n      h8 = this.h[8],\n      h9 = this.h[9];\n\n  var r0 = this.r[0],\n      r1 = this.r[1],\n      r2 = this.r[2],\n      r3 = this.r[3],\n      r4 = this.r[4],\n      r5 = this.r[5],\n      r6 = this.r[6],\n      r7 = this.r[7],\n      r8 = this.r[8],\n      r9 = this.r[9];\n\n  while (bytes >= 16) {\n    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;\n    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;\n    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;\n    h5 += ((t4 >>>  1)) & 0x1fff;\n    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;\n    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n    h9 += ((t7 >>> 5)) | hibit;\n\n    c = 0;\n\n    d0 = c;\n    d0 += h0 * r0;\n    d0 += h1 * (5 * r9);\n    d0 += h2 * (5 * r8);\n    d0 += h3 * (5 * r7);\n    d0 += h4 * (5 * r6);\n    c = (d0 >>> 13); d0 &= 0x1fff;\n    d0 += h5 * (5 * r5);\n    d0 += h6 * (5 * r4);\n    d0 += h7 * (5 * r3);\n    d0 += h8 * (5 * r2);\n    d0 += h9 * (5 * r1);\n    c += (d0 >>> 13); d0 &= 0x1fff;\n\n    d1 = c;\n    d1 += h0 * r1;\n    d1 += h1 * r0;\n    d1 += h2 * (5 * r9);\n    d1 += h3 * (5 * r8);\n    d1 += h4 * (5 * r7);\n    c = (d1 >>> 13); d1 &= 0x1fff;\n    d1 += h5 * (5 * r6);\n    d1 += h6 * (5 * r5);\n    d1 += h7 * (5 * r4);\n    d1 += h8 * (5 * r3);\n    d1 += h9 * (5 * r2);\n    c += (d1 >>> 13); d1 &= 0x1fff;\n\n    d2 = c;\n    d2 += h0 * r2;\n    d2 += h1 * r1;\n    d2 += h2 * r0;\n    d2 += h3 * (5 * r9);\n    d2 += h4 * (5 * r8);\n    c = (d2 >>> 13); d2 &= 0x1fff;\n    d2 += h5 * (5 * r7);\n    d2 += h6 * (5 * r6);\n    d2 += h7 * (5 * r5);\n    d2 += h8 * (5 * r4);\n    d2 += h9 * (5 * r3);\n    c += (d2 >>> 13); d2 &= 0x1fff;\n\n    d3 = c;\n    d3 += h0 * r3;\n    d3 += h1 * r2;\n    d3 += h2 * r1;\n    d3 += h3 * r0;\n    d3 += h4 * (5 * r9);\n    c = (d3 >>> 13); d3 &= 0x1fff;\n    d3 += h5 * (5 * r8);\n    d3 += h6 * (5 * r7);\n    d3 += h7 * (5 * r6);\n    d3 += h8 * (5 * r5);\n    d3 += h9 * (5 * r4);\n    c += (d3 >>> 13); d3 &= 0x1fff;\n\n    d4 = c;\n    d4 += h0 * r4;\n    d4 += h1 * r3;\n    d4 += h2 * r2;\n    d4 += h3 * r1;\n    d4 += h4 * r0;\n    c = (d4 >>> 13); d4 &= 0x1fff;\n    d4 += h5 * (5 * r9);\n    d4 += h6 * (5 * r8);\n    d4 += h7 * (5 * r7);\n    d4 += h8 * (5 * r6);\n    d4 += h9 * (5 * r5);\n    c += (d4 >>> 13); d4 &= 0x1fff;\n\n    d5 = c;\n    d5 += h0 * r5;\n    d5 += h1 * r4;\n    d5 += h2 * r3;\n    d5 += h3 * r2;\n    d5 += h4 * r1;\n    c = (d5 >>> 13); d5 &= 0x1fff;\n    d5 += h5 * r0;\n    d5 += h6 * (5 * r9);\n    d5 += h7 * (5 * r8);\n    d5 += h8 * (5 * r7);\n    d5 += h9 * (5 * r6);\n    c += (d5 >>> 13); d5 &= 0x1fff;\n\n    d6 = c;\n    d6 += h0 * r6;\n    d6 += h1 * r5;\n    d6 += h2 * r4;\n    d6 += h3 * r3;\n    d6 += h4 * r2;\n    c = (d6 >>> 13); d6 &= 0x1fff;\n    d6 += h5 * r1;\n    d6 += h6 * r0;\n    d6 += h7 * (5 * r9);\n    d6 += h8 * (5 * r8);\n    d6 += h9 * (5 * r7);\n    c += (d6 >>> 13); d6 &= 0x1fff;\n\n    d7 = c;\n    d7 += h0 * r7;\n    d7 += h1 * r6;\n    d7 += h2 * r5;\n    d7 += h3 * r4;\n    d7 += h4 * r3;\n    c = (d7 >>> 13); d7 &= 0x1fff;\n    d7 += h5 * r2;\n    d7 += h6 * r1;\n    d7 += h7 * r0;\n    d7 += h8 * (5 * r9);\n    d7 += h9 * (5 * r8);\n    c += (d7 >>> 13); d7 &= 0x1fff;\n\n    d8 = c;\n    d8 += h0 * r8;\n    d8 += h1 * r7;\n    d8 += h2 * r6;\n    d8 += h3 * r5;\n    d8 += h4 * r4;\n    c = (d8 >>> 13); d8 &= 0x1fff;\n    d8 += h5 * r3;\n    d8 += h6 * r2;\n    d8 += h7 * r1;\n    d8 += h8 * r0;\n    d8 += h9 * (5 * r9);\n    c += (d8 >>> 13); d8 &= 0x1fff;\n\n    d9 = c;\n    d9 += h0 * r9;\n    d9 += h1 * r8;\n    d9 += h2 * r7;\n    d9 += h3 * r6;\n    d9 += h4 * r5;\n    c = (d9 >>> 13); d9 &= 0x1fff;\n    d9 += h5 * r4;\n    d9 += h6 * r3;\n    d9 += h7 * r2;\n    d9 += h8 * r1;\n    d9 += h9 * r0;\n    c += (d9 >>> 13); d9 &= 0x1fff;\n\n    c = (((c << 2) + c)) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = (c >>> 13);\n    d1 += c;\n\n    h0 = d0;\n    h1 = d1;\n    h2 = d2;\n    h3 = d3;\n    h4 = d4;\n    h5 = d5;\n    h6 = d6;\n    h7 = d7;\n    h8 = d8;\n    h9 = d9;\n\n    mpos += 16;\n    bytes -= 16;\n  }\n  this.h[0] = h0;\n  this.h[1] = h1;\n  this.h[2] = h2;\n  this.h[3] = h3;\n  this.h[4] = h4;\n  this.h[5] = h5;\n  this.h[6] = h6;\n  this.h[7] = h7;\n  this.h[8] = h8;\n  this.h[9] = h9;\n};\n\npoly1305.prototype.finish = function(mac, macpos) {\n  var g = new Uint16Array(10);\n  var c, mask, f, i;\n\n  if (this.leftover) {\n    i = this.leftover;\n    this.buffer[i++] = 1;\n    for (; i < 16; i++) this.buffer[i] = 0;\n    this.fin = 1;\n    this.blocks(this.buffer, 0, 16);\n  }\n\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  for (i = 2; i < 10; i++) {\n    this.h[i] += c;\n    c = this.h[i] >>> 13;\n    this.h[i] &= 0x1fff;\n  }\n  this.h[0] += (c * 5);\n  c = this.h[0] >>> 13;\n  this.h[0] &= 0x1fff;\n  this.h[1] += c;\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  this.h[2] += c;\n\n  g[0] = this.h[0] + 5;\n  c = g[0] >>> 13;\n  g[0] &= 0x1fff;\n  for (i = 1; i < 10; i++) {\n    g[i] = this.h[i] + c;\n    c = g[i] >>> 13;\n    g[i] &= 0x1fff;\n  }\n  g[9] -= (1 << 13);\n\n  mask = (c ^ 1) - 1;\n  for (i = 0; i < 10; i++) g[i] &= mask;\n  mask = ~mask;\n  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];\n\n  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;\n  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;\n  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;\n  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;\n  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;\n  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;\n  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;\n  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;\n\n  f = this.h[0] + this.pad[0];\n  this.h[0] = f & 0xffff;\n  for (i = 1; i < 8; i++) {\n    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;\n    this.h[i] = f & 0xffff;\n  }\n\n  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;\n  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;\n  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;\n  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;\n  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;\n  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;\n  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;\n  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;\n  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;\n  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;\n  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;\n  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;\n  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;\n  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;\n  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;\n  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;\n};\n\npoly1305.prototype.update = function(m, mpos, bytes) {\n  var i, want;\n\n  if (this.leftover) {\n    want = (16 - this.leftover);\n    if (want > bytes)\n      want = bytes;\n    for (i = 0; i < want; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    bytes -= want;\n    mpos += want;\n    this.leftover += want;\n    if (this.leftover < 16)\n      return;\n    this.blocks(this.buffer, 0, 16);\n    this.leftover = 0;\n  }\n\n  if (bytes >= 16) {\n    want = bytes - (bytes % 16);\n    this.blocks(m, mpos, want);\n    mpos += want;\n    bytes -= want;\n  }\n\n  if (bytes) {\n    for (i = 0; i < bytes; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    this.leftover += bytes;\n  }\n};\n\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  var s = new poly1305(k);\n  s.update(m, mpos, n);\n  s.finish(out, outpos);\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x,0,m,mpos,n,k);\n  return crypto_verify_16(h,hpos,x,0);\n}\n\nfunction crypto_secretbox(c,m,d,n,k) {\n  var i;\n  if (d < 32) return -1;\n  crypto_stream_xor(c,0,m,0,d,n,k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open(m,c,d,n,k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream(x,0,32,n,k);\n  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;\n  crypto_stream_xor(m,0,c,0,d,n,k);\n  for (i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\n\nfunction set25519(r, a) {\n  var i;\n  for (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n  var i, v, c = 1;\n  for (i = 0; i < 16; i++) {\n    v = o[i] + c + 65535;\n    c = Math.floor(v / 65536);\n    o[i] = v - c * 65536;\n  }\n  o[0] += c-1 + 37 * (c-1);\n}\n\nfunction sel25519(p, q, b) {\n  var t, c = ~(b-1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519(o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++) t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n      m[i-1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n    b = (m[15]>>16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1-b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2*i] = t[i] & 0xff;\n    o[2*i+1] = t[i]>>8;\n  }\n}\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n}\n\nfunction Z(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n}\n\nfunction M(o, a, b) {\n  var v, c,\n     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\n     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\n    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\n    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\n    b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11],\n    b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n\n  v = a[0];\n  t0 += v * b0;\n  t1 += v * b1;\n  t2 += v * b2;\n  t3 += v * b3;\n  t4 += v * b4;\n  t5 += v * b5;\n  t6 += v * b6;\n  t7 += v * b7;\n  t8 += v * b8;\n  t9 += v * b9;\n  t10 += v * b10;\n  t11 += v * b11;\n  t12 += v * b12;\n  t13 += v * b13;\n  t14 += v * b14;\n  t15 += v * b15;\n  v = a[1];\n  t1 += v * b0;\n  t2 += v * b1;\n  t3 += v * b2;\n  t4 += v * b3;\n  t5 += v * b4;\n  t6 += v * b5;\n  t7 += v * b6;\n  t8 += v * b7;\n  t9 += v * b8;\n  t10 += v * b9;\n  t11 += v * b10;\n  t12 += v * b11;\n  t13 += v * b12;\n  t14 += v * b13;\n  t15 += v * b14;\n  t16 += v * b15;\n  v = a[2];\n  t2 += v * b0;\n  t3 += v * b1;\n  t4 += v * b2;\n  t5 += v * b3;\n  t6 += v * b4;\n  t7 += v * b5;\n  t8 += v * b6;\n  t9 += v * b7;\n  t10 += v * b8;\n  t11 += v * b9;\n  t12 += v * b10;\n  t13 += v * b11;\n  t14 += v * b12;\n  t15 += v * b13;\n  t16 += v * b14;\n  t17 += v * b15;\n  v = a[3];\n  t3 += v * b0;\n  t4 += v * b1;\n  t5 += v * b2;\n  t6 += v * b3;\n  t7 += v * b4;\n  t8 += v * b5;\n  t9 += v * b6;\n  t10 += v * b7;\n  t11 += v * b8;\n  t12 += v * b9;\n  t13 += v * b10;\n  t14 += v * b11;\n  t15 += v * b12;\n  t16 += v * b13;\n  t17 += v * b14;\n  t18 += v * b15;\n  v = a[4];\n  t4 += v * b0;\n  t5 += v * b1;\n  t6 += v * b2;\n  t7 += v * b3;\n  t8 += v * b4;\n  t9 += v * b5;\n  t10 += v * b6;\n  t11 += v * b7;\n  t12 += v * b8;\n  t13 += v * b9;\n  t14 += v * b10;\n  t15 += v * b11;\n  t16 += v * b12;\n  t17 += v * b13;\n  t18 += v * b14;\n  t19 += v * b15;\n  v = a[5];\n  t5 += v * b0;\n  t6 += v * b1;\n  t7 += v * b2;\n  t8 += v * b3;\n  t9 += v * b4;\n  t10 += v * b5;\n  t11 += v * b6;\n  t12 += v * b7;\n  t13 += v * b8;\n  t14 += v * b9;\n  t15 += v * b10;\n  t16 += v * b11;\n  t17 += v * b12;\n  t18 += v * b13;\n  t19 += v * b14;\n  t20 += v * b15;\n  v = a[6];\n  t6 += v * b0;\n  t7 += v * b1;\n  t8 += v * b2;\n  t9 += v * b3;\n  t10 += v * b4;\n  t11 += v * b5;\n  t12 += v * b6;\n  t13 += v * b7;\n  t14 += v * b8;\n  t15 += v * b9;\n  t16 += v * b10;\n  t17 += v * b11;\n  t18 += v * b12;\n  t19 += v * b13;\n  t20 += v * b14;\n  t21 += v * b15;\n  v = a[7];\n  t7 += v * b0;\n  t8 += v * b1;\n  t9 += v * b2;\n  t10 += v * b3;\n  t11 += v * b4;\n  t12 += v * b5;\n  t13 += v * b6;\n  t14 += v * b7;\n  t15 += v * b8;\n  t16 += v * b9;\n  t17 += v * b10;\n  t18 += v * b11;\n  t19 += v * b12;\n  t20 += v * b13;\n  t21 += v * b14;\n  t22 += v * b15;\n  v = a[8];\n  t8 += v * b0;\n  t9 += v * b1;\n  t10 += v * b2;\n  t11 += v * b3;\n  t12 += v * b4;\n  t13 += v * b5;\n  t14 += v * b6;\n  t15 += v * b7;\n  t16 += v * b8;\n  t17 += v * b9;\n  t18 += v * b10;\n  t19 += v * b11;\n  t20 += v * b12;\n  t21 += v * b13;\n  t22 += v * b14;\n  t23 += v * b15;\n  v = a[9];\n  t9 += v * b0;\n  t10 += v * b1;\n  t11 += v * b2;\n  t12 += v * b3;\n  t13 += v * b4;\n  t14 += v * b5;\n  t15 += v * b6;\n  t16 += v * b7;\n  t17 += v * b8;\n  t18 += v * b9;\n  t19 += v * b10;\n  t20 += v * b11;\n  t21 += v * b12;\n  t22 += v * b13;\n  t23 += v * b14;\n  t24 += v * b15;\n  v = a[10];\n  t10 += v * b0;\n  t11 += v * b1;\n  t12 += v * b2;\n  t13 += v * b3;\n  t14 += v * b4;\n  t15 += v * b5;\n  t16 += v * b6;\n  t17 += v * b7;\n  t18 += v * b8;\n  t19 += v * b9;\n  t20 += v * b10;\n  t21 += v * b11;\n  t22 += v * b12;\n  t23 += v * b13;\n  t24 += v * b14;\n  t25 += v * b15;\n  v = a[11];\n  t11 += v * b0;\n  t12 += v * b1;\n  t13 += v * b2;\n  t14 += v * b3;\n  t15 += v * b4;\n  t16 += v * b5;\n  t17 += v * b6;\n  t18 += v * b7;\n  t19 += v * b8;\n  t20 += v * b9;\n  t21 += v * b10;\n  t22 += v * b11;\n  t23 += v * b12;\n  t24 += v * b13;\n  t25 += v * b14;\n  t26 += v * b15;\n  v = a[12];\n  t12 += v * b0;\n  t13 += v * b1;\n  t14 += v * b2;\n  t15 += v * b3;\n  t16 += v * b4;\n  t17 += v * b5;\n  t18 += v * b6;\n  t19 += v * b7;\n  t20 += v * b8;\n  t21 += v * b9;\n  t22 += v * b10;\n  t23 += v * b11;\n  t24 += v * b12;\n  t25 += v * b13;\n  t26 += v * b14;\n  t27 += v * b15;\n  v = a[13];\n  t13 += v * b0;\n  t14 += v * b1;\n  t15 += v * b2;\n  t16 += v * b3;\n  t17 += v * b4;\n  t18 += v * b5;\n  t19 += v * b6;\n  t20 += v * b7;\n  t21 += v * b8;\n  t22 += v * b9;\n  t23 += v * b10;\n  t24 += v * b11;\n  t25 += v * b12;\n  t26 += v * b13;\n  t27 += v * b14;\n  t28 += v * b15;\n  v = a[14];\n  t14 += v * b0;\n  t15 += v * b1;\n  t16 += v * b2;\n  t17 += v * b3;\n  t18 += v * b4;\n  t19 += v * b5;\n  t20 += v * b6;\n  t21 += v * b7;\n  t22 += v * b8;\n  t23 += v * b9;\n  t24 += v * b10;\n  t25 += v * b11;\n  t26 += v * b12;\n  t27 += v * b13;\n  t28 += v * b14;\n  t29 += v * b15;\n  v = a[15];\n  t15 += v * b0;\n  t16 += v * b1;\n  t17 += v * b2;\n  t18 += v * b3;\n  t19 += v * b4;\n  t20 += v * b5;\n  t21 += v * b6;\n  t22 += v * b7;\n  t23 += v * b8;\n  t24 += v * b9;\n  t25 += v * b10;\n  t26 += v * b11;\n  t27 += v * b12;\n  t28 += v * b13;\n  t29 += v * b14;\n  t30 += v * b15;\n\n  t0  += 38 * t16;\n  t1  += 38 * t17;\n  t2  += 38 * t18;\n  t3  += 38 * t19;\n  t4  += 38 * t20;\n  t5  += 38 * t21;\n  t6  += 38 * t22;\n  t7  += 38 * t23;\n  t8  += 38 * t24;\n  t9  += 38 * t25;\n  t10 += 38 * t26;\n  t11 += 38 * t27;\n  t12 += 38 * t28;\n  t13 += 38 * t29;\n  t14 += 38 * t30;\n  // t15 left as is\n\n  // first car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  // second car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  o[ 0] = t0;\n  o[ 1] = t1;\n  o[ 2] = t2;\n  o[ 3] = t3;\n  o[ 4] = t4;\n  o[ 5] = t5;\n  o[ 6] = t6;\n  o[ 7] = t7;\n  o[ 8] = t8;\n  o[ 9] = t9;\n  o[10] = t10;\n  o[11] = t11;\n  o[12] = t12;\n  o[13] = t13;\n  o[14] = t14;\n  o[15] = t15;\n}\n\nfunction S(o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if(a !== 2 && a !== 4) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if(a !== 1) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_scalarmult(q, n, p) {\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++) z[i] = n[i];\n  z[31]=(n[31]&127)|64;\n  z[0]&=248;\n  unpack25519(x,p);\n  for (i = 0; i < 16; i++) {\n    b[i]=x[i];\n    d[i]=a[i]=c[i]=0;\n  }\n  a[0]=d[0]=1;\n  for (i=254; i>=0; --i) {\n    r=(z[i>>>3]>>>(i&7))&1;\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n    A(e,a,c);\n    Z(a,a,c);\n    A(c,b,d);\n    Z(b,b,d);\n    S(d,e);\n    S(f,a);\n    M(a,c,a);\n    M(c,b,e);\n    A(e,a,c);\n    Z(a,a,c);\n    S(b,a);\n    Z(c,d,f);\n    M(a,c,_121665);\n    A(a,a,d);\n    M(c,c,a);\n    M(a,d,f);\n    M(d,b,x);\n    S(b,e);\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i+16]=a[i];\n    x[i+32]=c[i];\n    x[i+48]=b[i];\n    x[i+64]=d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32,x32);\n  M(x16,x16,x32);\n  pack25519(q,x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base(q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nfunction crypto_box_keypair(y, x) {\n  randombytes(x, 32);\n  return crypto_scalarmult_base(y, x);\n}\n\nfunction crypto_box_beforenm(k, y, x) {\n  var s = new Uint8Array(32);\n  crypto_scalarmult(s, x, y);\n  return crypto_core_hsalsa20(k, _0, s, sigma);\n}\n\nvar crypto_box_afternm = crypto_secretbox;\nvar crypto_box_open_afternm = crypto_secretbox_open;\n\nfunction crypto_box(c, m, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_afternm(c, m, d, n, k);\n}\n\nfunction crypto_box_open(m, c, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_open_afternm(m, c, d, n, k);\n}\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction crypto_hashblocks_hl(hh, hl, m, n) {\n  var wh = new Int32Array(16), wl = new Int32Array(16),\n      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,\n      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,\n      th, tl, i, j, h, l, a, b, c, d;\n\n  var ah0 = hh[0],\n      ah1 = hh[1],\n      ah2 = hh[2],\n      ah3 = hh[3],\n      ah4 = hh[4],\n      ah5 = hh[5],\n      ah6 = hh[6],\n      ah7 = hh[7],\n\n      al0 = hl[0],\n      al1 = hl[1],\n      al2 = hl[2],\n      al3 = hl[3],\n      al4 = hl[4],\n      al5 = hl[5],\n      al6 = hl[6],\n      al7 = hl[7];\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++) {\n      j = 8 * i + pos;\n      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];\n      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];\n    }\n    for (i = 0; i < 80; i++) {\n      bh0 = ah0;\n      bh1 = ah1;\n      bh2 = ah2;\n      bh3 = ah3;\n      bh4 = ah4;\n      bh5 = ah5;\n      bh6 = ah6;\n      bh7 = ah7;\n\n      bl0 = al0;\n      bl1 = al1;\n      bl2 = al2;\n      bl3 = al3;\n      bl4 = al4;\n      bl5 = al5;\n      bl6 = al6;\n      bl7 = al7;\n\n      // add\n      h = ah7;\n      l = al7;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma1\n      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));\n      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Ch\n      h = (ah4 & ah5) ^ (~ah4 & ah6);\n      l = (al4 & al5) ^ (~al4 & al6);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // K\n      h = K[i*2];\n      l = K[i*2+1];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // w\n      h = wh[i%16];\n      l = wl[i%16];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      th = c & 0xffff | d << 16;\n      tl = a & 0xffff | b << 16;\n\n      // add\n      h = th;\n      l = tl;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma0\n      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));\n      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Maj\n      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);\n      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh7 = (c & 0xffff) | (d << 16);\n      bl7 = (a & 0xffff) | (b << 16);\n\n      // add\n      h = bh3;\n      l = bl3;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      h = th;\n      l = tl;\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh3 = (c & 0xffff) | (d << 16);\n      bl3 = (a & 0xffff) | (b << 16);\n\n      ah1 = bh0;\n      ah2 = bh1;\n      ah3 = bh2;\n      ah4 = bh3;\n      ah5 = bh4;\n      ah6 = bh5;\n      ah7 = bh6;\n      ah0 = bh7;\n\n      al1 = bl0;\n      al2 = bl1;\n      al3 = bl2;\n      al4 = bl3;\n      al5 = bl4;\n      al6 = bl5;\n      al7 = bl6;\n      al0 = bl7;\n\n      if (i%16 === 15) {\n        for (j = 0; j < 16; j++) {\n          // add\n          h = wh[j];\n          l = wl[j];\n\n          a = l & 0xffff; b = l >>> 16;\n          c = h & 0xffff; d = h >>> 16;\n\n          h = wh[(j+9)%16];\n          l = wl[(j+9)%16];\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma0\n          th = wh[(j+1)%16];\n          tl = wl[(j+1)%16];\n          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);\n          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma1\n          th = wh[(j+14)%16];\n          tl = wl[(j+14)%16];\n          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);\n          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          b += a >>> 16;\n          c += b >>> 16;\n          d += c >>> 16;\n\n          wh[j] = (c & 0xffff) | (d << 16);\n          wl[j] = (a & 0xffff) | (b << 16);\n        }\n      }\n    }\n\n    // add\n    h = ah0;\n    l = al0;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[0];\n    l = hl[0];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[0] = ah0 = (c & 0xffff) | (d << 16);\n    hl[0] = al0 = (a & 0xffff) | (b << 16);\n\n    h = ah1;\n    l = al1;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[1];\n    l = hl[1];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[1] = ah1 = (c & 0xffff) | (d << 16);\n    hl[1] = al1 = (a & 0xffff) | (b << 16);\n\n    h = ah2;\n    l = al2;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[2];\n    l = hl[2];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[2] = ah2 = (c & 0xffff) | (d << 16);\n    hl[2] = al2 = (a & 0xffff) | (b << 16);\n\n    h = ah3;\n    l = al3;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[3];\n    l = hl[3];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[3] = ah3 = (c & 0xffff) | (d << 16);\n    hl[3] = al3 = (a & 0xffff) | (b << 16);\n\n    h = ah4;\n    l = al4;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[4];\n    l = hl[4];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[4] = ah4 = (c & 0xffff) | (d << 16);\n    hl[4] = al4 = (a & 0xffff) | (b << 16);\n\n    h = ah5;\n    l = al5;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[5];\n    l = hl[5];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[5] = ah5 = (c & 0xffff) | (d << 16);\n    hl[5] = al5 = (a & 0xffff) | (b << 16);\n\n    h = ah6;\n    l = al6;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[6];\n    l = hl[6];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[6] = ah6 = (c & 0xffff) | (d << 16);\n    hl[6] = al6 = (a & 0xffff) | (b << 16);\n\n    h = ah7;\n    l = al7;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[7];\n    l = hl[7];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[7] = ah7 = (c & 0xffff) | (d << 16);\n    hl[7] = al7 = (a & 0xffff) | (b << 16);\n\n    pos += 128;\n    n -= 128;\n  }\n\n  return n;\n}\n\nfunction crypto_hash(out, m, n) {\n  var hh = new Int32Array(8),\n      hl = new Int32Array(8),\n      x = new Uint8Array(256),\n      i, b = n;\n\n  hh[0] = 0x6a09e667;\n  hh[1] = 0xbb67ae85;\n  hh[2] = 0x3c6ef372;\n  hh[3] = 0xa54ff53a;\n  hh[4] = 0x510e527f;\n  hh[5] = 0x9b05688c;\n  hh[6] = 0x1f83d9ab;\n  hh[7] = 0x5be0cd19;\n\n  hl[0] = 0xf3bcc908;\n  hl[1] = 0x84caa73b;\n  hl[2] = 0xfe94f82b;\n  hl[3] = 0x5f1d36f1;\n  hl[4] = 0xade682d1;\n  hl[5] = 0x2b3e6c1f;\n  hl[6] = 0xfb41bd6b;\n  hl[7] = 0x137e2179;\n\n  crypto_hashblocks_hl(hh, hl, m, n);\n  n %= 128;\n\n  for (i = 0; i < n; i++) x[i] = m[b-n+i];\n  x[n] = 128;\n\n  n = 256-128*(n<112?1:0);\n  x[n-9] = 0;\n  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);\n  crypto_hashblocks_hl(hh, hl, x, n);\n\n  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);\n\n  return 0;\n}\n\nfunction add(p, q) {\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf(),\n      g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack(r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i/8)|0] >> (i&7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase(p, s) {\n  var q = [gf(), gf(), gf(), gf()];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, seeded) {\n  var d = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n  var i;\n\n  if (!seeded) randombytes(sk, 32);\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  for (i = 0; i < 32; i++) sk[i+32] = pk[i];\n  return 0;\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = Math.floor((x[j] + 128) / 256);\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i+1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce(r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++) x[i] = r[i];\n  for (i = 0; i < 64; i++) r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk) {\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++) sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n  crypto_hash(r, sm.subarray(32), n+32);\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++) sm[i] = sk[i];\n  crypto_hash(h, sm, n + 64);\n  reduce(h);\n\n  for (i = 0; i < 64; i++) x[i] = 0;\n  for (i = 0; i < 32; i++) x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i+j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n  return smlen;\n}\n\nfunction unpackneg(r, p) {\n  var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) return -1;\n\n  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open(m, sm, n, pk) {\n  var i;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n\n  if (n < 64) return -1;\n\n  if (unpackneg(q, pk)) return -1;\n\n  for (i = 0; i < n; i++) m[i] = sm[i];\n  for (i = 0; i < 32; i++) m[i+32] = pk[i];\n  crypto_hash(h, m, n);\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++) m[i] = 0;\n    return -1;\n  }\n\n  for (i = 0; i < n; i++) m[i] = sm[i + 64];\n  return n;\n}\n\nvar crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n\nnacl.lowlevel = {\n  crypto_core_hsalsa20: crypto_core_hsalsa20,\n  crypto_stream_xor: crypto_stream_xor,\n  crypto_stream: crypto_stream,\n  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n  crypto_stream_salsa20: crypto_stream_salsa20,\n  crypto_onetimeauth: crypto_onetimeauth,\n  crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n  crypto_verify_16: crypto_verify_16,\n  crypto_verify_32: crypto_verify_32,\n  crypto_secretbox: crypto_secretbox,\n  crypto_secretbox_open: crypto_secretbox_open,\n  crypto_scalarmult: crypto_scalarmult,\n  crypto_scalarmult_base: crypto_scalarmult_base,\n  crypto_box_beforenm: crypto_box_beforenm,\n  crypto_box_afternm: crypto_box_afternm,\n  crypto_box: crypto_box,\n  crypto_box_open: crypto_box_open,\n  crypto_box_keypair: crypto_box_keypair,\n  crypto_hash: crypto_hash,\n  crypto_sign: crypto_sign,\n  crypto_sign_keypair: crypto_sign_keypair,\n  crypto_sign_open: crypto_sign_open,\n\n  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n  crypto_sign_BYTES: crypto_sign_BYTES,\n  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n  crypto_hash_BYTES: crypto_hash_BYTES,\n\n  gf: gf,\n  D: D,\n  L: L,\n  pack25519: pack25519,\n  unpack25519: unpack25519,\n  M: M,\n  A: A,\n  S: S,\n  Z: Z,\n  pow2523: pow2523,\n  add: add,\n  set25519: set25519,\n  modL: modL,\n  scalarmult: scalarmult,\n  scalarbase: scalarbase,\n};\n\n/* High-level API */\n\nfunction checkLengths(k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n}\n\nfunction checkBoxLengths(pk, sk) {\n  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n}\n\nfunction checkArrayTypes() {\n  for (var i = 0; i < arguments.length; i++) {\n    if (!(arguments[i] instanceof Uint8Array))\n      throw new TypeError('unexpected type, use Uint8Array');\n  }\n}\n\nfunction cleanup(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i] = 0;\n}\n\nnacl.randomBytes = function(n) {\n  var b = new Uint8Array(n);\n  randombytes(b, n);\n  return b;\n};\n\nnacl.secretbox = function(msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n};\n\nnacl.secretbox.open = function(box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return null;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n};\n\nnacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\nnacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\nnacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\nnacl.scalarMult = function(n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nnacl.scalarMult.base = function(n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nnacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\nnacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\nnacl.box = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox(msg, nonce, k);\n};\n\nnacl.box.before = function(publicKey, secretKey) {\n  checkArrayTypes(publicKey, secretKey);\n  checkBoxLengths(publicKey, secretKey);\n  var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n  crypto_box_beforenm(k, publicKey, secretKey);\n  return k;\n};\n\nnacl.box.after = nacl.secretbox;\n\nnacl.box.open = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox.open(msg, nonce, k);\n};\n\nnacl.box.open.after = nacl.secretbox.open;\n\nnacl.box.keyPair = function() {\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n  crypto_box_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.box.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  crypto_scalarmult_base(pk, secretKey);\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\nnacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\nnacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\nnacl.box.nonceLength = crypto_box_NONCEBYTES;\nnacl.box.overheadLength = nacl.secretbox.overheadLength;\n\nnacl.sign = function(msg, secretKey) {\n  checkArrayTypes(msg, secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);\n  crypto_sign(signedMsg, msg, msg.length, secretKey);\n  return signedMsg;\n};\n\nnacl.sign.open = function(signedMsg, publicKey) {\n  checkArrayTypes(signedMsg, publicKey);\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var tmp = new Uint8Array(signedMsg.length);\n  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n  if (mlen < 0) return null;\n  var m = new Uint8Array(mlen);\n  for (var i = 0; i < m.length; i++) m[i] = tmp[i];\n  return m;\n};\n\nnacl.sign.detached = function(msg, secretKey) {\n  var signedMsg = nacl.sign(msg, secretKey);\n  var sig = new Uint8Array(crypto_sign_BYTES);\n  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n  return sig;\n};\n\nnacl.sign.detached.verify = function(msg, sig, publicKey) {\n  checkArrayTypes(msg, sig, publicKey);\n  if (sig.length !== crypto_sign_BYTES)\n    throw new Error('bad signature size');\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var i;\n  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];\n  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\n};\n\nnacl.sign.keyPair = function() {\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  crypto_sign_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.sign.keyPair.fromSeed = function(seed) {\n  checkArrayTypes(seed);\n  if (seed.length !== crypto_sign_SEEDBYTES)\n    throw new Error('bad seed size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  for (var i = 0; i < 32; i++) sk[i] = seed[i];\n  crypto_sign_keypair(pk, sk, true);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\nnacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\nnacl.sign.seedLength = crypto_sign_SEEDBYTES;\nnacl.sign.signatureLength = crypto_sign_BYTES;\n\nnacl.hash = function(msg) {\n  checkArrayTypes(msg);\n  var h = new Uint8Array(crypto_hash_BYTES);\n  crypto_hash(h, msg, msg.length);\n  return h;\n};\n\nnacl.hash.hashLength = crypto_hash_BYTES;\n\nnacl.verify = function(x, y) {\n  checkArrayTypes(x, y);\n  // Zero length arguments are considered not equal.\n  if (x.length === 0 || y.length === 0) return false;\n  if (x.length !== y.length) return false;\n  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;\n};\n\nnacl.setPRNG = function(fn) {\n  randombytes = fn;\n};\n\n(function() {\n  // Initialize PRNG if environment provides CSPRNG.\n  // If not, methods calling randombytes will throw.\n  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;\n  if (crypto && crypto.getRandomValues) {\n    // Browsers.\n    var QUOTA = 65536;\n    nacl.setPRNG(function(x, n) {\n      var i, v = new Uint8Array(n);\n      for (i = 0; i < n; i += QUOTA) {\n        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n      }\n      for (i = 0; i < n; i++) x[i] = v[i];\n      cleanup(v);\n    });\n  } else if (true) {\n    // Node.js.\n    crypto = __nested_webpack_require_77865__(3);\n    if (crypto && crypto.randomBytes) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = crypto.randomBytes(n);\n        for (i = 0; i < n; i++) x[i] = v[i];\n        cleanup(v);\n      });\n    }\n  }\n})();\n\n})(  true && module.exports ? module.exports : (self.nacl = self.nacl || {}));\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __nested_webpack_require_139864__) {\n\nmodule.exports = __nested_webpack_require_139864__(47).default;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! buffer */ \"buffer\");\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! events */ \"events\");\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __nested_webpack_require_140176__) {\n\n\"use strict\";\n\n\n/**\n\nStreams in a WebSocket connection\n---------------------------------\n\nWe model a WebSocket as two duplex streams: one stream is for the wire protocol\nover an I/O socket, and the other is for incoming/outgoing messages.\n\n\n                        +----------+      +---------+      +----------+\n    [1] write(chunk) -->| ~~~~~~~~ +----->| parse() +----->| ~~~~~~~~ +--> emit('data') [2]\n                        |          |      +----+----+      |          |\n                        |          |           |           |          |\n                        |    IO    |           | [5]       | Messages |\n                        |          |           V           |          |\n                        |          |      +---------+      |          |\n    [4] emit('data') <--+ ~~~~~~~~ |<-----+ frame() |<-----+ ~~~~~~~~ |<-- write(chunk) [3]\n                        +----------+      +---------+      +----------+\n\n\nMessage transfer in each direction is simple: IO receives a byte stream [1] and\nsends this stream for parsing. The parser will periodically emit a complete\nmessage text on the Messages stream [2]. Similarly, when messages are written\nto the Messages stream [3], they are framed using the WebSocket wire format and\nemitted via IO [4].\n\nThere is a feedback loop via [5] since some input from [1] will be things like\nping, pong and close frames. In these cases the protocol responds by emitting\nresponses directly back to [4] rather than emitting messages via [2].\n\nFor the purposes of flow control, we consider the sources of each Readable\nstream to be as follows:\n\n* [2] receives input from [1]\n* [4] receives input from [1] and [3]\n\nThe classes below express the relationships described above without prescribing\nanything about how parse() and frame() work, other than assuming they emit\n'data' events to the IO and Messages streams. They will work with any protocol\ndriver having these two methods.\n**/\n\n\nvar Stream = __nested_webpack_require_140176__(5).Stream,\n    util   = __nested_webpack_require_140176__(0);\n\n\nvar IO = function(driver) {\n  this.readable = this.writable = true;\n  this._paused  = false;\n  this._driver  = driver;\n};\nutil.inherits(IO, Stream);\n\n// The IO pause() and resume() methods will be called when the socket we are\n// piping to gets backed up and drains. Since IO output [4] comes from IO input\n// [1] and Messages input [3], we need to tell both of those to return false\n// from write() when this stream is paused.\n\nIO.prototype.pause = function() {\n  this._paused = true;\n  this._driver.messages._paused = true;\n};\n\nIO.prototype.resume = function() {\n  this._paused = false;\n  this.emit('drain');\n\n  var messages = this._driver.messages;\n  messages._paused = false;\n  messages.emit('drain');\n};\n\n// When we receive input from a socket, send it to the parser and tell the\n// source whether to back off.\nIO.prototype.write = function(chunk) {\n  if (!this.writable) return false;\n  this._driver.parse(chunk);\n  return !this._paused;\n};\n\n// The IO end() method will be called when the socket piping into it emits\n// 'close' or 'end', i.e. the socket is closed. In this situation the Messages\n// stream will not emit any more data so we emit 'end'.\nIO.prototype.end = function(chunk) {\n  if (!this.writable) return;\n  if (chunk !== undefined) this.write(chunk);\n  this.writable = false;\n\n  var messages = this._driver.messages;\n  if (messages.readable) {\n    messages.readable = messages.writable = false;\n    messages.emit('end');\n  }\n};\n\nIO.prototype.destroy = function() {\n  this.end();\n};\n\n\nvar Messages = function(driver) {\n  this.readable = this.writable = true;\n  this._paused  = false;\n  this._driver  = driver;\n};\nutil.inherits(Messages, Stream);\n\n// The Messages pause() and resume() methods will be called when the app that's\n// processing the messages gets backed up and drains. If we're emitting\n// messages too fast we should tell the source to slow down. Message output [2]\n// comes from IO input [1].\n\nMessages.prototype.pause = function() {\n  this._driver.io._paused = true;\n};\n\nMessages.prototype.resume = function() {\n  this._driver.io._paused = false;\n  this._driver.io.emit('drain');\n};\n\n// When we receive messages from the user, send them to the formatter and tell\n// the source whether to back off.\nMessages.prototype.write = function(message) {\n  if (!this.writable) return false;\n  if (typeof message === 'string') this._driver.text(message);\n  else this._driver.binary(message);\n  return !this._paused;\n};\n\n// The Messages end() method will be called when a stream piping into it emits\n// 'end'. Many streams may be piped into the WebSocket and one of them ending\n// does not mean the whole socket is done, so just process the input and move\n// on leaving the socket open.\nMessages.prototype.end = function(message) {\n  if (message !== undefined) this.write(message);\n};\n\nMessages.prototype.destroy = function() {};\n\n\nexports.IO = IO;\nexports.Messages = Messages;\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __nested_webpack_require_145174__) {\n\n\"use strict\";\n\n\nvar Buffer = __nested_webpack_require_145174__(1).Buffer;\n\nvar StreamReader = function() {\n  this._queue     = [];\n  this._queueSize = 0;\n  this._offset    = 0;\n};\n\nStreamReader.prototype.put = function(buffer) {\n  if (!buffer || buffer.length === 0) return;\n  if (!Buffer.isBuffer(buffer)) buffer = Buffer.from(buffer);\n  this._queue.push(buffer);\n  this._queueSize += buffer.length;\n};\n\nStreamReader.prototype.read = function(length) {\n  if (length > this._queueSize) return null;\n  if (length === 0) return Buffer.alloc(0);\n\n  this._queueSize -= length;\n\n  var queue  = this._queue,\n      remain = length,\n      first  = queue[0],\n      buffers, buffer;\n\n  if (first.length >= length) {\n    if (first.length === length) {\n      return queue.shift();\n    } else {\n      buffer = first.slice(0, length);\n      queue[0] = first.slice(length);\n      return buffer;\n    }\n  }\n\n  for (var i = 0, n = queue.length; i < n; i++) {\n    if (remain < queue[i].length) break;\n    remain -= queue[i].length;\n  }\n  buffers = queue.splice(0, i);\n\n  if (remain > 0 && queue.length > 0) {\n    buffers.push(queue[0].slice(0, remain));\n    queue[0] = queue[0].slice(remain);\n  }\n  return Buffer.concat(buffers, length);\n};\n\nStreamReader.prototype.eachByte = function(callback, context) {\n  var buffer, n, index;\n\n  while (this._queue.length > 0) {\n    buffer = this._queue[0];\n    n = buffer.length;\n\n    while (this._offset < n) {\n      index = this._offset;\n      this._offset += 1;\n      callback.call(context, buffer[index]);\n    }\n    this._offset = 0;\n    this._queue.shift();\n  }\n};\n\nmodule.exports = StreamReader;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __nested_webpack_require_146859__) {\n\n\"use strict\";\n\n\nvar Buffer     = __nested_webpack_require_146859__(1).Buffer,\n    crypto     = __nested_webpack_require_146859__(3),\n    url        = __nested_webpack_require_146859__(6),\n    util       = __nested_webpack_require_146859__(0),\n    HttpParser = __nested_webpack_require_146859__(10),\n    Base       = __nested_webpack_require_146859__(2),\n    Hybi       = __nested_webpack_require_146859__(12),\n    Proxy      = __nested_webpack_require_146859__(36);\n\nvar Client = function(_url, options) {\n  this.version = 'hybi-' + Hybi.VERSION;\n  Hybi.call(this, null, _url, options);\n\n  this.readyState = -1;\n  this._key       = Client.generateKey();\n  this._accept    = Hybi.generateAccept(this._key);\n  this._http      = new HttpParser('response');\n\n  var uri  = url.parse(this.url),\n      auth = uri.auth && Buffer.from(uri.auth, 'utf8').toString('base64');\n\n  if (this.VALID_PROTOCOLS.indexOf(uri.protocol) < 0)\n    throw new Error(this.url + ' is not a valid WebSocket URL');\n\n  this._pathname = (uri.pathname || '/') + (uri.search || '');\n\n  this._headers.set('Host', uri.host);\n  this._headers.set('Upgrade', 'websocket');\n  this._headers.set('Connection', 'Upgrade');\n  this._headers.set('Sec-WebSocket-Key', this._key);\n  this._headers.set('Sec-WebSocket-Version', Hybi.VERSION);\n\n  if (this._protocols.length > 0)\n    this._headers.set('Sec-WebSocket-Protocol', this._protocols.join(', '));\n\n  if (auth)\n    this._headers.set('Authorization', 'Basic ' + auth);\n};\nutil.inherits(Client, Hybi);\n\nClient.generateKey = function() {\n  return crypto.randomBytes(16).toString('base64');\n};\n\nvar instance = {\n  VALID_PROTOCOLS: ['ws:', 'wss:'],\n\n  proxy: function(origin, options) {\n    return new Proxy(this, origin, options);\n  },\n\n  start: function() {\n    if (this.readyState !== -1) return false;\n    this._write(this._handshakeRequest());\n    this.readyState = 0;\n    return true;\n  },\n\n  parse: function(chunk) {\n    if (this.readyState === 3) return;\n    if (this.readyState > 0) return Hybi.prototype.parse.call(this, chunk);\n\n    this._http.parse(chunk);\n    if (!this._http.isComplete()) return;\n\n    this._validateHandshake();\n    if (this.readyState === 3) return;\n\n    this._open();\n    this.parse(this._http.body);\n  },\n\n  _handshakeRequest: function() {\n    var extensions = this._extensions.generateOffer();\n    if (extensions)\n      this._headers.set('Sec-WebSocket-Extensions', extensions);\n\n    var start   = 'GET ' + this._pathname + ' HTTP/1.1',\n        headers = [start, this._headers.toString(), ''];\n\n    return Buffer.from(headers.join('\\r\\n'), 'utf8');\n  },\n\n  _failHandshake: function(message) {\n    message = 'Error during WebSocket handshake: ' + message;\n    this.readyState = 3;\n    this.emit('error', new Error(message));\n    this.emit('close', new Base.CloseEvent(this.ERRORS.protocol_error, message));\n  },\n\n  _validateHandshake: function() {\n    this.statusCode = this._http.statusCode;\n    this.headers    = this._http.headers;\n\n    if (this._http.error)\n      return this._failHandshake(this._http.error.message);\n\n    if (this._http.statusCode !== 101)\n      return this._failHandshake('Unexpected response code: ' + this._http.statusCode);\n\n    var headers    = this._http.headers,\n        upgrade    = headers['upgrade'] || '',\n        connection = headers['connection'] || '',\n        accept     = headers['sec-websocket-accept'] || '',\n        protocol   = headers['sec-websocket-protocol'] || '';\n\n    if (upgrade === '')\n      return this._failHandshake(\"'Upgrade' header is missing\");\n    if (upgrade.toLowerCase() !== 'websocket')\n      return this._failHandshake(\"'Upgrade' header value is not 'WebSocket'\");\n\n    if (connection === '')\n      return this._failHandshake(\"'Connection' header is missing\");\n    if (connection.toLowerCase() !== 'upgrade')\n      return this._failHandshake(\"'Connection' header value is not 'Upgrade'\");\n\n    if (accept !== this._accept)\n      return this._failHandshake('Sec-WebSocket-Accept mismatch');\n\n    this.protocol = null;\n\n    if (protocol !== '') {\n      if (this._protocols.indexOf(protocol) < 0)\n        return this._failHandshake('Sec-WebSocket-Protocol mismatch');\n      else\n        this.protocol = protocol;\n    }\n\n    try {\n      this._extensions.activate(this.headers['sec-websocket-extensions']);\n    } catch (e) {\n      return this._failHandshake(e.message);\n    }\n  }\n};\n\nfor (var key in instance)\n  Client.prototype[key] = instance[key];\n\nmodule.exports = Client;\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __nested_webpack_require_151294__) {\n\n/*jshint node:true */\n\nvar assert = __nested_webpack_require_151294__(28);\n\nexports.HTTPParser = HTTPParser;\nfunction HTTPParser(type) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);\n  if (type === undefined) {\n    // Node v12+\n  } else {\n    this.initialize(type);\n  }\n  this.maxHeaderSize=HTTPParser.maxHeaderSize\n}\nHTTPParser.prototype.initialize = function (type, async_resource) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n  this.type = type;\n  this.state = type + '_LINE';\n  this.info = {\n    headers: [],\n    upgrade: false\n  };\n  this.trailers = [];\n  this.line = '';\n  this.isChunked = false;\n  this.connection = '';\n  this.headerSize = 0; // for preventing too big headers\n  this.body_bytes = null;\n  this.isUserCall = false;\n  this.hadError = false;\n};\n\nHTTPParser.encoding = 'ascii';\nHTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\nHTTPParser.REQUEST = 'REQUEST';\nHTTPParser.RESPONSE = 'RESPONSE';\n\n// Note: *not* starting with kOnHeaders=0 line the Node parser, because any\n//   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!\nvar kOnHeaders = HTTPParser.kOnHeaders = 1;\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;\nvar kOnBody = HTTPParser.kOnBody = 3;\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;\n\n// Some handler stubs, needed for compatibility\nHTTPParser.prototype[kOnHeaders] =\nHTTPParser.prototype[kOnHeadersComplete] =\nHTTPParser.prototype[kOnBody] =\nHTTPParser.prototype[kOnMessageComplete] = function () {};\n\nvar compatMode0_12 = true;\nObject.defineProperty(HTTPParser, 'kOnExecute', {\n    get: function () {\n      // hack for backward compatibility\n      compatMode0_12 = false;\n      return 99;\n    }\n  });\n\nvar methods = exports.methods = HTTPParser.methods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n  'CONNECT',\n  'OPTIONS',\n  'TRACE',\n  'COPY',\n  'LOCK',\n  'MKCOL',\n  'MOVE',\n  'PROPFIND',\n  'PROPPATCH',\n  'SEARCH',\n  'UNLOCK',\n  'BIND',\n  'REBIND',\n  'UNBIND',\n  'ACL',\n  'REPORT',\n  'MKACTIVITY',\n  'CHECKOUT',\n  'MERGE',\n  'M-SEARCH',\n  'NOTIFY',\n  'SUBSCRIBE',\n  'UNSUBSCRIBE',\n  'PATCH',\n  'PURGE',\n  'MKCALENDAR',\n  'LINK',\n  'UNLINK',\n  'SOURCE',\n];\nvar method_connect = methods.indexOf('CONNECT');\nHTTPParser.prototype.reinitialize = HTTPParser;\nHTTPParser.prototype.close =\nHTTPParser.prototype.pause =\nHTTPParser.prototype.resume =\nHTTPParser.prototype.free = function () {};\nHTTPParser.prototype._compatMode0_11 = false;\nHTTPParser.prototype.getAsyncId = function() { return 0; };\n\nvar headerState = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  HEADER: true\n};\nHTTPParser.prototype.execute = function (chunk, start, length) {\n  if (!(this instanceof HTTPParser)) {\n    throw new TypeError('not a HTTPParser');\n  }\n\n  // backward compat to node < 0.11.4\n  // Note: the start and length params were removed in newer version\n  start = start || 0;\n  length = typeof length === 'number' ? length : chunk.length;\n\n  this.chunk = chunk;\n  this.offset = start;\n  var end = this.end = start + length;\n  try {\n    while (this.offset < end) {\n      if (this[this.state]()) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (this.isUserCall) {\n      throw err;\n    }\n    this.hadError = true;\n    return err;\n  }\n  this.chunk = null;\n  length = this.offset - start;\n  if (headerState[this.state]) {\n    this.headerSize += length;\n    if (this.headerSize > (this.maxHeaderSize||HTTPParser.maxHeaderSize)) {\n      return new Error('max header size exceeded');\n    }\n  }\n  return length;\n};\n\nvar stateFinishAllowed = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  BODY_RAW: true\n};\nHTTPParser.prototype.finish = function () {\n  if (this.hadError) {\n    return;\n  }\n  if (!stateFinishAllowed[this.state]) {\n    return new Error('invalid state for EOF');\n  }\n  if (this.state === 'BODY_RAW') {\n    this.userCall()(this[kOnMessageComplete]());\n  }\n};\n\n// These three methods are used for an internal speed optimization, and it also\n// works if theses are noops. Basically consume() asks us to read the bytes\n// ourselves, but if we don't do it we get them through execute().\nHTTPParser.prototype.consume =\nHTTPParser.prototype.unconsume =\nHTTPParser.prototype.getCurrentBuffer = function () {};\n\n//For correct error handling - see HTTPParser#execute\n//Usage: this.userCall()(userFunction('arg'));\nHTTPParser.prototype.userCall = function () {\n  this.isUserCall = true;\n  var self = this;\n  return function (ret) {\n    self.isUserCall = false;\n    return ret;\n  };\n};\n\nHTTPParser.prototype.nextRequest = function () {\n  this.userCall()(this[kOnMessageComplete]());\n  this.reinitialize(this.type);\n};\n\nHTTPParser.prototype.consumeLine = function () {\n  var end = this.end,\n      chunk = this.chunk;\n  for (var i = this.offset; i < end; i++) {\n    if (chunk[i] === 0x0a) { // \\n\n      var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);\n      if (line.charAt(line.length - 1) === '\\r') {\n        line = line.substr(0, line.length - 1);\n      }\n      this.line = '';\n      this.offset = i + 1;\n      return line;\n    }\n  }\n  //line split over multiple chunks\n  this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);\n  this.offset = this.end;\n};\n\nvar headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nvar headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\nHTTPParser.prototype.parseHeader = function (line, headers) {\n  if (line.indexOf('\\r') !== -1) {\n    throw parseErrorCode('HPE_LF_EXPECTED');\n  }\n\n  var match = headerExp.exec(line);\n  var k = match && match[1];\n  if (k) { // skip empty string (malformed header)\n    headers.push(k);\n    headers.push(match[2]);\n  } else {\n    var matchContinue = headerContinueExp.exec(line);\n    if (matchContinue && headers.length) {\n      if (headers[headers.length - 1]) {\n        headers[headers.length - 1] += ' ';\n      }\n      headers[headers.length - 1] += matchContinue[1];\n    }\n  }\n};\n\nvar requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nHTTPParser.prototype.REQUEST_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = requestExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n  if (this.info.method === -1) {\n    throw new Error('invalid request method');\n  }\n  this.info.url = match[2];\n  this.info.versionMajor = +match[3];\n  this.info.versionMinor = +match[4];\n  this.body_bytes = 0;\n  this.state = 'HEADER';\n};\n\nvar responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\nHTTPParser.prototype.RESPONSE_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = responseExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.versionMajor = +match[1];\n  this.info.versionMinor = +match[2];\n  var statusCode = this.info.statusCode = +match[3];\n  this.info.statusMessage = match[4];\n  // Implied zero length.\n  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n    this.body_bytes = 0;\n  }\n  this.state = 'HEADER';\n};\n\nHTTPParser.prototype.shouldKeepAlive = function () {\n  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n    if (this.connection.indexOf('close') !== -1) {\n      return false;\n    }\n  } else if (this.connection.indexOf('keep-alive') === -1) {\n    return false;\n  }\n  if (this.body_bytes !== null || this.isChunked) { // || skipBody\n    return true;\n  }\n  return false;\n};\n\nHTTPParser.prototype.HEADER = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  var info = this.info;\n  if (line) {\n    this.parseHeader(line, info.headers);\n  } else {\n    var headers = info.headers;\n    var hasContentLength = false;\n    var currentContentLengthValue;\n    var hasUpgradeHeader = false;\n    for (var i = 0; i < headers.length; i += 2) {\n      switch (headers[i].toLowerCase()) {\n        case 'transfer-encoding':\n          this.isChunked = headers[i + 1].toLowerCase() === 'chunked';\n          break;\n        case 'content-length':\n          currentContentLengthValue = +headers[i + 1];\n          if (hasContentLength) {\n            // Fix duplicate Content-Length header with same values.\n            // Throw error only if values are different.\n            // Known issues:\n            // https://github.com/request/request/issues/2091#issuecomment-328715113\n            // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n            if (currentContentLengthValue !== this.body_bytes) {\n              throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');\n            }\n          } else {\n            hasContentLength = true;\n            this.body_bytes = currentContentLengthValue;\n          }\n          break;\n        case 'connection':\n          this.connection += headers[i + 1].toLowerCase();\n          break;\n        case 'upgrade':\n          hasUpgradeHeader = true;\n          break;\n      }\n    }\n\n    // if both isChunked and hasContentLength, isChunked wins\n    // This is required so the body is parsed using the chunked method, and matches\n    // Chrome's behavior.  We could, maybe, ignore them both (would get chunked\n    // encoding into the body), and/or disable shouldKeepAlive to be more\n    // resilient.\n    if (this.isChunked && hasContentLength) {\n      hasContentLength = false;\n      this.body_bytes = null;\n    }\n\n    // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737\n    // \"For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n    //   mandatory only when it is a 101 Switching Protocols response,\n    //   otherwise it is purely informational, to announce support.\n    if (hasUpgradeHeader && this.connection.indexOf('upgrade') != -1) {\n      info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;\n    } else {\n      info.upgrade = info.method === method_connect;\n    }\n\n    if (this.isChunked && info.upgrade) {\n      this.isChunked = false;\n    }\n\n    info.shouldKeepAlive = this.shouldKeepAlive();\n    //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n    var skipBody;\n    if (compatMode0_12) {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info));\n    } else {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor,\n          info.versionMinor, info.headers, info.method, info.url, info.statusCode,\n          info.statusMessage, info.upgrade, info.shouldKeepAlive));\n    }\n    if (skipBody === 2) {\n      this.nextRequest();\n      return true;\n    } else if (this.isChunked && !skipBody) {\n      this.state = 'BODY_CHUNKHEAD';\n    } else if (skipBody || this.body_bytes === 0) {\n      this.nextRequest();\n      // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,\n      //   need this \"return true;\" if it's an upgrade request.\n      return info.upgrade;\n    } else if (this.body_bytes === null) {\n      this.state = 'BODY_RAW';\n    } else {\n      this.state = 'BODY_SIZED';\n    }\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKHEAD = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  this.body_bytes = parseInt(line, 16);\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKTRAILERS';\n  } else {\n    this.state = 'BODY_CHUNK';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNK = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKEMPTYLINE';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKEMPTYLINE = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  assert.equal(line, '');\n  this.state = 'BODY_CHUNKHEAD';\n};\n\nHTTPParser.prototype.BODY_CHUNKTRAILERS = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  if (line) {\n    this.parseHeader(line, this.trailers);\n  } else {\n    if (this.trailers.length) {\n      this.userCall()(this[kOnHeaders](this.trailers, ''));\n    }\n    this.nextRequest();\n  }\n};\n\nHTTPParser.prototype.BODY_RAW = function () {\n  var length = this.end - this.offset;\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset = this.end;\n};\n\nHTTPParser.prototype.BODY_SIZED = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.nextRequest();\n  }\n};\n\n// backward compat to node < 0.11.6\n['Headers', 'HeadersComplete', 'Body', 'MessageComplete'].forEach(function (name) {\n  var k = HTTPParser['kOn' + name];\n  Object.defineProperty(HTTPParser.prototype, 'on' + name, {\n    get: function () {\n      return this[k];\n    },\n    set: function (to) {\n      // hack for backward compatibility\n      this._compatMode0_11 = true;\n      method_connect = 'CONNECT';\n      return (this[k] = to);\n    }\n  });\n});\n\nfunction parseErrorCode(code) {\n  var err = new Error('Parse Error');\n  err.code = code;\n  return err;\n}\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! assert */ \"assert\");\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __nested_webpack_require_164841__) {\n\n\"use strict\";\n\n\nvar Parser   = __nested_webpack_require_164841__(30),\n    Pipeline = __nested_webpack_require_164841__(31);\n\nvar Extensions = function() {\n  this._rsv1 = this._rsv2 = this._rsv3 = null;\n\n  this._byName   = {};\n  this._inOrder  = [];\n  this._sessions = [];\n  this._index    = {};\n};\n\nExtensions.MESSAGE_OPCODES = [1, 2];\n\nvar instance = {\n  add: function(ext) {\n    if (typeof ext.name !== 'string') throw new TypeError('extension.name must be a string');\n    if (ext.type !== 'permessage') throw new TypeError('extension.type must be \"permessage\"');\n\n    if (typeof ext.rsv1 !== 'boolean') throw new TypeError('extension.rsv1 must be true or false');\n    if (typeof ext.rsv2 !== 'boolean') throw new TypeError('extension.rsv2 must be true or false');\n    if (typeof ext.rsv3 !== 'boolean') throw new TypeError('extension.rsv3 must be true or false');\n\n    if (this._byName.hasOwnProperty(ext.name))\n      throw new TypeError('An extension with name \"' + ext.name + '\" is already registered');\n\n    this._byName[ext.name] = ext;\n    this._inOrder.push(ext);\n  },\n\n  generateOffer: function() {\n    var sessions = [],\n        offer    = [],\n        index    = {};\n\n    this._inOrder.forEach(function(ext) {\n      var session = ext.createClientSession();\n      if (!session) return;\n\n      var record = [ext, session];\n      sessions.push(record);\n      index[ext.name] = record;\n\n      var offers = session.generateOffer();\n      offers = offers ? [].concat(offers) : [];\n\n      offers.forEach(function(off) {\n        offer.push(Parser.serializeParams(ext.name, off));\n      }, this);\n    }, this);\n\n    this._sessions = sessions;\n    this._index    = index;\n\n    return offer.length > 0 ? offer.join(', ') : null;\n  },\n\n  activate: function(header) {\n    var responses = Parser.parseHeader(header),\n        sessions  = [];\n\n    responses.eachOffer(function(name, params) {\n      var record = this._index[name];\n\n      if (!record)\n        throw new Error('Server sent an extension response for unknown extension \"' + name + '\"');\n\n      var ext      = record[0],\n          session  = record[1],\n          reserved = this._reserved(ext);\n\n      if (reserved)\n        throw new Error('Server sent two extension responses that use the RSV' +\n                        reserved[0] + ' bit: \"' +\n                        reserved[1] + '\" and \"' + ext.name + '\"');\n\n      if (session.activate(params) !== true)\n        throw new Error('Server sent unacceptable extension parameters: ' +\n                        Parser.serializeParams(name, params));\n\n      this._reserve(ext);\n      sessions.push(record);\n    }, this);\n\n    this._sessions = sessions;\n    this._pipeline = new Pipeline(sessions);\n  },\n\n  generateResponse: function(header) {\n    var sessions = [],\n        response = [],\n        offers   = Parser.parseHeader(header);\n\n    this._inOrder.forEach(function(ext) {\n      var offer = offers.byName(ext.name);\n      if (offer.length === 0 || this._reserved(ext)) return;\n\n      var session = ext.createServerSession(offer);\n      if (!session) return;\n\n      this._reserve(ext);\n      sessions.push([ext, session]);\n      response.push(Parser.serializeParams(ext.name, session.generateResponse()));\n    }, this);\n\n    this._sessions = sessions;\n    this._pipeline = new Pipeline(sessions);\n\n    return response.length > 0 ? response.join(', ') : null;\n  },\n\n  validFrameRsv: function(frame) {\n    var allowed = { rsv1: false, rsv2: false, rsv3: false },\n        ext;\n\n    if (Extensions.MESSAGE_OPCODES.indexOf(frame.opcode) >= 0) {\n      for (var i = 0, n = this._sessions.length; i < n; i++) {\n        ext = this._sessions[i][0];\n        allowed.rsv1 = allowed.rsv1 || ext.rsv1;\n        allowed.rsv2 = allowed.rsv2 || ext.rsv2;\n        allowed.rsv3 = allowed.rsv3 || ext.rsv3;\n      }\n    }\n\n    return (allowed.rsv1 || !frame.rsv1) &&\n           (allowed.rsv2 || !frame.rsv2) &&\n           (allowed.rsv3 || !frame.rsv3);\n  },\n\n  processIncomingMessage: function(message, callback, context) {\n    this._pipeline.processIncomingMessage(message, callback, context);\n  },\n\n  processOutgoingMessage: function(message, callback, context) {\n    this._pipeline.processOutgoingMessage(message, callback, context);\n  },\n\n  close: function(callback, context) {\n    if (!this._pipeline) return callback.call(context);\n    this._pipeline.close(callback, context);\n  },\n\n  _reserve: function(ext) {\n    this._rsv1 = this._rsv1 || (ext.rsv1 && ext.name);\n    this._rsv2 = this._rsv2 || (ext.rsv2 && ext.name);\n    this._rsv3 = this._rsv3 || (ext.rsv3 && ext.name);\n  },\n\n  _reserved: function(ext) {\n    if (this._rsv1 && ext.rsv1) return [1, this._rsv1];\n    if (this._rsv2 && ext.rsv2) return [2, this._rsv2];\n    if (this._rsv3 && ext.rsv3) return [3, this._rsv3];\n    return false;\n  }\n};\n\nfor (var key in instance)\n  Extensions.prototype[key] = instance[key];\n\nmodule.exports = Extensions;\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar TOKEN    = /([!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+)/,\n    NOTOKEN  = /([^!#\\$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z])/g,\n    QUOTED   = /\"((?:\\\\[\\x00-\\x7f]|[^\\x00-\\x08\\x0a-\\x1f\\x7f\"\\\\])*)\"/,\n    PARAM    = new RegExp(TOKEN.source + '(?:=(?:' + TOKEN.source + '|' + QUOTED.source + '))?'),\n    EXT      = new RegExp(TOKEN.source + '(?: *; *' + PARAM.source + ')*', 'g'),\n    EXT_LIST = new RegExp('^' + EXT.source + '(?: *, *' + EXT.source + ')*$'),\n    NUMBER   = /^-?(0|[1-9][0-9]*)(\\.[0-9]+)?$/;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar Parser = {\n  parseHeader: function(header) {\n    var offers = new Offers();\n    if (header === '' || header === undefined) return offers;\n\n    if (!EXT_LIST.test(header))\n      throw new SyntaxError('Invalid Sec-WebSocket-Extensions header: ' + header);\n\n    var values = header.match(EXT);\n\n    values.forEach(function(value) {\n      var params = value.match(new RegExp(PARAM.source, 'g')),\n          name   = params.shift(),\n          offer  = {};\n\n      params.forEach(function(param) {\n        var args = param.match(PARAM), key = args[1], data;\n\n        if (args[2] !== undefined) {\n          data = args[2];\n        } else if (args[3] !== undefined) {\n          data = args[3].replace(/\\\\/g, '');\n        } else {\n          data = true;\n        }\n        if (NUMBER.test(data)) data = parseFloat(data);\n\n        if (hasOwnProperty.call(offer, key)) {\n          offer[key] = [].concat(offer[key]);\n          offer[key].push(data);\n        } else {\n          offer[key] = data;\n        }\n      }, this);\n      offers.push(name, offer);\n    }, this);\n\n    return offers;\n  },\n\n  serializeParams: function(name, params) {\n    var values = [];\n\n    var print = function(key, value) {\n      if (value instanceof Array) {\n        value.forEach(function(v) { print(key, v) });\n      } else if (value === true) {\n        values.push(key);\n      } else if (typeof value === 'number') {\n        values.push(key + '=' + value);\n      } else if (NOTOKEN.test(value)) {\n        values.push(key + '=\"' + value.replace(/\"/g, '\\\\\"') + '\"');\n      } else {\n        values.push(key + '=' + value);\n      }\n    };\n\n    for (var key in params) print(key, params[key]);\n\n    return [name].concat(values).join('; ');\n  }\n};\n\nvar Offers = function() {\n  this._byName  = {};\n  this._inOrder = [];\n};\n\nOffers.prototype.push = function(name, params) {\n  if (!hasOwnProperty.call(this._byName, name))\n    this._byName[name] = [];\n\n  this._byName[name].push(params);\n  this._inOrder.push({ name: name, params: params });\n};\n\nOffers.prototype.eachOffer = function(callback, context) {\n  var list = this._inOrder;\n  for (var i = 0, n = list.length; i < n; i++)\n    callback.call(context, list[i].name, list[i].params);\n};\n\nOffers.prototype.byName = function(name) {\n  return this._byName[name] || [];\n};\n\nOffers.prototype.toArray = function() {\n  return this._inOrder.slice();\n};\n\nmodule.exports = Parser;\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __nested_webpack_require_172814__) {\n\n\"use strict\";\n\n\nvar Cell   = __nested_webpack_require_172814__(32),\n    Pledge = __nested_webpack_require_172814__(14);\n\nvar Pipeline = function(sessions) {\n  this._cells   = sessions.map(function(session) { return new Cell(session) });\n  this._stopped = { incoming: false, outgoing: false };\n};\n\nPipeline.prototype.processIncomingMessage = function(message, callback, context) {\n  if (this._stopped.incoming) return;\n  this._loop('incoming', this._cells.length - 1, -1, -1, message, callback, context);\n};\n\nPipeline.prototype.processOutgoingMessage = function(message, callback, context) {\n  if (this._stopped.outgoing) return;\n  this._loop('outgoing', 0, this._cells.length, 1, message, callback, context);\n};\n\nPipeline.prototype.close = function(callback, context) {\n  this._stopped = { incoming: true, outgoing: true };\n\n  var closed = this._cells.map(function(a) { return a.close() });\n  if (callback)\n    Pledge.all(closed).then(function() { callback.call(context) });\n};\n\nPipeline.prototype._loop = function(direction, start, end, step, message, callback, context) {\n  var cells = this._cells,\n      n     = cells.length,\n      self  = this;\n\n  while (n--) cells[n].pending(direction);\n\n  var pipe = function(index, error, msg) {\n    if (index === end) return callback.call(context, error, msg);\n\n    cells[index][direction](error, msg, function(err, m) {\n      if (err) self._stopped[direction] = true;\n      pipe(index + step, err, m);\n    });\n  };\n  pipe(start, null, message);\n};\n\nmodule.exports = Pipeline;\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __nested_webpack_require_174383__) {\n\n\"use strict\";\n\n\nvar Functor = __nested_webpack_require_174383__(33),\n    Pledge  = __nested_webpack_require_174383__(14);\n\nvar Cell = function(tuple) {\n  this._ext     = tuple[0];\n  this._session = tuple[1];\n\n  this._functors = {\n    incoming: new Functor(this._session, 'processIncomingMessage'),\n    outgoing: new Functor(this._session, 'processOutgoingMessage')\n  };\n};\n\nCell.prototype.pending = function(direction) {\n  var functor = this._functors[direction];\n  if (!functor._stopped) functor.pending += 1;\n};\n\nCell.prototype.incoming = function(error, message, callback, context) {\n  this._exec('incoming', error, message, callback, context);\n};\n\nCell.prototype.outgoing = function(error, message, callback, context) {\n  this._exec('outgoing', error, message, callback, context);\n};\n\nCell.prototype.close = function() {\n  this._closed = this._closed || new Pledge();\n  this._doClose();\n  return this._closed;\n};\n\nCell.prototype._exec = function(direction, error, message, callback, context) {\n  this._functors[direction].call(error, message, function(err, msg) {\n    if (err) err.message = this._ext.name + ': ' + err.message;\n    callback.call(context, err, msg);\n    this._doClose();\n  }, this);\n};\n\nCell.prototype._doClose = function() {\n  var fin  = this._functors.incoming,\n      fout = this._functors.outgoing;\n\n  if (!this._closed || fin.pending + fout.pending !== 0) return;\n  if (this._session) this._session.close();\n  this._session = null;\n  this._closed.done();\n};\n\nmodule.exports = Cell;\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __nested_webpack_require_175939__) {\n\n\"use strict\";\n\n\nvar RingBuffer = __nested_webpack_require_175939__(13);\n\nvar Functor = function(session, method) {\n  this._session = session;\n  this._method  = method;\n  this._queue   = new RingBuffer(Functor.QUEUE_SIZE);\n  this._stopped = false;\n  this.pending  = 0;\n};\n\nFunctor.QUEUE_SIZE = 8;\n\nFunctor.prototype.call = function(error, message, callback, context) {\n  if (this._stopped) return;\n\n  var record = { error: error, message: message, callback: callback, context: context, done: false },\n      called = false,\n      self   = this;\n\n  this._queue.push(record);\n\n  if (record.error) {\n    record.done = true;\n    this._stop();\n    return this._flushQueue();\n  }\n\n  var handler = function(err, msg) {\n    if (!(called ^ (called = true))) return;\n\n    if (err) {\n      self._stop();\n      record.error   = err;\n      record.message = null;\n    } else {\n      record.message = msg;\n    }\n\n    record.done = true;\n    self._flushQueue();\n  };\n\n  try {\n    this._session[this._method](message, handler);\n  } catch (err) {\n    handler(err);\n  }\n};\n\nFunctor.prototype._stop = function() {\n  this.pending  = this._queue.length;\n  this._stopped = true;\n};\n\nFunctor.prototype._flushQueue = function() {\n  var queue = this._queue, record;\n\n  while (queue.length > 0 && queue.peek().done) {\n    record = queue.shift();\n    if (record.error) {\n      this.pending = 0;\n      queue.clear();\n    } else {\n      this.pending -= 1;\n    }\n    record.callback.call(record.context, record.error, record.message);\n  }\n};\n\nmodule.exports = Functor;\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Frame = function() {};\n\nvar instance = {\n  final:        false,\n  rsv1:         false,\n  rsv2:         false,\n  rsv3:         false,\n  opcode:       null,\n  masked:       false,\n  maskingKey:   null,\n  lengthBytes:  1,\n  length:       0,\n  payload:      null\n};\n\nfor (var key in instance)\n  Frame.prototype[key] = instance[key];\n\nmodule.exports = Frame;\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __nested_webpack_require_177991__) {\n\n\"use strict\";\n\n\nvar Buffer = __nested_webpack_require_177991__(1).Buffer;\n\nvar Message = function() {\n  this.rsv1    = false;\n  this.rsv2    = false;\n  this.rsv3    = false;\n  this.opcode  = null;\n  this.length  = 0;\n  this._chunks = [];\n};\n\nvar instance = {\n  read: function() {\n    return this.data = this.data || Buffer.concat(this._chunks, this.length);\n  },\n\n  pushFrame: function(frame) {\n    this.rsv1 = this.rsv1 || frame.rsv1;\n    this.rsv2 = this.rsv2 || frame.rsv2;\n    this.rsv3 = this.rsv3 || frame.rsv3;\n\n    if (this.opcode === null) this.opcode = frame.opcode;\n\n    this._chunks.push(frame.payload);\n    this.length += frame.length;\n  }\n};\n\nfor (var key in instance)\n  Message.prototype[key] = instance[key];\n\nmodule.exports = Message;\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __nested_webpack_require_178807__) {\n\n\"use strict\";\n\n\nvar Buffer     = __nested_webpack_require_178807__(1).Buffer,\n    Stream     = __nested_webpack_require_178807__(5).Stream,\n    url        = __nested_webpack_require_178807__(6),\n    util       = __nested_webpack_require_178807__(0),\n    Base       = __nested_webpack_require_178807__(2),\n    Headers    = __nested_webpack_require_178807__(9),\n    HttpParser = __nested_webpack_require_178807__(10);\n\nvar PORTS = { 'ws:': 80, 'wss:': 443 };\n\nvar Proxy = function(client, origin, options) {\n  this._client  = client;\n  this._http    = new HttpParser('response');\n  this._origin  = (typeof client.url === 'object') ? client.url : url.parse(client.url);\n  this._url     = (typeof origin === 'object') ? origin : url.parse(origin);\n  this._options = options || {};\n  this._state   = 0;\n\n  this.readable = this.writable = true;\n  this._paused  = false;\n\n  this._headers = new Headers();\n  this._headers.set('Host', this._origin.host);\n  this._headers.set('Connection', 'keep-alive');\n  this._headers.set('Proxy-Connection', 'keep-alive');\n\n  var auth = this._url.auth && Buffer.from(this._url.auth, 'utf8').toString('base64');\n  if (auth) this._headers.set('Proxy-Authorization', 'Basic ' + auth);\n};\nutil.inherits(Proxy, Stream);\n\nvar instance = {\n  setHeader: function(name, value) {\n    if (this._state !== 0) return false;\n    this._headers.set(name, value);\n    return true;\n  },\n\n  start: function() {\n    if (this._state !== 0) return false;\n    this._state = 1;\n\n    var origin = this._origin,\n        port   = origin.port || PORTS[origin.protocol],\n        start  = 'CONNECT ' + origin.hostname + ':' + port + ' HTTP/1.1';\n\n    var headers = [start, this._headers.toString(), ''];\n\n    this.emit('data', Buffer.from(headers.join('\\r\\n'), 'utf8'));\n    return true;\n  },\n\n  pause: function() {\n    this._paused = true;\n  },\n\n  resume: function() {\n    this._paused = false;\n    this.emit('drain');\n  },\n\n  write: function(chunk) {\n    if (!this.writable) return false;\n\n    this._http.parse(chunk);\n    if (!this._http.isComplete()) return !this._paused;\n\n    this.statusCode = this._http.statusCode;\n    this.headers    = this._http.headers;\n\n    if (this.statusCode === 200) {\n      this.emit('connect', new Base.ConnectEvent());\n    } else {\n      var message = \"Can't establish a connection to the server at \" + this._origin.href;\n      this.emit('error', new Error(message));\n    }\n    this.end();\n    return !this._paused;\n  },\n\n  end: function(chunk) {\n    if (!this.writable) return;\n    if (chunk !== undefined) this.write(chunk);\n    this.readable = this.writable = false;\n    this.emit('close');\n    this.emit('end');\n  },\n\n  destroy: function() {\n    this.end();\n  }\n};\n\nfor (var key in instance)\n  Proxy.prototype[key] = instance[key];\n\nmodule.exports = Proxy;\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __nested_webpack_require_181580__) {\n\n\"use strict\";\n\n\nvar util       = __nested_webpack_require_181580__(0),\n    HttpParser = __nested_webpack_require_181580__(10),\n    Base       = __nested_webpack_require_181580__(2),\n    Draft75    = __nested_webpack_require_181580__(15),\n    Draft76    = __nested_webpack_require_181580__(38),\n    Hybi       = __nested_webpack_require_181580__(12);\n\nvar Server = function(options) {\n  Base.call(this, null, null, options);\n  this._http = new HttpParser('request');\n};\nutil.inherits(Server, Base);\n\nvar instance = {\n  EVENTS: ['open', 'message', 'error', 'close', 'ping', 'pong'],\n\n  _bindEventListeners: function() {\n    this.messages.on('error', function() {});\n    this.on('error', function() {});\n  },\n\n  parse: function(chunk) {\n    if (this._delegate) return this._delegate.parse(chunk);\n\n    this._http.parse(chunk);\n    if (!this._http.isComplete()) return;\n\n    this.method  = this._http.method;\n    this.url     = this._http.url;\n    this.headers = this._http.headers;\n    this.body    = this._http.body;\n\n    var self = this;\n    this._delegate = Server.http(this, this._options);\n    this._delegate.messages = this.messages;\n    this._delegate.io = this.io;\n    this._open();\n\n    this.EVENTS.forEach(function(event) {\n      this._delegate.on(event, function(e) { self.emit(event, e) });\n    }, this);\n\n    this.protocol = this._delegate.protocol;\n    this.version  = this._delegate.version;\n\n    this.parse(this._http.body);\n    this.emit('connect', new Base.ConnectEvent());\n  },\n\n  _open: function() {\n    this.__queue.forEach(function(msg) {\n      this._delegate[msg[0]].apply(this._delegate, msg[1]);\n    }, this);\n    this.__queue = [];\n  }\n};\n\n['addExtension', 'setHeader', 'start', 'frame', 'text', 'binary', 'ping', 'close'].forEach(function(method) {\n  instance[method] = function() {\n    if (this._delegate) {\n      return this._delegate[method].apply(this._delegate, arguments);\n    } else {\n      this.__queue.push([method, arguments]);\n      return true;\n    }\n  };\n});\n\nfor (var key in instance)\n  Server.prototype[key] = instance[key];\n\nServer.isSecureRequest = function(request) {\n  if (request.connection && request.connection.authorized !== undefined) return true;\n  if (request.socket && request.socket.secure) return true;\n\n  var headers = request.headers;\n  if (!headers) return false;\n  if (headers['https'] === 'on') return true;\n  if (headers['x-forwarded-ssl'] === 'on') return true;\n  if (headers['x-forwarded-scheme'] === 'https') return true;\n  if (headers['x-forwarded-proto'] === 'https') return true;\n\n  return false;\n};\n\nServer.determineUrl = function(request) {\n  var scheme = this.isSecureRequest(request) ? 'wss:' : 'ws:';\n  return scheme + '//' + request.headers.host + request.url;\n};\n\nServer.http = function(request, options) {\n  options = options || {};\n  if (options.requireMasking === undefined) options.requireMasking = true;\n\n  var headers = request.headers,\n      version = headers['sec-websocket-version'],\n      key     = headers['sec-websocket-key'],\n      key1    = headers['sec-websocket-key1'],\n      key2    = headers['sec-websocket-key2'],\n      url     = this.determineUrl(request);\n\n  if (version || key)\n    return new Hybi(request, url, options);\n  else if (key1 || key2)\n    return new Draft76(request, url, options);\n  else\n    return new Draft75(request, url, options);\n};\n\nmodule.exports = Server;\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __nested_webpack_require_184945__) {\n\n\"use strict\";\n\n\nvar Buffer  = __nested_webpack_require_184945__(1).Buffer,\n    Base    = __nested_webpack_require_184945__(2),\n    Draft75 = __nested_webpack_require_184945__(15),\n    crypto  = __nested_webpack_require_184945__(3),\n    util    = __nested_webpack_require_184945__(0);\n\n\nvar numberFromKey = function(key) {\n  return parseInt((key.match(/[0-9]/g) || []).join(''), 10);\n};\n\nvar spacesInKey = function(key) {\n  return (key.match(/ /g) || []).length;\n};\n\n\nvar Draft76 = function(request, url, options) {\n  Draft75.apply(this, arguments);\n  this._stage  = -1;\n  this._body   = [];\n  this.version = 'hixie-76';\n\n  this._headers.clear();\n\n  this._headers.set('Upgrade', 'WebSocket');\n  this._headers.set('Connection', 'Upgrade');\n  this._headers.set('Sec-WebSocket-Origin', this._request.headers.origin);\n  this._headers.set('Sec-WebSocket-Location', this.url);\n};\nutil.inherits(Draft76, Draft75);\n\nvar instance = {\n  BODY_SIZE: 8,\n\n  start: function() {\n    if (!Draft75.prototype.start.call(this)) return false;\n    this._started = true;\n    this._sendHandshakeBody();\n    return true;\n  },\n\n  close: function() {\n    if (this.readyState === 3) return false;\n    if (this.readyState === 1) this._write(Buffer.from([0xFF, 0x00]));\n    this.readyState = 3;\n    this.emit('close', new Base.CloseEvent(null, null));\n    return true;\n  },\n\n  _handshakeResponse: function() {\n    var headers = this._request.headers,\n        key1    = headers['sec-websocket-key1'],\n        key2    = headers['sec-websocket-key2'];\n\n    if (!key1) throw new Error('Missing required header: Sec-WebSocket-Key1');\n    if (!key2) throw new Error('Missing required header: Sec-WebSocket-Key2');\n\n    var number1 = numberFromKey(key1),\n        spaces1 = spacesInKey(key1),\n\n        number2 = numberFromKey(key2),\n        spaces2 = spacesInKey(key2);\n\n    if (number1 % spaces1 !== 0 || number2 % spaces2 !== 0)\n      throw new Error('Client sent invalid Sec-WebSocket-Key headers');\n\n    this._keyValues = [number1 / spaces1, number2 / spaces2];\n\n    var start   = 'HTTP/1.1 101 WebSocket Protocol Handshake',\n        headers = [start, this._headers.toString(), ''];\n\n    return Buffer.from(headers.join('\\r\\n'), 'binary');\n  },\n\n  _handshakeSignature: function() {\n    if (this._body.length < this.BODY_SIZE) return null;\n\n    var md5    = crypto.createHash('md5'),\n        buffer = Buffer.allocUnsafe(8 + this.BODY_SIZE);\n\n    buffer.writeUInt32BE(this._keyValues[0], 0);\n    buffer.writeUInt32BE(this._keyValues[1], 4);\n    Buffer.from(this._body).copy(buffer, 8, 0, this.BODY_SIZE);\n\n    md5.update(buffer);\n    return Buffer.from(md5.digest('binary'), 'binary');\n  },\n\n  _sendHandshakeBody: function() {\n    if (!this._started) return;\n    var signature = this._handshakeSignature();\n    if (!signature) return;\n\n    this._write(signature);\n    this._stage = 0;\n    this._open();\n\n    if (this._body.length > this.BODY_SIZE)\n      this.parse(this._body.slice(this.BODY_SIZE));\n  },\n\n  _parseLeadingByte: function(octet) {\n    if (octet !== 0xFF)\n      return Draft75.prototype._parseLeadingByte.call(this, octet);\n\n    this._closing = true;\n    this._length  = 0;\n    this._stage   = 1;\n  }\n};\n\nfor (var key in instance)\n  Draft76.prototype[key] = instance[key];\n\nmodule.exports = Draft76;\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __nested_webpack_require_188230__) {\n\n\"use strict\";\n\n\nvar util   = __nested_webpack_require_188230__(0),\n    net    = __nested_webpack_require_188230__(40),\n    tls    = __nested_webpack_require_188230__(41),\n    url    = __nested_webpack_require_188230__(6),\n    driver = __nested_webpack_require_188230__(4),\n    API    = __nested_webpack_require_188230__(11),\n    Event  = __nested_webpack_require_188230__(7);\n\nvar DEFAULT_PORTS    = {'http:': 80, 'https:': 443, 'ws:':80, 'wss:': 443},\n    SECURE_PROTOCOLS = ['https:', 'wss:'];\n\nvar Client = function(_url, protocols, options) {\n  options = options || {};\n\n  this.url     = _url;\n  this._driver = driver.client(this.url, {maxLength: options.maxLength, protocols: protocols});\n\n  ['open', 'error'].forEach(function(event) {\n    this._driver.on(event, function() {\n      self.headers    = self._driver.headers;\n      self.statusCode = self._driver.statusCode;\n    });\n  }, this);\n\n  var proxy      = options.proxy || {},\n      endpoint   = url.parse(proxy.origin || this.url),\n      port       = endpoint.port || DEFAULT_PORTS[endpoint.protocol],\n      secure     = SECURE_PROTOCOLS.indexOf(endpoint.protocol) >= 0,\n      onConnect  = function() { self._onConnect() },\n      netOptions = options.net || {},\n      originTLS  = options.tls || {},\n      socketTLS  = proxy.origin ? (proxy.tls || {}) : originTLS,\n      self       = this;\n\n  netOptions.host = socketTLS.host = endpoint.hostname;\n  netOptions.port = socketTLS.port = port;\n\n  originTLS.ca = originTLS.ca || options.ca;\n  socketTLS.servername = socketTLS.servername || endpoint.hostname;\n\n  this._stream = secure\n               ? tls.connect(socketTLS, onConnect)\n               : net.connect(netOptions, onConnect);\n\n  if (proxy.origin) this._configureProxy(proxy, originTLS);\n\n  API.call(this, options);\n};\nutil.inherits(Client, API);\n\nClient.prototype._onConnect = function() {\n  var worker = this._proxy || this._driver;\n  worker.start();\n};\n\nClient.prototype._configureProxy = function(proxy, originTLS) {\n  var uri    = url.parse(this.url),\n      secure = SECURE_PROTOCOLS.indexOf(uri.protocol) >= 0,\n      self   = this,\n      name;\n\n  this._proxy = this._driver.proxy(proxy.origin);\n\n  if (proxy.headers) {\n    for (name in proxy.headers) this._proxy.setHeader(name, proxy.headers[name]);\n  }\n\n  this._proxy.pipe(this._stream, {end: false});\n  this._stream.pipe(this._proxy);\n\n  this._proxy.on('connect', function() {\n    if (secure) {\n      var options = {socket: self._stream, servername: uri.hostname};\n      for (name in originTLS) options[name] = originTLS[name];\n      self._stream = tls.connect(options);\n      self._configureStream();\n    }\n    self._driver.io.pipe(self._stream);\n    self._stream.pipe(self._driver.io);\n    self._driver.start();\n  });\n\n  this._proxy.on('error', function(error) {\n    self._driver.emit('error', error);\n  });\n};\n\nmodule.exports = Client;\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! net */ \"net\");\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! tls */ \"tls\");\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __nested_webpack_require_191253__) {\n\n\"use strict\";\n\n\nvar Stream      = __nested_webpack_require_191253__(5).Stream,\n    util        = __nested_webpack_require_191253__(0),\n    driver      = __nested_webpack_require_191253__(4),\n    Headers     = __nested_webpack_require_191253__(9),\n    API         = __nested_webpack_require_191253__(11),\n    EventTarget = __nested_webpack_require_191253__(16),\n    Event       = __nested_webpack_require_191253__(7);\n\nvar EventSource = function(request, response, options) {\n  this.writable = true;\n  options = options || {};\n\n  this._stream = response.socket;\n  this._ping   = options.ping  || this.DEFAULT_PING;\n  this._retry  = options.retry || this.DEFAULT_RETRY;\n\n  var scheme       = driver.isSecureRequest(request) ? 'https:' : 'http:';\n  this.url         = scheme + '//' + request.headers.host + request.url;\n  this.lastEventId = request.headers['last-event-id'] || '';\n  this.readyState  = API.CONNECTING;\n\n  var headers = new Headers(),\n      self    = this;\n\n  if (options.headers) {\n    for (var key in options.headers) headers.set(key, options.headers[key]);\n  }\n\n  if (!this._stream || !this._stream.writable) return;\n  process.nextTick(function() { self._open() });\n\n  this._stream.setTimeout(0);\n  this._stream.setNoDelay(true);\n\n  var handshake = 'HTTP/1.1 200 OK\\r\\n' +\n                  'Content-Type: text/event-stream\\r\\n' +\n                  'Cache-Control: no-cache, no-store\\r\\n' +\n                  'Connection: close\\r\\n' +\n                  headers.toString() +\n                  '\\r\\n' +\n                  'retry: ' + Math.floor(this._retry * 1000) + '\\r\\n\\r\\n';\n\n  this._write(handshake);\n\n  this._stream.on('drain', function() { self.emit('drain') });\n\n  if (this._ping)\n    this._pingTimer = setInterval(function() { self.ping() }, this._ping * 1000);\n\n  ['error', 'end'].forEach(function(event) {\n    self._stream.on(event, function() { self.close() });\n  });\n};\nutil.inherits(EventSource, Stream);\n\nEventSource.isEventSource = function(request) {\n  if (request.method !== 'GET') return false;\n  var accept = (request.headers.accept || '').split(/\\s*,\\s*/);\n  return accept.indexOf('text/event-stream') >= 0;\n};\n\nvar instance = {\n  DEFAULT_PING:   10,\n  DEFAULT_RETRY:  5,\n\n  _write: function(chunk) {\n    if (!this.writable) return false;\n    try {\n      return this._stream.write(chunk, 'utf8');\n    } catch (e) {\n      return false;\n    }\n  },\n\n  _open: function() {\n    if (this.readyState !== API.CONNECTING) return;\n\n    this.readyState = API.OPEN;\n\n    var event = new Event('open');\n    event.initEvent('open', false, false);\n    this.dispatchEvent(event);\n  },\n\n  write: function(message) {\n    return this.send(message);\n  },\n\n  end: function(message) {\n    if (message !== undefined) this.write(message);\n    this.close();\n  },\n\n  send: function(message, options) {\n    if (this.readyState > API.OPEN) return false;\n\n    message = String(message).replace(/(\\r\\n|\\r|\\n)/g, '$1data: ');\n    options = options || {};\n\n    var frame = '';\n    if (options.event) frame += 'event: ' + options.event + '\\r\\n';\n    if (options.id)    frame += 'id: '    + options.id    + '\\r\\n';\n    frame += 'data: ' + message + '\\r\\n\\r\\n';\n\n    return this._write(frame);\n  },\n\n  ping: function() {\n    return this._write(':\\r\\n\\r\\n');\n  },\n\n  close: function() {\n    if (this.readyState > API.OPEN) return false;\n\n    this.readyState = API.CLOSED;\n    this.writable = false;\n    if (this._pingTimer) clearInterval(this._pingTimer);\n    if (this._stream) this._stream.end();\n\n    var event = new Event('close');\n    event.initEvent('close', false, false);\n    this.dispatchEvent(event);\n\n    return true;\n  }\n};\n\nfor (var method in instance) EventSource.prototype[method] = instance[method];\nfor (var key in EventTarget) EventSource.prototype[key] = EventTarget[key];\n\nmodule.exports = EventSource;\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! child_process */ \"child_process\");\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! fs */ \"fs\");\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! http */ \"http\");\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! https */ \"https\");\n\n/***/ }),\n/* 47 */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_195432__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__nested_webpack_require_195432__.r(__nested_webpack_exports__);\n\n// EXPORTS\n__nested_webpack_require_195432__.d(__nested_webpack_exports__, \"default\", function() { return /* binding */ pusher_with_encryption_PusherWithEncryption; });\n\n// CONCATENATED MODULE: ./src/core/base64.ts\nfunction encode(s) {\n    return btoa(utob(s));\n}\nvar fromCharCode = String.fromCharCode;\nvar b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nvar b64tab = {};\nfor (var base64_i = 0, l = b64chars.length; base64_i < l; base64_i++) {\n    b64tab[b64chars.charAt(base64_i)] = base64_i;\n}\nvar cb_utob = function (c) {\n    var cc = c.charCodeAt(0);\n    return cc < 0x80\n        ? c\n        : cc < 0x800\n            ? fromCharCode(0xc0 | (cc >>> 6)) + fromCharCode(0x80 | (cc & 0x3f))\n            : fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) +\n                fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) +\n                fromCharCode(0x80 | (cc & 0x3f));\n};\nvar utob = function (u) {\n    return u.replace(/[^\\x00-\\x7F]/g, cb_utob);\n};\nvar cb_encode = function (ccc) {\n    var padlen = [0, 2, 1][ccc.length % 3];\n    var ord = (ccc.charCodeAt(0) << 16) |\n        ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) |\n        (ccc.length > 2 ? ccc.charCodeAt(2) : 0);\n    var chars = [\n        b64chars.charAt(ord >>> 18),\n        b64chars.charAt((ord >>> 12) & 63),\n        padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n        padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n    ];\n    return chars.join('');\n};\nvar btoa = global.btoa ||\n    function (b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n\n// CONCATENATED MODULE: ./src/core/utils/timers/abstract_timer.ts\nclass Timer {\n    constructor(set, clear, delay, callback) {\n        this.clear = clear;\n        this.timer = set(() => {\n            if (this.timer) {\n                this.timer = callback(this.timer);\n            }\n        }, delay);\n    }\n    isRunning() {\n        return this.timer !== null;\n    }\n    ensureAborted() {\n        if (this.timer) {\n            this.clear(this.timer);\n            this.timer = null;\n        }\n    }\n}\n/* harmony default export */ var abstract_timer = (Timer);\n\n// CONCATENATED MODULE: ./src/core/utils/timers/index.ts\n\nfunction timers_clearTimeout(timer) {\n    global.clearTimeout(timer);\n}\nfunction timers_clearInterval(timer) {\n    global.clearInterval(timer);\n}\nclass timers_OneOffTimer extends abstract_timer {\n    constructor(delay, callback) {\n        super(setTimeout, timers_clearTimeout, delay, function (timer) {\n            callback();\n            return null;\n        });\n    }\n}\nclass timers_PeriodicTimer extends abstract_timer {\n    constructor(delay, callback) {\n        super(setInterval, timers_clearInterval, delay, function (timer) {\n            callback();\n            return timer;\n        });\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/util.ts\n\nvar Util = {\n    now() {\n        if (Date.now) {\n            return Date.now();\n        }\n        else {\n            return new Date().valueOf();\n        }\n    },\n    defer(callback) {\n        return new timers_OneOffTimer(0, callback);\n    },\n    method(name, ...args) {\n        var boundArguments = Array.prototype.slice.call(arguments, 1);\n        return function (object) {\n            return object[name].apply(object, boundArguments.concat(arguments));\n        };\n    }\n};\n/* harmony default export */ var util = (Util);\n\n// CONCATENATED MODULE: ./src/core/utils/collections.ts\n\n\nfunction extend(target, ...sources) {\n    for (var i = 0; i < sources.length; i++) {\n        var extensions = sources[i];\n        for (var property in extensions) {\n            if (extensions[property] &&\n                extensions[property].constructor &&\n                extensions[property].constructor === Object) {\n                target[property] = extend(target[property] || {}, extensions[property]);\n            }\n            else {\n                target[property] = extensions[property];\n            }\n        }\n    }\n    return target;\n}\nfunction stringify() {\n    var m = ['Pusher'];\n    for (var i = 0; i < arguments.length; i++) {\n        if (typeof arguments[i] === 'string') {\n            m.push(arguments[i]);\n        }\n        else {\n            m.push(safeJSONStringify(arguments[i]));\n        }\n    }\n    return m.join(' : ');\n}\nfunction arrayIndexOf(array, item) {\n    var nativeIndexOf = Array.prototype.indexOf;\n    if (array === null) {\n        return -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) {\n        return array.indexOf(item);\n    }\n    for (var i = 0, l = array.length; i < l; i++) {\n        if (array[i] === item) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction objectApply(object, f) {\n    for (var key in object) {\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            f(object[key], key, object);\n        }\n    }\n}\nfunction keys(object) {\n    var keys = [];\n    objectApply(object, function (_, key) {\n        keys.push(key);\n    });\n    return keys;\n}\nfunction values(object) {\n    var values = [];\n    objectApply(object, function (value) {\n        values.push(value);\n    });\n    return values;\n}\nfunction apply(array, f, context) {\n    for (var i = 0; i < array.length; i++) {\n        f.call(context || global, array[i], i, array);\n    }\n}\nfunction map(array, f) {\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n        result.push(f(array[i], i, array, result));\n    }\n    return result;\n}\nfunction mapObject(object, f) {\n    var result = {};\n    objectApply(object, function (value, key) {\n        result[key] = f(value);\n    });\n    return result;\n}\nfunction filter(array, test) {\n    test =\n        test ||\n            function (value) {\n                return !!value;\n            };\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array, result)) {\n            result.push(array[i]);\n        }\n    }\n    return result;\n}\nfunction filterObject(object, test) {\n    var result = {};\n    objectApply(object, function (value, key) {\n        if ((test && test(value, key, object, result)) || Boolean(value)) {\n            result[key] = value;\n        }\n    });\n    return result;\n}\nfunction flatten(object) {\n    var result = [];\n    objectApply(object, function (value, key) {\n        result.push([key, value]);\n    });\n    return result;\n}\nfunction any(array, test) {\n    for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction collections_all(array, test) {\n    for (var i = 0; i < array.length; i++) {\n        if (!test(array[i], i, array)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction encodeParamsObject(data) {\n    return mapObject(data, function (value) {\n        if (typeof value === 'object') {\n            value = safeJSONStringify(value);\n        }\n        return encodeURIComponent(encode(value.toString()));\n    });\n}\nfunction buildQueryString(data) {\n    var params = filterObject(data, function (value) {\n        return value !== undefined;\n    });\n    var query = map(flatten(encodeParamsObject(params)), util.method('join', '=')).join('&');\n    return query;\n}\nfunction decycleObject(object) {\n    var objects = [], paths = [];\n    return (function derez(value, path) {\n        var i, name, nu;\n        switch (typeof value) {\n            case 'object':\n                if (!value) {\n                    return null;\n                }\n                for (i = 0; i < objects.length; i += 1) {\n                    if (objects[i] === value) {\n                        return { $ref: paths[i] };\n                    }\n                }\n                objects.push(value);\n                paths.push(path);\n                if (Object.prototype.toString.apply(value) === '[object Array]') {\n                    nu = [];\n                    for (i = 0; i < value.length; i += 1) {\n                        nu[i] = derez(value[i], path + '[' + i + ']');\n                    }\n                }\n                else {\n                    nu = {};\n                    for (name in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, name)) {\n                            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n                        }\n                    }\n                }\n                return nu;\n            case 'number':\n            case 'string':\n            case 'boolean':\n                return value;\n        }\n    })(object, '$');\n}\nfunction safeJSONStringify(source) {\n    try {\n        return JSON.stringify(source);\n    }\n    catch (e) {\n        return JSON.stringify(decycleObject(source));\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/defaults.ts\nvar Defaults = {\n    VERSION: \"8.3.0\",\n    PROTOCOL: 7,\n    wsPort: 80,\n    wssPort: 443,\n    wsPath: '',\n    httpHost: 'sockjs.pusher.com',\n    httpPort: 80,\n    httpsPort: 443,\n    httpPath: '/pusher',\n    stats_host: 'stats.pusher.com',\n    authEndpoint: '/pusher/auth',\n    authTransport: 'ajax',\n    activityTimeout: 120000,\n    pongTimeout: 30000,\n    unavailableTimeout: 10000,\n    userAuthentication: {\n        endpoint: '/pusher/user-auth',\n        transport: 'ajax'\n    },\n    channelAuthorization: {\n        endpoint: '/pusher/auth',\n        transport: 'ajax'\n    },\n    cdn_http: \"http://js.pusher.com\",\n    cdn_https: \"https://js.pusher.com\",\n    dependency_suffix: \"\"\n};\n/* harmony default export */ var defaults = (Defaults);\n\n// CONCATENATED MODULE: ./src/core/transports/url_schemes.ts\n\nfunction getGenericURL(baseScheme, params, path) {\n    var scheme = baseScheme + (params.useTLS ? 's' : '');\n    var host = params.useTLS ? params.hostTLS : params.hostNonTLS;\n    return scheme + '://' + host + path;\n}\nfunction getGenericPath(key, queryString) {\n    var path = '/app/' + key;\n    var query = '?protocol=' +\n        defaults.PROTOCOL +\n        '&client=js' +\n        '&version=' +\n        defaults.VERSION +\n        (queryString ? '&' + queryString : '');\n    return path + query;\n}\nvar ws = {\n    getInitial: function (key, params) {\n        var path = (params.httpPath || '') + getGenericPath(key, 'flash=false');\n        return getGenericURL('ws', params, path);\n    }\n};\nvar http = {\n    getInitial: function (key, params) {\n        var path = (params.httpPath || '/pusher') + getGenericPath(key);\n        return getGenericURL('http', params, path);\n    }\n};\nvar sockjs = {\n    getInitial: function (key, params) {\n        return getGenericURL('http', params, params.httpPath || '/pusher');\n    },\n    getPath: function (key, params) {\n        return getGenericPath(key);\n    }\n};\n\n// CONCATENATED MODULE: ./src/core/events/callback_registry.ts\n\nclass callback_registry_CallbackRegistry {\n    constructor() {\n        this._callbacks = {};\n    }\n    get(name) {\n        return this._callbacks[prefix(name)];\n    }\n    add(name, callback, context) {\n        var prefixedEventName = prefix(name);\n        this._callbacks[prefixedEventName] =\n            this._callbacks[prefixedEventName] || [];\n        this._callbacks[prefixedEventName].push({\n            fn: callback,\n            context: context\n        });\n    }\n    remove(name, callback, context) {\n        if (!name && !callback && !context) {\n            this._callbacks = {};\n            return;\n        }\n        var names = name ? [prefix(name)] : keys(this._callbacks);\n        if (callback || context) {\n            this.removeCallback(names, callback, context);\n        }\n        else {\n            this.removeAllCallbacks(names);\n        }\n    }\n    removeCallback(names, callback, context) {\n        apply(names, function (name) {\n            this._callbacks[name] = filter(this._callbacks[name] || [], function (binding) {\n                return ((callback && callback !== binding.fn) ||\n                    (context && context !== binding.context));\n            });\n            if (this._callbacks[name].length === 0) {\n                delete this._callbacks[name];\n            }\n        }, this);\n    }\n    removeAllCallbacks(names) {\n        apply(names, function (name) {\n            delete this._callbacks[name];\n        }, this);\n    }\n}\nfunction prefix(name) {\n    return '_' + name;\n}\n\n// CONCATENATED MODULE: ./src/core/events/dispatcher.ts\n\n\nclass dispatcher_Dispatcher {\n    constructor(failThrough) {\n        this.callbacks = new callback_registry_CallbackRegistry();\n        this.global_callbacks = [];\n        this.failThrough = failThrough;\n    }\n    bind(eventName, callback, context) {\n        this.callbacks.add(eventName, callback, context);\n        return this;\n    }\n    bind_global(callback) {\n        this.global_callbacks.push(callback);\n        return this;\n    }\n    unbind(eventName, callback, context) {\n        this.callbacks.remove(eventName, callback, context);\n        return this;\n    }\n    unbind_global(callback) {\n        if (!callback) {\n            this.global_callbacks = [];\n            return this;\n        }\n        this.global_callbacks = filter(this.global_callbacks || [], c => c !== callback);\n        return this;\n    }\n    unbind_all() {\n        this.unbind();\n        this.unbind_global();\n        return this;\n    }\n    emit(eventName, data, metadata) {\n        for (var i = 0; i < this.global_callbacks.length; i++) {\n            this.global_callbacks[i](eventName, data);\n        }\n        var callbacks = this.callbacks.get(eventName);\n        var args = [];\n        if (metadata) {\n            args.push(data, metadata);\n        }\n        else if (data) {\n            args.push(data);\n        }\n        if (callbacks && callbacks.length > 0) {\n            for (var i = 0; i < callbacks.length; i++) {\n                callbacks[i].fn.apply(callbacks[i].context || global, args);\n            }\n        }\n        else if (this.failThrough) {\n            this.failThrough(eventName, data);\n        }\n        return this;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/logger.ts\n\n\nclass logger_Logger {\n    constructor() {\n        this.globalLog = (message) => {\n            if (global.console && global.console.log) {\n                global.console.log(message);\n            }\n        };\n    }\n    debug(...args) {\n        this.log(this.globalLog, args);\n    }\n    warn(...args) {\n        this.log(this.globalLogWarn, args);\n    }\n    error(...args) {\n        this.log(this.globalLogError, args);\n    }\n    globalLogWarn(message) {\n        if (global.console && global.console.warn) {\n            global.console.warn(message);\n        }\n        else {\n            this.globalLog(message);\n        }\n    }\n    globalLogError(message) {\n        if (global.console && global.console.error) {\n            global.console.error(message);\n        }\n        else {\n            this.globalLogWarn(message);\n        }\n    }\n    log(defaultLoggingFunction, ...args) {\n        var message = stringify.apply(this, arguments);\n        if (core_pusher.log) {\n            core_pusher.log(message);\n        }\n        else if (core_pusher.logToConsole) {\n            const log = defaultLoggingFunction.bind(this);\n            log(message);\n        }\n    }\n}\n/* harmony default export */ var logger = (new logger_Logger());\n\n// CONCATENATED MODULE: ./src/core/transports/transport_connection.ts\n\n\n\n\n\nclass transport_connection_TransportConnection extends dispatcher_Dispatcher {\n    constructor(hooks, name, priority, key, options) {\n        super();\n        this.initialize = node_runtime.transportConnectionInitializer;\n        this.hooks = hooks;\n        this.name = name;\n        this.priority = priority;\n        this.key = key;\n        this.options = options;\n        this.state = 'new';\n        this.timeline = options.timeline;\n        this.activityTimeout = options.activityTimeout;\n        this.id = this.timeline.generateUniqueID();\n    }\n    handlesActivityChecks() {\n        return Boolean(this.hooks.handlesActivityChecks);\n    }\n    supportsPing() {\n        return Boolean(this.hooks.supportsPing);\n    }\n    connect() {\n        if (this.socket || this.state !== 'initialized') {\n            return false;\n        }\n        var url = this.hooks.urls.getInitial(this.key, this.options);\n        try {\n            this.socket = this.hooks.getSocket(url, this.options);\n        }\n        catch (e) {\n            util.defer(() => {\n                this.onError(e);\n                this.changeState('closed');\n            });\n            return false;\n        }\n        this.bindListeners();\n        logger.debug('Connecting', { transport: this.name, url });\n        this.changeState('connecting');\n        return true;\n    }\n    close() {\n        if (this.socket) {\n            this.socket.close();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    send(data) {\n        if (this.state === 'open') {\n            util.defer(() => {\n                if (this.socket) {\n                    this.socket.send(data);\n                }\n            });\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    ping() {\n        if (this.state === 'open' && this.supportsPing()) {\n            this.socket.ping();\n        }\n    }\n    onOpen() {\n        if (this.hooks.beforeOpen) {\n            this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));\n        }\n        this.changeState('open');\n        this.socket.onopen = undefined;\n    }\n    onError(error) {\n        this.emit('error', { type: 'WebSocketError', error: error });\n        this.timeline.error(this.buildTimelineMessage({ error: error.toString() }));\n    }\n    onClose(closeEvent) {\n        if (closeEvent) {\n            this.changeState('closed', {\n                code: closeEvent.code,\n                reason: closeEvent.reason,\n                wasClean: closeEvent.wasClean\n            });\n        }\n        else {\n            this.changeState('closed');\n        }\n        this.unbindListeners();\n        this.socket = undefined;\n    }\n    onMessage(message) {\n        this.emit('message', message);\n    }\n    onActivity() {\n        this.emit('activity');\n    }\n    bindListeners() {\n        this.socket.onopen = () => {\n            this.onOpen();\n        };\n        this.socket.onerror = error => {\n            this.onError(error);\n        };\n        this.socket.onclose = closeEvent => {\n            this.onClose(closeEvent);\n        };\n        this.socket.onmessage = message => {\n            this.onMessage(message);\n        };\n        if (this.supportsPing()) {\n            this.socket.onactivity = () => {\n                this.onActivity();\n            };\n        }\n    }\n    unbindListeners() {\n        if (this.socket) {\n            this.socket.onopen = undefined;\n            this.socket.onerror = undefined;\n            this.socket.onclose = undefined;\n            this.socket.onmessage = undefined;\n            if (this.supportsPing()) {\n                this.socket.onactivity = undefined;\n            }\n        }\n    }\n    changeState(state, params) {\n        this.state = state;\n        this.timeline.info(this.buildTimelineMessage({\n            state: state,\n            params: params\n        }));\n        this.emit(state, params);\n    }\n    buildTimelineMessage(message) {\n        return extend({ cid: this.id }, message);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/transports/transport.ts\n\nclass transport_Transport {\n    constructor(hooks) {\n        this.hooks = hooks;\n    }\n    isSupported(environment) {\n        return this.hooks.isSupported(environment);\n    }\n    createConnection(name, priority, key, options) {\n        return new transport_connection_TransportConnection(this.hooks, name, priority, key, options);\n    }\n}\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transports.ts\n\n\n\n\nvar WSTransport = new transport_Transport({\n    urls: ws,\n    handlesActivityChecks: false,\n    supportsPing: false,\n    isInitialized: function () {\n        return Boolean(node_runtime.getWebSocketAPI());\n    },\n    isSupported: function () {\n        return Boolean(node_runtime.getWebSocketAPI());\n    },\n    getSocket: function (url) {\n        return node_runtime.createWebSocket(url);\n    }\n});\nvar httpConfiguration = {\n    urls: http,\n    handlesActivityChecks: false,\n    supportsPing: true,\n    isInitialized: function () {\n        return true;\n    }\n};\nvar streamingConfiguration = extend({\n    getSocket: function (url) {\n        return node_runtime.HTTPFactory.createStreamingSocket(url);\n    }\n}, httpConfiguration);\nvar pollingConfiguration = extend({\n    getSocket: function (url) {\n        return node_runtime.HTTPFactory.createPollingSocket(url);\n    }\n}, httpConfiguration);\nvar xhrConfiguration = {\n    isSupported: function () {\n        return node_runtime.isXHRSupported();\n    }\n};\nvar XHRStreamingTransport = new transport_Transport((extend({}, streamingConfiguration, xhrConfiguration)));\nvar XHRPollingTransport = new transport_Transport(extend({}, pollingConfiguration, xhrConfiguration));\nvar Transports = {\n    ws: WSTransport,\n    xhr_streaming: XHRStreamingTransport,\n    xhr_polling: XHRPollingTransport\n};\n/* harmony default export */ var transports = (Transports);\n\n// CONCATENATED MODULE: ./src/core/transports/assistant_to_the_transport_manager.ts\n\n\nclass assistant_to_the_transport_manager_AssistantToTheTransportManager {\n    constructor(manager, transport, options) {\n        this.manager = manager;\n        this.transport = transport;\n        this.minPingDelay = options.minPingDelay;\n        this.maxPingDelay = options.maxPingDelay;\n        this.pingDelay = undefined;\n    }\n    createConnection(name, priority, key, options) {\n        options = extend({}, options, {\n            activityTimeout: this.pingDelay\n        });\n        var connection = this.transport.createConnection(name, priority, key, options);\n        var openTimestamp = null;\n        var onOpen = function () {\n            connection.unbind('open', onOpen);\n            connection.bind('closed', onClosed);\n            openTimestamp = util.now();\n        };\n        var onClosed = closeEvent => {\n            connection.unbind('closed', onClosed);\n            if (closeEvent.code === 1002 || closeEvent.code === 1003) {\n                this.manager.reportDeath();\n            }\n            else if (!closeEvent.wasClean && openTimestamp) {\n                var lifespan = util.now() - openTimestamp;\n                if (lifespan < 2 * this.maxPingDelay) {\n                    this.manager.reportDeath();\n                    this.pingDelay = Math.max(lifespan / 2, this.minPingDelay);\n                }\n            }\n        };\n        connection.bind('open', onOpen);\n        return connection;\n    }\n    isSupported(environment) {\n        return this.manager.isAlive() && this.transport.isSupported(environment);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/connection/protocol/protocol.ts\nconst Protocol = {\n    decodeMessage: function (messageEvent) {\n        try {\n            var messageData = JSON.parse(messageEvent.data);\n            var pusherEventData = messageData.data;\n            if (typeof pusherEventData === 'string') {\n                try {\n                    pusherEventData = JSON.parse(messageData.data);\n                }\n                catch (e) { }\n            }\n            var pusherEvent = {\n                event: messageData.event,\n                channel: messageData.channel,\n                data: pusherEventData\n            };\n            if (messageData.user_id) {\n                pusherEvent.user_id = messageData.user_id;\n            }\n            return pusherEvent;\n        }\n        catch (e) {\n            throw { type: 'MessageParseError', error: e, data: messageEvent.data };\n        }\n    },\n    encodeMessage: function (event) {\n        return JSON.stringify(event);\n    },\n    processHandshake: function (messageEvent) {\n        var message = Protocol.decodeMessage(messageEvent);\n        if (message.event === 'pusher:connection_established') {\n            if (!message.data.activity_timeout) {\n                throw 'No activity timeout specified in handshake';\n            }\n            return {\n                action: 'connected',\n                id: message.data.socket_id,\n                activityTimeout: message.data.activity_timeout * 1000\n            };\n        }\n        else if (message.event === 'pusher:error') {\n            return {\n                action: this.getCloseAction(message.data),\n                error: this.getCloseError(message.data)\n            };\n        }\n        else {\n            throw 'Invalid handshake';\n        }\n    },\n    getCloseAction: function (closeEvent) {\n        if (closeEvent.code < 4000) {\n            if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {\n                return 'backoff';\n            }\n            else {\n                return null;\n            }\n        }\n        else if (closeEvent.code === 4000) {\n            return 'tls_only';\n        }\n        else if (closeEvent.code < 4100) {\n            return 'refused';\n        }\n        else if (closeEvent.code < 4200) {\n            return 'backoff';\n        }\n        else if (closeEvent.code < 4300) {\n            return 'retry';\n        }\n        else {\n            return 'refused';\n        }\n    },\n    getCloseError: function (closeEvent) {\n        if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {\n            return {\n                type: 'PusherError',\n                data: {\n                    code: closeEvent.code,\n                    message: closeEvent.reason || closeEvent.message\n                }\n            };\n        }\n        else {\n            return null;\n        }\n    }\n};\n/* harmony default export */ var protocol = (Protocol);\n\n// CONCATENATED MODULE: ./src/core/connection/connection.ts\n\n\n\n\nclass connection_Connection extends dispatcher_Dispatcher {\n    constructor(id, transport) {\n        super();\n        this.id = id;\n        this.transport = transport;\n        this.activityTimeout = transport.activityTimeout;\n        this.bindListeners();\n    }\n    handlesActivityChecks() {\n        return this.transport.handlesActivityChecks();\n    }\n    send(data) {\n        return this.transport.send(data);\n    }\n    send_event(name, data, channel) {\n        var event = { event: name, data: data };\n        if (channel) {\n            event.channel = channel;\n        }\n        logger.debug('Event sent', event);\n        return this.send(protocol.encodeMessage(event));\n    }\n    ping() {\n        if (this.transport.supportsPing()) {\n            this.transport.ping();\n        }\n        else {\n            this.send_event('pusher:ping', {});\n        }\n    }\n    close() {\n        this.transport.close();\n    }\n    bindListeners() {\n        var listeners = {\n            message: (messageEvent) => {\n                var pusherEvent;\n                try {\n                    pusherEvent = protocol.decodeMessage(messageEvent);\n                }\n                catch (e) {\n                    this.emit('error', {\n                        type: 'MessageParseError',\n                        error: e,\n                        data: messageEvent.data\n                    });\n                }\n                if (pusherEvent !== undefined) {\n                    logger.debug('Event recd', pusherEvent);\n                    switch (pusherEvent.event) {\n                        case 'pusher:error':\n                            this.emit('error', {\n                                type: 'PusherError',\n                                data: pusherEvent.data\n                            });\n                            break;\n                        case 'pusher:ping':\n                            this.emit('ping');\n                            break;\n                        case 'pusher:pong':\n                            this.emit('pong');\n                            break;\n                    }\n                    this.emit('message', pusherEvent);\n                }\n            },\n            activity: () => {\n                this.emit('activity');\n            },\n            error: error => {\n                this.emit('error', error);\n            },\n            closed: closeEvent => {\n                unbindListeners();\n                if (closeEvent && closeEvent.code) {\n                    this.handleCloseEvent(closeEvent);\n                }\n                this.transport = null;\n                this.emit('closed');\n            }\n        };\n        var unbindListeners = () => {\n            objectApply(listeners, (listener, event) => {\n                this.transport.unbind(event, listener);\n            });\n        };\n        objectApply(listeners, (listener, event) => {\n            this.transport.bind(event, listener);\n        });\n    }\n    handleCloseEvent(closeEvent) {\n        var action = protocol.getCloseAction(closeEvent);\n        var error = protocol.getCloseError(closeEvent);\n        if (error) {\n            this.emit('error', error);\n        }\n        if (action) {\n            this.emit(action, { action: action, error: error });\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/connection/handshake/index.ts\n\n\n\nclass handshake_Handshake {\n    constructor(transport, callback) {\n        this.transport = transport;\n        this.callback = callback;\n        this.bindListeners();\n    }\n    close() {\n        this.unbindListeners();\n        this.transport.close();\n    }\n    bindListeners() {\n        this.onMessage = m => {\n            this.unbindListeners();\n            var result;\n            try {\n                result = protocol.processHandshake(m);\n            }\n            catch (e) {\n                this.finish('error', { error: e });\n                this.transport.close();\n                return;\n            }\n            if (result.action === 'connected') {\n                this.finish('connected', {\n                    connection: new connection_Connection(result.id, this.transport),\n                    activityTimeout: result.activityTimeout\n                });\n            }\n            else {\n                this.finish(result.action, { error: result.error });\n                this.transport.close();\n            }\n        };\n        this.onClosed = closeEvent => {\n            this.unbindListeners();\n            var action = protocol.getCloseAction(closeEvent) || 'backoff';\n            var error = protocol.getCloseError(closeEvent);\n            this.finish(action, { error: error });\n        };\n        this.transport.bind('message', this.onMessage);\n        this.transport.bind('closed', this.onClosed);\n    }\n    unbindListeners() {\n        this.transport.unbind('message', this.onMessage);\n        this.transport.unbind('closed', this.onClosed);\n    }\n    finish(action, params) {\n        this.callback(extend({ transport: this.transport, action: action }, params));\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/timeline/timeline_sender.ts\n\nclass timeline_sender_TimelineSender {\n    constructor(timeline, options) {\n        this.timeline = timeline;\n        this.options = options || {};\n    }\n    send(useTLS, callback) {\n        if (this.timeline.isEmpty()) {\n            return;\n        }\n        this.timeline.send(node_runtime.TimelineTransport.getAgent(this, useTLS), callback);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/errors.ts\nclass BadEventName extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass BadChannelName extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass RequestTimedOut extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass TransportPriorityTooLow extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass TransportClosed extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass UnsupportedFeature extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass UnsupportedTransport extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass UnsupportedStrategy extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass HTTPAuthError extends Error {\n    constructor(status, msg) {\n        super(msg);\n        this.status = status;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/utils/url_store.ts\nconst urlStore = {\n    baseUrl: 'https://pusher.com',\n    urls: {\n        authenticationEndpoint: {\n            path: '/docs/channels/server_api/authenticating_users'\n        },\n        authorizationEndpoint: {\n            path: '/docs/channels/server_api/authorizing-users/'\n        },\n        javascriptQuickStart: {\n            path: '/docs/javascript_quick_start'\n        },\n        triggeringClientEvents: {\n            path: '/docs/client_api_guide/client_events#trigger-events'\n        },\n        encryptedChannelSupport: {\n            fullUrl: 'https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support'\n        }\n    }\n};\nconst buildLogSuffix = function (key) {\n    const urlPrefix = 'See:';\n    const urlObj = urlStore.urls[key];\n    if (!urlObj)\n        return '';\n    let url;\n    if (urlObj.fullUrl) {\n        url = urlObj.fullUrl;\n    }\n    else if (urlObj.path) {\n        url = urlStore.baseUrl + urlObj.path;\n    }\n    if (!url)\n        return '';\n    return `${urlPrefix} ${url}`;\n};\n/* harmony default export */ var url_store = ({ buildLogSuffix });\n\n// CONCATENATED MODULE: ./src/core/channels/channel.ts\n\n\n\n\n\nclass channel_Channel extends dispatcher_Dispatcher {\n    constructor(name, pusher) {\n        super(function (event, data) {\n            logger.debug('No callbacks on ' + name + ' for ' + event);\n        });\n        this.name = name;\n        this.pusher = pusher;\n        this.subscribed = false;\n        this.subscriptionPending = false;\n        this.subscriptionCancelled = false;\n    }\n    authorize(socketId, callback) {\n        return callback(null, { auth: '' });\n    }\n    trigger(event, data) {\n        if (event.indexOf('client-') !== 0) {\n            throw new BadEventName(\"Event '\" + event + \"' does not start with 'client-'\");\n        }\n        if (!this.subscribed) {\n            var suffix = url_store.buildLogSuffix('triggeringClientEvents');\n            logger.warn(`Client event triggered before channel 'subscription_succeeded' event . ${suffix}`);\n        }\n        return this.pusher.send_event(event, data, this.name);\n    }\n    disconnect() {\n        this.subscribed = false;\n        this.subscriptionPending = false;\n    }\n    handleEvent(event) {\n        var eventName = event.event;\n        var data = event.data;\n        if (eventName === 'pusher_internal:subscription_succeeded') {\n            this.handleSubscriptionSucceededEvent(event);\n        }\n        else if (eventName === 'pusher_internal:subscription_count') {\n            this.handleSubscriptionCountEvent(event);\n        }\n        else if (eventName.indexOf('pusher_internal:') !== 0) {\n            var metadata = {};\n            this.emit(eventName, data, metadata);\n        }\n    }\n    handleSubscriptionSucceededEvent(event) {\n        this.subscriptionPending = false;\n        this.subscribed = true;\n        if (this.subscriptionCancelled) {\n            this.pusher.unsubscribe(this.name);\n        }\n        else {\n            this.emit('pusher:subscription_succeeded', event.data);\n        }\n    }\n    handleSubscriptionCountEvent(event) {\n        if (event.data.subscription_count) {\n            this.subscriptionCount = event.data.subscription_count;\n        }\n        this.emit('pusher:subscription_count', event.data);\n    }\n    subscribe() {\n        if (this.subscribed) {\n            return;\n        }\n        this.subscriptionPending = true;\n        this.subscriptionCancelled = false;\n        this.authorize(this.pusher.connection.socket_id, (error, data) => {\n            if (error) {\n                this.subscriptionPending = false;\n                logger.error(error.toString());\n                this.emit('pusher:subscription_error', Object.assign({}, {\n                    type: 'AuthError',\n                    error: error.message\n                }, error instanceof HTTPAuthError ? { status: error.status } : {}));\n            }\n            else {\n                this.pusher.send_event('pusher:subscribe', {\n                    auth: data.auth,\n                    channel_data: data.channel_data,\n                    channel: this.name\n                });\n            }\n        });\n    }\n    unsubscribe() {\n        this.subscribed = false;\n        this.pusher.send_event('pusher:unsubscribe', {\n            channel: this.name\n        });\n    }\n    cancelSubscription() {\n        this.subscriptionCancelled = true;\n    }\n    reinstateSubscription() {\n        this.subscriptionCancelled = false;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/channels/private_channel.ts\n\nclass private_channel_PrivateChannel extends channel_Channel {\n    authorize(socketId, callback) {\n        return this.pusher.config.channelAuthorizer({\n            channelName: this.name,\n            socketId: socketId\n        }, callback);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/channels/members.ts\n\nclass members_Members {\n    constructor() {\n        this.reset();\n    }\n    get(id) {\n        if (Object.prototype.hasOwnProperty.call(this.members, id)) {\n            return {\n                id: id,\n                info: this.members[id]\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    each(callback) {\n        objectApply(this.members, (member, id) => {\n            callback(this.get(id));\n        });\n    }\n    setMyID(id) {\n        this.myID = id;\n    }\n    onSubscription(subscriptionData) {\n        this.members = subscriptionData.presence.hash;\n        this.count = subscriptionData.presence.count;\n        this.me = this.get(this.myID);\n    }\n    addMember(memberData) {\n        if (this.get(memberData.user_id) === null) {\n            this.count++;\n        }\n        this.members[memberData.user_id] = memberData.user_info;\n        return this.get(memberData.user_id);\n    }\n    removeMember(memberData) {\n        var member = this.get(memberData.user_id);\n        if (member) {\n            delete this.members[memberData.user_id];\n            this.count--;\n        }\n        return member;\n    }\n    reset() {\n        this.members = {};\n        this.count = 0;\n        this.myID = null;\n        this.me = null;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/channels/presence_channel.ts\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass presence_channel_PresenceChannel extends private_channel_PrivateChannel {\n    constructor(name, pusher) {\n        super(name, pusher);\n        this.members = new members_Members();\n    }\n    authorize(socketId, callback) {\n        super.authorize(socketId, (error, authData) => __awaiter(this, void 0, void 0, function* () {\n            if (!error) {\n                authData = authData;\n                if (authData.channel_data != null) {\n                    var channelData = JSON.parse(authData.channel_data);\n                    this.members.setMyID(channelData.user_id);\n                }\n                else {\n                    yield this.pusher.user.signinDonePromise;\n                    if (this.pusher.user.user_data != null) {\n                        this.members.setMyID(this.pusher.user.user_data.id);\n                    }\n                    else {\n                        let suffix = url_store.buildLogSuffix('authorizationEndpoint');\n                        logger.error(`Invalid auth response for channel '${this.name}', ` +\n                            `expected 'channel_data' field. ${suffix}, ` +\n                            `or the user should be signed in.`);\n                        callback('Invalid auth response');\n                        return;\n                    }\n                }\n            }\n            callback(error, authData);\n        }));\n    }\n    handleEvent(event) {\n        var eventName = event.event;\n        if (eventName.indexOf('pusher_internal:') === 0) {\n            this.handleInternalEvent(event);\n        }\n        else {\n            var data = event.data;\n            var metadata = {};\n            if (event.user_id) {\n                metadata.user_id = event.user_id;\n            }\n            this.emit(eventName, data, metadata);\n        }\n    }\n    handleInternalEvent(event) {\n        var eventName = event.event;\n        var data = event.data;\n        switch (eventName) {\n            case 'pusher_internal:subscription_succeeded':\n                this.handleSubscriptionSucceededEvent(event);\n                break;\n            case 'pusher_internal:subscription_count':\n                this.handleSubscriptionCountEvent(event);\n                break;\n            case 'pusher_internal:member_added':\n                var addedMember = this.members.addMember(data);\n                this.emit('pusher:member_added', addedMember);\n                break;\n            case 'pusher_internal:member_removed':\n                var removedMember = this.members.removeMember(data);\n                if (removedMember) {\n                    this.emit('pusher:member_removed', removedMember);\n                }\n                break;\n        }\n    }\n    handleSubscriptionSucceededEvent(event) {\n        this.subscriptionPending = false;\n        this.subscribed = true;\n        if (this.subscriptionCancelled) {\n            this.pusher.unsubscribe(this.name);\n        }\n        else {\n            this.members.onSubscription(event.data);\n            this.emit('pusher:subscription_succeeded', this.members);\n        }\n    }\n    disconnect() {\n        this.members.reset();\n        super.disconnect();\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/@stablelib/utf8/lib/utf8.js\nvar utf8 = __nested_webpack_require_195432__(17);\n\n// EXTERNAL MODULE: ./node_modules/@stablelib/base64/lib/base64.js\nvar base64 = __nested_webpack_require_195432__(8);\n\n// CONCATENATED MODULE: ./src/core/channels/encrypted_channel.ts\n\n\n\n\n\nclass encrypted_channel_EncryptedChannel extends private_channel_PrivateChannel {\n    constructor(name, pusher, nacl) {\n        super(name, pusher);\n        this.key = null;\n        this.nacl = nacl;\n    }\n    authorize(socketId, callback) {\n        super.authorize(socketId, (error, authData) => {\n            if (error) {\n                callback(error, authData);\n                return;\n            }\n            let sharedSecret = authData['shared_secret'];\n            if (!sharedSecret) {\n                callback(new Error(`No shared_secret key in auth payload for encrypted channel: ${this.name}`), null);\n                return;\n            }\n            this.key = Object(base64[\"decode\"])(sharedSecret);\n            delete authData['shared_secret'];\n            callback(null, authData);\n        });\n    }\n    trigger(event, data) {\n        throw new UnsupportedFeature('Client events are not currently supported for encrypted channels');\n    }\n    handleEvent(event) {\n        var eventName = event.event;\n        var data = event.data;\n        if (eventName.indexOf('pusher_internal:') === 0 ||\n            eventName.indexOf('pusher:') === 0) {\n            super.handleEvent(event);\n            return;\n        }\n        this.handleEncryptedEvent(eventName, data);\n    }\n    handleEncryptedEvent(event, data) {\n        if (!this.key) {\n            logger.debug('Received encrypted event before key has been retrieved from the authEndpoint');\n            return;\n        }\n        if (!data.ciphertext || !data.nonce) {\n            logger.error('Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: ' +\n                data);\n            return;\n        }\n        let cipherText = Object(base64[\"decode\"])(data.ciphertext);\n        if (cipherText.length < this.nacl.secretbox.overheadLength) {\n            logger.error(`Expected encrypted event ciphertext length to be ${this.nacl.secretbox.overheadLength}, got: ${cipherText.length}`);\n            return;\n        }\n        let nonce = Object(base64[\"decode\"])(data.nonce);\n        if (nonce.length < this.nacl.secretbox.nonceLength) {\n            logger.error(`Expected encrypted event nonce length to be ${this.nacl.secretbox.nonceLength}, got: ${nonce.length}`);\n            return;\n        }\n        let bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n        if (bytes === null) {\n            logger.debug('Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...');\n            this.authorize(this.pusher.connection.socket_id, (error, authData) => {\n                if (error) {\n                    logger.error(`Failed to make a request to the authEndpoint: ${authData}. Unable to fetch new key, so dropping encrypted event`);\n                    return;\n                }\n                bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n                if (bytes === null) {\n                    logger.error(`Failed to decrypt event with new key. Dropping encrypted event`);\n                    return;\n                }\n                this.emit(event, this.getDataToEmit(bytes));\n                return;\n            });\n            return;\n        }\n        this.emit(event, this.getDataToEmit(bytes));\n    }\n    getDataToEmit(bytes) {\n        let raw = Object(utf8[\"decode\"])(bytes);\n        try {\n            return JSON.parse(raw);\n        }\n        catch (_a) {\n            return raw;\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/connection/connection_manager.ts\n\n\n\n\n\nclass connection_manager_ConnectionManager extends dispatcher_Dispatcher {\n    constructor(key, options) {\n        super();\n        this.state = 'initialized';\n        this.connection = null;\n        this.key = key;\n        this.options = options;\n        this.timeline = this.options.timeline;\n        this.usingTLS = this.options.useTLS;\n        this.errorCallbacks = this.buildErrorCallbacks();\n        this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);\n        this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);\n        var Network = node_runtime.getNetwork();\n        Network.bind('online', () => {\n            this.timeline.info({ netinfo: 'online' });\n            if (this.state === 'connecting' || this.state === 'unavailable') {\n                this.retryIn(0);\n            }\n        });\n        Network.bind('offline', () => {\n            this.timeline.info({ netinfo: 'offline' });\n            if (this.connection) {\n                this.sendActivityCheck();\n            }\n        });\n        this.updateStrategy();\n    }\n    connect() {\n        if (this.connection || this.runner) {\n            return;\n        }\n        if (!this.strategy.isSupported()) {\n            this.updateState('failed');\n            return;\n        }\n        this.updateState('connecting');\n        this.startConnecting();\n        this.setUnavailableTimer();\n    }\n    send(data) {\n        if (this.connection) {\n            return this.connection.send(data);\n        }\n        else {\n            return false;\n        }\n    }\n    send_event(name, data, channel) {\n        if (this.connection) {\n            return this.connection.send_event(name, data, channel);\n        }\n        else {\n            return false;\n        }\n    }\n    disconnect() {\n        this.disconnectInternally();\n        this.updateState('disconnected');\n    }\n    isUsingTLS() {\n        return this.usingTLS;\n    }\n    startConnecting() {\n        var callback = (error, handshake) => {\n            if (error) {\n                this.runner = this.strategy.connect(0, callback);\n            }\n            else {\n                if (handshake.action === 'error') {\n                    this.emit('error', {\n                        type: 'HandshakeError',\n                        error: handshake.error\n                    });\n                    this.timeline.error({ handshakeError: handshake.error });\n                }\n                else {\n                    this.abortConnecting();\n                    this.handshakeCallbacks[handshake.action](handshake);\n                }\n            }\n        };\n        this.runner = this.strategy.connect(0, callback);\n    }\n    abortConnecting() {\n        if (this.runner) {\n            this.runner.abort();\n            this.runner = null;\n        }\n    }\n    disconnectInternally() {\n        this.abortConnecting();\n        this.clearRetryTimer();\n        this.clearUnavailableTimer();\n        if (this.connection) {\n            var connection = this.abandonConnection();\n            connection.close();\n        }\n    }\n    updateStrategy() {\n        this.strategy = this.options.getStrategy({\n            key: this.key,\n            timeline: this.timeline,\n            useTLS: this.usingTLS\n        });\n    }\n    retryIn(delay) {\n        this.timeline.info({ action: 'retry', delay: delay });\n        if (delay > 0) {\n            this.emit('connecting_in', Math.round(delay / 1000));\n        }\n        this.retryTimer = new timers_OneOffTimer(delay || 0, () => {\n            this.disconnectInternally();\n            this.connect();\n        });\n    }\n    clearRetryTimer() {\n        if (this.retryTimer) {\n            this.retryTimer.ensureAborted();\n            this.retryTimer = null;\n        }\n    }\n    setUnavailableTimer() {\n        this.unavailableTimer = new timers_OneOffTimer(this.options.unavailableTimeout, () => {\n            this.updateState('unavailable');\n        });\n    }\n    clearUnavailableTimer() {\n        if (this.unavailableTimer) {\n            this.unavailableTimer.ensureAborted();\n        }\n    }\n    sendActivityCheck() {\n        this.stopActivityCheck();\n        this.connection.ping();\n        this.activityTimer = new timers_OneOffTimer(this.options.pongTimeout, () => {\n            this.timeline.error({ pong_timed_out: this.options.pongTimeout });\n            this.retryIn(0);\n        });\n    }\n    resetActivityCheck() {\n        this.stopActivityCheck();\n        if (this.connection && !this.connection.handlesActivityChecks()) {\n            this.activityTimer = new timers_OneOffTimer(this.activityTimeout, () => {\n                this.sendActivityCheck();\n            });\n        }\n    }\n    stopActivityCheck() {\n        if (this.activityTimer) {\n            this.activityTimer.ensureAborted();\n        }\n    }\n    buildConnectionCallbacks(errorCallbacks) {\n        return extend({}, errorCallbacks, {\n            message: message => {\n                this.resetActivityCheck();\n                this.emit('message', message);\n            },\n            ping: () => {\n                this.send_event('pusher:pong', {});\n            },\n            activity: () => {\n                this.resetActivityCheck();\n            },\n            error: error => {\n                this.emit('error', error);\n            },\n            closed: () => {\n                this.abandonConnection();\n                if (this.shouldRetry()) {\n                    this.retryIn(1000);\n                }\n            }\n        });\n    }\n    buildHandshakeCallbacks(errorCallbacks) {\n        return extend({}, errorCallbacks, {\n            connected: (handshake) => {\n                this.activityTimeout = Math.min(this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);\n                this.clearUnavailableTimer();\n                this.setConnection(handshake.connection);\n                this.socket_id = this.connection.id;\n                this.updateState('connected', { socket_id: this.socket_id });\n            }\n        });\n    }\n    buildErrorCallbacks() {\n        let withErrorEmitted = callback => {\n            return (result) => {\n                if (result.error) {\n                    this.emit('error', { type: 'WebSocketError', error: result.error });\n                }\n                callback(result);\n            };\n        };\n        return {\n            tls_only: withErrorEmitted(() => {\n                this.usingTLS = true;\n                this.updateStrategy();\n                this.retryIn(0);\n            }),\n            refused: withErrorEmitted(() => {\n                this.disconnect();\n            }),\n            backoff: withErrorEmitted(() => {\n                this.retryIn(1000);\n            }),\n            retry: withErrorEmitted(() => {\n                this.retryIn(0);\n            })\n        };\n    }\n    setConnection(connection) {\n        this.connection = connection;\n        for (var event in this.connectionCallbacks) {\n            this.connection.bind(event, this.connectionCallbacks[event]);\n        }\n        this.resetActivityCheck();\n    }\n    abandonConnection() {\n        if (!this.connection) {\n            return;\n        }\n        this.stopActivityCheck();\n        for (var event in this.connectionCallbacks) {\n            this.connection.unbind(event, this.connectionCallbacks[event]);\n        }\n        var connection = this.connection;\n        this.connection = null;\n        return connection;\n    }\n    updateState(newState, data) {\n        var previousState = this.state;\n        this.state = newState;\n        if (previousState !== newState) {\n            var newStateDescription = newState;\n            if (newStateDescription === 'connected') {\n                newStateDescription += ' with new socket ID ' + data.socket_id;\n            }\n            logger.debug('State changed', previousState + ' -> ' + newStateDescription);\n            this.timeline.info({ state: newState, params: data });\n            this.emit('state_change', { previous: previousState, current: newState });\n            this.emit(newState, data);\n        }\n    }\n    shouldRetry() {\n        return this.state === 'connecting' || this.state === 'connected';\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/channels/channels.ts\n\n\n\n\nclass channels_Channels {\n    constructor() {\n        this.channels = {};\n    }\n    add(name, pusher) {\n        if (!this.channels[name]) {\n            this.channels[name] = createChannel(name, pusher);\n        }\n        return this.channels[name];\n    }\n    all() {\n        return values(this.channels);\n    }\n    find(name) {\n        return this.channels[name];\n    }\n    remove(name) {\n        var channel = this.channels[name];\n        delete this.channels[name];\n        return channel;\n    }\n    disconnect() {\n        objectApply(this.channels, function (channel) {\n            channel.disconnect();\n        });\n    }\n}\nfunction createChannel(name, pusher) {\n    if (name.indexOf('private-encrypted-') === 0) {\n        if (pusher.config.nacl) {\n            return factory.createEncryptedChannel(name, pusher, pusher.config.nacl);\n        }\n        let errMsg = 'Tried to subscribe to a private-encrypted- channel but no nacl implementation available';\n        let suffix = url_store.buildLogSuffix('encryptedChannelSupport');\n        throw new UnsupportedFeature(`${errMsg}. ${suffix}`);\n    }\n    else if (name.indexOf('private-') === 0) {\n        return factory.createPrivateChannel(name, pusher);\n    }\n    else if (name.indexOf('presence-') === 0) {\n        return factory.createPresenceChannel(name, pusher);\n    }\n    else if (name.indexOf('#') === 0) {\n        throw new BadChannelName('Cannot create a channel with name \"' + name + '\".');\n    }\n    else {\n        return factory.createChannel(name, pusher);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/utils/factory.ts\n\n\n\n\n\n\n\n\n\nvar Factory = {\n    createChannels() {\n        return new channels_Channels();\n    },\n    createConnectionManager(key, options) {\n        return new connection_manager_ConnectionManager(key, options);\n    },\n    createChannel(name, pusher) {\n        return new channel_Channel(name, pusher);\n    },\n    createPrivateChannel(name, pusher) {\n        return new private_channel_PrivateChannel(name, pusher);\n    },\n    createPresenceChannel(name, pusher) {\n        return new presence_channel_PresenceChannel(name, pusher);\n    },\n    createEncryptedChannel(name, pusher, nacl) {\n        return new encrypted_channel_EncryptedChannel(name, pusher, nacl);\n    },\n    createTimelineSender(timeline, options) {\n        return new timeline_sender_TimelineSender(timeline, options);\n    },\n    createHandshake(transport, callback) {\n        return new handshake_Handshake(transport, callback);\n    },\n    createAssistantToTheTransportManager(manager, transport, options) {\n        return new assistant_to_the_transport_manager_AssistantToTheTransportManager(manager, transport, options);\n    }\n};\n/* harmony default export */ var factory = (Factory);\n\n// CONCATENATED MODULE: ./src/core/transports/transport_manager.ts\n\nclass transport_manager_TransportManager {\n    constructor(options) {\n        this.options = options || {};\n        this.livesLeft = this.options.lives || Infinity;\n    }\n    getAssistant(transport) {\n        return factory.createAssistantToTheTransportManager(this, transport, {\n            minPingDelay: this.options.minPingDelay,\n            maxPingDelay: this.options.maxPingDelay\n        });\n    }\n    isAlive() {\n        return this.livesLeft > 0;\n    }\n    reportDeath() {\n        this.livesLeft -= 1;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/sequential_strategy.ts\n\n\n\nclass sequential_strategy_SequentialStrategy {\n    constructor(strategies, options) {\n        this.strategies = strategies;\n        this.loop = Boolean(options.loop);\n        this.failFast = Boolean(options.failFast);\n        this.timeout = options.timeout;\n        this.timeoutLimit = options.timeoutLimit;\n    }\n    isSupported() {\n        return any(this.strategies, util.method('isSupported'));\n    }\n    connect(minPriority, callback) {\n        var strategies = this.strategies;\n        var current = 0;\n        var timeout = this.timeout;\n        var runner = null;\n        var tryNextStrategy = (error, handshake) => {\n            if (handshake) {\n                callback(null, handshake);\n            }\n            else {\n                current = current + 1;\n                if (this.loop) {\n                    current = current % strategies.length;\n                }\n                if (current < strategies.length) {\n                    if (timeout) {\n                        timeout = timeout * 2;\n                        if (this.timeoutLimit) {\n                            timeout = Math.min(timeout, this.timeoutLimit);\n                        }\n                    }\n                    runner = this.tryStrategy(strategies[current], minPriority, { timeout, failFast: this.failFast }, tryNextStrategy);\n                }\n                else {\n                    callback(true);\n                }\n            }\n        };\n        runner = this.tryStrategy(strategies[current], minPriority, { timeout: timeout, failFast: this.failFast }, tryNextStrategy);\n        return {\n            abort: function () {\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            }\n        };\n    }\n    tryStrategy(strategy, minPriority, options, callback) {\n        var timer = null;\n        var runner = null;\n        if (options.timeout > 0) {\n            timer = new timers_OneOffTimer(options.timeout, function () {\n                runner.abort();\n                callback(true);\n            });\n        }\n        runner = strategy.connect(minPriority, function (error, handshake) {\n            if (error && timer && timer.isRunning() && !options.failFast) {\n                return;\n            }\n            if (timer) {\n                timer.ensureAborted();\n            }\n            callback(error, handshake);\n        });\n        return {\n            abort: function () {\n                if (timer) {\n                    timer.ensureAborted();\n                }\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                runner.forceMinPriority(p);\n            }\n        };\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/best_connected_ever_strategy.ts\n\n\nclass best_connected_ever_strategy_BestConnectedEverStrategy {\n    constructor(strategies) {\n        this.strategies = strategies;\n    }\n    isSupported() {\n        return any(this.strategies, util.method('isSupported'));\n    }\n    connect(minPriority, callback) {\n        return connect(this.strategies, minPriority, function (i, runners) {\n            return function (error, handshake) {\n                runners[i].error = error;\n                if (error) {\n                    if (allRunnersFailed(runners)) {\n                        callback(true);\n                    }\n                    return;\n                }\n                apply(runners, function (runner) {\n                    runner.forceMinPriority(handshake.transport.priority);\n                });\n                callback(null, handshake);\n            };\n        });\n    }\n}\nfunction connect(strategies, minPriority, callbackBuilder) {\n    var runners = map(strategies, function (strategy, i, _, rs) {\n        return strategy.connect(minPriority, callbackBuilder(i, rs));\n    });\n    return {\n        abort: function () {\n            apply(runners, abortRunner);\n        },\n        forceMinPriority: function (p) {\n            apply(runners, function (runner) {\n                runner.forceMinPriority(p);\n            });\n        }\n    };\n}\nfunction allRunnersFailed(runners) {\n    return collections_all(runners, function (runner) {\n        return Boolean(runner.error);\n    });\n}\nfunction abortRunner(runner) {\n    if (!runner.error && !runner.aborted) {\n        runner.abort();\n        runner.aborted = true;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/websocket_prioritized_cached_strategy.ts\n\n\n\n\nclass websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy {\n    constructor(strategy, transports, options) {\n        this.strategy = strategy;\n        this.transports = transports;\n        this.ttl = options.ttl || 1800 * 1000;\n        this.usingTLS = options.useTLS;\n        this.timeline = options.timeline;\n    }\n    isSupported() {\n        return this.strategy.isSupported();\n    }\n    connect(minPriority, callback) {\n        var usingTLS = this.usingTLS;\n        var info = fetchTransportCache(usingTLS);\n        var cacheSkipCount = info && info.cacheSkipCount ? info.cacheSkipCount : 0;\n        var strategies = [this.strategy];\n        if (info && info.timestamp + this.ttl >= util.now()) {\n            var transport = this.transports[info.transport];\n            if (transport) {\n                if (['ws', 'wss'].includes(info.transport) || cacheSkipCount > 3) {\n                    this.timeline.info({\n                        cached: true,\n                        transport: info.transport,\n                        latency: info.latency\n                    });\n                    strategies.push(new sequential_strategy_SequentialStrategy([transport], {\n                        timeout: info.latency * 2 + 1000,\n                        failFast: true\n                    }));\n                }\n                else {\n                    cacheSkipCount++;\n                }\n            }\n        }\n        var startTimestamp = util.now();\n        var runner = strategies\n            .pop()\n            .connect(minPriority, function cb(error, handshake) {\n            if (error) {\n                flushTransportCache(usingTLS);\n                if (strategies.length > 0) {\n                    startTimestamp = util.now();\n                    runner = strategies.pop().connect(minPriority, cb);\n                }\n                else {\n                    callback(error);\n                }\n            }\n            else {\n                storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp, cacheSkipCount);\n                callback(null, handshake);\n            }\n        });\n        return {\n            abort: function () {\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            }\n        };\n    }\n}\nfunction getTransportCacheKey(usingTLS) {\n    return 'pusherTransport' + (usingTLS ? 'TLS' : 'NonTLS');\n}\nfunction fetchTransportCache(usingTLS) {\n    var storage = node_runtime.getLocalStorage();\n    if (storage) {\n        try {\n            var serializedCache = storage[getTransportCacheKey(usingTLS)];\n            if (serializedCache) {\n                return JSON.parse(serializedCache);\n            }\n        }\n        catch (e) {\n            flushTransportCache(usingTLS);\n        }\n    }\n    return null;\n}\nfunction storeTransportCache(usingTLS, transport, latency, cacheSkipCount) {\n    var storage = node_runtime.getLocalStorage();\n    if (storage) {\n        try {\n            storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({\n                timestamp: util.now(),\n                transport: transport,\n                latency: latency,\n                cacheSkipCount: cacheSkipCount\n            });\n        }\n        catch (e) {\n        }\n    }\n}\nfunction flushTransportCache(usingTLS) {\n    var storage = node_runtime.getLocalStorage();\n    if (storage) {\n        try {\n            delete storage[getTransportCacheKey(usingTLS)];\n        }\n        catch (e) {\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/delayed_strategy.ts\n\nclass delayed_strategy_DelayedStrategy {\n    constructor(strategy, { delay: number }) {\n        this.strategy = strategy;\n        this.options = { delay: number };\n    }\n    isSupported() {\n        return this.strategy.isSupported();\n    }\n    connect(minPriority, callback) {\n        var strategy = this.strategy;\n        var runner;\n        var timer = new timers_OneOffTimer(this.options.delay, function () {\n            runner = strategy.connect(minPriority, callback);\n        });\n        return {\n            abort: function () {\n                timer.ensureAborted();\n                if (runner) {\n                    runner.abort();\n                }\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            }\n        };\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/if_strategy.ts\nclass IfStrategy {\n    constructor(test, trueBranch, falseBranch) {\n        this.test = test;\n        this.trueBranch = trueBranch;\n        this.falseBranch = falseBranch;\n    }\n    isSupported() {\n        var branch = this.test() ? this.trueBranch : this.falseBranch;\n        return branch.isSupported();\n    }\n    connect(minPriority, callback) {\n        var branch = this.test() ? this.trueBranch : this.falseBranch;\n        return branch.connect(minPriority, callback);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/first_connected_strategy.ts\nclass FirstConnectedStrategy {\n    constructor(strategy) {\n        this.strategy = strategy;\n    }\n    isSupported() {\n        return this.strategy.isSupported();\n    }\n    connect(minPriority, callback) {\n        var runner = this.strategy.connect(minPriority, function (error, handshake) {\n            if (handshake) {\n                runner.abort();\n            }\n            callback(error, handshake);\n        });\n        return runner;\n    }\n}\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/default_strategy.ts\n\n\n\n\n\n\n\n\nfunction testSupportsStrategy(strategy) {\n    return function () {\n        return strategy.isSupported();\n    };\n}\nvar getDefaultStrategy = function (config, baseOptions, defineTransport) {\n    var definedTransports = {};\n    function defineTransportStrategy(name, type, priority, options, manager) {\n        var transport = defineTransport(config, name, type, priority, options, manager);\n        definedTransports[name] = transport;\n        return transport;\n    }\n    var ws_options = Object.assign({}, baseOptions, {\n        hostNonTLS: config.wsHost + ':' + config.wsPort,\n        hostTLS: config.wsHost + ':' + config.wssPort,\n        httpPath: config.wsPath\n    });\n    var wss_options = extend({}, ws_options, {\n        useTLS: true\n    });\n    var http_options = Object.assign({}, baseOptions, {\n        hostNonTLS: config.httpHost + ':' + config.httpPort,\n        hostTLS: config.httpHost + ':' + config.httpsPort,\n        httpPath: config.httpPath\n    });\n    var timeouts = {\n        loop: true,\n        timeout: 15000,\n        timeoutLimit: 60000\n    };\n    var ws_manager = new transport_manager_TransportManager({\n        minPingDelay: 10000,\n        maxPingDelay: config.activityTimeout\n    });\n    var streaming_manager = new transport_manager_TransportManager({\n        lives: 2,\n        minPingDelay: 10000,\n        maxPingDelay: config.activityTimeout\n    });\n    var ws_transport = defineTransportStrategy('ws', 'ws', 3, ws_options, ws_manager);\n    var wss_transport = defineTransportStrategy('wss', 'ws', 3, wss_options, ws_manager);\n    var xhr_streaming_transport = defineTransportStrategy('xhr_streaming', 'xhr_streaming', 1, http_options, streaming_manager);\n    var xhr_polling_transport = defineTransportStrategy('xhr_polling', 'xhr_polling', 1, http_options);\n    var ws_loop = new sequential_strategy_SequentialStrategy([ws_transport], timeouts);\n    var wss_loop = new sequential_strategy_SequentialStrategy([wss_transport], timeouts);\n    var streaming_loop = new sequential_strategy_SequentialStrategy([xhr_streaming_transport], timeouts);\n    var polling_loop = new sequential_strategy_SequentialStrategy([xhr_polling_transport], timeouts);\n    var http_loop = new sequential_strategy_SequentialStrategy([\n        new IfStrategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy_BestConnectedEverStrategy([\n            streaming_loop,\n            new delayed_strategy_DelayedStrategy(polling_loop, { delay: 4000 })\n        ]), polling_loop)\n    ], timeouts);\n    var wsStrategy;\n    if (baseOptions.useTLS) {\n        wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n            ws_loop,\n            new delayed_strategy_DelayedStrategy(http_loop, { delay: 2000 })\n        ]);\n    }\n    else {\n        wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n            ws_loop,\n            new delayed_strategy_DelayedStrategy(wss_loop, { delay: 2000 }),\n            new delayed_strategy_DelayedStrategy(http_loop, { delay: 5000 })\n        ]);\n    }\n    return new websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy(new FirstConnectedStrategy(new IfStrategy(testSupportsStrategy(ws_transport), wsStrategy, http_loop)), definedTransports, {\n        ttl: 1800000,\n        timeline: baseOptions.timeline,\n        useTLS: baseOptions.useTLS\n    });\n};\n/* harmony default export */ var default_strategy = (getDefaultStrategy);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transport_connection_initializer.ts\n/* harmony default export */ var transport_connection_initializer = (function () {\n    var self = this;\n    self.timeline.info(self.buildTimelineMessage({\n        transport: self.name + (self.options.useTLS ? 's' : '')\n    }));\n    if (self.hooks.isInitialized()) {\n        self.changeState('initialized');\n    }\n    else {\n        self.onClose();\n    }\n});\n\n// CONCATENATED MODULE: ./src/core/http/http_request.ts\n\n\nconst MAX_BUFFER_LENGTH = 256 * 1024;\nclass http_request_HTTPRequest extends dispatcher_Dispatcher {\n    constructor(hooks, method, url) {\n        super();\n        this.hooks = hooks;\n        this.method = method;\n        this.url = url;\n    }\n    start(payload) {\n        this.position = 0;\n        this.xhr = this.hooks.getRequest(this);\n        this.unloader = () => {\n            this.close();\n        };\n        node_runtime.addUnloadListener(this.unloader);\n        this.xhr.open(this.method, this.url, true);\n        if (this.xhr.setRequestHeader) {\n            this.xhr.setRequestHeader('Content-Type', 'application/json');\n        }\n        this.xhr.send(payload);\n    }\n    close() {\n        if (this.unloader) {\n            node_runtime.removeUnloadListener(this.unloader);\n            this.unloader = null;\n        }\n        if (this.xhr) {\n            this.hooks.abortRequest(this.xhr);\n            this.xhr = null;\n        }\n    }\n    onChunk(status, data) {\n        while (true) {\n            var chunk = this.advanceBuffer(data);\n            if (chunk) {\n                this.emit('chunk', { status: status, data: chunk });\n            }\n            else {\n                break;\n            }\n        }\n        if (this.isBufferTooLong(data)) {\n            this.emit('buffer_too_long');\n        }\n    }\n    advanceBuffer(buffer) {\n        var unreadData = buffer.slice(this.position);\n        var endOfLinePosition = unreadData.indexOf('\\n');\n        if (endOfLinePosition !== -1) {\n            this.position += endOfLinePosition + 1;\n            return unreadData.slice(0, endOfLinePosition);\n        }\n        else {\n            return null;\n        }\n    }\n    isBufferTooLong(buffer) {\n        return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/http/state.ts\nvar State;\n(function (State) {\n    State[State[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    State[State[\"OPEN\"] = 1] = \"OPEN\";\n    State[State[\"CLOSED\"] = 3] = \"CLOSED\";\n})(State || (State = {}));\n/* harmony default export */ var state = (State);\n\n// CONCATENATED MODULE: ./src/core/http/http_socket.ts\n\n\n\nvar autoIncrement = 1;\nclass http_socket_HTTPSocket {\n    constructor(hooks, url) {\n        this.hooks = hooks;\n        this.session = randomNumber(1000) + '/' + randomString(8);\n        this.location = getLocation(url);\n        this.readyState = state.CONNECTING;\n        this.openStream();\n    }\n    send(payload) {\n        return this.sendRaw(JSON.stringify([payload]));\n    }\n    ping() {\n        this.hooks.sendHeartbeat(this);\n    }\n    close(code, reason) {\n        this.onClose(code, reason, true);\n    }\n    sendRaw(payload) {\n        if (this.readyState === state.OPEN) {\n            try {\n                node_runtime.createSocketRequest('POST', getUniqueURL(getSendURL(this.location, this.session))).start(payload);\n                return true;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    reconnect() {\n        this.closeStream();\n        this.openStream();\n    }\n    onClose(code, reason, wasClean) {\n        this.closeStream();\n        this.readyState = state.CLOSED;\n        if (this.onclose) {\n            this.onclose({\n                code: code,\n                reason: reason,\n                wasClean: wasClean\n            });\n        }\n    }\n    onChunk(chunk) {\n        if (chunk.status !== 200) {\n            return;\n        }\n        if (this.readyState === state.OPEN) {\n            this.onActivity();\n        }\n        var payload;\n        var type = chunk.data.slice(0, 1);\n        switch (type) {\n            case 'o':\n                payload = JSON.parse(chunk.data.slice(1) || '{}');\n                this.onOpen(payload);\n                break;\n            case 'a':\n                payload = JSON.parse(chunk.data.slice(1) || '[]');\n                for (var i = 0; i < payload.length; i++) {\n                    this.onEvent(payload[i]);\n                }\n                break;\n            case 'm':\n                payload = JSON.parse(chunk.data.slice(1) || 'null');\n                this.onEvent(payload);\n                break;\n            case 'h':\n                this.hooks.onHeartbeat(this);\n                break;\n            case 'c':\n                payload = JSON.parse(chunk.data.slice(1) || '[]');\n                this.onClose(payload[0], payload[1], true);\n                break;\n        }\n    }\n    onOpen(options) {\n        if (this.readyState === state.CONNECTING) {\n            if (options && options.hostname) {\n                this.location.base = replaceHost(this.location.base, options.hostname);\n            }\n            this.readyState = state.OPEN;\n            if (this.onopen) {\n                this.onopen();\n            }\n        }\n        else {\n            this.onClose(1006, 'Server lost session', true);\n        }\n    }\n    onEvent(event) {\n        if (this.readyState === state.OPEN && this.onmessage) {\n            this.onmessage({ data: event });\n        }\n    }\n    onActivity() {\n        if (this.onactivity) {\n            this.onactivity();\n        }\n    }\n    onError(error) {\n        if (this.onerror) {\n            this.onerror(error);\n        }\n    }\n    openStream() {\n        this.stream = node_runtime.createSocketRequest('POST', getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));\n        this.stream.bind('chunk', chunk => {\n            this.onChunk(chunk);\n        });\n        this.stream.bind('finished', status => {\n            this.hooks.onFinished(this, status);\n        });\n        this.stream.bind('buffer_too_long', () => {\n            this.reconnect();\n        });\n        try {\n            this.stream.start();\n        }\n        catch (error) {\n            util.defer(() => {\n                this.onError(error);\n                this.onClose(1006, 'Could not start streaming', false);\n            });\n        }\n    }\n    closeStream() {\n        if (this.stream) {\n            this.stream.unbind_all();\n            this.stream.close();\n            this.stream = null;\n        }\n    }\n}\nfunction getLocation(url) {\n    var parts = /([^\\?]*)\\/*(\\??.*)/.exec(url);\n    return {\n        base: parts[1],\n        queryString: parts[2]\n    };\n}\nfunction getSendURL(url, session) {\n    return url.base + '/' + session + '/xhr_send';\n}\nfunction getUniqueURL(url) {\n    var separator = url.indexOf('?') === -1 ? '?' : '&';\n    return url + separator + 't=' + +new Date() + '&n=' + autoIncrement++;\n}\nfunction replaceHost(url, hostname) {\n    var urlParts = /(https?:\\/\\/)([^\\/:]+)((\\/|:)?.*)/.exec(url);\n    return urlParts[1] + hostname + urlParts[3];\n}\nfunction randomNumber(max) {\n    return node_runtime.randomInt(max);\n}\nfunction randomString(length) {\n    var result = [];\n    for (var i = 0; i < length; i++) {\n        result.push(randomNumber(32).toString(32));\n    }\n    return result.join('');\n}\n/* harmony default export */ var http_socket = (http_socket_HTTPSocket);\n\n// CONCATENATED MODULE: ./src/core/http/http_streaming_socket.ts\nvar http_streaming_socket_hooks = {\n    getReceiveURL: function (url, session) {\n        return url.base + '/' + session + '/xhr_streaming' + url.queryString;\n    },\n    onHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    sendHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    onFinished: function (socket, status) {\n        socket.onClose(1006, 'Connection interrupted (' + status + ')', false);\n    }\n};\n/* harmony default export */ var http_streaming_socket = (http_streaming_socket_hooks);\n\n// CONCATENATED MODULE: ./src/core/http/http_polling_socket.ts\nvar http_polling_socket_hooks = {\n    getReceiveURL: function (url, session) {\n        return url.base + '/' + session + '/xhr' + url.queryString;\n    },\n    onHeartbeat: function () {\n    },\n    sendHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    onFinished: function (socket, status) {\n        if (status === 200) {\n            socket.reconnect();\n        }\n        else {\n            socket.onClose(1006, 'Connection interrupted (' + status + ')', false);\n        }\n    }\n};\n/* harmony default export */ var http_polling_socket = (http_polling_socket_hooks);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http_xhr_request.ts\n\nvar http_xhr_request_hooks = {\n    getRequest: function (socket) {\n        var Constructor = node_runtime.getXHRAPI();\n        var xhr = new Constructor();\n        xhr.onreadystatechange = xhr.onprogress = function () {\n            switch (xhr.readyState) {\n                case 3:\n                    if (xhr.responseText && xhr.responseText.length > 0) {\n                        socket.onChunk(xhr.status, xhr.responseText);\n                    }\n                    break;\n                case 4:\n                    if (xhr.responseText && xhr.responseText.length > 0) {\n                        socket.onChunk(xhr.status, xhr.responseText);\n                    }\n                    socket.emit('finished', xhr.status);\n                    socket.close();\n                    break;\n            }\n        };\n        return xhr;\n    },\n    abortRequest: function (xhr) {\n        xhr.onreadystatechange = null;\n        xhr.abort();\n    }\n};\n/* harmony default export */ var http_xhr_request = (http_xhr_request_hooks);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http.ts\n\n\n\n\n\nvar HTTP = {\n    createStreamingSocket(url) {\n        return this.createSocket(http_streaming_socket, url);\n    },\n    createPollingSocket(url) {\n        return this.createSocket(http_polling_socket, url);\n    },\n    createSocket(hooks, url) {\n        return new http_socket(hooks, url);\n    },\n    createXHR(method, url) {\n        return this.createRequest(http_xhr_request, method, url);\n    },\n    createRequest(hooks, method, url) {\n        return new http_request_HTTPRequest(hooks, method, url);\n    }\n};\n/* harmony default export */ var http_http = (HTTP);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/runtime.ts\n\n\n\n\n\nvar Isomorphic = {\n    getDefaultStrategy: default_strategy,\n    Transports: transports,\n    transportConnectionInitializer: transport_connection_initializer,\n    HTTPFactory: http_http,\n    setup(PusherClass) {\n        PusherClass.ready();\n    },\n    getLocalStorage() {\n        return undefined;\n    },\n    getClientFeatures() {\n        return keys(filterObject({ ws: transports.ws }, function (t) {\n            return t.isSupported({});\n        }));\n    },\n    getProtocol() {\n        return 'http:';\n    },\n    isXHRSupported() {\n        return true;\n    },\n    createSocketRequest(method, url) {\n        if (this.isXHRSupported()) {\n            return this.HTTPFactory.createXHR(method, url);\n        }\n        else {\n            throw 'Cross-origin HTTP requests are not supported';\n        }\n    },\n    createXHR() {\n        var Constructor = this.getXHRAPI();\n        return new Constructor();\n    },\n    createWebSocket(url) {\n        var Constructor = this.getWebSocketAPI();\n        return new Constructor(url);\n    },\n    addUnloadListener(listener) { },\n    removeUnloadListener(listener) { }\n};\n/* harmony default export */ var runtime = (Isomorphic);\n\n// EXTERNAL MODULE: ./node_modules/faye-websocket/lib/faye/websocket.js\nvar websocket = __nested_webpack_require_195432__(18);\n\n// EXTERNAL MODULE: ./node_modules/xmlhttprequest/lib/XMLHttpRequest.js\nvar XMLHttpRequest = __nested_webpack_require_195432__(19);\n\n// CONCATENATED MODULE: ./src/runtimes/node/net_info.ts\n\nclass net_info_NetInfo extends dispatcher_Dispatcher {\n    isOnline() {\n        return true;\n    }\n}\nvar net_info_Network = new net_info_NetInfo();\n\n// CONCATENATED MODULE: ./src/core/auth/options.ts\nvar AuthRequestType;\n(function (AuthRequestType) {\n    AuthRequestType[\"UserAuthentication\"] = \"user-authentication\";\n    AuthRequestType[\"ChannelAuthorization\"] = \"channel-authorization\";\n})(AuthRequestType || (AuthRequestType = {}));\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/auth/xhr_auth.ts\n\n\n\n\nconst ajax = function (context, query, authOptions, authRequestType, callback) {\n    const xhr = node_runtime.createXHR();\n    xhr.open('POST', authOptions.endpoint, true);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    for (var headerName in authOptions.headers) {\n        xhr.setRequestHeader(headerName, authOptions.headers[headerName]);\n    }\n    if (authOptions.headersProvider != null) {\n        let dynamicHeaders = authOptions.headersProvider();\n        for (var headerName in dynamicHeaders) {\n            xhr.setRequestHeader(headerName, dynamicHeaders[headerName]);\n        }\n    }\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                let data;\n                let parsed = false;\n                try {\n                    data = JSON.parse(xhr.responseText);\n                    parsed = true;\n                }\n                catch (e) {\n                    callback(new HTTPAuthError(200, `JSON returned from ${authRequestType.toString()} endpoint was invalid, yet status code was 200. Data was: ${xhr.responseText}`), null);\n                }\n                if (parsed) {\n                    callback(null, data);\n                }\n            }\n            else {\n                let suffix = '';\n                switch (authRequestType) {\n                    case AuthRequestType.UserAuthentication:\n                        suffix = url_store.buildLogSuffix('authenticationEndpoint');\n                        break;\n                    case AuthRequestType.ChannelAuthorization:\n                        suffix = `Clients must be authorized to join private or presence channels. ${url_store.buildLogSuffix('authorizationEndpoint')}`;\n                        break;\n                }\n                callback(new HTTPAuthError(xhr.status, `Unable to retrieve auth string from ${authRequestType.toString()} endpoint - ` +\n                    `received status: ${xhr.status} from ${authOptions.endpoint}. ${suffix}`), null);\n            }\n        }\n    };\n    xhr.send(query);\n    return xhr;\n};\n/* harmony default export */ var xhr_auth = (ajax);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/timeline/xhr_timeline.ts\n\n\n\nvar getAgent = function (sender, useTLS) {\n    return function (data, callback) {\n        var scheme = 'http' + (useTLS ? 's' : '') + '://';\n        var url = scheme + (sender.host || sender.options.host) + sender.options.path;\n        var query = buildQueryString(data);\n        url += '/' + 2 + '?' + query;\n        var xhr = node_runtime.createXHR();\n        xhr.open('GET', url, true);\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                let { status, responseText } = xhr;\n                if (status !== 200) {\n                    logger.debug(`TimelineSender Error: received ${status} from stats.pusher.com`);\n                    return;\n                }\n                try {\n                    var { host } = JSON.parse(responseText);\n                }\n                catch (e) {\n                    logger.debug(`TimelineSenderError: invalid response ${responseText}`);\n                }\n                if (host) {\n                    sender.host = host;\n                }\n            }\n        };\n        xhr.send();\n    };\n};\nvar xhr_timeline_xhr = {\n    name: 'xhr',\n    getAgent\n};\n/* harmony default export */ var xhr_timeline = (xhr_timeline_xhr);\n\n// EXTERNAL MODULE: external \"crypto\"\nvar external_crypto_ = __nested_webpack_require_195432__(3);\n\n// CONCATENATED MODULE: ./src/runtimes/node/runtime.ts\n\n\n\n\n\n\n\nconst { getDefaultStrategy: runtime_getDefaultStrategy, Transports: runtime_Transports, setup, getProtocol, isXHRSupported, getLocalStorage, createXHR, createWebSocket, addUnloadListener, removeUnloadListener, transportConnectionInitializer, createSocketRequest, HTTPFactory } = runtime;\nconst NodeJS = {\n    getDefaultStrategy: runtime_getDefaultStrategy,\n    Transports: runtime_Transports,\n    setup,\n    getProtocol,\n    isXHRSupported,\n    createSocketRequest,\n    getLocalStorage,\n    createXHR,\n    createWebSocket,\n    addUnloadListener,\n    removeUnloadListener,\n    transportConnectionInitializer,\n    HTTPFactory,\n    TimelineTransport: xhr_timeline,\n    getAuthorizers() {\n        return { ajax: xhr_auth };\n    },\n    getWebSocketAPI() {\n        return websocket[\"Client\"];\n    },\n    getXHRAPI() {\n        return XMLHttpRequest[\"XMLHttpRequest\"];\n    },\n    getNetwork() {\n        return net_info_Network;\n    },\n    randomInt(max) {\n        return Object(external_crypto_[\"randomInt\"])(max);\n    }\n};\n/* harmony default export */ var node_runtime = (NodeJS);\n\n// CONCATENATED MODULE: ./src/core/timeline/level.ts\nvar TimelineLevel;\n(function (TimelineLevel) {\n    TimelineLevel[TimelineLevel[\"ERROR\"] = 3] = \"ERROR\";\n    TimelineLevel[TimelineLevel[\"INFO\"] = 6] = \"INFO\";\n    TimelineLevel[TimelineLevel[\"DEBUG\"] = 7] = \"DEBUG\";\n})(TimelineLevel || (TimelineLevel = {}));\n/* harmony default export */ var timeline_level = (TimelineLevel);\n\n// CONCATENATED MODULE: ./src/core/timeline/timeline.ts\n\n\n\nclass timeline_Timeline {\n    constructor(key, session, options) {\n        this.key = key;\n        this.session = session;\n        this.events = [];\n        this.options = options || {};\n        this.sent = 0;\n        this.uniqueID = 0;\n    }\n    log(level, event) {\n        if (level <= this.options.level) {\n            this.events.push(extend({}, event, { timestamp: util.now() }));\n            if (this.options.limit && this.events.length > this.options.limit) {\n                this.events.shift();\n            }\n        }\n    }\n    error(event) {\n        this.log(timeline_level.ERROR, event);\n    }\n    info(event) {\n        this.log(timeline_level.INFO, event);\n    }\n    debug(event) {\n        this.log(timeline_level.DEBUG, event);\n    }\n    isEmpty() {\n        return this.events.length === 0;\n    }\n    send(sendfn, callback) {\n        var data = extend({\n            session: this.session,\n            bundle: this.sent + 1,\n            key: this.key,\n            lib: 'js',\n            version: this.options.version,\n            cluster: this.options.cluster,\n            features: this.options.features,\n            timeline: this.events\n        }, this.options.params);\n        this.events = [];\n        sendfn(data, (error, result) => {\n            if (!error) {\n                this.sent++;\n            }\n            if (callback) {\n                callback(error, result);\n            }\n        });\n        return true;\n    }\n    generateUniqueID() {\n        this.uniqueID++;\n        return this.uniqueID;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/transport_strategy.ts\n\n\n\n\nclass transport_strategy_TransportStrategy {\n    constructor(name, priority, transport, options) {\n        this.name = name;\n        this.priority = priority;\n        this.transport = transport;\n        this.options = options || {};\n    }\n    isSupported() {\n        return this.transport.isSupported({\n            useTLS: this.options.useTLS\n        });\n    }\n    connect(minPriority, callback) {\n        if (!this.isSupported()) {\n            return failAttempt(new UnsupportedStrategy(), callback);\n        }\n        else if (this.priority < minPriority) {\n            return failAttempt(new TransportPriorityTooLow(), callback);\n        }\n        var connected = false;\n        var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);\n        var handshake = null;\n        var onInitialized = function () {\n            transport.unbind('initialized', onInitialized);\n            transport.connect();\n        };\n        var onOpen = function () {\n            handshake = factory.createHandshake(transport, function (result) {\n                connected = true;\n                unbindListeners();\n                callback(null, result);\n            });\n        };\n        var onError = function (error) {\n            unbindListeners();\n            callback(error);\n        };\n        var onClosed = function () {\n            unbindListeners();\n            var serializedTransport;\n            serializedTransport = safeJSONStringify(transport);\n            callback(new TransportClosed(serializedTransport));\n        };\n        var unbindListeners = function () {\n            transport.unbind('initialized', onInitialized);\n            transport.unbind('open', onOpen);\n            transport.unbind('error', onError);\n            transport.unbind('closed', onClosed);\n        };\n        transport.bind('initialized', onInitialized);\n        transport.bind('open', onOpen);\n        transport.bind('error', onError);\n        transport.bind('closed', onClosed);\n        transport.initialize();\n        return {\n            abort: () => {\n                if (connected) {\n                    return;\n                }\n                unbindListeners();\n                if (handshake) {\n                    handshake.close();\n                }\n                else {\n                    transport.close();\n                }\n            },\n            forceMinPriority: p => {\n                if (connected) {\n                    return;\n                }\n                if (this.priority < p) {\n                    if (handshake) {\n                        handshake.close();\n                    }\n                    else {\n                        transport.close();\n                    }\n                }\n            }\n        };\n    }\n}\nfunction failAttempt(error, callback) {\n    util.defer(function () {\n        callback(error);\n    });\n    return {\n        abort: function () { },\n        forceMinPriority: function () { }\n    };\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/strategy_builder.ts\n\n\n\n\n\nconst { Transports: strategy_builder_Transports } = node_runtime;\nvar strategy_builder_defineTransport = function (config, name, type, priority, options, manager) {\n    var transportClass = strategy_builder_Transports[type];\n    if (!transportClass) {\n        throw new UnsupportedTransport(type);\n    }\n    var enabled = (!config.enabledTransports ||\n        arrayIndexOf(config.enabledTransports, name) !== -1) &&\n        (!config.disabledTransports ||\n            arrayIndexOf(config.disabledTransports, name) === -1);\n    var transport;\n    if (enabled) {\n        options = Object.assign({ ignoreNullOrigin: config.ignoreNullOrigin }, options);\n        transport = new transport_strategy_TransportStrategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, options);\n    }\n    else {\n        transport = strategy_builder_UnsupportedStrategy;\n    }\n    return transport;\n};\nvar strategy_builder_UnsupportedStrategy = {\n    isSupported: function () {\n        return false;\n    },\n    connect: function (_, callback) {\n        var deferred = util.defer(function () {\n            callback(new UnsupportedStrategy());\n        });\n        return {\n            abort: function () {\n                deferred.ensureAborted();\n            },\n            forceMinPriority: function () { }\n        };\n    }\n};\n\n// CONCATENATED MODULE: ./src/core/options.ts\n\nfunction validateOptions(options) {\n    if (options == null) {\n        throw 'You must pass an options object';\n    }\n    if (options.cluster == null) {\n        throw 'Options object must provide a cluster';\n    }\n    if ('disableStats' in options) {\n        logger.warn('The disableStats option is deprecated in favor of enableStats');\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/auth/user_authenticator.ts\n\n\nconst composeChannelQuery = (params, authOptions) => {\n    var query = 'socket_id=' + encodeURIComponent(params.socketId);\n    for (var key in authOptions.params) {\n        query +=\n            '&' +\n                encodeURIComponent(key) +\n                '=' +\n                encodeURIComponent(authOptions.params[key]);\n    }\n    if (authOptions.paramsProvider != null) {\n        let dynamicParams = authOptions.paramsProvider();\n        for (var key in dynamicParams) {\n            query +=\n                '&' +\n                    encodeURIComponent(key) +\n                    '=' +\n                    encodeURIComponent(dynamicParams[key]);\n        }\n    }\n    return query;\n};\nconst UserAuthenticator = (authOptions) => {\n    if (typeof node_runtime.getAuthorizers()[authOptions.transport] === 'undefined') {\n        throw `'${authOptions.transport}' is not a recognized auth transport`;\n    }\n    return (params, callback) => {\n        const query = composeChannelQuery(params, authOptions);\n        node_runtime.getAuthorizers()[authOptions.transport](node_runtime, query, authOptions, AuthRequestType.UserAuthentication, callback);\n    };\n};\n/* harmony default export */ var user_authenticator = (UserAuthenticator);\n\n// CONCATENATED MODULE: ./src/core/auth/channel_authorizer.ts\n\n\nconst channel_authorizer_composeChannelQuery = (params, authOptions) => {\n    var query = 'socket_id=' + encodeURIComponent(params.socketId);\n    query += '&channel_name=' + encodeURIComponent(params.channelName);\n    for (var key in authOptions.params) {\n        query +=\n            '&' +\n                encodeURIComponent(key) +\n                '=' +\n                encodeURIComponent(authOptions.params[key]);\n    }\n    if (authOptions.paramsProvider != null) {\n        let dynamicParams = authOptions.paramsProvider();\n        for (var key in dynamicParams) {\n            query +=\n                '&' +\n                    encodeURIComponent(key) +\n                    '=' +\n                    encodeURIComponent(dynamicParams[key]);\n        }\n    }\n    return query;\n};\nconst ChannelAuthorizer = (authOptions) => {\n    if (typeof node_runtime.getAuthorizers()[authOptions.transport] === 'undefined') {\n        throw `'${authOptions.transport}' is not a recognized auth transport`;\n    }\n    return (params, callback) => {\n        const query = channel_authorizer_composeChannelQuery(params, authOptions);\n        node_runtime.getAuthorizers()[authOptions.transport](node_runtime, query, authOptions, AuthRequestType.ChannelAuthorization, callback);\n    };\n};\n/* harmony default export */ var channel_authorizer = (ChannelAuthorizer);\n\n// CONCATENATED MODULE: ./src/core/auth/deprecated_channel_authorizer.ts\nconst ChannelAuthorizerProxy = (pusher, authOptions, channelAuthorizerGenerator) => {\n    const deprecatedAuthorizerOptions = {\n        authTransport: authOptions.transport,\n        authEndpoint: authOptions.endpoint,\n        auth: {\n            params: authOptions.params,\n            headers: authOptions.headers\n        }\n    };\n    return (params, callback) => {\n        const channel = pusher.channel(params.channelName);\n        const channelAuthorizer = channelAuthorizerGenerator(channel, deprecatedAuthorizerOptions);\n        channelAuthorizer.authorize(params.socketId, callback);\n    };\n};\n\n// CONCATENATED MODULE: ./src/core/config.ts\n\n\n\n\n\nfunction getConfig(opts, pusher) {\n    let config = {\n        activityTimeout: opts.activityTimeout || defaults.activityTimeout,\n        cluster: opts.cluster,\n        httpPath: opts.httpPath || defaults.httpPath,\n        httpPort: opts.httpPort || defaults.httpPort,\n        httpsPort: opts.httpsPort || defaults.httpsPort,\n        pongTimeout: opts.pongTimeout || defaults.pongTimeout,\n        statsHost: opts.statsHost || defaults.stats_host,\n        unavailableTimeout: opts.unavailableTimeout || defaults.unavailableTimeout,\n        wsPath: opts.wsPath || defaults.wsPath,\n        wsPort: opts.wsPort || defaults.wsPort,\n        wssPort: opts.wssPort || defaults.wssPort,\n        enableStats: getEnableStatsConfig(opts),\n        httpHost: getHttpHost(opts),\n        useTLS: shouldUseTLS(opts),\n        wsHost: getWebsocketHost(opts),\n        userAuthenticator: buildUserAuthenticator(opts),\n        channelAuthorizer: buildChannelAuthorizer(opts, pusher)\n    };\n    if ('disabledTransports' in opts)\n        config.disabledTransports = opts.disabledTransports;\n    if ('enabledTransports' in opts)\n        config.enabledTransports = opts.enabledTransports;\n    if ('ignoreNullOrigin' in opts)\n        config.ignoreNullOrigin = opts.ignoreNullOrigin;\n    if ('timelineParams' in opts)\n        config.timelineParams = opts.timelineParams;\n    if ('nacl' in opts) {\n        config.nacl = opts.nacl;\n    }\n    return config;\n}\nfunction getHttpHost(opts) {\n    if (opts.httpHost) {\n        return opts.httpHost;\n    }\n    if (opts.cluster) {\n        return `sockjs-${opts.cluster}.pusher.com`;\n    }\n    return defaults.httpHost;\n}\nfunction getWebsocketHost(opts) {\n    if (opts.wsHost) {\n        return opts.wsHost;\n    }\n    return getWebsocketHostFromCluster(opts.cluster);\n}\nfunction getWebsocketHostFromCluster(cluster) {\n    return `ws-${cluster}.pusher.com`;\n}\nfunction shouldUseTLS(opts) {\n    if (node_runtime.getProtocol() === 'https:') {\n        return true;\n    }\n    else if (opts.forceTLS === false) {\n        return false;\n    }\n    return true;\n}\nfunction getEnableStatsConfig(opts) {\n    if ('enableStats' in opts) {\n        return opts.enableStats;\n    }\n    if ('disableStats' in opts) {\n        return !opts.disableStats;\n    }\n    return false;\n}\nfunction buildUserAuthenticator(opts) {\n    const userAuthentication = Object.assign(Object.assign({}, defaults.userAuthentication), opts.userAuthentication);\n    if ('customHandler' in userAuthentication &&\n        userAuthentication['customHandler'] != null) {\n        return userAuthentication['customHandler'];\n    }\n    return user_authenticator(userAuthentication);\n}\nfunction buildChannelAuth(opts, pusher) {\n    let channelAuthorization;\n    if ('channelAuthorization' in opts) {\n        channelAuthorization = Object.assign(Object.assign({}, defaults.channelAuthorization), opts.channelAuthorization);\n    }\n    else {\n        channelAuthorization = {\n            transport: opts.authTransport || defaults.authTransport,\n            endpoint: opts.authEndpoint || defaults.authEndpoint\n        };\n        if ('auth' in opts) {\n            if ('params' in opts.auth)\n                channelAuthorization.params = opts.auth.params;\n            if ('headers' in opts.auth)\n                channelAuthorization.headers = opts.auth.headers;\n        }\n        if ('authorizer' in opts)\n            channelAuthorization.customHandler = ChannelAuthorizerProxy(pusher, channelAuthorization, opts.authorizer);\n    }\n    return channelAuthorization;\n}\nfunction buildChannelAuthorizer(opts, pusher) {\n    const channelAuthorization = buildChannelAuth(opts, pusher);\n    if ('customHandler' in channelAuthorization &&\n        channelAuthorization['customHandler'] != null) {\n        return channelAuthorization['customHandler'];\n    }\n    return channel_authorizer(channelAuthorization);\n}\n\n// CONCATENATED MODULE: ./src/core/watchlist.ts\n\n\nclass watchlist_WatchlistFacade extends dispatcher_Dispatcher {\n    constructor(pusher) {\n        super(function (eventName, data) {\n            logger.debug(`No callbacks on watchlist events for ${eventName}`);\n        });\n        this.pusher = pusher;\n        this.bindWatchlistInternalEvent();\n    }\n    handleEvent(pusherEvent) {\n        pusherEvent.data.events.forEach(watchlistEvent => {\n            this.emit(watchlistEvent.name, watchlistEvent);\n        });\n    }\n    bindWatchlistInternalEvent() {\n        this.pusher.connection.bind('message', pusherEvent => {\n            var eventName = pusherEvent.event;\n            if (eventName === 'pusher_internal:watchlist_events') {\n                this.handleEvent(pusherEvent);\n            }\n        });\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/utils/flat_promise.ts\nfunction flatPromise() {\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n/* harmony default export */ var flat_promise = (flatPromise);\n\n// CONCATENATED MODULE: ./src/core/user.ts\n\n\n\n\n\nclass user_UserFacade extends dispatcher_Dispatcher {\n    constructor(pusher) {\n        super(function (eventName, data) {\n            logger.debug('No callbacks on user for ' + eventName);\n        });\n        this.signin_requested = false;\n        this.user_data = null;\n        this.serverToUserChannel = null;\n        this.signinDonePromise = null;\n        this._signinDoneResolve = null;\n        this._onAuthorize = (err, authData) => {\n            if (err) {\n                logger.warn(`Error during signin: ${err}`);\n                this._cleanup();\n                return;\n            }\n            this.pusher.send_event('pusher:signin', {\n                auth: authData.auth,\n                user_data: authData.user_data\n            });\n        };\n        this.pusher = pusher;\n        this.pusher.connection.bind('state_change', ({ previous, current }) => {\n            if (previous !== 'connected' && current === 'connected') {\n                this._signin();\n            }\n            if (previous === 'connected' && current !== 'connected') {\n                this._cleanup();\n                this._newSigninPromiseIfNeeded();\n            }\n        });\n        this.watchlist = new watchlist_WatchlistFacade(pusher);\n        this.pusher.connection.bind('message', event => {\n            var eventName = event.event;\n            if (eventName === 'pusher:signin_success') {\n                this._onSigninSuccess(event.data);\n            }\n            if (this.serverToUserChannel &&\n                this.serverToUserChannel.name === event.channel) {\n                this.serverToUserChannel.handleEvent(event);\n            }\n        });\n    }\n    signin() {\n        if (this.signin_requested) {\n            return;\n        }\n        this.signin_requested = true;\n        this._signin();\n    }\n    _signin() {\n        if (!this.signin_requested) {\n            return;\n        }\n        this._newSigninPromiseIfNeeded();\n        if (this.pusher.connection.state !== 'connected') {\n            return;\n        }\n        this.pusher.config.userAuthenticator({\n            socketId: this.pusher.connection.socket_id\n        }, this._onAuthorize);\n    }\n    _onSigninSuccess(data) {\n        try {\n            this.user_data = JSON.parse(data.user_data);\n        }\n        catch (e) {\n            logger.error(`Failed parsing user data after signin: ${data.user_data}`);\n            this._cleanup();\n            return;\n        }\n        if (typeof this.user_data.id !== 'string' || this.user_data.id === '') {\n            logger.error(`user_data doesn't contain an id. user_data: ${this.user_data}`);\n            this._cleanup();\n            return;\n        }\n        this._signinDoneResolve();\n        this._subscribeChannels();\n    }\n    _subscribeChannels() {\n        const ensure_subscribed = channel => {\n            if (channel.subscriptionPending && channel.subscriptionCancelled) {\n                channel.reinstateSubscription();\n            }\n            else if (!channel.subscriptionPending &&\n                this.pusher.connection.state === 'connected') {\n                channel.subscribe();\n            }\n        };\n        this.serverToUserChannel = new channel_Channel(`#server-to-user-${this.user_data.id}`, this.pusher);\n        this.serverToUserChannel.bind_global((eventName, data) => {\n            if (eventName.indexOf('pusher_internal:') === 0 ||\n                eventName.indexOf('pusher:') === 0) {\n                return;\n            }\n            this.emit(eventName, data);\n        });\n        ensure_subscribed(this.serverToUserChannel);\n    }\n    _cleanup() {\n        this.user_data = null;\n        if (this.serverToUserChannel) {\n            this.serverToUserChannel.unbind_all();\n            this.serverToUserChannel.disconnect();\n            this.serverToUserChannel = null;\n        }\n        if (this.signin_requested) {\n            this._signinDoneResolve();\n        }\n    }\n    _newSigninPromiseIfNeeded() {\n        if (!this.signin_requested) {\n            return;\n        }\n        if (this.signinDonePromise && !this.signinDonePromise.done) {\n            return;\n        }\n        const { promise, resolve, reject: _ } = flat_promise();\n        promise.done = false;\n        const setDone = () => {\n            promise.done = true;\n        };\n        promise.then(setDone).catch(setDone);\n        this.signinDonePromise = promise;\n        this._signinDoneResolve = resolve;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/pusher.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass pusher_Pusher {\n    static ready() {\n        pusher_Pusher.isReady = true;\n        for (var i = 0, l = pusher_Pusher.instances.length; i < l; i++) {\n            pusher_Pusher.instances[i].connect();\n        }\n    }\n    static getClientFeatures() {\n        return keys(filterObject({ ws: node_runtime.Transports.ws }, function (t) {\n            return t.isSupported({});\n        }));\n    }\n    constructor(app_key, options) {\n        checkAppKey(app_key);\n        validateOptions(options);\n        this.key = app_key;\n        this.config = getConfig(options, this);\n        this.channels = factory.createChannels();\n        this.global_emitter = new dispatcher_Dispatcher();\n        this.sessionID = node_runtime.randomInt(1000000000);\n        this.timeline = new timeline_Timeline(this.key, this.sessionID, {\n            cluster: this.config.cluster,\n            features: pusher_Pusher.getClientFeatures(),\n            params: this.config.timelineParams || {},\n            limit: 50,\n            level: timeline_level.INFO,\n            version: defaults.VERSION\n        });\n        if (this.config.enableStats) {\n            this.timelineSender = factory.createTimelineSender(this.timeline, {\n                host: this.config.statsHost,\n                path: '/timeline/v2/' + node_runtime.TimelineTransport.name\n            });\n        }\n        var getStrategy = (options) => {\n            return node_runtime.getDefaultStrategy(this.config, options, strategy_builder_defineTransport);\n        };\n        this.connection = factory.createConnectionManager(this.key, {\n            getStrategy: getStrategy,\n            timeline: this.timeline,\n            activityTimeout: this.config.activityTimeout,\n            pongTimeout: this.config.pongTimeout,\n            unavailableTimeout: this.config.unavailableTimeout,\n            useTLS: Boolean(this.config.useTLS)\n        });\n        this.connection.bind('connected', () => {\n            this.subscribeAll();\n            if (this.timelineSender) {\n                this.timelineSender.send(this.connection.isUsingTLS());\n            }\n        });\n        this.connection.bind('message', event => {\n            var eventName = event.event;\n            var internal = eventName.indexOf('pusher_internal:') === 0;\n            if (event.channel) {\n                var channel = this.channel(event.channel);\n                if (channel) {\n                    channel.handleEvent(event);\n                }\n            }\n            if (!internal) {\n                this.global_emitter.emit(event.event, event.data);\n            }\n        });\n        this.connection.bind('connecting', () => {\n            this.channels.disconnect();\n        });\n        this.connection.bind('disconnected', () => {\n            this.channels.disconnect();\n        });\n        this.connection.bind('error', err => {\n            logger.warn(err);\n        });\n        pusher_Pusher.instances.push(this);\n        this.timeline.info({ instances: pusher_Pusher.instances.length });\n        this.user = new user_UserFacade(this);\n        if (pusher_Pusher.isReady) {\n            this.connect();\n        }\n    }\n    channel(name) {\n        return this.channels.find(name);\n    }\n    allChannels() {\n        return this.channels.all();\n    }\n    connect() {\n        this.connection.connect();\n        if (this.timelineSender) {\n            if (!this.timelineSenderTimer) {\n                var usingTLS = this.connection.isUsingTLS();\n                var timelineSender = this.timelineSender;\n                this.timelineSenderTimer = new timers_PeriodicTimer(60000, function () {\n                    timelineSender.send(usingTLS);\n                });\n            }\n        }\n    }\n    disconnect() {\n        this.connection.disconnect();\n        if (this.timelineSenderTimer) {\n            this.timelineSenderTimer.ensureAborted();\n            this.timelineSenderTimer = null;\n        }\n    }\n    bind(event_name, callback, context) {\n        this.global_emitter.bind(event_name, callback, context);\n        return this;\n    }\n    unbind(event_name, callback, context) {\n        this.global_emitter.unbind(event_name, callback, context);\n        return this;\n    }\n    bind_global(callback) {\n        this.global_emitter.bind_global(callback);\n        return this;\n    }\n    unbind_global(callback) {\n        this.global_emitter.unbind_global(callback);\n        return this;\n    }\n    unbind_all(callback) {\n        this.global_emitter.unbind_all();\n        return this;\n    }\n    subscribeAll() {\n        var channelName;\n        for (channelName in this.channels.channels) {\n            if (this.channels.channels.hasOwnProperty(channelName)) {\n                this.subscribe(channelName);\n            }\n        }\n    }\n    subscribe(channel_name) {\n        var channel = this.channels.add(channel_name, this);\n        if (channel.subscriptionPending && channel.subscriptionCancelled) {\n            channel.reinstateSubscription();\n        }\n        else if (!channel.subscriptionPending &&\n            this.connection.state === 'connected') {\n            channel.subscribe();\n        }\n        return channel;\n    }\n    unsubscribe(channel_name) {\n        var channel = this.channels.find(channel_name);\n        if (channel && channel.subscriptionPending) {\n            channel.cancelSubscription();\n        }\n        else {\n            channel = this.channels.remove(channel_name);\n            if (channel && channel.subscribed) {\n                channel.unsubscribe();\n            }\n        }\n    }\n    send_event(event_name, data, channel) {\n        return this.connection.send_event(event_name, data, channel);\n    }\n    shouldUseTLS() {\n        return this.config.useTLS;\n    }\n    signin() {\n        this.user.signin();\n    }\n}\npusher_Pusher.instances = [];\npusher_Pusher.isReady = false;\npusher_Pusher.logToConsole = false;\npusher_Pusher.Runtime = node_runtime;\npusher_Pusher.ScriptReceivers = node_runtime.ScriptReceivers;\npusher_Pusher.DependenciesReceivers = node_runtime.DependenciesReceivers;\npusher_Pusher.auth_callbacks = node_runtime.auth_callbacks;\n/* harmony default export */ var core_pusher = (pusher_Pusher);\nfunction checkAppKey(key) {\n    if (key === null || key === undefined) {\n        throw 'You must pass your app key when you instantiate Pusher.';\n    }\n}\nnode_runtime.setup(pusher_Pusher);\n\n// EXTERNAL MODULE: ./node_modules/tweetnacl/nacl-fast.js\nvar nacl_fast = __nested_webpack_require_195432__(20);\n\n// CONCATENATED MODULE: ./src/core/pusher-with-encryption.ts\n\n\n\nclass pusher_with_encryption_PusherWithEncryption extends core_pusher {\n    constructor(app_key, options) {\n        core_pusher.logToConsole = pusher_with_encryption_PusherWithEncryption.logToConsole;\n        core_pusher.log = pusher_with_encryption_PusherWithEncryption.log;\n        validateOptions(options);\n        options.nacl = nacl_fast;\n        super(app_key, options);\n    }\n}\n\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=pusher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHVzaGVyLWpzL2Rpc3Qvbm9kZS9wdXNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEMsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZ0NBQWdDLDhCQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUFtQjtBQUM5QixrREFBa0QsZ0NBQWdDO0FBQ2xGLDBFQUEwRSw4QkFBbUIsNEJBQTRCLG9CQUFvQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUIsQ0FBQyw4QkFBbUI7QUFDeEQsVUFBVTtBQUNW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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMENBQTBDLG1DQUFtQztBQUM3RTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQztBQUNBLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQ7QUFDQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDRCQUE0QjtBQUNuRCx1QkFBdUIsNEJBQTRCO0FBQ25ELHVCQUF1Qiw0QkFBNEI7QUFDbkQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQsdUJBQXVCLDJCQUEyQjtBQUNsRCx1QkFBdUIsMkJBQTJCO0FBQ2xELHVCQUF1QiwyQkFBMkI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFROztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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Q3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGtDQUFrQztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMkNBQTJDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7QUFDTCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxhQUFhO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRSw4REFBOEQsYUFBYTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNkJBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2Qjs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RCxtQ0FBbUM7QUFDbkMsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BLFFBQVEsMENBQTBDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkNBQTJDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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WyJ3ZWJwYWNrOi8vbWVzc2VuZ2VyLy4vbm9kZV9tb2R1bGVzL3B1c2hlci1qcy9kaXN0L25vZGUvcHVzaGVyLmpzPzIyYmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBQdXNoZXIgSmF2YVNjcmlwdCBMaWJyYXJ5IHY4LjMuMFxuICogaHR0cHM6Ly9wdXNoZXIuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDIwLCBQdXNoZXJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5jZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIxKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBCdWZmZXIgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXIsXG4gICAgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpLkV2ZW50RW1pdHRlcixcbiAgICB1dGlsICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBzdHJlYW1zID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCksXG4gICAgSGVhZGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oOSksXG4gICAgUmVhZGVyICA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIHVybCwgb3B0aW9ucykge1xuICBFbWl0dGVyLmNhbGwodGhpcyk7XG4gIEJhc2UudmFsaWRhdGVPcHRpb25zKG9wdGlvbnMgfHwge30sIFsnbWF4TGVuZ3RoJywgJ21hc2tpbmcnLCAncmVxdWlyZU1hc2tpbmcnLCAncHJvdG9jb2xzJ10pO1xuXG4gIHRoaXMuX3JlcXVlc3QgICA9IHJlcXVlc3Q7XG4gIHRoaXMuX3JlYWRlciAgICA9IG5ldyBSZWFkZXIoKTtcbiAgdGhpcy5fb3B0aW9ucyAgID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5fb3B0aW9ucy5tYXhMZW5ndGggfHwgdGhpcy5NQVhfTEVOR1RIO1xuICB0aGlzLl9oZWFkZXJzICAgPSBuZXcgSGVhZGVycygpO1xuICB0aGlzLl9fcXVldWUgICAgPSBbXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gMDtcbiAgdGhpcy51cmwgICAgICAgID0gdXJsO1xuXG4gIHRoaXMuaW8gPSBuZXcgc3RyZWFtcy5JTyh0aGlzKTtcbiAgdGhpcy5tZXNzYWdlcyA9IG5ldyBzdHJlYW1zLk1lc3NhZ2VzKHRoaXMpO1xuICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG51dGlsLmluaGVyaXRzKEJhc2UsIEVtaXR0ZXIpO1xuXG5CYXNlLmlzV2ViU29ja2V0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICB2YXIgY29ubmVjdGlvbiA9IHJlcXVlc3QuaGVhZGVycy5jb25uZWN0aW9uIHx8ICcnLFxuICAgICAgdXBncmFkZSAgICA9IHJlcXVlc3QuaGVhZGVycy51cGdyYWRlIHx8ICcnO1xuXG4gIHJldHVybiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcgJiZcbiAgICAgICAgIGNvbm5lY3Rpb24udG9Mb3dlckNhc2UoKS5zcGxpdCgvICosICovKS5pbmRleE9mKCd1cGdyYWRlJykgPj0gMCAmJlxuICAgICAgICAgdXBncmFkZS50b0xvd2VyQ2FzZSgpID09PSAnd2Vic29ja2V0Jztcbn07XG5cbkJhc2UudmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucywgdmFsaWRLZXlzKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKHZhbGlkS2V5cy5pbmRleE9mKGtleSkgPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uOiAnICsga2V5KTtcbiAgfVxufTtcblxudmFyIGluc3RhbmNlID0ge1xuICAvLyBUaGlzIGlzIDY0TUIsIHNtYWxsIGVub3VnaCBmb3IgYW4gYXZlcmFnZSBWUFMgdG8gaGFuZGxlIHdpdGhvdXRcbiAgLy8gY3Jhc2hpbmcgZnJvbSBwcm9jZXNzIG91dCBvZiBtZW1vcnlcbiAgTUFYX0xFTkdUSDogMHgzZmZmZmZmLFxuXG4gIFNUQVRFUzogWydjb25uZWN0aW5nJywgJ29wZW4nLCAnY2xvc2luZycsICdjbG9zZWQnXSxcblxuICBfYmluZEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBQcm90b2NvbCBlcnJvcnMgYXJlIGluZm9ybWF0aW9uYWwgYW5kIGRvIG5vdCBoYXZlIHRvIGJlIGhhbmRsZWRcbiAgICB0aGlzLm1lc3NhZ2VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge30pO1xuXG4gICAgdGhpcy5vbignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgbWVzc2FnZXMgPSBzZWxmLm1lc3NhZ2VzO1xuICAgICAgaWYgKG1lc3NhZ2VzLnJlYWRhYmxlKSBtZXNzYWdlcy5lbWl0KCdkYXRhJywgZXZlbnQuZGF0YSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICB2YXIgbWVzc2FnZXMgPSBzZWxmLm1lc3NhZ2VzO1xuICAgICAgaWYgKG1lc3NhZ2VzLnJlYWRhYmxlKSBtZXNzYWdlcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWVzc2FnZXMgPSBzZWxmLm1lc3NhZ2VzO1xuICAgICAgaWYgKCFtZXNzYWdlcy5yZWFkYWJsZSkgcmV0dXJuO1xuICAgICAgbWVzc2FnZXMucmVhZGFibGUgPSBtZXNzYWdlcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgbWVzc2FnZXMuZW1pdCgnZW5kJyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLlNUQVRFU1t0aGlzLnJlYWR5U3RhdGVdIHx8IG51bGw7XG4gIH0sXG5cbiAgYWRkRXh0ZW5zaW9uOiBmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgc2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5faGVhZGVycy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIUJhc2UuaXNXZWJTb2NrZXQodGhpcy5fcmVxdWVzdCkpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZShuZXcgRXJyb3IoJ05vdCBhIFdlYlNvY2tldCByZXF1ZXN0JykpO1xuXG4gICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gdGhpcy5faGFuZHNoYWtlUmVzcG9uc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoZXJyb3IpO1xuICAgIH1cblxuICAgIHRoaXMuX3dyaXRlKHJlc3BvbnNlKTtcbiAgICBpZiAodGhpcy5fc3RhZ2UgIT09IC0xKSB0aGlzLl9vcGVuKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX2ZhaWxIYW5kc2hha2U6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpO1xuICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LUxlbmd0aCcsIEJ1ZmZlci5ieXRlTGVuZ3RoKGVycm9yLm1lc3NhZ2UsICd1dGY4JykpO1xuXG4gICAgaGVhZGVycyA9IFsnSFRUUC8xLjEgNDAwIEJhZCBSZXF1ZXN0JywgaGVhZGVycy50b1N0cmluZygpLCBlcnJvci5tZXNzYWdlXTtcbiAgICB0aGlzLl93cml0ZShCdWZmZXIuZnJvbShoZWFkZXJzLmpvaW4oJ1xcclxcbicpLCAndXRmOCcpKTtcbiAgICB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHRleHQ6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFtZShtZXNzYWdlKTtcbiAgfSxcblxuICBiaW5hcnk6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgcGluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHBvbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbihyZWFzb24sIGNvZGUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMztcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbmV3IEJhc2UuQ2xvc2VFdmVudChudWxsLCBudWxsKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX29wZW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDE7XG4gICAgdGhpcy5fX3F1ZXVlLmZvckVhY2goZnVuY3Rpb24oYXJncykgeyB0aGlzLmZyYW1lLmFwcGx5KHRoaXMsIGFyZ3MpIH0sIHRoaXMpO1xuICAgIHRoaXMuX19xdWV1ZSA9IFtdO1xuICAgIHRoaXMuZW1pdCgnb3BlbicsIG5ldyBCYXNlLk9wZW5FdmVudCgpKTtcbiAgfSxcblxuICBfcXVldWU6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9fcXVldWUucHVzaChtZXNzYWdlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfd3JpdGU6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgdmFyIGlvID0gdGhpcy5pbztcbiAgICBpZiAoaW8ucmVhZGFibGUpIGlvLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0sXG5cbiAgX2ZhaWw6IGZ1bmN0aW9uKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAyO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxufTtcblxuZm9yICh2YXIga2V5IGluIGluc3RhbmNlKVxuICBCYXNlLnByb3RvdHlwZVtrZXldID0gaW5zdGFuY2Vba2V5XTtcblxuXG5CYXNlLkNvbm5lY3RFdmVudCA9IGZ1bmN0aW9uKCkge307XG5cbkJhc2UuT3BlbkV2ZW50ID0gZnVuY3Rpb24oKSB7fTtcblxuQmFzZS5DbG9zZUV2ZW50ID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIHRoaXMuY29kZSAgID0gY29kZTtcbiAgdGhpcy5yZWFzb24gPSByZWFzb247XG59O1xuXG5CYXNlLk1lc3NhZ2VFdmVudCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn07XG5cbkJhc2UuUGluZ0V2ZW50ID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufTtcblxuQmFzZS5Qb25nRXZlbnQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIFByb3RvY29sIHJlZmVyZW5jZXM6XG4vL1xuLy8gKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1oaXhpZS10aGV3ZWJzb2NrZXRwcm90b2NvbC03NVxuLy8gKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1oaXhpZS10aGV3ZWJzb2NrZXRwcm90b2NvbC03NlxuLy8gKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLWh5YmktdGhld2Vic29ja2V0cHJvdG9jb2wtMTdcblxudmFyIEJhc2UgICA9IF9fd2VicGFja19yZXF1aXJlX18oMiksXG4gICAgQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNiksXG4gICAgU2VydmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbnZhciBEcml2ZXIgPSB7XG4gIGNsaWVudDogZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMubWFza2luZyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zLm1hc2tpbmcgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgQ2xpZW50KHVybCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc2VydmVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMucmVxdWlyZU1hc2tpbmcgPT09IHVuZGVmaW5lZCkgb3B0aW9ucy5yZXF1aXJlTWFza2luZyA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXIob3B0aW9ucyk7XG4gIH0sXG5cbiAgaHR0cDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFNlcnZlci5odHRwLmFwcGx5KFNlcnZlciwgYXJndW1lbnRzKTtcbiAgfSxcblxuICBpc1NlY3VyZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gU2VydmVyLmlzU2VjdXJlUmVxdWVzdChyZXF1ZXN0KTtcbiAgfSxcblxuICBpc1dlYlNvY2tldDogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHJldHVybiBCYXNlLmlzV2ViU29ja2V0KHJlcXVlc3QpO1xuICB9LFxuXG4gIHZhbGlkYXRlT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucywgdmFsaWRLZXlzKSB7XG4gICAgQmFzZS52YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgdmFsaWRLZXlzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcml2ZXI7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmVhbVwiKTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgb3B0aW9ucykge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKVxuICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgICAgICAgPSBldmVudFR5cGU7XG4gIHRoaXMuYnViYmxlcyAgICA9IGNhbkJ1YmJsZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ICA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgICAgICAgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgID0gMztcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENvcHlyaWdodCAoQykgMjAxNiBEbWl0cnkgQ2hlc3RueWtoXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIGJhc2U2NCBpbXBsZW1lbnRzIEJhc2U2NCBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKi9cbi8vIEludmFsaWQgY2hhcmFjdGVyIHVzZWQgaW4gZGVjb2RpbmcgdG8gaW5kaWNhdGVcbi8vIHRoYXQgdGhlIGNoYXJhY3RlciB0byBkZWNvZGUgaXMgb3V0IG9mIHJhbmdlIG9mXG4vLyBhbHBoYWJldCBhbmQgY2Fubm90IGJlIGRlY29kZWQuXG52YXIgSU5WQUxJRF9CWVRFID0gMjU2O1xuLyoqXG4gKiBJbXBsZW1lbnRzIHN0YW5kYXJkIEJhc2U2NCBlbmNvZGluZy5cbiAqXG4gKiBPcGVyYXRlcyBpbiBjb25zdGFudCB0aW1lLlxuICovXG52YXIgQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETyhkY2hlc3QpOiBtZXRob2RzIHRvIGVuY29kZSBjaHVuay1ieS1jaHVuay5cbiAgICBmdW5jdGlvbiBDb2RlcihfcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICBpZiAoX3BhZGRpbmdDaGFyYWN0ZXIgPT09IHZvaWQgMCkgeyBfcGFkZGluZ0NoYXJhY3RlciA9IFwiPVwiOyB9XG4gICAgICAgIHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgPSBfcGFkZGluZ0NoYXJhY3RlcjtcbiAgICB9XG4gICAgQ29kZXIucHJvdG90eXBlLmVuY29kZWRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIChsZW5ndGggKiA4ICsgNSkgLyA2IHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGxlbmd0aCArIDIpIC8gMyAqIDQgfCAwO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBvdXQgPSBcIlwiO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgZGF0YS5sZW5ndGggLSAyOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHZhciBjID0gKGRhdGFbaV0gPDwgMTYpIHwgKGRhdGFbaSArIDFdIDw8IDgpIHwgKGRhdGFbaSArIDJdKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAzICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMiAqIDYpICYgNjMpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDEgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAwICogNikgJiA2Myk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSBkYXRhLmxlbmd0aCAtIGk7XG4gICAgICAgIGlmIChsZWZ0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGMgPSAoZGF0YVtpXSA8PCAxNikgfCAobGVmdCA9PT0gMiA/IGRhdGFbaSArIDFdIDw8IDggOiAwKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAzICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMiAqIDYpICYgNjMpO1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMSAqIDYpICYgNjMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgfHwgXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5tYXhEZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAobGVuZ3RoICogNiArIDcpIC8gOCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aCAvIDQgKiAzIHwgMDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5kZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RGVjb2RlZExlbmd0aChzLmxlbmd0aCAtIHRoaXMuX2dldFBhZGRpbmdMZW5ndGgocykpO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWRkaW5nTGVuZ3RoID0gdGhpcy5fZ2V0UGFkZGluZ0xlbmd0aChzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoIC0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4RGVjb2RlZExlbmd0aChsZW5ndGgpKTtcbiAgICAgICAgdmFyIG9wID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgaGF2ZUJhZCA9IDA7XG4gICAgICAgIHZhciB2MCA9IDAsIHYxID0gMCwgdjIgPSAwLCB2MyA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoIC0gNDsgaSArPSA0KSB7XG4gICAgICAgICAgICB2MCA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAwKSk7XG4gICAgICAgICAgICB2MSA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICB2MiA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAyKSk7XG4gICAgICAgICAgICB2MyA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjAgPDwgMikgfCAodjEgPj4+IDQpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYxIDw8IDQpIHwgKHYyID4+PiAyKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MiA8PCA2KSB8IHYzO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MCAmIElOVkFMSURfQllURTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjEgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYyICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MyAmIElOVkFMSURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHYwID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgdjEgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYwIDw8IDIpIHwgKHYxID4+PiA0KTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjAgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYxICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgdjIgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMikpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYxIDw8IDQpIHwgKHYyID4+PiAyKTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjIgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAzKSB7XG4gICAgICAgICAgICB2MyA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjIgPDwgNikgfCB2MztcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjMgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhdmVCYWQgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NENvZGVyOiBpbmNvcnJlY3QgY2hhcmFjdGVycyBmb3IgZGVjb2RpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8vIFN0YW5kYXJkIGVuY29kaW5nIGhhdmUgdGhlIGZvbGxvd2luZyBlbmNvZGVkL2RlY29kZWQgcmFuZ2VzLFxuICAgIC8vIHdoaWNoIHdlIG5lZWQgdG8gY29udmVydCBiZXR3ZWVuLlxuICAgIC8vXG4gICAgLy8gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogMDEyMzQ1Njc4OSAgKyAgIC9cbiAgICAvLyBJbmRleDogICAwIC0gMjUgICAgICAgICAgICAgICAgICAgIDI2IC0gNTEgICAgICAgICAgICAgIDUyIC0gNjEgICA2MiAgNjNcbiAgICAvLyBBU0NJSTogIDY1IC0gOTAgICAgICAgICAgICAgICAgICAgIDk3IC0gMTIyICAgICAgICAgICAgIDQ4IC0gNTcgICA0MyAgNDdcbiAgICAvL1xuICAgIC8vIEVuY29kZSA2IGJpdHMgaW4gYiBpbnRvIGEgbmV3IGNoYXJhY3Rlci5cbiAgICBDb2Rlci5wcm90b3R5cGUuX2VuY29kZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAvLyBFbmNvZGluZyB1c2VzIGNvbnN0YW50IHRpbWUgb3BlcmF0aW9ucyBhcyBmb2xsb3dzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBEZWZpbmUgY29tcGFyaXNvbiBvZiBBIHdpdGggQiB1c2luZyAoQSAtIEIpID4+PiA4OlxuICAgICAgICAvLyAgICAgICAgICBpZiBBID4gQiwgdGhlbiByZXN1bHQgaXMgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAvLyAgICAgICAgICBpZiBBIDw9IEIsIHRoZW4gcmVzdWx0IGlzIDBcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMi4gRGVmaW5lIHNlbGVjdGlvbiBvZiBDIG9yIDAgdXNpbmcgYml0d2lzZSBBTkQ6IFggJiBDOlxuICAgICAgICAvLyAgICAgICAgICBpZiBYID09IDAsIHRoZW4gcmVzdWx0IGlzIDBcbiAgICAgICAgLy8gICAgICAgICAgaWYgWCAhPSAwLCB0aGVuIHJlc3VsdCBpcyBDXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDMuIFN0YXJ0IHdpdGggdGhlIHNtYWxsZXN0IGNvbXBhcmlzb24gKGIgPj0gMCksIHdoaWNoIGlzIGFsd2F5c1xuICAgICAgICAvLyAgICB0cnVlLCBzbyBzZXQgdGhlIHJlc3VsdCB0byB0aGUgc3RhcnRpbmcgQVNDSUkgdmFsdWUgKDY1KS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gNC4gQ29udGludWUgY29tcGFyaW5nIGIgdG8gaGlnaGVyIEFTQ0lJIHZhbHVlcywgYW5kIHNlbGVjdGluZ1xuICAgICAgICAvLyAgICB6ZXJvIGlmIGNvbXBhcmlzb24gaXNuJ3QgdHJ1ZSwgb3RoZXJ3aXNlIHNlbGVjdGluZyBhIHZhbHVlXG4gICAgICAgIC8vICAgIHRvIGFkZCB0byByZXN1bHQsIHdoaWNoOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgICBhKSB1bmRvZXMgdGhlIHByZXZpb3VzIGFkZGl0aW9uXG4gICAgICAgIC8vICAgICAgICAgIGIpIHByb3ZpZGVzIG5ldyB2YWx1ZSB0byBhZGRcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHJlc3VsdCA9IGI7XG4gICAgICAgIC8vIGIgPj0gMFxuICAgICAgICByZXN1bHQgKz0gNjU7XG4gICAgICAgIC8vIGIgPiAyNVxuICAgICAgICByZXN1bHQgKz0gKCgyNSAtIGIpID4+PiA4KSAmICgoMCAtIDY1KSAtIDI2ICsgOTcpO1xuICAgICAgICAvLyBiID4gNTFcbiAgICAgICAgcmVzdWx0ICs9ICgoNTEgLSBiKSA+Pj4gOCkgJiAoKDI2IC0gOTcpIC0gNTIgKyA0OCk7XG4gICAgICAgIC8vIGIgPiA2MVxuICAgICAgICByZXN1bHQgKz0gKCg2MSAtIGIpID4+PiA4KSAmICgoNTIgLSA0OCkgLSA2MiArIDQzKTtcbiAgICAgICAgLy8gYiA+IDYyXG4gICAgICAgIHJlc3VsdCArPSAoKDYyIC0gYikgPj4+IDgpICYgKCg2MiAtIDQzKSAtIDYzICsgNDcpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShyZXN1bHQpO1xuICAgIH07XG4gICAgLy8gRGVjb2RlIGEgY2hhcmFjdGVyIGNvZGUgaW50byBhIGJ5dGUuXG4gICAgLy8gTXVzdCByZXR1cm4gMjU2IGlmIGNoYXJhY3RlciBpcyBvdXQgb2YgYWxwaGFiZXQgcmFuZ2UuXG4gICAgQ29kZXIucHJvdG90eXBlLl9kZWNvZGVDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gRGVjb2Rpbmcgd29ya3Mgc2ltaWxhciB0byBlbmNvZGluZzogdXNpbmcgdGhlIHNhbWUgY29tcGFyaXNvblxuICAgICAgICAvLyBmdW5jdGlvbiwgYnV0IG5vdyBpdCB3b3JrcyBvbiByYW5nZXM6IHJlc3VsdCBpcyBhbHdheXMgaW5jcmVtZW50ZWRcbiAgICAgICAgLy8gYnkgdmFsdWUsIGJ1dCB0aGlzIHZhbHVlIGJlY29tZXMgemVybyBpZiB0aGUgcmFuZ2UgaXMgbm90XG4gICAgICAgIC8vIHNhdGlzZmllZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVjb2Rpbmcgc3RhcnRzIHdpdGggaW52YWxpZCB2YWx1ZSwgMjU2LCB3aGljaCBpcyB0aGVuXG4gICAgICAgIC8vIHN1YnRyYWN0ZWQgd2hlbiB0aGUgcmFuZ2UgaXMgc2F0aXNmaWVkLiBJZiBub25lIG9mIHRoZSByYW5nZXNcbiAgICAgICAgLy8gYXBwbHksIHRoZSBmdW5jdGlvbiByZXR1cm5zIDI1Niwgd2hpY2ggaXMgdGhlbiBjaGVja2VkIGJ5XG4gICAgICAgIC8vIHRoZSBjYWxsZXIgdG8gdGhyb3cgZXJyb3IuXG4gICAgICAgIHZhciByZXN1bHQgPSBJTlZBTElEX0JZVEU7IC8vIHN0YXJ0IHdpdGggaW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgICAgLy8gYyA9PSA0MyAoYyA+IDQyIGFuZCBjIDwgNDQpXG4gICAgICAgIHJlc3VsdCArPSAoKCg0MiAtIGMpICYgKGMgLSA0NCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQzICsgNjIpO1xuICAgICAgICAvLyBjID09IDQ3IChjID4gNDYgYW5kIGMgPCA0OClcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ2IC0gYykgJiAoYyAtIDQ4KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDcgKyA2Myk7XG4gICAgICAgIC8vIGMgPiA0NyBhbmQgYyA8IDU4XG4gICAgICAgIHJlc3VsdCArPSAoKCg0NyAtIGMpICYgKGMgLSA1OCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ4ICsgNTIpO1xuICAgICAgICAvLyBjID4gNjQgYW5kIGMgPCA5MVxuICAgICAgICByZXN1bHQgKz0gKCgoNjQgLSBjKSAmIChjIC0gOTEpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA2NSArIDApO1xuICAgICAgICAvLyBjID4gOTYgYW5kIGMgPCAxMjNcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk2IC0gYykgJiAoYyAtIDEyMykpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDk3ICsgMjYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLl9nZXRQYWRkaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHBhZGRpbmdMZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPT0gdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMubGVuZ3RoIDwgNCB8fCBwYWRkaW5nTGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NENvZGVyOiBpbmNvcnJlY3QgcGFkZGluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZ0xlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBDb2Rlcjtcbn0oKSk7XG5leHBvcnRzLkNvZGVyID0gQ29kZXI7XG52YXIgc3RkQ29kZXIgPSBuZXcgQ29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmVuY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZnVuY3Rpb24gZGVjb2RlKHMpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZGVjb2RlKHMpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIEltcGxlbWVudHMgVVJMLXNhZmUgQmFzZTY0IGVuY29kaW5nLlxuICogKFNhbWUgYXMgQmFzZTY0LCBidXQgJysnIGlzIHJlcGxhY2VkIHdpdGggJy0nLCBhbmQgJy8nIHdpdGggJ18nKS5cbiAqXG4gKiBPcGVyYXRlcyBpbiBjb25zdGFudCB0aW1lLlxuICovXG52YXIgVVJMU2FmZUNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVUkxTYWZlQ29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVVJMU2FmZUNvZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIFVSTC1zYWZlIGVuY29kaW5nIGhhdmUgdGhlIGZvbGxvd2luZyBlbmNvZGVkL2RlY29kZWQgcmFuZ2VzOlxuICAgIC8vXG4gICAgLy8gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogMDEyMzQ1Njc4OSAgLSAgIF9cbiAgICAvLyBJbmRleDogICAwIC0gMjUgICAgICAgICAgICAgICAgICAgIDI2IC0gNTEgICAgICAgICAgICAgIDUyIC0gNjEgICA2MiAgNjNcbiAgICAvLyBBU0NJSTogIDY1IC0gOTAgICAgICAgICAgICAgICAgICAgIDk3IC0gMTIyICAgICAgICAgICAgIDQ4IC0gNTcgICA0NSAgOTVcbiAgICAvL1xuICAgIFVSTFNhZmVDb2Rlci5wcm90b3R5cGUuX2VuY29kZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYjtcbiAgICAgICAgLy8gYiA+PSAwXG4gICAgICAgIHJlc3VsdCArPSA2NTtcbiAgICAgICAgLy8gYiA+IDI1XG4gICAgICAgIHJlc3VsdCArPSAoKDI1IC0gYikgPj4+IDgpICYgKCgwIC0gNjUpIC0gMjYgKyA5Nyk7XG4gICAgICAgIC8vIGIgPiA1MVxuICAgICAgICByZXN1bHQgKz0gKCg1MSAtIGIpID4+PiA4KSAmICgoMjYgLSA5NykgLSA1MiArIDQ4KTtcbiAgICAgICAgLy8gYiA+IDYxXG4gICAgICAgIHJlc3VsdCArPSAoKDYxIC0gYikgPj4+IDgpICYgKCg1MiAtIDQ4KSAtIDYyICsgNDUpO1xuICAgICAgICAvLyBiID4gNjJcbiAgICAgICAgcmVzdWx0ICs9ICgoNjIgLSBiKSA+Pj4gOCkgJiAoKDYyIC0gNDUpIC0gNjMgKyA5NSk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlc3VsdCk7XG4gICAgfTtcbiAgICBVUkxTYWZlQ29kZXIucHJvdG90eXBlLl9kZWNvZGVDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IElOVkFMSURfQllURTtcbiAgICAgICAgLy8gYyA9PSA0NSAoYyA+IDQ0IGFuZCBjIDwgNDYpXG4gICAgICAgIHJlc3VsdCArPSAoKCg0NCAtIGMpICYgKGMgLSA0NikpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ1ICsgNjIpO1xuICAgICAgICAvLyBjID09IDk1IChjID4gOTQgYW5kIGMgPCA5NilcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk0IC0gYykgJiAoYyAtIDk2KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gOTUgKyA2Myk7XG4gICAgICAgIC8vIGMgPiA0NyBhbmQgYyA8IDU4XG4gICAgICAgIHJlc3VsdCArPSAoKCg0NyAtIGMpICYgKGMgLSA1OCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ4ICsgNTIpO1xuICAgICAgICAvLyBjID4gNjQgYW5kIGMgPCA5MVxuICAgICAgICByZXN1bHQgKz0gKCgoNjQgLSBjKSAmIChjIC0gOTEpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA2NSArIDApO1xuICAgICAgICAvLyBjID4gOTYgYW5kIGMgPCAxMjNcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk2IC0gYykgJiAoYyAtIDEyMykpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDk3ICsgMjYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFVSTFNhZmVDb2Rlcjtcbn0oQ29kZXIpKTtcbmV4cG9ydHMuVVJMU2FmZUNvZGVyID0gVVJMU2FmZUNvZGVyO1xudmFyIHVybFNhZmVDb2RlciA9IG5ldyBVUkxTYWZlQ29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZVVSTFNhZmUoZGF0YSkge1xuICAgIHJldHVybiB1cmxTYWZlQ29kZXIuZW5jb2RlKGRhdGEpO1xufVxuZXhwb3J0cy5lbmNvZGVVUkxTYWZlID0gZW5jb2RlVVJMU2FmZTtcbmZ1bmN0aW9uIGRlY29kZVVSTFNhZmUocykge1xuICAgIHJldHVybiB1cmxTYWZlQ29kZXIuZGVjb2RlKHMpO1xufVxuZXhwb3J0cy5kZWNvZGVVUkxTYWZlID0gZGVjb2RlVVJMU2FmZTtcbmV4cG9ydHMuZW5jb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZW5jb2RlZExlbmd0aChsZW5ndGgpO1xufTtcbmV4cG9ydHMubWF4RGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIubWF4RGVjb2RlZExlbmd0aChsZW5ndGgpO1xufTtcbmV4cG9ydHMuZGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmRlY29kZWRMZW5ndGgocyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgSGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNsZWFyKCk7XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS5BTExPV0VEX0RVUExJQ0FURVMgPSBbJ3NldC1jb29raWUnLCAnc2V0LWNvb2tpZTInLCAnd2FybmluZycsICd3d3ctYXV0aGVudGljYXRlJ107XG5cbkhlYWRlcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3NlbnQgID0ge307XG4gIHRoaXMuX2xpbmVzID0gW107XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIG5hbWUgPSB0aGlzLl9zdHJpcChuYW1lKTtcbiAgdmFsdWUgPSB0aGlzLl9zdHJpcCh2YWx1ZSk7XG5cbiAgdmFyIGtleSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCF0aGlzLl9zZW50Lmhhc093blByb3BlcnR5KGtleSkgfHwgdGhpcy5BTExPV0VEX0RVUExJQ0FURVMuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICB0aGlzLl9zZW50W2tleV0gPSB0cnVlO1xuICAgIHRoaXMuX2xpbmVzLnB1c2gobmFtZSArICc6ICcgKyB2YWx1ZSArICdcXHJcXG4nKTtcbiAgfVxufTtcblxuSGVhZGVycy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpbmVzLmpvaW4oJycpO1xufTtcblxuSGVhZGVycy5wcm90b3R5cGUuX3N0cmlwID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudG9TdHJpbmcoKS5yZXBsYWNlKC9eICovLCAnJykucmVwbGFjZSgvICokLywgJycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXJzO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIE5vZGVIVFRQUGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNykuSFRUUFBhcnNlcixcbiAgICBCdWZmZXIgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyO1xuXG52YXIgVFlQRVMgPSB7XG4gIHJlcXVlc3Q6ICBOb2RlSFRUUFBhcnNlci5SRVFVRVNUICB8fCAncmVxdWVzdCcsXG4gIHJlc3BvbnNlOiBOb2RlSFRUUFBhcnNlci5SRVNQT05TRSB8fCAncmVzcG9uc2UnXG59O1xuXG52YXIgSHR0cFBhcnNlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdGhpcy5fdHlwZSAgICAgPSB0eXBlO1xuICB0aGlzLl9wYXJzZXIgICA9IG5ldyBOb2RlSFRUUFBhcnNlcihUWVBFU1t0eXBlXSk7XG4gIHRoaXMuX2NvbXBsZXRlID0gZmFsc2U7XG4gIHRoaXMuaGVhZGVycyAgID0ge307XG5cbiAgdmFyIGN1cnJlbnQgPSBudWxsLFxuICAgICAgc2VsZiAgICA9IHRoaXM7XG5cbiAgdGhpcy5fcGFyc2VyLm9uSGVhZGVyRmllbGQgPSBmdW5jdGlvbihiLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgY3VycmVudCA9IGIudG9TdHJpbmcoJ3V0ZjgnLCBzdGFydCwgc3RhcnQgKyBsZW5ndGgpLnRvTG93ZXJDYXNlKCk7XG4gIH07XG5cbiAgdGhpcy5fcGFyc2VyLm9uSGVhZGVyVmFsdWUgPSBmdW5jdGlvbihiLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYi50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBzdGFydCArIGxlbmd0aCk7XG5cbiAgICBpZiAoc2VsZi5oZWFkZXJzLmhhc093blByb3BlcnR5KGN1cnJlbnQpKVxuICAgICAgc2VsZi5oZWFkZXJzW2N1cnJlbnRdICs9ICcsICcgKyB2YWx1ZTtcbiAgICBlbHNlXG4gICAgICBzZWxmLmhlYWRlcnNbY3VycmVudF0gPSB2YWx1ZTtcbiAgfTtcblxuICB0aGlzLl9wYXJzZXIub25IZWFkZXJzQ29tcGxldGUgPSB0aGlzLl9wYXJzZXJbTm9kZUhUVFBQYXJzZXIua09uSGVhZGVyc0NvbXBsZXRlXSA9XG4gIGZ1bmN0aW9uKG1ham9yVmVyc2lvbiwgbWlub3JWZXJzaW9uLCBoZWFkZXJzLCBtZXRob2QsIHBhdGhuYW1lLCBzdGF0dXNDb2RlKSB7XG4gICAgdmFyIGluZm8gPSBhcmd1bWVudHNbMF07XG5cbiAgICBpZiAodHlwZW9mIGluZm8gPT09ICdvYmplY3QnKSB7XG4gICAgICBtZXRob2QgICAgID0gaW5mby5tZXRob2Q7XG4gICAgICBwYXRobmFtZSAgID0gaW5mby51cmw7XG4gICAgICBzdGF0dXNDb2RlID0gaW5mby5zdGF0dXNDb2RlO1xuICAgICAgaGVhZGVycyAgICA9IGluZm8uaGVhZGVycztcbiAgICB9XG5cbiAgICBzZWxmLm1ldGhvZCAgICAgPSAodHlwZW9mIG1ldGhvZCA9PT0gJ251bWJlcicpID8gSHR0cFBhcnNlci5NRVRIT0RTW21ldGhvZF0gOiBtZXRob2Q7XG4gICAgc2VsZi5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICBzZWxmLnVybCAgICAgICAgPSBwYXRobmFtZTtcblxuICAgIGlmICghaGVhZGVycykgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBoZWFkZXJzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IG47IGkgKz0gMikge1xuICAgICAga2V5ICAgPSBoZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9IGhlYWRlcnNbaSsxXTtcbiAgICAgIGlmIChzZWxmLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgc2VsZi5oZWFkZXJzW2tleV0gKz0gJywgJyArIHZhbHVlO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHNlbGYuX2NvbXBsZXRlID0gdHJ1ZTtcbiAgfTtcbn07XG5cbkh0dHBQYXJzZXIuTUVUSE9EUyA9IHtcbiAgMDogICdERUxFVEUnLFxuICAxOiAgJ0dFVCcsXG4gIDI6ICAnSEVBRCcsXG4gIDM6ICAnUE9TVCcsXG4gIDQ6ICAnUFVUJyxcbiAgNTogICdDT05ORUNUJyxcbiAgNjogICdPUFRJT05TJyxcbiAgNzogICdUUkFDRScsXG4gIDg6ICAnQ09QWScsXG4gIDk6ICAnTE9DSycsXG4gIDEwOiAnTUtDT0wnLFxuICAxMTogJ01PVkUnLFxuICAxMjogJ1BST1BGSU5EJyxcbiAgMTM6ICdQUk9QUEFUQ0gnLFxuICAxNDogJ1NFQVJDSCcsXG4gIDE1OiAnVU5MT0NLJyxcbiAgMTY6ICdCSU5EJyxcbiAgMTc6ICdSRUJJTkQnLFxuICAxODogJ1VOQklORCcsXG4gIDE5OiAnQUNMJyxcbiAgMjA6ICdSRVBPUlQnLFxuICAyMTogJ01LQUNUSVZJVFknLFxuICAyMjogJ0NIRUNLT1VUJyxcbiAgMjM6ICdNRVJHRScsXG4gIDI0OiAnTS1TRUFSQ0gnLFxuICAyNTogJ05PVElGWScsXG4gIDI2OiAnU1VCU0NSSUJFJyxcbiAgMjc6ICdVTlNVQlNDUklCRScsXG4gIDI4OiAnUEFUQ0gnLFxuICAyOTogJ1BVUkdFJyxcbiAgMzA6ICdNS0NBTEVOREFSJyxcbiAgMzE6ICdMSU5LJyxcbiAgMzI6ICdVTkxJTksnXG59O1xuXG52YXIgVkVSU0lPTiA9IHByb2Nlc3MudmVyc2lvblxuICA/IHByb2Nlc3MudmVyc2lvbi5tYXRjaCgvWzAtOV0rL2cpLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBwYXJzZUludChuLCAxMCkgfSlcbiAgOiBbXTtcblxuaWYgKFZFUlNJT05bMF0gPT09IDAgJiYgVkVSU0lPTlsxXSA9PT0gMTIpIHtcbiAgSHR0cFBhcnNlci5NRVRIT0RTWzE2XSA9ICdSRVBPUlQnO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMTddID0gJ01LQUNUSVZJVFknO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMThdID0gJ0NIRUNLT1VUJztcbiAgSHR0cFBhcnNlci5NRVRIT0RTWzE5XSA9ICdNRVJHRSc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1syMF0gPSAnTS1TRUFSQ0gnO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMjFdID0gJ05PVElGWSc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1syMl0gPSAnU1VCU0NSSUJFJztcbiAgSHR0cFBhcnNlci5NRVRIT0RTWzIzXSA9ICdVTlNVQlNDUklCRSc7XG4gIEh0dHBQYXJzZXIuTUVUSE9EU1syNF0gPSAnUEFUQ0gnO1xuICBIdHRwUGFyc2VyLk1FVEhPRFNbMjVdID0gJ1BVUkdFJztcbn1cblxuSHR0cFBhcnNlci5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29tcGxldGU7XG59O1xuXG5IdHRwUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBjb25zdW1lZCA9IHRoaXMuX3BhcnNlci5leGVjdXRlKGNodW5rLCAwLCBjaHVuay5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgY29uc3VtZWQgIT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5lcnJvciAgICAgPSBjb25zdW1lZDtcbiAgICB0aGlzLl9jb21wbGV0ZSA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2NvbXBsZXRlKVxuICAgIHRoaXMuYm9keSA9IChjb25zdW1lZCA8IGNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgPyBjaHVuay5zbGljZShjb25zdW1lZClcbiAgICAgICAgICAgICAgOiBCdWZmZXIuYWxsb2MoMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0dHBQYXJzZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgU3RyZWFtICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLlN0cmVhbSxcbiAgICB1dGlsICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgZHJpdmVyICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLFxuICAgIEV2ZW50VGFyZ2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG4gICAgRXZlbnQgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgQVBJID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZHJpdmVyLnZhbGlkYXRlT3B0aW9ucyhvcHRpb25zLCBbJ2hlYWRlcnMnLCAnZXh0ZW5zaW9ucycsICdtYXhMZW5ndGgnLCAncGluZycsICdwcm94eScsICd0bHMnLCAnY2EnXSk7XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICBpZiAoaGVhZGVycykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykgdGhpcy5fZHJpdmVyLnNldEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgfVxuXG4gIHZhciBleHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zO1xuICBpZiAoZXh0ZW5zaW9ucykge1xuICAgIFtdLmNvbmNhdChleHRlbnNpb25zKS5mb3JFYWNoKHRoaXMuX2RyaXZlci5hZGRFeHRlbnNpb24sIHRoaXMuX2RyaXZlcik7XG4gIH1cblxuICB0aGlzLl9waW5nICAgICAgICAgID0gb3B0aW9ucy5waW5nO1xuICB0aGlzLl9waW5nSWQgICAgICAgID0gMDtcbiAgdGhpcy5yZWFkeVN0YXRlICAgICA9IEFQSS5DT05ORUNUSU5HO1xuICB0aGlzLmJ1ZmZlcmVkQW1vdW50ID0gMDtcbiAgdGhpcy5wcm90b2NvbCAgICAgICA9ICcnO1xuICB0aGlzLnVybCAgICAgICAgICAgID0gdGhpcy5fZHJpdmVyLnVybDtcbiAgdGhpcy52ZXJzaW9uICAgICAgICA9IHRoaXMuX2RyaXZlci52ZXJzaW9uO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLl9kcml2ZXIub24oJ29wZW4nLCAgICBmdW5jdGlvbihlKSB7IHNlbGYuX29wZW4oKSB9KTtcbiAgdGhpcy5fZHJpdmVyLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkgeyBzZWxmLl9yZWNlaXZlTWVzc2FnZShlLmRhdGEpIH0pO1xuICB0aGlzLl9kcml2ZXIub24oJ2Nsb3NlJywgICBmdW5jdGlvbihlKSB7IHNlbGYuX2JlZ2luQ2xvc2UoZS5yZWFzb24sIGUuY29kZSkgfSk7XG5cbiAgdGhpcy5fZHJpdmVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgc2VsZi5fZW1pdEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICB9KTtcbiAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbigpIHt9KTtcblxuICB0aGlzLl9kcml2ZXIubWVzc2FnZXMub24oJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9KTtcblxuICBpZiAodGhpcy5fcGluZylcbiAgICB0aGlzLl9waW5nVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX3BpbmdJZCArPSAxO1xuICAgICAgc2VsZi5waW5nKHNlbGYuX3BpbmdJZC50b1N0cmluZygpKTtcbiAgICB9LCB0aGlzLl9waW5nICogMTAwMCk7XG5cbiAgdGhpcy5fY29uZmlndXJlU3RyZWFtKCk7XG5cbiAgaWYgKCF0aGlzLl9wcm94eSkge1xuICAgIHRoaXMuX3N0cmVhbS5waXBlKHRoaXMuX2RyaXZlci5pbyk7XG4gICAgdGhpcy5fZHJpdmVyLmlvLnBpcGUodGhpcy5fc3RyZWFtKTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoQVBJLCBTdHJlYW0pO1xuXG5BUEkuQ09OTkVDVElORyA9IDA7XG5BUEkuT1BFTiAgICAgICA9IDE7XG5BUEkuQ0xPU0lORyAgICA9IDI7XG5BUEkuQ0xPU0VEICAgICA9IDM7XG5cbkFQSS5DTE9TRV9USU1FT1VUID0gMzAwMDA7XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgd3JpdGU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kKGRhdGEpO1xuICB9LFxuXG4gIGVuZDogZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHRoaXMuc2VuZChkYXRhKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH0sXG5cbiAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kcml2ZXIubWVzc2FnZXMucGF1c2UoKTtcbiAgfSxcblxuICByZXN1bWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kcml2ZXIubWVzc2FnZXMucmVzdW1lKCk7XG4gIH0sXG5cbiAgc2VuZDogZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiBBUEkuT1BFTikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBCdWZmZXIpKSBkYXRhID0gU3RyaW5nKGRhdGEpO1xuICAgIHJldHVybiB0aGlzLl9kcml2ZXIubWVzc2FnZXMud3JpdGUoZGF0YSk7XG4gIH0sXG5cbiAgcGluZzogZnVuY3Rpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gQVBJLk9QRU4pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5fZHJpdmVyLnBpbmcobWVzc2FnZSwgY2FsbGJhY2spO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSBjb2RlID0gMTAwMDtcbiAgICBpZiAocmVhc29uID09PSB1bmRlZmluZWQpIHJlYXNvbiA9ICcnO1xuXG4gICAgaWYgKGNvZGUgIT09IDEwMDAgJiYgKGNvZGUgPCAzMDAwIHx8IGNvZGUgPiA0OTk5KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdjbG9zZScgb24gV2ViU29ja2V0OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaGUgY29kZSBtdXN0IGJlIGVpdGhlciAxMDAwLCBvciBiZXR3ZWVuIDMwMDAgYW5kIDQ5OTkuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBjb2RlICsgXCIgaXMgbmVpdGhlci5cIik7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBBUEkuQ0xPU0VEKSB0aGlzLnJlYWR5U3RhdGUgPSBBUEkuQ0xPU0lORztcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX2JlZ2luQ2xvc2UoJycsIDEwMDYpO1xuICAgIH0sIEFQSS5DTE9TRV9USU1FT1VUKTtcblxuICAgIHRoaXMuX2RyaXZlci5jbG9zZShyZWFzb24sIGNvZGUpO1xuICB9LFxuXG4gIF9jb25maWd1cmVTdHJlYW06IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX3N0cmVhbS5zZXRUaW1lb3V0KDApO1xuICAgIHRoaXMuX3N0cmVhbS5zZXROb0RlbGF5KHRydWUpO1xuXG4gICAgWydjbG9zZScsICdlbmQnXS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB0aGlzLl9zdHJlYW0ub24oZXZlbnQsIGZ1bmN0aW9uKCkgeyBzZWxmLl9maW5hbGl6ZUNsb3NlKCkgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9zdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHNlbGYuX2VtaXRFcnJvcignTmV0d29yayBlcnJvcjogJyArIHNlbGYudXJsICsgJzogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgc2VsZi5fZmluYWxpemVDbG9zZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIF9vcGVuOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBBUEkuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gQVBJLk9QRU47XG4gICAgdGhpcy5wcm90b2NvbCA9IHRoaXMuX2RyaXZlci5wcm90b2NvbCB8fCAnJztcblxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnb3BlbicpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnb3BlbicsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSxcblxuICBfcmVjZWl2ZU1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gQVBJLk9QRU4pIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh0aGlzLnJlYWRhYmxlKSB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcblxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnbWVzc2FnZScsIHtkYXRhOiBkYXRhfSk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9LFxuXG4gIF9lbWl0RXJyb3I6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID49IEFQSS5DTE9TSU5HKSByZXR1cm47XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2Vycm9yJywge21lc3NhZ2U6IG1lc3NhZ2V9KTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2Vycm9yJywgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9LFxuXG4gIF9iZWdpbkNsb3NlOiBmdW5jdGlvbihyZWFzb24sIGNvZGUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBBUEkuQ0xPU0VEKSByZXR1cm47XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gQVBJLkNMT1NJTkc7XG4gICAgdGhpcy5fY2xvc2VQYXJhbXMgPSBbcmVhc29uLCBjb2RlXTtcblxuICAgIGlmICh0aGlzLl9zdHJlYW0pIHtcbiAgICAgIHRoaXMuX3N0cmVhbS5kZXN0cm95KCk7XG4gICAgICBpZiAoIXRoaXMuX3N0cmVhbS5yZWFkYWJsZSkgdGhpcy5fZmluYWxpemVDbG9zZSgpO1xuICAgIH1cbiAgfSxcblxuICBfZmluYWxpemVDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gQVBJLkNMT1NFRCkgcmV0dXJuO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IEFQSS5DTE9TRUQ7XG5cbiAgICBpZiAodGhpcy5fY2xvc2VUaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuX2Nsb3NlVGltZXIpO1xuICAgIGlmICh0aGlzLl9waW5nVGltZXIpIGNsZWFySW50ZXJ2YWwodGhpcy5fcGluZ1RpbWVyKTtcbiAgICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9zdHJlYW0uZW5kKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkYWJsZSkgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlYXNvbiA9IHRoaXMuX2Nsb3NlUGFyYW1zID8gdGhpcy5fY2xvc2VQYXJhbXNbMF0gOiAnJyxcbiAgICAgICAgY29kZSAgID0gdGhpcy5fY2xvc2VQYXJhbXMgPyB0aGlzLl9jbG9zZVBhcmFtc1sxXSA6IDEwMDY7XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2Nsb3NlJywge2NvZGU6IGNvZGUsIHJlYXNvbjogcmVhc29ufSk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdjbG9zZScsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufTtcblxuZm9yICh2YXIgbWV0aG9kIGluIGluc3RhbmNlKSBBUEkucHJvdG90eXBlW21ldGhvZF0gPSBpbnN0YW5jZVttZXRob2RdO1xuZm9yICh2YXIga2V5IGluIEV2ZW50VGFyZ2V0KSBBUEkucHJvdG90eXBlW2tleV0gPSBFdmVudFRhcmdldFtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFQSTtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBCdWZmZXIgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXIsXG4gICAgY3J5cHRvICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMyksXG4gICAgdXRpbCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgRXh0ZW5zaW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpLFxuICAgIEJhc2UgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuICAgIEZyYW1lICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSxcbiAgICBNZXNzYWdlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBIeWJpID0gZnVuY3Rpb24ocmVxdWVzdCwgdXJsLCBvcHRpb25zKSB7XG4gIEJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLl9leHRlbnNpb25zICAgICA9IG5ldyBFeHRlbnNpb25zKCk7XG4gIHRoaXMuX3N0YWdlICAgICAgICAgID0gMDtcbiAgdGhpcy5fbWFza2luZyAgICAgICAgPSB0aGlzLl9vcHRpb25zLm1hc2tpbmc7XG4gIHRoaXMuX3Byb3RvY29scyAgICAgID0gdGhpcy5fb3B0aW9ucy5wcm90b2NvbHMgfHwgW107XG4gIHRoaXMuX3JlcXVpcmVNYXNraW5nID0gdGhpcy5fb3B0aW9ucy5yZXF1aXJlTWFza2luZztcbiAgdGhpcy5fcGluZ0NhbGxiYWNrcyAgPSB7fTtcblxuICBpZiAodHlwZW9mIHRoaXMuX3Byb3RvY29scyA9PT0gJ3N0cmluZycpXG4gICAgdGhpcy5fcHJvdG9jb2xzID0gdGhpcy5fcHJvdG9jb2xzLnNwbGl0KC8gKiwgKi8pO1xuXG4gIGlmICghdGhpcy5fcmVxdWVzdCkgcmV0dXJuO1xuXG4gIHZhciBwcm90b3MgICAgPSB0aGlzLl9yZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXSxcbiAgICAgIHN1cHBvcnRlZCA9IHRoaXMuX3Byb3RvY29scztcblxuICBpZiAocHJvdG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHByb3RvcyA9PT0gJ3N0cmluZycpIHByb3RvcyA9IHByb3Rvcy5zcGxpdCgvICosICovKTtcbiAgICB0aGlzLnByb3RvY29sID0gcHJvdG9zLmZpbHRlcihmdW5jdGlvbihwKSB7IHJldHVybiBzdXBwb3J0ZWQuaW5kZXhPZihwKSA+PSAwIH0pWzBdO1xuICB9XG5cbiAgdGhpcy52ZXJzaW9uID0gJ2h5YmktJyArIEh5YmkuVkVSU0lPTjtcbn07XG51dGlsLmluaGVyaXRzKEh5YmksIEJhc2UpO1xuXG5IeWJpLlZFUlNJT04gPSAnMTMnO1xuXG5IeWJpLm1hc2sgPSBmdW5jdGlvbihwYXlsb2FkLCBtYXNrLCBvZmZzZXQpIHtcbiAgaWYgKCFtYXNrIHx8IG1hc2subGVuZ3RoID09PSAwKSByZXR1cm4gcGF5bG9hZDtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBwYXlsb2FkLmxlbmd0aCAtIG9mZnNldDsgaSA8IG47IGkrKykge1xuICAgIHBheWxvYWRbb2Zmc2V0ICsgaV0gPSBwYXlsb2FkW29mZnNldCArIGldIF4gbWFza1tpICUgNF07XG4gIH1cbiAgcmV0dXJuIHBheWxvYWQ7XG59O1xuXG5IeWJpLmdlbmVyYXRlQWNjZXB0ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBzaGExID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgc2hhMS51cGRhdGUoa2V5ICsgSHliaS5HVUlEKTtcbiAgcmV0dXJuIHNoYTEuZGlnZXN0KCdiYXNlNjQnKTtcbn07XG5cbkh5YmkuR1VJRCA9ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnO1xuXG52YXIgaW5zdGFuY2UgPSB7XG4gIEZJTjogICAgMHg4MCxcbiAgTUFTSzogICAweDgwLFxuICBSU1YxOiAgIDB4NDAsXG4gIFJTVjI6ICAgMHgyMCxcbiAgUlNWMzogICAweDEwLFxuICBPUENPREU6IDB4MEYsXG4gIExFTkdUSDogMHg3RixcblxuICBPUENPREVTOiB7XG4gICAgY29udGludWF0aW9uOiAwLFxuICAgIHRleHQ6ICAgICAgICAgMSxcbiAgICBiaW5hcnk6ICAgICAgIDIsXG4gICAgY2xvc2U6ICAgICAgICA4LFxuICAgIHBpbmc6ICAgICAgICAgOSxcbiAgICBwb25nOiAgICAgICAgIDEwXG4gIH0sXG5cbiAgT1BDT0RFX0NPREVTOiAgICBbMCwgMSwgMiwgOCwgOSwgMTBdLFxuICBNRVNTQUdFX09QQ09ERVM6IFswLCAxLCAyXSxcbiAgT1BFTklOR19PUENPREVTOiBbMSwgMl0sXG5cbiAgRVJST1JTOiB7XG4gICAgbm9ybWFsX2Nsb3N1cmU6ICAgICAgIDEwMDAsXG4gICAgZ29pbmdfYXdheTogICAgICAgICAgIDEwMDEsXG4gICAgcHJvdG9jb2xfZXJyb3I6ICAgICAgIDEwMDIsXG4gICAgdW5hY2NlcHRhYmxlOiAgICAgICAgIDEwMDMsXG4gICAgZW5jb2RpbmdfZXJyb3I6ICAgICAgIDEwMDcsXG4gICAgcG9saWN5X3Zpb2xhdGlvbjogICAgIDEwMDgsXG4gICAgdG9vX2xhcmdlOiAgICAgICAgICAgIDEwMDksXG4gICAgZXh0ZW5zaW9uX2Vycm9yOiAgICAgIDEwMTAsXG4gICAgdW5leHBlY3RlZF9jb25kaXRpb246IDEwMTFcbiAgfSxcblxuICBFUlJPUl9DT0RFUzogICAgICAgIFsxMDAwLCAxMDAxLCAxMDAyLCAxMDAzLCAxMDA3LCAxMDA4LCAxMDA5LCAxMDEwLCAxMDExXSxcbiAgREVGQVVMVF9FUlJPUl9DT0RFOiAxMDAwLFxuICBNSU5fUkVTRVJWRURfRVJST1I6IDMwMDAsXG4gIE1BWF9SRVNFUlZFRF9FUlJPUjogNDk5OSxcblxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL3F1ZXN0aW9ucy9xYS1mb3Jtcy11dGYtOC5lbi5waHBcbiAgVVRGOF9NQVRDSDogL14oW1xceDAwLVxceDdGXXxbXFx4QzItXFx4REZdW1xceDgwLVxceEJGXXxcXHhFMFtcXHhBMC1cXHhCRl1bXFx4ODAtXFx4QkZdfFtcXHhFMS1cXHhFQ1xceEVFXFx4RUZdW1xceDgwLVxceEJGXXsyfXxcXHhFRFtcXHg4MC1cXHg5Rl1bXFx4ODAtXFx4QkZdfFxceEYwW1xceDkwLVxceEJGXVtcXHg4MC1cXHhCRl17Mn18W1xceEYxLVxceEYzXVtcXHg4MC1cXHhCRl17M318XFx4RjRbXFx4ODAtXFx4OEZdW1xceDgwLVxceEJGXXsyfSkqJC8sXG5cbiAgYWRkRXh0ZW5zaW9uOiBmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICB0aGlzLl9leHRlbnNpb25zLmFkZChleHRlbnNpb24pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihjaHVuaykge1xuICAgIHRoaXMuX3JlYWRlci5wdXQoY2h1bmspO1xuICAgIHZhciBidWZmZXIgPSB0cnVlO1xuICAgIHdoaWxlIChidWZmZXIpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhZ2UpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3JlYWRlci5yZWFkKDEpO1xuICAgICAgICAgIGlmIChidWZmZXIpIHRoaXMuX3BhcnNlT3Bjb2RlKGJ1ZmZlclswXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3JlYWRlci5yZWFkKDEpO1xuICAgICAgICAgIGlmIChidWZmZXIpIHRoaXMuX3BhcnNlTGVuZ3RoKGJ1ZmZlclswXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3JlYWRlci5yZWFkKHRoaXMuX2ZyYW1lLmxlbmd0aEJ5dGVzKTtcbiAgICAgICAgICBpZiAoYnVmZmVyKSB0aGlzLl9wYXJzZUV4dGVuZGVkTGVuZ3RoKGJ1ZmZlcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuX3JlYWRlci5yZWFkKDQpO1xuICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWdlID0gNDtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lLm1hc2tpbmdLZXkgPSBidWZmZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBidWZmZXIgPSB0aGlzLl9yZWFkZXIucmVhZCh0aGlzLl9mcmFtZS5sZW5ndGgpO1xuICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWdlID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRGcmFtZShidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRleHQ6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmZyYW1lKG1lc3NhZ2UsICd0ZXh0Jyk7XG4gIH0sXG5cbiAgYmluYXJ5OiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5mcmFtZShtZXNzYWdlLCAnYmluYXJ5Jyk7XG4gIH0sXG5cbiAgcGluZzogZnVuY3Rpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuICAgIGlmIChjYWxsYmFjaykgdGhpcy5fcGluZ0NhbGxiYWNrc1ttZXNzYWdlXSA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzLmZyYW1lKG1lc3NhZ2UsICdwaW5nJyk7XG4gIH0sXG5cbiAgcG9uZzogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDEpIHJldHVybiBmYWxzZTtcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8Jyc7XG4gICAgICByZXR1cm4gdGhpcy5mcmFtZShtZXNzYWdlLCAncG9uZycpO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbihyZWFzb24sIGNvZGUpIHtcbiAgICByZWFzb24gPSByZWFzb24gfHwgJyc7XG4gICAgY29kZSAgID0gY29kZSAgIHx8IHRoaXMuRVJST1JTLm5vcm1hbF9jbG9zdXJlO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA8PSAwKSB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSAzO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIG5ldyBCYXNlLkNsb3NlRXZlbnQoY29kZSwgcmVhc29uKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gMjtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMuY2xvc2UoZnVuY3Rpb24oKSB7IHRoaXMuZnJhbWUocmVhc29uLCAnY2xvc2UnLCBjb2RlKSB9LCB0aGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGZyYW1lOiBmdW5jdGlvbihidWZmZXIsIHR5cGUsIGNvZGUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDw9IDApIHJldHVybiB0aGlzLl9xdWV1ZShbYnVmZmVyLCB0eXBlLCBjb2RlXSk7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDIpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheSkgICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ251bWJlcicpIGJ1ZmZlciA9IGJ1ZmZlci50b1N0cmluZygpO1xuXG4gICAgdmFyIG1lc3NhZ2UgPSBuZXcgTWVzc2FnZSgpLFxuICAgICAgICBpc1RleHQgID0gKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSxcbiAgICAgICAgcGF5bG9hZCwgY29weTtcblxuICAgIG1lc3NhZ2UucnN2MSAgID0gbWVzc2FnZS5yc3YyID0gbWVzc2FnZS5yc3YzID0gZmFsc2U7XG4gICAgbWVzc2FnZS5vcGNvZGUgPSB0aGlzLk9QQ09ERVNbdHlwZSB8fCAoaXNUZXh0ID8gJ3RleHQnIDogJ2JpbmFyeScpXTtcblxuICAgIHBheWxvYWQgPSBpc1RleHQgPyBCdWZmZXIuZnJvbShidWZmZXIsICd1dGY4JykgOiBidWZmZXI7XG5cbiAgICBpZiAoY29kZSkge1xuICAgICAgY29weSA9IHBheWxvYWQ7XG4gICAgICBwYXlsb2FkID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBjb3B5Lmxlbmd0aCk7XG4gICAgICBwYXlsb2FkLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgICBjb3B5LmNvcHkocGF5bG9hZCwgMik7XG4gICAgfVxuICAgIG1lc3NhZ2UuZGF0YSA9IHBheWxvYWQ7XG5cbiAgICB2YXIgb25NZXNzYWdlUmVhZHkgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICB2YXIgZnJhbWUgPSBuZXcgRnJhbWUoKTtcblxuICAgICAgZnJhbWUuZmluYWwgICA9IHRydWU7XG4gICAgICBmcmFtZS5yc3YxICAgID0gbWVzc2FnZS5yc3YxO1xuICAgICAgZnJhbWUucnN2MiAgICA9IG1lc3NhZ2UucnN2MjtcbiAgICAgIGZyYW1lLnJzdjMgICAgPSBtZXNzYWdlLnJzdjM7XG4gICAgICBmcmFtZS5vcGNvZGUgID0gbWVzc2FnZS5vcGNvZGU7XG4gICAgICBmcmFtZS5tYXNrZWQgID0gISF0aGlzLl9tYXNraW5nO1xuICAgICAgZnJhbWUubGVuZ3RoICA9IG1lc3NhZ2UuZGF0YS5sZW5ndGg7XG4gICAgICBmcmFtZS5wYXlsb2FkID0gbWVzc2FnZS5kYXRhO1xuXG4gICAgICBpZiAoZnJhbWUubWFza2VkKSBmcmFtZS5tYXNraW5nS2V5ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpO1xuXG4gICAgICB0aGlzLl9zZW5kRnJhbWUoZnJhbWUpO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5NRVNTQUdFX09QQ09ERVMuaW5kZXhPZihtZXNzYWdlLm9wY29kZSkgPj0gMClcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMucHJvY2Vzc091dGdvaW5nTWVzc2FnZShtZXNzYWdlLCBmdW5jdGlvbihlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiB0aGlzLl9mYWlsKCdleHRlbnNpb25fZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgb25NZXNzYWdlUmVhZHkuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIG9uTWVzc2FnZVJlYWR5LmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfc2VuZEZyYW1lOiBmdW5jdGlvbihmcmFtZSkge1xuICAgIHZhciBsZW5ndGggPSBmcmFtZS5sZW5ndGgsXG4gICAgICAgIGhlYWRlciA9IChsZW5ndGggPD0gMTI1KSA/IDIgOiAobGVuZ3RoIDw9IDY1NTM1ID8gNCA6IDEwKSxcbiAgICAgICAgb2Zmc2V0ID0gaGVhZGVyICsgKGZyYW1lLm1hc2tlZCA/IDQgOiAwKSxcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG9mZnNldCArIGxlbmd0aCksXG4gICAgICAgIG1hc2tlZCA9IGZyYW1lLm1hc2tlZCA/IHRoaXMuTUFTSyA6IDA7XG5cbiAgICBidWZmZXJbMF0gPSAoZnJhbWUuZmluYWwgPyB0aGlzLkZJTiA6IDApIHxcbiAgICAgICAgICAgICAgICAoZnJhbWUucnN2MSA/IHRoaXMuUlNWMSA6IDApIHxcbiAgICAgICAgICAgICAgICAoZnJhbWUucnN2MiA/IHRoaXMuUlNWMiA6IDApIHxcbiAgICAgICAgICAgICAgICAoZnJhbWUucnN2MyA/IHRoaXMuUlNWMyA6IDApIHxcbiAgICAgICAgICAgICAgICBmcmFtZS5vcGNvZGU7XG5cbiAgICBpZiAobGVuZ3RoIDw9IDEyNSkge1xuICAgICAgYnVmZmVyWzFdID0gbWFza2VkIHwgbGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDY1NTM1KSB7XG4gICAgICBidWZmZXJbMV0gPSBtYXNrZWQgfCAxMjY7XG4gICAgICBidWZmZXIud3JpdGVVSW50MTZCRShsZW5ndGgsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJbMV0gPSBtYXNrZWQgfCAxMjc7XG4gICAgICBidWZmZXIud3JpdGVVSW50MzJCRShNYXRoLmZsb29yKGxlbmd0aCAvIDB4MTAwMDAwMDAwKSwgMik7XG4gICAgICBidWZmZXIud3JpdGVVSW50MzJCRShsZW5ndGggJSAweDEwMDAwMDAwMCwgNik7XG4gICAgfVxuXG4gICAgZnJhbWUucGF5bG9hZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcblxuICAgIGlmIChmcmFtZS5tYXNrZWQpIHtcbiAgICAgIGZyYW1lLm1hc2tpbmdLZXkuY29weShidWZmZXIsIGhlYWRlcik7XG4gICAgICBIeWJpLm1hc2soYnVmZmVyLCBmcmFtZS5tYXNraW5nS2V5LCBvZmZzZXQpO1xuICAgIH1cblxuICAgIHRoaXMuX3dyaXRlKGJ1ZmZlcik7XG4gIH0sXG5cbiAgX2hhbmRzaGFrZVJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VjS2V5ICA9IHRoaXMuX3JlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSxcbiAgICAgICAgdmVyc2lvbiA9IHRoaXMuX3JlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG5cbiAgICBpZiAodmVyc2lvbiAhPT0gSHliaS5WRVJTSU9OKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBXZWJTb2NrZXQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuXG4gICAgaWYgKHR5cGVvZiBzZWNLZXkgIT09ICdzdHJpbmcnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGhhbmRzaGFrZSByZXF1ZXN0IGhlYWRlcjogU2VjLVdlYlNvY2tldC1LZXknKTtcblxuICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdVcGdyYWRlJywgJ3dlYnNvY2tldCcpO1xuICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdDb25uZWN0aW9uJywgJ1VwZ3JhZGUnKTtcbiAgICB0aGlzLl9oZWFkZXJzLnNldCgnU2VjLVdlYlNvY2tldC1BY2NlcHQnLCBIeWJpLmdlbmVyYXRlQWNjZXB0KHNlY0tleSkpO1xuXG4gICAgaWYgKHRoaXMucHJvdG9jb2wpIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJywgdGhpcy5wcm90b2NvbCk7XG5cbiAgICB2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuX2V4dGVuc2lvbnMuZ2VuZXJhdGVSZXNwb25zZSh0aGlzLl9yZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddKTtcbiAgICBpZiAoZXh0ZW5zaW9ucykgdGhpcy5faGVhZGVycy5zZXQoJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucycsIGV4dGVuc2lvbnMpO1xuXG4gICAgdmFyIHN0YXJ0ICAgPSAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgICBoZWFkZXJzID0gW3N0YXJ0LCB0aGlzLl9oZWFkZXJzLnRvU3RyaW5nKCksICcnXTtcblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShoZWFkZXJzLmpvaW4oJ1xcclxcbicpLCAndXRmOCcpO1xuICB9LFxuXG4gIF9zaHV0ZG93bjogZnVuY3Rpb24oY29kZSwgcmVhc29uLCBlcnJvcikge1xuICAgIGRlbGV0ZSB0aGlzLl9mcmFtZTtcbiAgICBkZWxldGUgdGhpcy5fbWVzc2FnZTtcbiAgICB0aGlzLl9zdGFnZSA9IDU7XG5cbiAgICB2YXIgc2VuZENsb3NlRnJhbWUgPSAodGhpcy5yZWFkeVN0YXRlID09PSAxKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAyO1xuXG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5jbG9zZShmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZW5kQ2xvc2VGcmFtZSkgdGhpcy5mcmFtZShyZWFzb24sICdjbG9zZScsIGNvZGUpO1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gMztcbiAgICAgIGlmIChlcnJvcikgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBuZXcgQmFzZS5DbG9zZUV2ZW50KGNvZGUsIHJlYXNvbikpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIF9mYWlsOiBmdW5jdGlvbih0eXBlLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDEpIHJldHVybjtcbiAgICB0aGlzLl9zaHV0ZG93bih0aGlzLkVSUk9SU1t0eXBlXSwgbWVzc2FnZSwgdHJ1ZSk7XG4gIH0sXG5cbiAgX3BhcnNlT3Bjb2RlOiBmdW5jdGlvbihvY3RldCkge1xuICAgIHZhciByc3ZzID0gW3RoaXMuUlNWMSwgdGhpcy5SU1YyLCB0aGlzLlJTVjNdLm1hcChmdW5jdGlvbihyc3YpIHtcbiAgICAgIHJldHVybiAob2N0ZXQgJiByc3YpID09PSByc3Y7XG4gICAgfSk7XG5cbiAgICB2YXIgZnJhbWUgPSB0aGlzLl9mcmFtZSA9IG5ldyBGcmFtZSgpO1xuXG4gICAgZnJhbWUuZmluYWwgID0gKG9jdGV0ICYgdGhpcy5GSU4pID09PSB0aGlzLkZJTjtcbiAgICBmcmFtZS5yc3YxICAgPSByc3ZzWzBdO1xuICAgIGZyYW1lLnJzdjIgICA9IHJzdnNbMV07XG4gICAgZnJhbWUucnN2MyAgID0gcnN2c1syXTtcbiAgICBmcmFtZS5vcGNvZGUgPSAob2N0ZXQgJiB0aGlzLk9QQ09ERSk7XG5cbiAgICB0aGlzLl9zdGFnZSA9IDE7XG5cbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnMudmFsaWRGcmFtZVJzdihmcmFtZSkpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbCgncHJvdG9jb2xfZXJyb3InLFxuICAgICAgICAgICdPbmUgb3IgbW9yZSByZXNlcnZlZCBiaXRzIGFyZSBvbjogcmVzZXJ2ZWQxID0gJyArIChmcmFtZS5yc3YxID8gMSA6IDApICtcbiAgICAgICAgICAnLCByZXNlcnZlZDIgPSAnICsgKGZyYW1lLnJzdjIgPyAxIDogMCkgK1xuICAgICAgICAgICcsIHJlc2VydmVkMyA9ICcgKyAoZnJhbWUucnN2MyA/IDEgOiAwKSk7XG5cbiAgICBpZiAodGhpcy5PUENPREVfQ09ERVMuaW5kZXhPZihmcmFtZS5vcGNvZGUpIDwgMClcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsICdVbnJlY29nbml6ZWQgZnJhbWUgb3Bjb2RlOiAnICsgZnJhbWUub3Bjb2RlKTtcblxuICAgIGlmICh0aGlzLk1FU1NBR0VfT1BDT0RFUy5pbmRleE9mKGZyYW1lLm9wY29kZSkgPCAwICYmICFmcmFtZS5maW5hbClcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsKCdwcm90b2NvbF9lcnJvcicsICdSZWNlaXZlZCBmcmFnbWVudGVkIGNvbnRyb2wgZnJhbWU6IG9wY29kZSA9ICcgKyBmcmFtZS5vcGNvZGUpO1xuXG4gICAgaWYgKHRoaXMuX21lc3NhZ2UgJiYgdGhpcy5PUEVOSU5HX09QQ09ERVMuaW5kZXhPZihmcmFtZS5vcGNvZGUpID49IDApXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbCgncHJvdG9jb2xfZXJyb3InLCAnUmVjZWl2ZWQgbmV3IGRhdGEgZnJhbWUgYnV0IHByZXZpb3VzIGNvbnRpbnVvdXMgZnJhbWUgaXMgdW5maW5pc2hlZCcpO1xuICB9LFxuXG4gIF9wYXJzZUxlbmd0aDogZnVuY3Rpb24ob2N0ZXQpIHtcbiAgICB2YXIgZnJhbWUgPSB0aGlzLl9mcmFtZTtcbiAgICBmcmFtZS5tYXNrZWQgPSAob2N0ZXQgJiB0aGlzLk1BU0spID09PSB0aGlzLk1BU0s7XG4gICAgZnJhbWUubGVuZ3RoID0gKG9jdGV0ICYgdGhpcy5MRU5HVEgpO1xuXG4gICAgaWYgKGZyYW1lLmxlbmd0aCA+PSAwICYmIGZyYW1lLmxlbmd0aCA8PSAxMjUpIHtcbiAgICAgIHRoaXMuX3N0YWdlID0gZnJhbWUubWFza2VkID8gMyA6IDQ7XG4gICAgICBpZiAoIXRoaXMuX2NoZWNrRnJhbWVMZW5ndGgoKSkgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGFnZSA9IDI7XG4gICAgICBmcmFtZS5sZW5ndGhCeXRlcyA9IChmcmFtZS5sZW5ndGggPT09IDEyNiA/IDIgOiA4KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVxdWlyZU1hc2tpbmcgJiYgIWZyYW1lLm1hc2tlZClcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsKCd1bmFjY2VwdGFibGUnLCAnUmVjZWl2ZWQgdW5tYXNrZWQgZnJhbWUgYnV0IG1hc2tpbmcgaXMgcmVxdWlyZWQnKTtcbiAgfSxcblxuICBfcGFyc2VFeHRlbmRlZExlbmd0aDogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgdmFyIGZyYW1lID0gdGhpcy5fZnJhbWU7XG4gICAgZnJhbWUubGVuZ3RoID0gdGhpcy5fcmVhZFVJbnQoYnVmZmVyKTtcblxuICAgIHRoaXMuX3N0YWdlID0gZnJhbWUubWFza2VkID8gMyA6IDQ7XG5cbiAgICBpZiAodGhpcy5NRVNTQUdFX09QQ09ERVMuaW5kZXhPZihmcmFtZS5vcGNvZGUpIDwgMCAmJiBmcmFtZS5sZW5ndGggPiAxMjUpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbCgncHJvdG9jb2xfZXJyb3InLCAnUmVjZWl2ZWQgY29udHJvbCBmcmFtZSBoYXZpbmcgdG9vIGxvbmcgcGF5bG9hZDogJyArIGZyYW1lLmxlbmd0aCk7XG5cbiAgICBpZiAoIXRoaXMuX2NoZWNrRnJhbWVMZW5ndGgoKSkgcmV0dXJuO1xuICB9LFxuXG4gIF9jaGVja0ZyYW1lTGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbWVzc2FnZSA/IHRoaXMuX21lc3NhZ2UubGVuZ3RoIDogMDtcblxuICAgIGlmIChsZW5ndGggKyB0aGlzLl9mcmFtZS5sZW5ndGggPiB0aGlzLl9tYXhMZW5ndGgpIHtcbiAgICAgIHRoaXMuX2ZhaWwoJ3Rvb19sYXJnZScsICdXZWJTb2NrZXQgZnJhbWUgbGVuZ3RoIHRvbyBsYXJnZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgX2VtaXRGcmFtZTogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgdmFyIGZyYW1lICAgPSB0aGlzLl9mcmFtZSxcbiAgICAgICAgcGF5bG9hZCA9IGZyYW1lLnBheWxvYWQgPSBIeWJpLm1hc2soYnVmZmVyLCBmcmFtZS5tYXNraW5nS2V5KSxcbiAgICAgICAgb3Bjb2RlICA9IGZyYW1lLm9wY29kZSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgY29kZSwgcmVhc29uLFxuICAgICAgICBjYWxsYmFja3MsIGNhbGxiYWNrO1xuXG4gICAgZGVsZXRlIHRoaXMuX2ZyYW1lO1xuXG4gICAgaWYgKG9wY29kZSA9PT0gdGhpcy5PUENPREVTLmNvbnRpbnVhdGlvbikge1xuICAgICAgaWYgKCF0aGlzLl9tZXNzYWdlKSByZXR1cm4gdGhpcy5fZmFpbCgncHJvdG9jb2xfZXJyb3InLCAnUmVjZWl2ZWQgdW5leHBlY3RlZCBjb250aW51YXRpb24gZnJhbWUnKTtcbiAgICAgIHRoaXMuX21lc3NhZ2UucHVzaEZyYW1lKGZyYW1lKTtcbiAgICB9XG5cbiAgICBpZiAob3Bjb2RlID09PSB0aGlzLk9QQ09ERVMudGV4dCB8fCBvcGNvZGUgPT09IHRoaXMuT1BDT0RFUy5iaW5hcnkpIHtcbiAgICAgIHRoaXMuX21lc3NhZ2UgPSBuZXcgTWVzc2FnZSgpO1xuICAgICAgdGhpcy5fbWVzc2FnZS5wdXNoRnJhbWUoZnJhbWUpO1xuICAgIH1cblxuICAgIGlmIChmcmFtZS5maW5hbCAmJiB0aGlzLk1FU1NBR0VfT1BDT0RFUy5pbmRleE9mKG9wY29kZSkgPj0gMClcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0TWVzc2FnZSh0aGlzLl9tZXNzYWdlKTtcblxuICAgIGlmIChvcGNvZGUgPT09IHRoaXMuT1BDT0RFUy5jbG9zZSkge1xuICAgICAgY29kZSAgID0gKHBheWxvYWQubGVuZ3RoID49IDIpID8gcGF5bG9hZC5yZWFkVUludDE2QkUoMCkgOiBudWxsO1xuICAgICAgcmVhc29uID0gKHBheWxvYWQubGVuZ3RoID4gMikgPyB0aGlzLl9lbmNvZGUocGF5bG9hZC5zbGljZSgyKSkgOiBudWxsO1xuXG4gICAgICBpZiAoIShwYXlsb2FkLmxlbmd0aCA9PT0gMCkgJiZcbiAgICAgICAgICAhKGNvZGUgIT09IG51bGwgJiYgY29kZSA+PSB0aGlzLk1JTl9SRVNFUlZFRF9FUlJPUiAmJiBjb2RlIDw9IHRoaXMuTUFYX1JFU0VSVkVEX0VSUk9SKSAmJlxuICAgICAgICAgIHRoaXMuRVJST1JfQ09ERVMuaW5kZXhPZihjb2RlKSA8IDApXG4gICAgICAgIGNvZGUgPSB0aGlzLkVSUk9SUy5wcm90b2NvbF9lcnJvcjtcblxuICAgICAgaWYgKHBheWxvYWQubGVuZ3RoID4gMTI1IHx8IChwYXlsb2FkLmxlbmd0aCA+IDIgJiYgIXJlYXNvbikpXG4gICAgICAgIGNvZGUgPSB0aGlzLkVSUk9SUy5wcm90b2NvbF9lcnJvcjtcblxuICAgICAgdGhpcy5fc2h1dGRvd24oY29kZSB8fCB0aGlzLkRFRkFVTFRfRVJST1JfQ09ERSwgcmVhc29uIHx8ICcnKTtcbiAgICB9XG5cbiAgICBpZiAob3Bjb2RlID09PSB0aGlzLk9QQ09ERVMucGluZykge1xuICAgICAgdGhpcy5mcmFtZShwYXlsb2FkLCAncG9uZycpO1xuICAgICAgdGhpcy5lbWl0KCdwaW5nJywgbmV3IEJhc2UuUGluZ0V2ZW50KHBheWxvYWQudG9TdHJpbmcoKSkpXG4gICAgfVxuXG4gICAgaWYgKG9wY29kZSA9PT0gdGhpcy5PUENPREVTLnBvbmcpIHtcbiAgICAgIGNhbGxiYWNrcyA9IHRoaXMuX3BpbmdDYWxsYmFja3M7XG4gICAgICBtZXNzYWdlICAgPSB0aGlzLl9lbmNvZGUocGF5bG9hZCk7XG4gICAgICBjYWxsYmFjayAgPSBjYWxsYmFja3NbbWVzc2FnZV07XG5cbiAgICAgIGRlbGV0ZSBjYWxsYmFja3NbbWVzc2FnZV07XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcblxuICAgICAgdGhpcy5lbWl0KCdwb25nJywgbmV3IEJhc2UuUG9uZ0V2ZW50KHBheWxvYWQudG9TdHJpbmcoKSkpXG4gICAgfVxuICB9LFxuXG4gIF9lbWl0TWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHZhciBtZXNzYWdlID0gdGhpcy5fbWVzc2FnZTtcbiAgICBtZXNzYWdlLnJlYWQoKTtcblxuICAgIGRlbGV0ZSB0aGlzLl9tZXNzYWdlO1xuXG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5wcm9jZXNzSW5jb21pbmdNZXNzYWdlKG1lc3NhZ2UsIGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlKSB7XG4gICAgICBpZiAoZXJyb3IpIHJldHVybiB0aGlzLl9mYWlsKCdleHRlbnNpb25fZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcblxuICAgICAgdmFyIHBheWxvYWQgPSBtZXNzYWdlLmRhdGE7XG4gICAgICBpZiAobWVzc2FnZS5vcGNvZGUgPT09IHRoaXMuT1BDT0RFUy50ZXh0KSBwYXlsb2FkID0gdGhpcy5fZW5jb2RlKHBheWxvYWQpO1xuXG4gICAgICBpZiAocGF5bG9hZCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoJ2VuY29kaW5nX2Vycm9yJywgJ0NvdWxkIG5vdCBkZWNvZGUgYSB0ZXh0IGZyYW1lIGFzIFVURi04Jyk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG5ldyBCYXNlLk1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX2VuY29kZTogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBzdHJpbmcgPSBidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScsIDAsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgaWYgKCF0aGlzLlVURjhfTUFUQ0gudGVzdChzdHJpbmcpKSByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ3V0ZjgnLCAwLCBidWZmZXIubGVuZ3RoKTtcbiAgfSxcblxuICBfcmVhZFVJbnQ6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAyKSByZXR1cm4gYnVmZmVyLnJlYWRVSW50MTZCRSgwKTtcblxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkJFKDApICogMHgxMDAwMDAwMDAgK1xuICAgICAgICAgICBidWZmZXIucmVhZFVJbnQzMkJFKDQpO1xuICB9XG59O1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIEh5YmkucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh5Ymk7XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgUmluZ0J1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlclNpemUpIHtcbiAgdGhpcy5fYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XG4gIHRoaXMuY2xlYXIoKTtcbn07XG5cblJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2J1ZmZlciAgICAgPSBuZXcgQXJyYXkodGhpcy5fYnVmZmVyU2l6ZSk7XG4gIHRoaXMuX3JpbmdPZmZzZXQgPSAwO1xuICB0aGlzLl9yaW5nU2l6ZSAgID0gdGhpcy5fYnVmZmVyU2l6ZTtcbiAgdGhpcy5faGVhZCAgICAgICA9IDA7XG4gIHRoaXMuX3RhaWwgICAgICAgPSAwO1xuICB0aGlzLmxlbmd0aCAgICAgID0gMDtcbn07XG5cblJpbmdCdWZmZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgZXhwYW5kQnVmZmVyID0gZmFsc2UsXG4gICAgICBleHBhbmRSaW5nICAgPSBmYWxzZTtcblxuICBpZiAodGhpcy5fcmluZ1NpemUgPCB0aGlzLl9idWZmZXJTaXplKSB7XG4gICAgZXhwYW5kQnVmZmVyID0gKHRoaXMuX3RhaWwgPT09IDApO1xuICB9IGVsc2UgaWYgKHRoaXMuX3JpbmdPZmZzZXQgPT09IHRoaXMuX3JpbmdTaXplKSB7XG4gICAgZXhwYW5kQnVmZmVyID0gdHJ1ZTtcbiAgICBleHBhbmRSaW5nICAgPSAodGhpcy5fdGFpbCA9PT0gMCk7XG4gIH1cblxuICBpZiAoZXhwYW5kQnVmZmVyKSB7XG4gICAgdGhpcy5fdGFpbCAgICAgICA9IHRoaXMuX2J1ZmZlclNpemU7XG4gICAgdGhpcy5fYnVmZmVyICAgICA9IHRoaXMuX2J1ZmZlci5jb25jYXQobmV3IEFycmF5KHRoaXMuX2J1ZmZlclNpemUpKTtcbiAgICB0aGlzLl9idWZmZXJTaXplID0gdGhpcy5fYnVmZmVyLmxlbmd0aDtcblxuICAgIGlmIChleHBhbmRSaW5nKVxuICAgICAgdGhpcy5fcmluZ1NpemUgPSB0aGlzLl9idWZmZXJTaXplO1xuICB9XG5cbiAgdGhpcy5fYnVmZmVyW3RoaXMuX3RhaWxdID0gdmFsdWU7XG4gIHRoaXMubGVuZ3RoICs9IDE7XG4gIGlmICh0aGlzLl90YWlsIDwgdGhpcy5fcmluZ1NpemUpIHRoaXMuX3JpbmdPZmZzZXQgKz0gMTtcbiAgdGhpcy5fdGFpbCA9ICh0aGlzLl90YWlsICsgMSkgJSB0aGlzLl9idWZmZXJTaXplO1xufTtcblxuUmluZ0J1ZmZlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiB0aGlzLl9idWZmZXJbdGhpcy5faGVhZF07XG59O1xuXG5SaW5nQnVmZmVyLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG5cbiAgdmFyIHZhbHVlID0gdGhpcy5fYnVmZmVyW3RoaXMuX2hlYWRdO1xuICB0aGlzLl9idWZmZXJbdGhpcy5faGVhZF0gPSB2b2lkIDA7XG4gIHRoaXMubGVuZ3RoIC09IDE7XG4gIHRoaXMuX3JpbmdPZmZzZXQgLT0gMTtcblxuICBpZiAodGhpcy5fcmluZ09mZnNldCA9PT0gMCAmJiB0aGlzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9oZWFkICAgICAgID0gdGhpcy5fcmluZ1NpemU7XG4gICAgdGhpcy5fcmluZ09mZnNldCA9IHRoaXMubGVuZ3RoO1xuICAgIHRoaXMuX3JpbmdTaXplICAgPSB0aGlzLl9idWZmZXJTaXplO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2hlYWQgPSAodGhpcy5faGVhZCArIDEpICUgdGhpcy5fcmluZ1NpemU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSaW5nQnVmZmVyO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFJpbmdCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIFBsZWRnZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jb21wbGV0ZSAgPSBmYWxzZTtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IFJpbmdCdWZmZXIoUGxlZGdlLlFVRVVFX1NJWkUpO1xufTtcblxuUGxlZGdlLlFVRVVFX1NJWkUgPSA0O1xuXG5QbGVkZ2UuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuICB2YXIgcGxlZGdlICA9IG5ldyBQbGVkZ2UoKSxcbiAgICAgIHBlbmRpbmcgPSBsaXN0Lmxlbmd0aCxcbiAgICAgIG4gICAgICAgPSBwZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nID09PSAwKSBwbGVkZ2UuZG9uZSgpO1xuXG4gIHdoaWxlIChuLS0pIGxpc3Rbbl0udGhlbihmdW5jdGlvbigpIHtcbiAgICBwZW5kaW5nIC09IDE7XG4gICAgaWYgKHBlbmRpbmcgPT09IDApIHBsZWRnZS5kb25lKCk7XG4gIH0pO1xuICByZXR1cm4gcGxlZGdlO1xufTtcblxuUGxlZGdlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuX2NvbXBsZXRlKSBjYWxsYmFjaygpO1xuICBlbHNlIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbn07XG5cblBsZWRnZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jb21wbGV0ZSA9IHRydWU7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MsIGNhbGxiYWNrO1xuICB3aGlsZSAoY2FsbGJhY2sgPSBjYWxsYmFja3Muc2hpZnQoKSkgY2FsbGJhY2soKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGxlZGdlO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyLFxuICAgIEJhc2UgICA9IF9fd2VicGFja19yZXF1aXJlX18oMiksXG4gICAgdXRpbCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIERyYWZ0NzUgPSBmdW5jdGlvbihyZXF1ZXN0LCB1cmwsIG9wdGlvbnMpIHtcbiAgQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLl9zdGFnZSAgPSAwO1xuICB0aGlzLnZlcnNpb24gPSAnaGl4aWUtNzUnO1xuXG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdVcGdyYWRlJywgJ1dlYlNvY2tldCcpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnQ29ubmVjdGlvbicsICdVcGdyYWRlJyk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdXZWJTb2NrZXQtT3JpZ2luJywgdGhpcy5fcmVxdWVzdC5oZWFkZXJzLm9yaWdpbik7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdXZWJTb2NrZXQtTG9jYXRpb24nLCB0aGlzLnVybCk7XG59O1xudXRpbC5pbmhlcml0cyhEcmFmdDc1LCBCYXNlKTtcblxudmFyIGluc3RhbmNlID0ge1xuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gMykgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDM7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG5ldyBCYXNlLkNsb3NlRXZlbnQobnVsbCwgbnVsbCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPiAxKSByZXR1cm47XG5cbiAgICB0aGlzLl9yZWFkZXIucHV0KGNodW5rKTtcblxuICAgIHRoaXMuX3JlYWRlci5lYWNoQnl0ZShmdW5jdGlvbihvY3RldCkge1xuICAgICAgdmFyIG1lc3NhZ2U7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhZ2UpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICB0aGlzLl9ib2R5LnB1c2gob2N0ZXQpO1xuICAgICAgICAgIHRoaXMuX3NlbmRIYW5kc2hha2VCb2R5KCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHRoaXMuX3BhcnNlTGVhZGluZ0J5dGUob2N0ZXQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLl9sZW5ndGggPSAob2N0ZXQgJiAweDdGKSArIDEyOCAqIHRoaXMuX2xlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLl9jbG9zaW5nICYmIHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9jdGV0ICYgMHg4MCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3RhZ2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NraXBwZWQgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl9zdGFnZSAgID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmIChvY3RldCA9PT0gMHhGRikge1xuICAgICAgICAgICAgdGhpcy5fc3RhZ2UgPSAwO1xuICAgICAgICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKHRoaXMuX2J1ZmZlcikudG9TdHJpbmcoJ3V0ZjgnLCAwLCB0aGlzLl9idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG5ldyBCYXNlLk1lc3NhZ2VFdmVudChtZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICAgICAgICB0aGlzLl9za2lwcGVkICs9IDE7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9za2lwcGVkID09PSB0aGlzLl9sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhZ2UgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnB1c2gob2N0ZXQpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA+IHRoaXMuX21heExlbmd0aCkgcmV0dXJuIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgZnJhbWU6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDApIHJldHVybiB0aGlzLl9xdWV1ZShbYnVmZmVyXSk7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDEpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgYnVmZmVyICE9PSAnc3RyaW5nJykgYnVmZmVyID0gYnVmZmVyLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoYnVmZmVyKSxcbiAgICAgICAgZnJhbWUgID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCArIDIpO1xuXG4gICAgZnJhbWVbMF0gPSAweDAwO1xuICAgIGZyYW1lLndyaXRlKGJ1ZmZlciwgMSk7XG4gICAgZnJhbWVbZnJhbWUubGVuZ3RoIC0gMV0gPSAweEZGO1xuXG4gICAgdGhpcy5fd3JpdGUoZnJhbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIF9oYW5kc2hha2VSZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0ICAgPSAnSFRUUC8xLjEgMTAxIFdlYiBTb2NrZXQgUHJvdG9jb2wgSGFuZHNoYWtlJyxcbiAgICAgICAgaGVhZGVycyA9IFtzdGFydCwgdGhpcy5faGVhZGVycy50b1N0cmluZygpLCAnJ107XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGVhZGVycy5qb2luKCdcXHJcXG4nKSwgJ3V0ZjgnKTtcbiAgfSxcblxuICBfcGFyc2VMZWFkaW5nQnl0ZTogZnVuY3Rpb24ob2N0ZXQpIHtcbiAgICBpZiAoKG9jdGV0ICYgMHg4MCkgPT09IDB4ODApIHtcbiAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9zdGFnZSAgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGVuZ3RoO1xuICAgICAgZGVsZXRlIHRoaXMuX3NraXBwZWQ7XG4gICAgICB0aGlzLl9idWZmZXIgPSBbXTtcbiAgICAgIHRoaXMuX3N0YWdlICA9IDI7XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIERyYWZ0NzUucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0NzU7XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgRXZlbnRUYXJnZXQgPSB7XG4gIG9ub3BlbjogICAgIG51bGwsXG4gIG9ubWVzc2FnZTogIG51bGwsXG4gIG9uZXJyb3I6ICAgIG51bGwsXG4gIG9uY2xvc2U6ICAgIG51bGwsXG5cbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgIHRoaXMub24oZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudC50YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcbiAgICBldmVudC5ldmVudFBoYXNlID0gRXZlbnQuQVRfVEFSR0VUO1xuXG4gICAgaWYgKHRoaXNbJ29uJyArIGV2ZW50LnR5cGVdKVxuICAgICAgdGhpc1snb24nICsgZXZlbnQudHlwZV0oZXZlbnQpO1xuXG4gICAgdGhpcy5lbWl0KGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFBhY2thZ2UgdXRmOCBpbXBsZW1lbnRzIFVURi04IGVuY29kaW5nIGFuZCBkZWNvZGluZy5cbiAqL1xudmFyIElOVkFMSURfVVRGMTYgPSBcInV0Zjg6IGludmFsaWQgc3RyaW5nXCI7XG52YXIgSU5WQUxJRF9VVEY4ID0gXCJ1dGY4OiBpbnZhbGlkIHNvdXJjZSBlbmNvZGluZ1wiO1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgaW50byBVVEYtOCBieXRlIGFycmF5LlxuICogVGhyb3dzIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGhhcyBpbnZhbGlkIFVURi0xNiBlbmNvZGluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHMpIHtcbiAgICAvLyBDYWxjdWxhdGUgcmVzdWx0IGxlbmd0aCBhbmQgYWxsb2NhdGUgb3V0cHV0IGFycmF5LlxuICAgIC8vIGVuY29kZWRMZW5ndGgoKSBhbHNvIHZhbGlkYXRlcyBzdHJpbmcgYW5kIHRocm93cyBlcnJvcnMsXG4gICAgLy8gc28gd2UgZG9uJ3QgbmVlZCByZXBlYXQgdmFsaWRhdGlvbiBoZXJlLlxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShlbmNvZGVkTGVuZ3RoKHMpKTtcbiAgICB2YXIgcG9zID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHhjMCB8IGMgPj4gNjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCkge1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ZTAgfCBjID4+IDEyO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCAoYyA+PiA2KSAmIDB4M2Y7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSsrOyAvLyBnZXQgb25lIG1vcmUgY2hhcmFjdGVyXG4gICAgICAgICAgICBjID0gKGMgJiAweDNmZikgPDwgMTA7XG4gICAgICAgICAgICBjIHw9IHMuY2hhckNvZGVBdChpKSAmIDB4M2ZmO1xuICAgICAgICAgICAgYyArPSAweDEwMDAwO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ZjAgfCBjID4+IDE4O1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCAoYyA+PiAxMikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCAoYyA+PiA2KSAmIDB4M2Y7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIGVuY29kZSB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gVVRGLTguXG4gKiBUaHJvd3MgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaGFzIGludmFsaWQgVVRGLTE2IGVuY29kaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGVkTGVuZ3RoKHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgaWYgKGkgPj0gcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrOyAvLyBcImVhdFwiIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICByZXN1bHQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5lbmNvZGVkTGVuZ3RoID0gZW5jb2RlZExlbmd0aDtcbi8qKlxuICogRGVjb2RlcyB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSBmcm9tIFVURi04IGludG8gYSBzdHJpbmcuXG4gKiBUaHJvd3MgaWYgZW5jb2RpbmcgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGFycikge1xuICAgIHZhciBjaGFycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBiID0gYXJyW2ldO1xuICAgICAgICBpZiAoYiAmIDB4ODApIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoYiA8IDB4ZTApIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIDEgbW9yZSBieXRlLlxuICAgICAgICAgICAgICAgIGlmIChpID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuMSA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIGlmICgobjEgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IChiICYgMHgxZikgPDwgNiB8IChuMSAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIG1pbiA9IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiIDwgMHhmMCkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgMiBtb3JlIGJ5dGVzLlxuICAgICAgICAgICAgICAgIGlmIChpID49IGFyci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbjEgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICB2YXIgbjIgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG4xICYgMHhjMCkgIT09IDB4ODAgfHwgKG4yICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSAoYiAmIDB4MGYpIDw8IDEyIHwgKG4xICYgMHgzZikgPDwgNiB8IChuMiAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIG1pbiA9IDB4ODAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA8IDB4ZjgpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIDMgbW9yZSBieXRlcy5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG4xID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgdmFyIG4yID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgdmFyIG4zID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgaWYgKChuMSAmIDB4YzApICE9PSAweDgwIHx8IChuMiAmIDB4YzApICE9PSAweDgwIHx8IChuMyAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gKGIgJiAweDBmKSA8PCAxOCB8IChuMSAmIDB4M2YpIDw8IDEyIHwgKG4yICYgMHgzZikgPDwgNiB8IChuMyAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIG1pbiA9IDB4MTAwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiIDwgbWluIHx8IChiID49IDB4ZDgwMCAmJiBiIDw9IDB4ZGZmZikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiID49IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICAvLyBTdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICAgICAgICBpZiAoYiA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiIC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgY2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCB8IChiID4+IDEwKSkpO1xuICAgICAgICAgICAgICAgIGIgPSAweGRjMDAgfCAoYiAmIDB4M2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYikpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbihcIlwiKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBBUEkgcmVmZXJlbmNlczpcbi8vXG4vLyAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjbmV0d29ya1xuLy8gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1ldmVudHRhcmdldFxuLy8gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1ldmVudFxuXG5cblxudmFyIHV0aWwgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgZHJpdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KSxcbiAgICBBUEkgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIFdlYlNvY2tldCA9IGZ1bmN0aW9uKHJlcXVlc3QsIHNvY2tldCwgYm9keSwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuX3N0cmVhbSA9IHNvY2tldDtcbiAgdGhpcy5fZHJpdmVyID0gZHJpdmVyLmh0dHAocmVxdWVzdCwge21heExlbmd0aDogb3B0aW9ucy5tYXhMZW5ndGgsIHByb3RvY29sczogcHJvdG9jb2xzfSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoIXRoaXMuX3N0cmVhbSB8fCAhdGhpcy5fc3RyZWFtLndyaXRhYmxlKSByZXR1cm47XG4gIGlmICghdGhpcy5fc3RyZWFtLnJlYWRhYmxlKSByZXR1cm4gdGhpcy5fc3RyZWFtLmVuZCgpO1xuXG4gIHZhciBjYXRjaHVwID0gZnVuY3Rpb24oKSB7IHNlbGYuX3N0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGNhdGNodXApIH07XG4gIHRoaXMuX3N0cmVhbS5vbignZGF0YScsIGNhdGNodXApO1xuXG4gIEFQSS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZHJpdmVyLnN0YXJ0KCk7XG4gICAgc2VsZi5fZHJpdmVyLmlvLndyaXRlKGJvZHkpO1xuICB9KTtcbn07XG51dGlsLmluaGVyaXRzKFdlYlNvY2tldCwgQVBJKTtcblxuV2ViU29ja2V0LmlzV2ViU29ja2V0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICByZXR1cm4gZHJpdmVyLmlzV2ViU29ja2V0KHJlcXVlc3QpO1xufTtcblxuV2ViU29ja2V0LnZhbGlkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIHZhbGlkS2V5cykge1xuICBkcml2ZXIudmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIHZhbGlkS2V5cyk7XG59O1xuXG5XZWJTb2NrZXQuV2ViU29ja2V0ICAgPSBXZWJTb2NrZXQ7XG5XZWJTb2NrZXQuQ2xpZW50ICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbldlYlNvY2tldC5FdmVudFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuXG5tb2R1bGUuZXhwb3J0cyAgICAgICAgPSBXZWJTb2NrZXQ7XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIGJ1aWx0LWluIGh0dHAuanMgdG8gZW11bGF0ZSB0aGUgYnJvd3NlciBYTUxIdHRwUmVxdWVzdCBvYmplY3QuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aXRoIEpTIGRlc2lnbmVkIGZvciBicm93c2VycyB0byBpbXByb3ZlIHJldXNlIG9mIGNvZGUgYW5kXG4gKiBhbGxvdyB0aGUgdXNlIG9mIGV4aXN0aW5nIGxpYnJhcmllcy5cbiAqXG4gKiBVc2FnZTogaW5jbHVkZShcIlhNTEh0dHBSZXF1ZXN0LmpzXCIpIGFuZCB1c2UgWE1MSHR0cFJlcXVlc3QgcGVyIFczQyBzcGVjcy5cbiAqXG4gKiBAYXV0aG9yIERhbiBEZUZlbGlwcGkgPGRhbkBkcml2ZXJkYW4uY29tPlxuICogQGNvbnRyaWJ1dG9yIERhdmlkIEVsbGlzIDxkLmYuZWxsaXNAaWVlZS5vcmc+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG52YXIgVXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBzcGF3biA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpLnNwYXduO1xudmFyIGZzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG5cbmV4cG9ydHMuWE1MSHR0cFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgdmFyaWFibGVzXG4gICAqL1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBodHRwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG4gIHZhciBodHRwcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuXG4gIC8vIEhvbGRzIGh0dHAuanMgb2JqZWN0c1xuICB2YXIgcmVxdWVzdDtcbiAgdmFyIHJlc3BvbnNlO1xuXG4gIC8vIFJlcXVlc3Qgc2V0dGluZ3NcbiAgdmFyIHNldHRpbmdzID0ge307XG5cbiAgLy8gRGlzYWJsZSBoZWFkZXIgYmxhY2tsaXN0LlxuICAvLyBOb3QgcGFydCBvZiBYSFIgc3BlY3MuXG4gIHZhciBkaXNhYmxlSGVhZGVyQ2hlY2sgPSBmYWxzZTtcblxuICAvLyBTZXQgc29tZSBkZWZhdWx0IGhlYWRlcnNcbiAgdmFyIGRlZmF1bHRIZWFkZXJzID0ge1xuICAgIFwiVXNlci1BZ2VudFwiOiBcIm5vZGUtWE1MSHR0cFJlcXVlc3RcIixcbiAgICBcIkFjY2VwdFwiOiBcIiovKlwiLFxuICB9O1xuXG4gIHZhciBoZWFkZXJzID0ge307XG4gIHZhciBoZWFkZXJzQ2FzZSA9IHt9O1xuXG4gIC8vIFRoZXNlIGhlYWRlcnMgYXJlIG5vdCB1c2VyIHNldGFibGUuXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXJlIGFsbG93ZWQgYnV0IGJhbm5lZCBpbiB0aGUgc3BlYzpcbiAgLy8gKiB1c2VyLWFnZW50XG4gIHZhciBmb3JiaWRkZW5SZXF1ZXN0SGVhZGVycyA9IFtcbiAgICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcImNvbm5lY3Rpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImNvb2tpZTJcIixcbiAgICBcImRhdGVcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgIFwib3JpZ2luXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidHJhaWxlclwiLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInZpYVwiXG4gIF07XG5cbiAgLy8gVGhlc2UgcmVxdWVzdCBtZXRob2RzIGFyZSBub3QgYWxsb3dlZFxuICB2YXIgZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMgPSBbXG4gICAgXCJUUkFDRVwiLFxuICAgIFwiVFJBQ0tcIixcbiAgICBcIkNPTk5FQ1RcIlxuICBdO1xuXG4gIC8vIFNlbmQgZmxhZ1xuICB2YXIgc2VuZEZsYWcgPSBmYWxzZTtcbiAgLy8gRXJyb3IgZmxhZywgdXNlZCB3aGVuIGVycm9ycyBvY2N1ciBvciBhYm9ydCBpcyBjYWxsZWRcbiAgdmFyIGVycm9yRmxhZyA9IGZhbHNlO1xuXG4gIC8vIEV2ZW50IGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0ge307XG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICB0aGlzLlVOU0VOVCA9IDA7XG4gIHRoaXMuT1BFTkVEID0gMTtcbiAgdGhpcy5IRUFERVJTX1JFQ0VJVkVEID0gMjtcbiAgdGhpcy5MT0FESU5HID0gMztcbiAgdGhpcy5ET05FID0gNDtcblxuICAvKipcbiAgICogUHVibGljIHZhcnNcbiAgICovXG5cbiAgLy8gQ3VycmVudCBzdGF0ZVxuICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLlVOU0VOVDtcblxuICAvLyBkZWZhdWx0IHJlYWR5IHN0YXRlIGNoYW5nZSBoYW5kbGVyIGluIGNhc2Ugb25lIGlzIG5vdCBzZXQgb3IgaXMgc2V0IGxhdGVcbiAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG4gIC8vIFJlc3VsdCAmIHJlc3BvbnNlXG4gIHRoaXMucmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XG4gIHRoaXMuc3RhdHVzID0gbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gbnVsbDtcbiAgXG4gIC8vIFdoZXRoZXIgY3Jvc3Mtc2l0ZSBBY2Nlc3MtQ29udHJvbCByZXF1ZXN0cyBzaG91bGQgYmUgbWFkZSB1c2luZ1xuICAvLyBjcmVkZW50aWFscyBzdWNoIGFzIGNvb2tpZXMgb3IgYXV0aG9yaXphdGlvbiBoZWFkZXJzXG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbWV0aG9kc1xuICAgKi9cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHNwZWNpZmllZCBoZWFkZXIgaXMgYWxsb3dlZC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgSGVhZGVyIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm4gYm9vbGVhbiBGYWxzZSBpZiBub3QgYWxsb3dlZCwgb3RoZXJ3aXNlIHRydWVcbiAgICovXG4gIHZhciBpc0FsbG93ZWRIdHRwSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgcmV0dXJuIGRpc2FibGVIZWFkZXJDaGVjayB8fCAoaGVhZGVyICYmIGZvcmJpZGRlblJlcXVlc3RIZWFkZXJzLmluZGV4T2YoaGVhZGVyLnRvTG93ZXJDYXNlKCkpID09PSAtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgbWV0aG9kIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgbWV0aG9kIFJlcXVlc3QgbWV0aG9kIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm4gYm9vbGVhbiBGYWxzZSBpZiBub3QgYWxsb3dlZCwgb3RoZXJ3aXNlIHRydWVcbiAgICovXG4gIHZhciBpc0FsbG93ZWRIdHRwTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgcmV0dXJuIChtZXRob2QgJiYgZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMuaW5kZXhPZihtZXRob2QpID09PSAtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2RzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcGVuIHRoZSBjb25uZWN0aW9uLiBDdXJyZW50bHkgc3VwcG9ydHMgbG9jYWwgc2VydmVyIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIG1ldGhvZCBDb25uZWN0aW9uIG1ldGhvZCAoZWcgR0VULCBQT1NUKVxuICAgKiBAcGFyYW0gc3RyaW5nIHVybCBVUkwgZm9yIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0gYm9vbGVhbiBhc3luYyBBc3luY2hyb25vdXMgY29ubmVjdGlvbi4gRGVmYXVsdCBpcyB0cnVlLlxuICAgKiBAcGFyYW0gc3RyaW5nIHVzZXIgVXNlcm5hbWUgZm9yIGJhc2ljIGF1dGhlbnRpY2F0aW9uIChvcHRpb25hbClcbiAgICogQHBhcmFtIHN0cmluZyBwYXNzd29yZCBQYXNzd29yZCBmb3IgYmFzaWMgYXV0aGVudGljYXRpb24gKG9wdGlvbmFsKVxuICAgKi9cbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCkge1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgICBlcnJvckZsYWcgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGZvciB2YWxpZCByZXF1ZXN0IG1ldGhvZFxuICAgIGlmICghaXNBbGxvd2VkSHR0cE1ldGhvZChtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWN1cml0eUVycm9yOiBSZXF1ZXN0IG1ldGhvZCBub3QgYWxsb3dlZFwiKTtcbiAgICB9XG5cbiAgICBzZXR0aW5ncyA9IHtcbiAgICAgIFwibWV0aG9kXCI6IG1ldGhvZCxcbiAgICAgIFwidXJsXCI6IHVybC50b1N0cmluZygpLFxuICAgICAgXCJhc3luY1wiOiAodHlwZW9mIGFzeW5jICE9PSBcImJvb2xlYW5cIiA/IHRydWUgOiBhc3luYyksXG4gICAgICBcInVzZXJcIjogdXNlciB8fCBudWxsLFxuICAgICAgXCJwYXNzd29yZFwiOiBwYXNzd29yZCB8fCBudWxsXG4gICAgfTtcblxuICAgIHNldFN0YXRlKHRoaXMuT1BFTkVEKTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZXMgb3IgZW5hYmxlcyBpc0FsbG93ZWRIdHRwSGVhZGVyKCkgY2hlY2sgdGhlIHJlcXVlc3QuIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICogVGhpcyBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBXM0Mgc3BlYy5cbiAgICpcbiAgICogQHBhcmFtIGJvb2xlYW4gc3RhdGUgRW5hYmxlIG9yIGRpc2FibGUgaGVhZGVyIGNoZWNraW5nLlxuICAgKi9cbiAgdGhpcy5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGRpc2FibGVIZWFkZXJDaGVjayA9IHN0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgaGVhZGVyIGZvciB0aGUgcmVxdWVzdCBvciBhcHBlbmRzIHRoZSB2YWx1ZSBpZiBvbmUgaXMgYWxyZWFkeSBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIEhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSBzdHJpbmcgdmFsdWUgSGVhZGVyIHZhbHVlXG4gICAqL1xuICB0aGlzLnNldFJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5PUEVORUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBzZXRSZXF1ZXN0SGVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIHN0YXRlIGlzIE9QRU5cIik7XG4gICAgfVxuICAgIGlmICghaXNBbGxvd2VkSHR0cEhlYWRlcihoZWFkZXIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJSZWZ1c2VkIHRvIHNldCB1bnNhZmUgaGVhZGVyIFxcXCJcIiArIGhlYWRlciArIFwiXFxcIlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogc2VuZCBmbGFnIGlzIHRydWVcIik7XG4gICAgfVxuICAgIGhlYWRlciA9IGhlYWRlcnNDYXNlW2hlYWRlci50b0xvd2VyQ2FzZSgpXSB8fCBoZWFkZXI7XG4gICAgaGVhZGVyc0Nhc2VbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyO1xuICAgIGhlYWRlcnNbaGVhZGVyXSA9IGhlYWRlcnNbaGVhZGVyXSA/IGhlYWRlcnNbaGVhZGVyXSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgaGVhZGVyIGZyb20gdGhlIHNlcnZlciByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgTmFtZSBvZiBoZWFkZXIgdG8gZ2V0LlxuICAgKiBAcmV0dXJuIHN0cmluZyBUZXh0IG9mIHRoZSBoZWFkZXIgb3IgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgdGhpcy5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIGlmICh0eXBlb2YgaGVhZGVyID09PSBcInN0cmluZ1wiXG4gICAgICAmJiB0aGlzLnJlYWR5U3RhdGUgPiB0aGlzLk9QRU5FRFxuICAgICAgJiYgcmVzcG9uc2VcbiAgICAgICYmIHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICYmIHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldXG4gICAgICAmJiAhZXJyb3JGbGFnXG4gICAgKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgKlxuICAgKiBAcmV0dXJuIHN0cmluZyBBIHN0cmluZyB3aXRoIGFsbCByZXNwb25zZSBoZWFkZXJzIHNlcGFyYXRlZCBieSBDUitMRlxuICAgKi9cbiAgdGhpcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDwgdGhpcy5IRUFERVJTX1JFQ0VJVkVEIHx8IGVycm9yRmxhZykge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAvLyBDb29raWUgaGVhZGVycyBhcmUgZXhjbHVkZWRcbiAgICAgIGlmIChpICE9PSBcInNldC1jb29raWVcIiAmJiBpICE9PSBcInNldC1jb29raWUyXCIpIHtcbiAgICAgICAgcmVzdWx0ICs9IGkgKyBcIjogXCIgKyByZXNwb25zZS5oZWFkZXJzW2ldICsgXCJcXHJcXG5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zdWJzdHIoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVxdWVzdCBoZWFkZXJcbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBuYW1lIE5hbWUgb2YgaGVhZGVyIHRvIGdldFxuICAgKiBAcmV0dXJuIHN0cmluZyBSZXR1cm5zIHRoZSByZXF1ZXN0IGhlYWRlciBvciBlbXB0eSBzdHJpbmcgaWYgbm90IHNldFxuICAgKi9cbiAgdGhpcy5nZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBoZWFkZXJzQ2FzZVtuYW1lLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICByZXR1cm4gaGVhZGVyc1toZWFkZXJzQ2FzZVtuYW1lLnRvTG93ZXJDYXNlKCldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIjtcbiAgfTtcblxuICAvKipcbiAgICogU2VuZHMgdGhlIHJlcXVlc3QgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBkYXRhIE9wdGlvbmFsIGRhdGEgdG8gc2VuZCBhcyByZXF1ZXN0IGJvZHkuXG4gICAqL1xuICB0aGlzLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5PUEVORUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBjb25uZWN0aW9uIG11c3QgYmUgb3BlbmVkIGJlZm9yZSBzZW5kKCkgaXMgY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlI6IHNlbmQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgdmFyIHNzbCA9IGZhbHNlLCBsb2NhbCA9IGZhbHNlO1xuICAgIHZhciB1cmwgPSBVcmwucGFyc2Uoc2V0dGluZ3MudXJsKTtcbiAgICB2YXIgaG9zdDtcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHNlcnZlclxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgICAgIHNzbCA9IHRydWU7XG4gICAgICAgIC8vIFNTTCAmIG5vbi1TU0wgYm90aCBuZWVkIGhvc3QsIG5vIGJyZWFrIGhlcmUuXG4gICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJmaWxlOlwiOlxuICAgICAgICBsb2NhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgaG9zdCA9IFwibG9jYWxob3N0XCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm90b2NvbCBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG5cbiAgICAvLyBMb2FkIGZpbGVzIG9mZiB0aGUgbG9jYWwgZmlsZXN5c3RlbSAoZmlsZTovLylcbiAgICBpZiAobG9jYWwpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3Q6IE9ubHkgR0VUIG1ldGhvZCBpcyBzdXBwb3J0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXR0aW5ncy5hc3luYykge1xuICAgICAgICBmcy5yZWFkRmlsZSh1cmwucGF0aG5hbWUsIFwidXRmOFwiLCBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBkYXRhO1xuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IGZzLnJlYWRGaWxlU3luYyh1cmwucGF0aG5hbWUsIFwidXRmOFwiKTtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IDIwMDtcbiAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHBvcnQgODAuIElmIGFjY2Vzc2luZyBsb2NhbGhvc3Qgb24gYW5vdGhlciBwb3J0IGJlIHN1cmVcbiAgICAvLyB0byB1c2UgaHR0cDovL2xvY2FsaG9zdDpwb3J0L3BhdGhcbiAgICB2YXIgcG9ydCA9IHVybC5wb3J0IHx8IChzc2wgPyA0NDMgOiA4MCk7XG4gICAgLy8gQWRkIHF1ZXJ5IHN0cmluZyBpZiBvbmUgaXMgdXNlZFxuICAgIHZhciB1cmkgPSB1cmwucGF0aG5hbWUgKyAodXJsLnNlYXJjaCA/IHVybC5zZWFyY2ggOiBcIlwiKTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgaWYgdGhleSBoYXZlbid0IGJlZW4gc2V0XG4gICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0SGVhZGVycykge1xuICAgICAgaWYgKCFoZWFkZXJzQ2FzZVtuYW1lLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIGhlYWRlcnNbbmFtZV0gPSBkZWZhdWx0SGVhZGVyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIEhvc3QgaGVhZGVyIG9yIHRoZSBzZXJ2ZXIgbWF5IHJlamVjdCB0aGUgcmVxdWVzdFxuICAgIGhlYWRlcnMuSG9zdCA9IGhvc3Q7XG4gICAgaWYgKCEoKHNzbCAmJiBwb3J0ID09PSA0NDMpIHx8IHBvcnQgPT09IDgwKSkge1xuICAgICAgaGVhZGVycy5Ib3N0ICs9IFwiOlwiICsgdXJsLnBvcnQ7XG4gICAgfVxuXG4gICAgLy8gU2V0IEJhc2ljIEF1dGggaWYgbmVjZXNzYXJ5XG4gICAgaWYgKHNldHRpbmdzLnVzZXIpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MucGFzc3dvcmQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2V0dGluZ3MucGFzc3dvcmQgPSBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIGF1dGhCdWYgPSBuZXcgQnVmZmVyKHNldHRpbmdzLnVzZXIgKyBcIjpcIiArIHNldHRpbmdzLnBhc3N3b3JkKTtcbiAgICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IFwiQmFzaWMgXCIgKyBhdXRoQnVmLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cblxuICAgIC8vIFNldCBjb250ZW50IGxlbmd0aCBoZWFkZXJcbiAgICBpZiAoc2V0dGluZ3MubWV0aG9kID09PSBcIkdFVFwiIHx8IHNldHRpbmdzLm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgIGRhdGEgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gQnVmZmVyLmlzQnVmZmVyKGRhdGEpID8gZGF0YS5sZW5ndGggOiBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKCFoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKSB7XG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgLy8gRm9yIGEgcG9zdCB3aXRoIG5vIGRhdGEgc2V0IENvbnRlbnQtTGVuZ3RoOiAwLlxuICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBieSBidWdneSBzZXJ2ZXJzIHRoYXQgZG9uJ3QgbWVldCB0aGUgc3BlY3MuXG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSAwO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgaG9zdDogaG9zdCxcbiAgICAgIHBvcnQ6IHBvcnQsXG4gICAgICBwYXRoOiB1cmksXG4gICAgICBtZXRob2Q6IHNldHRpbmdzLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBhZ2VudDogZmFsc2UsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYud2l0aENyZWRlbnRpYWxzXG4gICAgfTtcblxuICAgIC8vIFJlc2V0IGVycm9yIGZsYWdcbiAgICBlcnJvckZsYWcgPSBmYWxzZTtcblxuICAgIC8vIEhhbmRsZSBhc3luYyByZXF1ZXN0c1xuICAgIGlmIChzZXR0aW5ncy5hc3luYykge1xuICAgICAgLy8gVXNlIHRoZSBwcm9wZXIgcHJvdG9jb2xcbiAgICAgIHZhciBkb1JlcXVlc3QgPSBzc2wgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0O1xuXG4gICAgICAvLyBSZXF1ZXN0IGlzIGJlaW5nIHNlbnQsIHNldCBzZW5kIGZsYWdcbiAgICAgIHNlbmRGbGFnID0gdHJ1ZTtcblxuICAgICAgLy8gQXMgcGVyIHNwZWMsIHRoaXMgaXMgY2FsbGVkIGhlcmUgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIik7XG5cbiAgICAgIC8vIEhhbmRsZXIgZm9yIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGFuZGxlciA9IGZ1bmN0aW9uIHJlc3BvbnNlSGFuZGxlcihyZXNwKSB7XG4gICAgICAgIC8vIFNldCByZXNwb25zZSB2YXIgdG8gdGhlIHJlc3BvbnNlIHdlIGdvdCBiYWNrXG4gICAgICAgIC8vIFRoaXMgaXMgc28gaXQgcmVtYWlucyBhY2Nlc3NhYmxlIG91dHNpZGUgdGhpcyBzY29wZVxuICAgICAgICByZXNwb25zZSA9IHJlc3A7XG4gICAgICAgIC8vIENoZWNrIGZvciByZWRpcmVjdFxuICAgICAgICAvLyBAVE9ETyBQcmV2ZW50IGxvb3BlZCByZWRpcmVjdHNcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAzIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNykge1xuICAgICAgICAgIC8vIENoYW5nZSBVUkwgdG8gdGhlIHJlZGlyZWN0IGxvY2F0aW9uXG4gICAgICAgICAgc2V0dGluZ3MudXJsID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbjtcbiAgICAgICAgICB2YXIgdXJsID0gVXJsLnBhcnNlKHNldHRpbmdzLnVybCk7XG4gICAgICAgICAgLy8gU2V0IGhvc3QgdmFyIGluIGNhc2UgaXQncyB1c2VkIGxhdGVyXG4gICAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgICAvLyBPcHRpb25zIGZvciB0aGUgbmV3IHJlcXVlc3RcbiAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUsXG4gICAgICAgICAgICBwb3J0OiB1cmwucG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHVybC5wYXRoLFxuICAgICAgICAgICAgbWV0aG9kOiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDMgPyBcIkdFVFwiIDogc2V0dGluZ3MubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi53aXRoQ3JlZGVudGlhbHNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gSXNzdWUgdGhlIG5ldyByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdCA9IGRvUmVxdWVzdChuZXdPcHRpb25zLCByZXNwb25zZUhhbmRsZXIpLm9uKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICAgIC8vIEBUT0RPIENoZWNrIGlmIGFuIFhIUiBldmVudCBuZWVkcyB0byBiZSBmaXJlZCBoZXJlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuXG4gICAgICAgIHNldFN0YXRlKHNlbGYuSEVBREVSU19SRUNFSVZFRCk7XG4gICAgICAgIHNlbGYuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcblxuICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUncyBzb21lIGRhdGFcbiAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ICs9IGNodW5rO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEb24ndCBlbWl0IHN0YXRlIGNoYW5nZXMgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHNlbGYuTE9BRElORyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXNwb25zZS5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgICAgICAgIC8vIERpc2NhcmQgdGhlIGVuZCBldmVudCBpZiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBhYm9ydGVkXG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICAgICAgc2VuZEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBFcnJvciBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdFxuICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIGVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IGRvUmVxdWVzdChvcHRpb25zLCByZXNwb25zZUhhbmRsZXIpLm9uKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcblxuICAgICAgLy8gTm9kZSAwLjQgYW5kIGxhdGVyIHdvbid0IGFjY2VwdCBlbXB0eSBkYXRhLiBNYWtlIHN1cmUgaXQncyBuZWVkZWQuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXF1ZXN0LndyaXRlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmVuZCgpO1xuXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG4gICAgfSBlbHNlIHsgLy8gU3luY2hyb25vdXNcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBmaWxlIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIG90aGVyIE5vZGUgcHJvY2Vzc1xuICAgICAgdmFyIGNvbnRlbnRGaWxlID0gXCIubm9kZS14bWxodHRwcmVxdWVzdC1jb250ZW50LVwiICsgcHJvY2Vzcy5waWQ7XG4gICAgICB2YXIgc3luY0ZpbGUgPSBcIi5ub2RlLXhtbGh0dHByZXF1ZXN0LXN5bmMtXCIgKyBwcm9jZXNzLnBpZDtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoc3luY0ZpbGUsIFwiXCIsIFwidXRmOFwiKTtcbiAgICAgIC8vIFRoZSBhc3luYyByZXF1ZXN0IHRoZSBvdGhlciBOb2RlIHByb2Nlc3MgZXhlY3V0ZXNcbiAgICAgIHZhciBleGVjU3RyaW5nID0gXCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKSwgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpLCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XCJcbiAgICAgICAgKyBcInZhciBkb1JlcXVlc3QgPSBodHRwXCIgKyAoc3NsID8gXCJzXCIgOiBcIlwiKSArIFwiLnJlcXVlc3Q7XCJcbiAgICAgICAgKyBcInZhciBvcHRpb25zID0gXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSArIFwiO1wiXG4gICAgICAgICsgXCJ2YXIgcmVzcG9uc2VUZXh0ID0gJyc7XCJcbiAgICAgICAgKyBcInZhciByZXEgPSBkb1JlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcIlxuICAgICAgICArIFwicmVzcG9uc2Uuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcIlxuICAgICAgICArIFwicmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1wiXG4gICAgICAgICsgXCIgIHJlc3BvbnNlVGV4dCArPSBjaHVuaztcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcIlxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgSlNPTi5zdHJpbmdpZnkoe2VycjogbnVsbCwgZGF0YToge3N0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsIHRleHQ6IHJlc3BvbnNlVGV4dH19KSwgJ3V0ZjgnKTtcIlxuICAgICAgICArIFwiZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcbiAgICAgICAgKyBcIn0pO1wiXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1wiXG4gICAgICAgICsgXCJmcy53cml0ZUZpbGVTeW5jKCdcIiArIGNvbnRlbnRGaWxlICsgXCInLCBKU09OLnN0cmluZ2lmeSh7ZXJyOiBlcnJvcn0pLCAndXRmOCcpO1wiXG4gICAgICAgICsgXCJmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcIn0pLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XCJcbiAgICAgICAgKyBcImZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsIEpTT04uc3RyaW5naWZ5KHtlcnI6IGVycm9yfSksICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcImZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXG4gICAgICAgICsgXCJ9KTtcIlxuICAgICAgICArIChkYXRhID8gXCJyZXEud3JpdGUoJ1wiICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkuc2xpY2UoMSwtMSkucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpICsgXCInKTtcIjpcIlwiKVxuICAgICAgICArIFwicmVxLmVuZCgpO1wiO1xuICAgICAgLy8gU3RhcnQgdGhlIG90aGVyIE5vZGUgUHJvY2VzcywgZXhlY3V0aW5nIHRoaXMgc3RyaW5nXG4gICAgICB2YXIgc3luY1Byb2MgPSBzcGF3bihwcm9jZXNzLmFyZ3ZbMF0sIFtcIi1lXCIsIGV4ZWNTdHJpbmddKTtcbiAgICAgIHdoaWxlKGZzLmV4aXN0c1N5bmMoc3luY0ZpbGUpKSB7XG4gICAgICAgIC8vIFdhaXQgd2hpbGUgdGhlIHN5bmMgZmlsZSBpcyBlbXB0eVxuICAgICAgfVxuICAgICAgdmFyIHJlc3AgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhjb250ZW50RmlsZSwgJ3V0ZjgnKSk7XG4gICAgICAvLyBLaWxsIHRoZSBjaGlsZCBwcm9jZXNzIG9uY2UgdGhlIGZpbGUgaGFzIGRhdGFcbiAgICAgIHN5bmNQcm9jLnN0ZGluLmVuZCgpO1xuICAgICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgZmlsZVxuICAgICAgZnMudW5saW5rU3luYyhjb250ZW50RmlsZSk7XG5cbiAgICAgIGlmIChyZXNwLmVycikge1xuICAgICAgICBzZWxmLmhhbmRsZUVycm9yKHJlc3AuZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNlID0gcmVzcC5kYXRhO1xuICAgICAgICBzZWxmLnN0YXR1cyA9IHJlc3AuZGF0YS5zdGF0dXNDb2RlO1xuICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IHJlc3AuZGF0YS50ZXh0O1xuICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgdG8gZGVhbCB3aXRoIGl0LlxuICAgKi9cbiAgdGhpcy5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgdGhpcy5zdGF0dXMgPSAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGVycm9yO1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gZXJyb3Iuc3RhY2s7XG4gICAgZXJyb3JGbGFnID0gdHJ1ZTtcbiAgICBzZXRTdGF0ZSh0aGlzLkRPTkUpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZXJyb3InKTtcbiAgfTtcblxuICAvKipcbiAgICogQWJvcnRzIGEgcmVxdWVzdC5cbiAgICovXG4gIHRoaXMuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaGVhZGVycyA9IGRlZmF1bHRIZWFkZXJzO1xuICAgIHRoaXMuc3RhdHVzID0gMDtcbiAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gICAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XG5cbiAgICBlcnJvckZsYWcgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5VTlNFTlRcbiAgICAgICAgJiYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5PUEVORUQgfHwgc2VuZEZsYWcpXG4gICAgICAgICYmIHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5ET05FKSB7XG4gICAgICBzZW5kRmxhZyA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUodGhpcy5ET05FKTtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlQ7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdhYm9ydCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyLiBQcmVmZXJyZWQgbWV0aG9kIG9mIGJpbmRpbmcgdG8gZXZlbnRzLlxuICAgKi9cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoZXZlbnQgaW4gbGlzdGVuZXJzKSkge1xuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICAvLyBDdXJyZW50bHkgYWxsb3dzIGR1cGxpY2F0ZSBjYWxsYmFja3MuIFNob3VsZCBpdD9cbiAgICBsaXN0ZW5lcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgY2FsbGJhY2sgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kLlxuICAgKiBPbmx5IHdvcmtzIG9uIHRoZSBtYXRjaGluZyBmdW5jaXRvbiwgY2Fubm90IGJlIGEgY29weS5cbiAgICovXG4gIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmIChldmVudCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIC8vIEZpbHRlciB3aWxsIHJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZSBjYWxsYmFjayByZW1vdmVkXG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXJzW2V2ZW50XS5maWx0ZXIoZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgcmV0dXJuIGV2ICE9PSBjYWxsYmFjaztcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2ggYW55IGV2ZW50cywgaW5jbHVkaW5nIGJvdGggXCJvblwiIG1ldGhvZHMgYW5kIGV2ZW50cyBhdHRhY2hlZCB1c2luZyBhZGRFdmVudExpc3RlbmVyLlxuICAgKi9cbiAgdGhpcy5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIHNlbGZbXCJvblwiICsgZXZlbnRdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHNlbGZbXCJvblwiICsgZXZlbnRdKCk7XG4gICAgfVxuICAgIGlmIChldmVudCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnNbZXZlbnRdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tldmVudF1baV0uY2FsbChzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgcmVhZHlTdGF0ZSBhbmQgY2FsbHMgb25yZWFkeXN0YXRlY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0gaW50IHN0YXRlIE5ldyBzdGF0ZVxuICAgKi9cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT0gc2VsZi5MT0FESU5HIHx8IHNlbGYucmVhZHlTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IHN0YXRlO1xuXG4gICAgICBpZiAoc2V0dGluZ3MuYXN5bmMgfHwgc2VsZi5yZWFkeVN0YXRlIDwgc2VsZi5PUEVORUQgfHwgc2VsZi5yZWFkeVN0YXRlID09PSBzZWxmLkRPTkUpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5ET05FICYmICFlcnJvckZsYWcpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZFwiKTtcbiAgICAgICAgLy8gQFRPRE8gZmlndXJlIG91dCBJbnNwZWN0b3JJbnN0cnVtZW50YXRpb246OmRpZExvYWRYSFIoY29va2llKVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2FkZW5kXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4oZnVuY3Rpb24obmFjbCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQb3J0ZWQgaW4gMjAxNCBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuLy9cbi8vIEltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBUd2VldE5hQ2wgdmVyc2lvbiAyMDE0MDQyNy5cbi8vIFNlZSBmb3IgZGV0YWlsczogaHR0cDovL3R3ZWV0bmFjbC5jci55cC50by9cblxudmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBpZiAoaW5pdCkgZm9yIChpID0gMDsgaSA8IGluaXQubGVuZ3RoOyBpKyspIHJbaV0gPSBpbml0W2ldO1xuICByZXR1cm4gcjtcbn07XG5cbi8vICBQbHVnZ2FibGUsIGluaXRpYWxpemVkIGluIGhpZ2gtbGV2ZWwgQVBJIGJlbG93LlxudmFyIHJhbmRvbWJ5dGVzID0gZnVuY3Rpb24oLyogeCwgbiAqLykgeyB0aHJvdyBuZXcgRXJyb3IoJ25vIFBSTkcnKTsgfTtcblxudmFyIF8wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xudmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyBfOVswXSA9IDk7XG5cbnZhciBnZjAgPSBnZigpLFxuICAgIGdmMSA9IGdmKFsxXSksXG4gICAgXzEyMTY2NSA9IGdmKFsweGRiNDEsIDFdKSxcbiAgICBEID0gZ2YoWzB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLCAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pLFxuICAgIEQyID0gZ2YoWzB4ZjE1OSwgMHgyNmIyLCAweDliOTQsIDB4ZWJkNiwgMHhiMTU2LCAweDgyODMsIDB4MTQ5YSwgMHgwMGUwLCAweGQxMzAsIDB4ZWVmMywgMHg4MGYyLCAweDE5OGUsIDB4ZmNlNywgMHg1NmRmLCAweGQ5ZGMsIDB4MjQwNl0pLFxuICAgIFggPSBnZihbMHhkNTFhLCAweDhmMjUsIDB4MmQ2MCwgMHhjOTU2LCAweGE3YjIsIDB4OTUyNSwgMHhjNzYwLCAweDY5MmMsIDB4ZGM1YywgMHhmZGQ2LCAweGUyMzEsIDB4YzBhNCwgMHg1M2ZlLCAweGNkNmUsIDB4MzZkMywgMHgyMTY5XSksXG4gICAgWSA9IGdmKFsweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKSxcbiAgICBJID0gZ2YoWzB4YTBiMCwgMHg0YTBlLCAweDFiMjcsIDB4YzRlZSwgMHhlNDc4LCAweGFkMmYsIDB4MTgwNiwgMHgyZjQzLCAweGQ3YTcsIDB4M2RmYiwgMHgwMDk5LCAweDJiNGQsIDB4ZGYwYiwgMHg0ZmMxLCAweDI0ODAsIDB4MmI4M10pO1xuXG5mdW5jdGlvbiB0czY0KHgsIGksIGgsIGwpIHtcbiAgeFtpXSAgID0gKGggPj4gMjQpICYgMHhmZjtcbiAgeFtpKzFdID0gKGggPj4gMTYpICYgMHhmZjtcbiAgeFtpKzJdID0gKGggPj4gIDgpICYgMHhmZjtcbiAgeFtpKzNdID0gaCAmIDB4ZmY7XG4gIHhbaSs0XSA9IChsID4+IDI0KSAgJiAweGZmO1xuICB4W2krNV0gPSAobCA+PiAxNikgICYgMHhmZjtcbiAgeFtpKzZdID0gKGwgPj4gIDgpICAmIDB4ZmY7XG4gIHhbaSs3XSA9IGwgJiAweGZmO1xufVxuXG5mdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgdmFyIGksZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGQgfD0geFt4aStpXV55W3lpK2ldO1xuICByZXR1cm4gKDEgJiAoKGQgLSAxKSA+Pj4gOCkpIC0gMTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8xNih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwxNik7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMzIpO1xufVxuXG5mdW5jdGlvbiBjb3JlX3NhbHNhMjAobywgcCwgaywgYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZik8PDggfCAoY1sgMl0gJiAweGZmKTw8MTYgfCAoY1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKTw8OCB8IChrWyAyXSAmIDB4ZmYpPDwxNiB8IChrWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpPDw4IHwgKGtbIDZdICYgMHhmZik8PDE2IHwgKGtbIDddICYgMHhmZik8PDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZik8PDggfCAoa1sxMF0gJiAweGZmKTw8MTYgfCAoa1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKTw8OCB8IChrWzE0XSAmIDB4ZmYpPDwxNiB8IChrWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpPDw4IHwgKGNbIDZdICYgMHhmZik8PDE2IHwgKGNbIDddICYgMHhmZik8PDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZik8PDggfCAocFsgMl0gJiAweGZmKTw8MTYgfCAocFsgM10gJiAweGZmKTw8MjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKTw8OCB8IChwWyA2XSAmIDB4ZmYpPDwxNiB8IChwWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpPDw4IHwgKHBbMTBdICYgMHhmZik8PDE2IHwgKHBbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZik8PDggfCAocFsxNF0gJiAweGZmKTw8MTYgfCAocFsxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKTw8OCB8IChjWzEwXSAmIDB4ZmYpPDwxNiB8IChjWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpPDw4IHwgKGtbMThdICYgMHhmZik8PDE2IHwgKGtbMTldICYgMHhmZik8PDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZik8PDggfCAoa1syMl0gJiAweGZmKTw8MTYgfCAoa1syM10gJiAweGZmKTw8MjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKTw8OCB8IChrWzI2XSAmIDB4ZmYpPDwxNiB8IChrWzI3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpPDw4IHwgKGtbMzBdICYgMHhmZik8PDE2IHwgKGtbMzFdICYgMHhmZik8PDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZik8PDggfCAoY1sxNF0gJiAweGZmKTw8MTYgfCAoY1sxNV0gJiAweGZmKTw8MjQ7XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwO1xuICAgIHg0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NCArIHgwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4NCB8IDA7XG4gICAgeDEyIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMiArIHg4IHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDEgfCAwO1xuICAgIHg5IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4OSArIHg1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHg5IHwgMDtcbiAgICB4MSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MSArIHgxMyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4NiB8IDA7XG4gICAgeDE0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTQgKyB4MTAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxNCB8IDA7XG4gICAgeDYgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDYgKyB4MiB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMDtcbiAgICB4MyBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDMgKyB4MTUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHgzIHwgMDtcbiAgICB4MTEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDExICsgeDcgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgwICsgeDMgfCAwO1xuICAgIHgxIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MSArIHgwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MSB8IDA7XG4gICAgeDMgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDMgKyB4MiB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHg0IHwgMDtcbiAgICB4NiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDYgKyB4NSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDYgfCAwO1xuICAgIHg0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg0ICsgeDcgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDkgfCAwO1xuICAgIHgxMSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDExICsgeDEwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4MTEgfCAwO1xuICAgIHg5IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg5ICsgeDggfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxNCB8IDA7XG4gICAgeDEyIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTIgKyB4MTUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDEyIHwgMDtcbiAgICB4MTQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDE0ICsgeDEzIHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcbiAgfVxuICAgeDAgPSAgeDAgKyAgajAgfCAwO1xuICAgeDEgPSAgeDEgKyAgajEgfCAwO1xuICAgeDIgPSAgeDIgKyAgajIgfCAwO1xuICAgeDMgPSAgeDMgKyAgajMgfCAwO1xuICAgeDQgPSAgeDQgKyAgajQgfCAwO1xuICAgeDUgPSAgeDUgKyAgajUgfCAwO1xuICAgeDYgPSAgeDYgKyAgajYgfCAwO1xuICAgeDcgPSAgeDcgKyAgajcgfCAwO1xuICAgeDggPSAgeDggKyAgajggfCAwO1xuICAgeDkgPSAgeDkgKyAgajkgfCAwO1xuICB4MTAgPSB4MTAgKyBqMTAgfCAwO1xuICB4MTEgPSB4MTEgKyBqMTEgfCAwO1xuICB4MTIgPSB4MTIgKyBqMTIgfCAwO1xuICB4MTMgPSB4MTMgKyBqMTMgfCAwO1xuICB4MTQgPSB4MTQgKyBqMTQgfCAwO1xuICB4MTUgPSB4MTUgKyBqMTUgfCAwO1xuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZjtcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmO1xuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA0XSA9IHgxID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDVdID0geDEgPj4+ICA4ICYgMHhmZjtcbiAgb1sgNl0gPSB4MSA+Pj4gMTYgJiAweGZmO1xuICBvWyA3XSA9IHgxID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgOF0gPSB4MiA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgyID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDIgPj4+IDE2ICYgMHhmZjtcbiAgb1sxMV0gPSB4MiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDMgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MyA+Pj4gIDggJiAweGZmO1xuICBvWzE0XSA9IHgzID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDMgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDQgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NCA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDYgPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4NiA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg2ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDYgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg3ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDcgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4NyA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg3ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szMl0gPSB4OCA+Pj4gIDAgJiAweGZmO1xuICBvWzMzXSA9IHg4ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzRdID0geDggPj4+IDE2ICYgMHhmZjtcbiAgb1szNV0gPSB4OCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMzZdID0geDkgPj4+ICAwICYgMHhmZjtcbiAgb1szN10gPSB4OSA+Pj4gIDggJiAweGZmO1xuICBvWzM4XSA9IHg5ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzldID0geDkgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQwXSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWzQxXSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzQyXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzQzXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDRdID0geDExID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDVdID0geDExID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDZdID0geDExID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDddID0geDExID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0OF0gPSB4MTIgPj4+ICAwICYgMHhmZjtcbiAgb1s0OV0gPSB4MTIgPj4+ICA4ICYgMHhmZjtcbiAgb1s1MF0gPSB4MTIgPj4+IDE2ICYgMHhmZjtcbiAgb1s1MV0gPSB4MTIgPj4+IDI0ICYgMHhmZjtcblxuICBvWzUyXSA9IHgxMyA+Pj4gIDAgJiAweGZmO1xuICBvWzUzXSA9IHgxMyA+Pj4gIDggJiAweGZmO1xuICBvWzU0XSA9IHgxMyA+Pj4gMTYgJiAweGZmO1xuICBvWzU1XSA9IHgxMyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTZdID0geDE0ID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTddID0geDE0ID4+PiAgOCAmIDB4ZmY7XG4gIG9bNThdID0geDE0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTldID0geDE0ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s2MF0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1s2MV0gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1s2Ml0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1s2M10gPSB4MTUgPj4+IDI0ICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gY29yZV9oc2Fsc2EyMChvLHAsayxjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDUgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4NSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHg1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDUgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgxMCA+Pj4gIDAgJiAweGZmO1xuICBvWyA5XSA9IHgxMCA+Pj4gIDggJiAweGZmO1xuICBvWzEwXSA9IHgxMCA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgxMCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTJdID0geDE1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTNdID0geDE1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDE1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTVdID0geDE1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxNl0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzE3XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMThdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1sxOV0gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjBdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syMV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzIyXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjNdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI0XSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjVdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1syNl0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzI3XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syOF0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzI5XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzBdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szMV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX2hzYWxzYTIwKG91dCxpbnAsayxjKSB7XG4gIGNvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpO1xufVxuXG52YXIgc2lnbWEgPSBuZXcgVWludDhBcnJheShbMTAxLCAxMjAsIDExMiwgOTcsIDExMCwgMTAwLCAzMiwgNTEsIDUwLCA0NSwgOTgsIDEyMSwgMTE2LCAxMDEsIDMyLCAxMDddKTtcbiAgICAgICAgICAgIC8vIFwiZXhwYW5kIDMyLWJ5dGUga1wiXG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYyxjcG9zLG0sbXBvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IG1bbXBvcytpXSBeIHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICAgIG1wb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxiLG4saykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHUsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB6W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgeltpXSA9IG5baV07XG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gICAgdSA9IDE7XG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICB6W2ldID0gdSAmIDB4ZmY7XG4gICAgICB1ID4+Pj0gODtcbiAgICB9XG4gICAgYiAtPSA2NDtcbiAgICBjcG9zICs9IDY0O1xuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiOyBpKyspIGNbY3BvcytpXSA9IHhbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW0oYyxjcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsY3BvcyxkLHNuLHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3hvcihjLGNwb3MsbSxtcG9zLGQsbixrKSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMChzLG4sayxzaWdtYSk7XG4gIHZhciBzbiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgc25baV0gPSBuW2krMTZdO1xuICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGQsc24scyk7XG59XG5cbi8qXG4qIFBvcnQgb2YgQW5kcmV3IE1vb24ncyBQb2x5MTMwNS1kb25uYS0xNi4gUHVibGljIGRvbWFpbi5cbiogaHR0cHM6Ly9naXRodWIuY29tL2Zsb29keWJlcnJ5L3BvbHkxMzA1LWRvbm5hXG4qL1xuXG52YXIgcG9seTEzMDUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgdGhpcy5maW4gPSAwO1xuXG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDc7XG5cbiAgdDAgPSBrZXlbIDBdICYgMHhmZiB8IChrZXlbIDFdICYgMHhmZikgPDwgODsgdGhpcy5yWzBdID0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gIHQxID0ga2V5WyAyXSAmIDB4ZmYgfCAoa2V5WyAzXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICB0MiA9IGtleVsgNF0gJiAweGZmIHwgKGtleVsgNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWYwMztcbiAgdDMgPSBrZXlbIDZdICYgMHhmZiB8IChrZXlbIDddICYgMHhmZikgPDwgODsgdGhpcy5yWzNdID0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gIHQ0ID0ga2V5WyA4XSAmIDB4ZmYgfCAoa2V5WyA5XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls0XSA9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuICB0aGlzLnJbNV0gPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZlO1xuICB0NSA9IGtleVsxMF0gJiAweGZmIHwgKGtleVsxMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgdDYgPSBrZXlbMTJdICYgMHhmZiB8IChrZXlbMTNdICYgMHhmZikgPDwgODsgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmODE7XG4gIHQ3ID0ga2V5WzE0XSAmIDB4ZmYgfCAoa2V5WzE1XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls4XSA9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICB0aGlzLnJbOV0gPSAoKHQ3ID4+PiAgNSkpICYgMHgwMDdmO1xuXG4gIHRoaXMucGFkWzBdID0ga2V5WzE2XSAmIDB4ZmYgfCAoa2V5WzE3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzFdID0ga2V5WzE4XSAmIDB4ZmYgfCAoa2V5WzE5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzJdID0ga2V5WzIwXSAmIDB4ZmYgfCAoa2V5WzIxXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzNdID0ga2V5WzIyXSAmIDB4ZmYgfCAoa2V5WzIzXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzRdID0ga2V5WzI0XSAmIDB4ZmYgfCAoa2V5WzI1XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzVdID0ga2V5WzI2XSAmIDB4ZmYgfCAoa2V5WzI3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzZdID0ga2V5WzI4XSAmIDB4ZmYgfCAoa2V5WzI5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzddID0ga2V5WzMwXSAmIDB4ZmYgfCAoa2V5WzMxXSAmIDB4ZmYpIDw8IDg7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGhpYml0ID0gdGhpcy5maW4gPyAwIDogKDEgPDwgMTEpO1xuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3LCBjO1xuICB2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDk7XG5cbiAgdmFyIGgwID0gdGhpcy5oWzBdLFxuICAgICAgaDEgPSB0aGlzLmhbMV0sXG4gICAgICBoMiA9IHRoaXMuaFsyXSxcbiAgICAgIGgzID0gdGhpcy5oWzNdLFxuICAgICAgaDQgPSB0aGlzLmhbNF0sXG4gICAgICBoNSA9IHRoaXMuaFs1XSxcbiAgICAgIGg2ID0gdGhpcy5oWzZdLFxuICAgICAgaDcgPSB0aGlzLmhbN10sXG4gICAgICBoOCA9IHRoaXMuaFs4XSxcbiAgICAgIGg5ID0gdGhpcy5oWzldO1xuXG4gIHZhciByMCA9IHRoaXMuclswXSxcbiAgICAgIHIxID0gdGhpcy5yWzFdLFxuICAgICAgcjIgPSB0aGlzLnJbMl0sXG4gICAgICByMyA9IHRoaXMuclszXSxcbiAgICAgIHI0ID0gdGhpcy5yWzRdLFxuICAgICAgcjUgPSB0aGlzLnJbNV0sXG4gICAgICByNiA9IHRoaXMucls2XSxcbiAgICAgIHI3ID0gdGhpcy5yWzddLFxuICAgICAgcjggPSB0aGlzLnJbOF0sXG4gICAgICByOSA9IHRoaXMucls5XTtcblxuICB3aGlsZSAoYnl0ZXMgPj0gMTYpIHtcbiAgICB0MCA9IG1bbXBvcysgMF0gJiAweGZmIHwgKG1bbXBvcysgMV0gJiAweGZmKSA8PCA4OyBoMCArPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgICB0MSA9IG1bbXBvcysgMl0gJiAweGZmIHwgKG1bbXBvcysgM10gJiAweGZmKSA8PCA4OyBoMSArPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgICB0MiA9IG1bbXBvcysgNF0gJiAweGZmIHwgKG1bbXBvcysgNV0gJiAweGZmKSA8PCA4OyBoMiArPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWZmZjtcbiAgICB0MyA9IG1bbXBvcysgNl0gJiAweGZmIHwgKG1bbXBvcysgN10gJiAweGZmKSA8PCA4OyBoMyArPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgICB0NCA9IG1bbXBvcysgOF0gJiAweGZmIHwgKG1bbXBvcysgOV0gJiAweGZmKSA8PCA4OyBoNCArPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZjtcbiAgICBoNSArPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZmO1xuICAgIHQ1ID0gbVttcG9zKzEwXSAmIDB4ZmYgfCAobVttcG9zKzExXSAmIDB4ZmYpIDw8IDg7IGg2ICs9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICAgIHQ2ID0gbVttcG9zKzEyXSAmIDB4ZmYgfCAobVttcG9zKzEzXSAmIDB4ZmYpIDw8IDg7IGg3ICs9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZmZmO1xuICAgIHQ3ID0gbVttcG9zKzE0XSAmIDB4ZmYgfCAobVttcG9zKzE1XSAmIDB4ZmYpIDw8IDg7IGg4ICs9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICAgIGg5ICs9ICgodDcgPj4+IDUpKSB8IGhpYml0O1xuXG4gICAgYyA9IDA7XG5cbiAgICBkMCA9IGM7XG4gICAgZDAgKz0gaDAgKiByMDtcbiAgICBkMCArPSBoMSAqICg1ICogcjkpO1xuICAgIGQwICs9IGgyICogKDUgKiByOCk7XG4gICAgZDAgKz0gaDMgKiAoNSAqIHI3KTtcbiAgICBkMCArPSBoNCAqICg1ICogcjYpO1xuICAgIGMgPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuICAgIGQwICs9IGg1ICogKDUgKiByNSk7XG4gICAgZDAgKz0gaDYgKiAoNSAqIHI0KTtcbiAgICBkMCArPSBoNyAqICg1ICogcjMpO1xuICAgIGQwICs9IGg4ICogKDUgKiByMik7XG4gICAgZDAgKz0gaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG5cbiAgICBkMSA9IGM7XG4gICAgZDEgKz0gaDAgKiByMTtcbiAgICBkMSArPSBoMSAqIHIwO1xuICAgIGQxICs9IGgyICogKDUgKiByOSk7XG4gICAgZDEgKz0gaDMgKiAoNSAqIHI4KTtcbiAgICBkMSArPSBoNCAqICg1ICogcjcpO1xuICAgIGMgPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuICAgIGQxICs9IGg1ICogKDUgKiByNik7XG4gICAgZDEgKz0gaDYgKiAoNSAqIHI1KTtcbiAgICBkMSArPSBoNyAqICg1ICogcjQpO1xuICAgIGQxICs9IGg4ICogKDUgKiByMyk7XG4gICAgZDEgKz0gaDkgKiAoNSAqIHIyKTtcbiAgICBjICs9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG5cbiAgICBkMiA9IGM7XG4gICAgZDIgKz0gaDAgKiByMjtcbiAgICBkMiArPSBoMSAqIHIxO1xuICAgIGQyICs9IGgyICogcjA7XG4gICAgZDIgKz0gaDMgKiAoNSAqIHI5KTtcbiAgICBkMiArPSBoNCAqICg1ICogcjgpO1xuICAgIGMgPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNyk7XG4gICAgZDIgKz0gaDYgKiAoNSAqIHI2KTtcbiAgICBkMiArPSBoNyAqICg1ICogcjUpO1xuICAgIGQyICs9IGg4ICogKDUgKiByNCk7XG4gICAgZDIgKz0gaDkgKiAoNSAqIHIzKTtcbiAgICBjICs9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG5cbiAgICBkMyA9IGM7XG4gICAgZDMgKz0gaDAgKiByMztcbiAgICBkMyArPSBoMSAqIHIyO1xuICAgIGQzICs9IGgyICogcjE7XG4gICAgZDMgKz0gaDMgKiByMDtcbiAgICBkMyArPSBoNCAqICg1ICogcjkpO1xuICAgIGMgPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuICAgIGQzICs9IGg1ICogKDUgKiByOCk7XG4gICAgZDMgKz0gaDYgKiAoNSAqIHI3KTtcbiAgICBkMyArPSBoNyAqICg1ICogcjYpO1xuICAgIGQzICs9IGg4ICogKDUgKiByNSk7XG4gICAgZDMgKz0gaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG5cbiAgICBkNCA9IGM7XG4gICAgZDQgKz0gaDAgKiByNDtcbiAgICBkNCArPSBoMSAqIHIzO1xuICAgIGQ0ICs9IGgyICogcjI7XG4gICAgZDQgKz0gaDMgKiByMTtcbiAgICBkNCArPSBoNCAqIHIwO1xuICAgIGMgPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuICAgIGQ0ICs9IGg1ICogKDUgKiByOSk7XG4gICAgZDQgKz0gaDYgKiAoNSAqIHI4KTtcbiAgICBkNCArPSBoNyAqICg1ICogcjcpO1xuICAgIGQ0ICs9IGg4ICogKDUgKiByNik7XG4gICAgZDQgKz0gaDkgKiAoNSAqIHI1KTtcbiAgICBjICs9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG5cbiAgICBkNSA9IGM7XG4gICAgZDUgKz0gaDAgKiByNTtcbiAgICBkNSArPSBoMSAqIHI0O1xuICAgIGQ1ICs9IGgyICogcjM7XG4gICAgZDUgKz0gaDMgKiByMjtcbiAgICBkNSArPSBoNCAqIHIxO1xuICAgIGMgPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjA7XG4gICAgZDUgKz0gaDYgKiAoNSAqIHI5KTtcbiAgICBkNSArPSBoNyAqICg1ICogcjgpO1xuICAgIGQ1ICs9IGg4ICogKDUgKiByNyk7XG4gICAgZDUgKz0gaDkgKiAoNSAqIHI2KTtcbiAgICBjICs9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG5cbiAgICBkNiA9IGM7XG4gICAgZDYgKz0gaDAgKiByNjtcbiAgICBkNiArPSBoMSAqIHI1O1xuICAgIGQ2ICs9IGgyICogcjQ7XG4gICAgZDYgKz0gaDMgKiByMztcbiAgICBkNiArPSBoNCAqIHIyO1xuICAgIGMgPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuICAgIGQ2ICs9IGg1ICogcjE7XG4gICAgZDYgKz0gaDYgKiByMDtcbiAgICBkNiArPSBoNyAqICg1ICogcjkpO1xuICAgIGQ2ICs9IGg4ICogKDUgKiByOCk7XG4gICAgZDYgKz0gaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG5cbiAgICBkNyA9IGM7XG4gICAgZDcgKz0gaDAgKiByNztcbiAgICBkNyArPSBoMSAqIHI2O1xuICAgIGQ3ICs9IGgyICogcjU7XG4gICAgZDcgKz0gaDMgKiByNDtcbiAgICBkNyArPSBoNCAqIHIzO1xuICAgIGMgPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuICAgIGQ3ICs9IGg1ICogcjI7XG4gICAgZDcgKz0gaDYgKiByMTtcbiAgICBkNyArPSBoNyAqIHIwO1xuICAgIGQ3ICs9IGg4ICogKDUgKiByOSk7XG4gICAgZDcgKz0gaDkgKiAoNSAqIHI4KTtcbiAgICBjICs9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG5cbiAgICBkOCA9IGM7XG4gICAgZDggKz0gaDAgKiByODtcbiAgICBkOCArPSBoMSAqIHI3O1xuICAgIGQ4ICs9IGgyICogcjY7XG4gICAgZDggKz0gaDMgKiByNTtcbiAgICBkOCArPSBoNCAqIHI0O1xuICAgIGMgPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjM7XG4gICAgZDggKz0gaDYgKiByMjtcbiAgICBkOCArPSBoNyAqIHIxO1xuICAgIGQ4ICs9IGg4ICogcjA7XG4gICAgZDggKz0gaDkgKiAoNSAqIHI5KTtcbiAgICBjICs9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG5cbiAgICBkOSA9IGM7XG4gICAgZDkgKz0gaDAgKiByOTtcbiAgICBkOSArPSBoMSAqIHI4O1xuICAgIGQ5ICs9IGgyICogcjc7XG4gICAgZDkgKz0gaDMgKiByNjtcbiAgICBkOSArPSBoNCAqIHI1O1xuICAgIGMgPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuICAgIGQ5ICs9IGg1ICogcjQ7XG4gICAgZDkgKz0gaDYgKiByMztcbiAgICBkOSArPSBoNyAqIHIyO1xuICAgIGQ5ICs9IGg4ICogcjE7XG4gICAgZDkgKz0gaDkgKiByMDtcbiAgICBjICs9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKCgoYyA8PCAyKSArIGMpKSB8IDA7XG4gICAgYyA9IChjICsgZDApIHwgMDtcbiAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgYyA9IChjID4+PiAxMyk7XG4gICAgZDEgKz0gYztcblxuICAgIGgwID0gZDA7XG4gICAgaDEgPSBkMTtcbiAgICBoMiA9IGQyO1xuICAgIGgzID0gZDM7XG4gICAgaDQgPSBkNDtcbiAgICBoNSA9IGQ1O1xuICAgIGg2ID0gZDY7XG4gICAgaDcgPSBkNztcbiAgICBoOCA9IGQ4O1xuICAgIGg5ID0gZDk7XG5cbiAgICBtcG9zICs9IDE2O1xuICAgIGJ5dGVzIC09IDE2O1xuICB9XG4gIHRoaXMuaFswXSA9IGgwO1xuICB0aGlzLmhbMV0gPSBoMTtcbiAgdGhpcy5oWzJdID0gaDI7XG4gIHRoaXMuaFszXSA9IGgzO1xuICB0aGlzLmhbNF0gPSBoNDtcbiAgdGhpcy5oWzVdID0gaDU7XG4gIHRoaXMuaFs2XSA9IGg2O1xuICB0aGlzLmhbN10gPSBoNztcbiAgdGhpcy5oWzhdID0gaDg7XG4gIHRoaXMuaFs5XSA9IGg5O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKG1hYywgbWFjcG9zKSB7XG4gIHZhciBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdmFyIGMsIG1hc2ssIGYsIGk7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICBpID0gdGhpcy5sZWZ0b3ZlcjtcbiAgICB0aGlzLmJ1ZmZlcltpKytdID0gMTtcbiAgICBmb3IgKDsgaSA8IDE2OyBpKyspIHRoaXMuYnVmZmVyW2ldID0gMDtcbiAgICB0aGlzLmZpbiA9IDE7XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgfVxuXG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgIHRoaXMuaFtpXSArPSBjO1xuICAgIGMgPSB0aGlzLmhbaV0gPj4+IDEzO1xuICAgIHRoaXMuaFtpXSAmPSAweDFmZmY7XG4gIH1cbiAgdGhpcy5oWzBdICs9IChjICogNSk7XG4gIGMgPSB0aGlzLmhbMF0gPj4+IDEzO1xuICB0aGlzLmhbMF0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMV0gKz0gYztcbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsyXSArPSBjO1xuXG4gIGdbMF0gPSB0aGlzLmhbMF0gKyA1O1xuICBjID0gZ1swXSA+Pj4gMTM7XG4gIGdbMF0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgIGdbaV0gPSB0aGlzLmhbaV0gKyBjO1xuICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICBnW2ldICY9IDB4MWZmZjtcbiAgfVxuICBnWzldIC09ICgxIDw8IDEzKTtcblxuICBtYXNrID0gKGMgXiAxKSAtIDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSBnW2ldICY9IG1hc2s7XG4gIG1hc2sgPSB+bWFzaztcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHRoaXMuaFtpXSA9ICh0aGlzLmhbaV0gJiBtYXNrKSB8IGdbaV07XG5cbiAgdGhpcy5oWzBdID0gKCh0aGlzLmhbMF0gICAgICAgKSB8ICh0aGlzLmhbMV0gPDwgMTMpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMV0gPSAoKHRoaXMuaFsxXSA+Pj4gIDMpIHwgKHRoaXMuaFsyXSA8PCAxMCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsyXSA9ICgodGhpcy5oWzJdID4+PiAgNikgfCAodGhpcy5oWzNdIDw8ICA3KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzNdID0gKCh0aGlzLmhbM10gPj4+ICA5KSB8ICh0aGlzLmhbNF0gPDwgIDQpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNF0gPSAoKHRoaXMuaFs0XSA+Pj4gMTIpIHwgKHRoaXMuaFs1XSA8PCAgMSkgfCAodGhpcy5oWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gIHRoaXMuaFs1XSA9ICgodGhpcy5oWzZdID4+PiAgMikgfCAodGhpcy5oWzddIDw8IDExKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzZdID0gKCh0aGlzLmhbN10gPj4+ICA1KSB8ICh0aGlzLmhbOF0gPDwgIDgpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbN10gPSAoKHRoaXMuaFs4XSA+Pj4gIDgpIHwgKHRoaXMuaFs5XSA8PCAgNSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG5cbiAgZiA9IHRoaXMuaFswXSArIHRoaXMucGFkWzBdO1xuICB0aGlzLmhbMF0gPSBmICYgMHhmZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgZiA9ICgoKHRoaXMuaFtpXSArIHRoaXMucGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgIHRoaXMuaFtpXSA9IGYgJiAweGZmZmY7XG4gIH1cblxuICBtYWNbbWFjcG9zKyAwXSA9ICh0aGlzLmhbMF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMV0gPSAodGhpcy5oWzBdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDJdID0gKHRoaXMuaFsxXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAzXSA9ICh0aGlzLmhbMV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNF0gPSAodGhpcy5oWzJdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDVdID0gKHRoaXMuaFsyXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA2XSA9ICh0aGlzLmhbM10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgN10gPSAodGhpcy5oWzNdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDhdID0gKHRoaXMuaFs0XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA5XSA9ICh0aGlzLmhbNF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMF0gPSAodGhpcy5oWzVdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTFdID0gKHRoaXMuaFs1XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEyXSA9ICh0aGlzLmhbNl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxM10gPSAodGhpcy5oWzZdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTRdID0gKHRoaXMuaFs3XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE1XSA9ICh0aGlzLmhbN10gPj4+IDgpICYgMHhmZjtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaSwgd2FudDtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIHdhbnQgPSAoMTYgLSB0aGlzLmxlZnRvdmVyKTtcbiAgICBpZiAod2FudCA+IGJ5dGVzKVxuICAgICAgd2FudCA9IGJ5dGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YW50OyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgdGhpcy5sZWZ0b3ZlciArPSB3YW50O1xuICAgIGlmICh0aGlzLmxlZnRvdmVyIDwgMTYpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgfVxuXG4gIGlmIChieXRlcyA+PSAxNikge1xuICAgIHdhbnQgPSBieXRlcyAtIChieXRlcyAlIDE2KTtcbiAgICB0aGlzLmJsb2NrcyhtLCBtcG9zLCB3YW50KTtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgfVxuXG4gIGlmIChieXRlcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIHRoaXMubGVmdG92ZXIgKz0gYnl0ZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aChvdXQsIG91dHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgcyA9IG5ldyBwb2x5MTMwNShrKTtcbiAgcy51cGRhdGUobSwgbXBvcywgbik7XG4gIHMuZmluaXNoKG91dCwgb3V0cG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoaCwgaHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKHgsMCxtLG1wb3MsbixrKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCxocG9zLHgsMCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYyxtLGQsbixrKSB7XG4gIHZhciBpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKGMsMCxtLDAsZCxuLGspO1xuICBjcnlwdG9fb25ldGltZWF1dGgoYywgMTYsIGMsIDMyLCBkIC0gMzIsIGMpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgY1tpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW4obSxjLGQsbixrKSB7XG4gIHZhciBpO1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtKHgsMCwzMixuLGspO1xuICBpZiAoY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShjLCAxNixjLCAzMixkIC0gMzIseCkgIT09IDApIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IobSwwLGMsMCxkLG4sayk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHNldDI1NTE5KHIsIGEpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSByW2ldID0gYVtpXXwwO1xufVxuXG5mdW5jdGlvbiBjYXIyNTUxOShvKSB7XG4gIHZhciBpLCB2LCBjID0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2ID0gb1tpXSArIGMgKyA2NTUzNTtcbiAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgIG9baV0gPSB2IC0gYyAqIDY1NTM2O1xuICB9XG4gIG9bMF0gKz0gYy0xICsgMzcgKiAoYy0xKTtcbn1cblxuZnVuY3Rpb24gc2VsMjU1MTkocCwgcSwgYikge1xuICB2YXIgdCwgYyA9IH4oYi0xKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgIHBbaV0gXj0gdDtcbiAgICBxW2ldIF49IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGI7XG4gIHZhciBtID0gZ2YoKSwgdCA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB0W2ldID0gbltpXTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgZm9yIChqID0gMDsgaiA8IDI7IGorKykge1xuICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgIGZvciAoaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtICgobVtpLTFdPj4xNikgJiAxKTtcbiAgICAgIG1baS0xXSAmPSAweGZmZmY7XG4gICAgfVxuICAgIG1bMTVdID0gdFsxNV0gLSAweDdmZmYgLSAoKG1bMTRdPj4xNikgJiAxKTtcbiAgICBiID0gKG1bMTVdPj4xNikgJiAxO1xuICAgIG1bMTRdICY9IDB4ZmZmZjtcbiAgICBzZWwyNTUxOSh0LCBtLCAxLWIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgb1syKmldID0gdFtpXSAmIDB4ZmY7XG4gICAgb1syKmkrMV0gPSB0W2ldPj44O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgzMiksIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShjLCBhKTtcbiAgcGFjazI1NTE5KGQsIGIpO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbn1cblxuZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGQsIGEpO1xuICByZXR1cm4gZFswXSAmIDE7XG59XG5cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gblsyKmldICsgKG5bMippKzFdIDw8IDgpO1xuICBvWzE1XSAmPSAweDdmZmY7XG59XG5cbmZ1bmN0aW9uIEEobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldICsgYltpXTtcbn1cblxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gLSBiW2ldO1xufVxuXG5mdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgdmFyIHYsIGMsXG4gICAgIHQwID0gMCwgIHQxID0gMCwgIHQyID0gMCwgIHQzID0gMCwgIHQ0ID0gMCwgIHQ1ID0gMCwgIHQ2ID0gMCwgIHQ3ID0gMCxcbiAgICAgdDggPSAwLCAgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLFxuICAgIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsXG4gICAgdDI0ID0gMCwgdDI1ID0gMCwgdDI2ID0gMCwgdDI3ID0gMCwgdDI4ID0gMCwgdDI5ID0gMCwgdDMwID0gMCxcbiAgICBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM10sXG4gICAgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddLFxuICAgIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV0sXG4gICAgYjEyID0gYlsxMl0sXG4gICAgYjEzID0gYlsxM10sXG4gICAgYjE0ID0gYlsxNF0sXG4gICAgYjE1ID0gYlsxNV07XG5cbiAgdiA9IGFbMF07XG4gIHQwICs9IHYgKiBiMDtcbiAgdDEgKz0gdiAqIGIxO1xuICB0MiArPSB2ICogYjI7XG4gIHQzICs9IHYgKiBiMztcbiAgdDQgKz0gdiAqIGI0O1xuICB0NSArPSB2ICogYjU7XG4gIHQ2ICs9IHYgKiBiNjtcbiAgdDcgKz0gdiAqIGI3O1xuICB0OCArPSB2ICogYjg7XG4gIHQ5ICs9IHYgKiBiOTtcbiAgdDEwICs9IHYgKiBiMTA7XG4gIHQxMSArPSB2ICogYjExO1xuICB0MTIgKz0gdiAqIGIxMjtcbiAgdDEzICs9IHYgKiBiMTM7XG4gIHQxNCArPSB2ICogYjE0O1xuICB0MTUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMV07XG4gIHQxICs9IHYgKiBiMDtcbiAgdDIgKz0gdiAqIGIxO1xuICB0MyArPSB2ICogYjI7XG4gIHQ0ICs9IHYgKiBiMztcbiAgdDUgKz0gdiAqIGI0O1xuICB0NiArPSB2ICogYjU7XG4gIHQ3ICs9IHYgKiBiNjtcbiAgdDggKz0gdiAqIGI3O1xuICB0OSArPSB2ICogYjg7XG4gIHQxMCArPSB2ICogYjk7XG4gIHQxMSArPSB2ICogYjEwO1xuICB0MTIgKz0gdiAqIGIxMTtcbiAgdDEzICs9IHYgKiBiMTI7XG4gIHQxNCArPSB2ICogYjEzO1xuICB0MTUgKz0gdiAqIGIxNDtcbiAgdDE2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzJdO1xuICB0MiArPSB2ICogYjA7XG4gIHQzICs9IHYgKiBiMTtcbiAgdDQgKz0gdiAqIGIyO1xuICB0NSArPSB2ICogYjM7XG4gIHQ2ICs9IHYgKiBiNDtcbiAgdDcgKz0gdiAqIGI1O1xuICB0OCArPSB2ICogYjY7XG4gIHQ5ICs9IHYgKiBiNztcbiAgdDEwICs9IHYgKiBiODtcbiAgdDExICs9IHYgKiBiOTtcbiAgdDEyICs9IHYgKiBiMTA7XG4gIHQxMyArPSB2ICogYjExO1xuICB0MTQgKz0gdiAqIGIxMjtcbiAgdDE1ICs9IHYgKiBiMTM7XG4gIHQxNiArPSB2ICogYjE0O1xuICB0MTcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbM107XG4gIHQzICs9IHYgKiBiMDtcbiAgdDQgKz0gdiAqIGIxO1xuICB0NSArPSB2ICogYjI7XG4gIHQ2ICs9IHYgKiBiMztcbiAgdDcgKz0gdiAqIGI0O1xuICB0OCArPSB2ICogYjU7XG4gIHQ5ICs9IHYgKiBiNjtcbiAgdDEwICs9IHYgKiBiNztcbiAgdDExICs9IHYgKiBiODtcbiAgdDEyICs9IHYgKiBiOTtcbiAgdDEzICs9IHYgKiBiMTA7XG4gIHQxNCArPSB2ICogYjExO1xuICB0MTUgKz0gdiAqIGIxMjtcbiAgdDE2ICs9IHYgKiBiMTM7XG4gIHQxNyArPSB2ICogYjE0O1xuICB0MTggKz0gdiAqIGIxNTtcbiAgdiA9IGFbNF07XG4gIHQ0ICs9IHYgKiBiMDtcbiAgdDUgKz0gdiAqIGIxO1xuICB0NiArPSB2ICogYjI7XG4gIHQ3ICs9IHYgKiBiMztcbiAgdDggKz0gdiAqIGI0O1xuICB0OSArPSB2ICogYjU7XG4gIHQxMCArPSB2ICogYjY7XG4gIHQxMSArPSB2ICogYjc7XG4gIHQxMiArPSB2ICogYjg7XG4gIHQxMyArPSB2ICogYjk7XG4gIHQxNCArPSB2ICogYjEwO1xuICB0MTUgKz0gdiAqIGIxMTtcbiAgdDE2ICs9IHYgKiBiMTI7XG4gIHQxNyArPSB2ICogYjEzO1xuICB0MTggKz0gdiAqIGIxNDtcbiAgdDE5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzVdO1xuICB0NSArPSB2ICogYjA7XG4gIHQ2ICs9IHYgKiBiMTtcbiAgdDcgKz0gdiAqIGIyO1xuICB0OCArPSB2ICogYjM7XG4gIHQ5ICs9IHYgKiBiNDtcbiAgdDEwICs9IHYgKiBiNTtcbiAgdDExICs9IHYgKiBiNjtcbiAgdDEyICs9IHYgKiBiNztcbiAgdDEzICs9IHYgKiBiODtcbiAgdDE0ICs9IHYgKiBiOTtcbiAgdDE1ICs9IHYgKiBiMTA7XG4gIHQxNiArPSB2ICogYjExO1xuICB0MTcgKz0gdiAqIGIxMjtcbiAgdDE4ICs9IHYgKiBiMTM7XG4gIHQxOSArPSB2ICogYjE0O1xuICB0MjAgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNl07XG4gIHQ2ICs9IHYgKiBiMDtcbiAgdDcgKz0gdiAqIGIxO1xuICB0OCArPSB2ICogYjI7XG4gIHQ5ICs9IHYgKiBiMztcbiAgdDEwICs9IHYgKiBiNDtcbiAgdDExICs9IHYgKiBiNTtcbiAgdDEyICs9IHYgKiBiNjtcbiAgdDEzICs9IHYgKiBiNztcbiAgdDE0ICs9IHYgKiBiODtcbiAgdDE1ICs9IHYgKiBiOTtcbiAgdDE2ICs9IHYgKiBiMTA7XG4gIHQxNyArPSB2ICogYjExO1xuICB0MTggKz0gdiAqIGIxMjtcbiAgdDE5ICs9IHYgKiBiMTM7XG4gIHQyMCArPSB2ICogYjE0O1xuICB0MjEgKz0gdiAqIGIxNTtcbiAgdiA9IGFbN107XG4gIHQ3ICs9IHYgKiBiMDtcbiAgdDggKz0gdiAqIGIxO1xuICB0OSArPSB2ICogYjI7XG4gIHQxMCArPSB2ICogYjM7XG4gIHQxMSArPSB2ICogYjQ7XG4gIHQxMiArPSB2ICogYjU7XG4gIHQxMyArPSB2ICogYjY7XG4gIHQxNCArPSB2ICogYjc7XG4gIHQxNSArPSB2ICogYjg7XG4gIHQxNiArPSB2ICogYjk7XG4gIHQxNyArPSB2ICogYjEwO1xuICB0MTggKz0gdiAqIGIxMTtcbiAgdDE5ICs9IHYgKiBiMTI7XG4gIHQyMCArPSB2ICogYjEzO1xuICB0MjEgKz0gdiAqIGIxNDtcbiAgdDIyICs9IHYgKiBiMTU7XG4gIHYgPSBhWzhdO1xuICB0OCArPSB2ICogYjA7XG4gIHQ5ICs9IHYgKiBiMTtcbiAgdDEwICs9IHYgKiBiMjtcbiAgdDExICs9IHYgKiBiMztcbiAgdDEyICs9IHYgKiBiNDtcbiAgdDEzICs9IHYgKiBiNTtcbiAgdDE0ICs9IHYgKiBiNjtcbiAgdDE1ICs9IHYgKiBiNztcbiAgdDE2ICs9IHYgKiBiODtcbiAgdDE3ICs9IHYgKiBiOTtcbiAgdDE4ICs9IHYgKiBiMTA7XG4gIHQxOSArPSB2ICogYjExO1xuICB0MjAgKz0gdiAqIGIxMjtcbiAgdDIxICs9IHYgKiBiMTM7XG4gIHQyMiArPSB2ICogYjE0O1xuICB0MjMgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOV07XG4gIHQ5ICs9IHYgKiBiMDtcbiAgdDEwICs9IHYgKiBiMTtcbiAgdDExICs9IHYgKiBiMjtcbiAgdDEyICs9IHYgKiBiMztcbiAgdDEzICs9IHYgKiBiNDtcbiAgdDE0ICs9IHYgKiBiNTtcbiAgdDE1ICs9IHYgKiBiNjtcbiAgdDE2ICs9IHYgKiBiNztcbiAgdDE3ICs9IHYgKiBiODtcbiAgdDE4ICs9IHYgKiBiOTtcbiAgdDE5ICs9IHYgKiBiMTA7XG4gIHQyMCArPSB2ICogYjExO1xuICB0MjEgKz0gdiAqIGIxMjtcbiAgdDIyICs9IHYgKiBiMTM7XG4gIHQyMyArPSB2ICogYjE0O1xuICB0MjQgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTBdO1xuICB0MTAgKz0gdiAqIGIwO1xuICB0MTEgKz0gdiAqIGIxO1xuICB0MTIgKz0gdiAqIGIyO1xuICB0MTMgKz0gdiAqIGIzO1xuICB0MTQgKz0gdiAqIGI0O1xuICB0MTUgKz0gdiAqIGI1O1xuICB0MTYgKz0gdiAqIGI2O1xuICB0MTcgKz0gdiAqIGI3O1xuICB0MTggKz0gdiAqIGI4O1xuICB0MTkgKz0gdiAqIGI5O1xuICB0MjAgKz0gdiAqIGIxMDtcbiAgdDIxICs9IHYgKiBiMTE7XG4gIHQyMiArPSB2ICogYjEyO1xuICB0MjMgKz0gdiAqIGIxMztcbiAgdDI0ICs9IHYgKiBiMTQ7XG4gIHQyNSArPSB2ICogYjE1O1xuICB2ID0gYVsxMV07XG4gIHQxMSArPSB2ICogYjA7XG4gIHQxMiArPSB2ICogYjE7XG4gIHQxMyArPSB2ICogYjI7XG4gIHQxNCArPSB2ICogYjM7XG4gIHQxNSArPSB2ICogYjQ7XG4gIHQxNiArPSB2ICogYjU7XG4gIHQxNyArPSB2ICogYjY7XG4gIHQxOCArPSB2ICogYjc7XG4gIHQxOSArPSB2ICogYjg7XG4gIHQyMCArPSB2ICogYjk7XG4gIHQyMSArPSB2ICogYjEwO1xuICB0MjIgKz0gdiAqIGIxMTtcbiAgdDIzICs9IHYgKiBiMTI7XG4gIHQyNCArPSB2ICogYjEzO1xuICB0MjUgKz0gdiAqIGIxNDtcbiAgdDI2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEyXTtcbiAgdDEyICs9IHYgKiBiMDtcbiAgdDEzICs9IHYgKiBiMTtcbiAgdDE0ICs9IHYgKiBiMjtcbiAgdDE1ICs9IHYgKiBiMztcbiAgdDE2ICs9IHYgKiBiNDtcbiAgdDE3ICs9IHYgKiBiNTtcbiAgdDE4ICs9IHYgKiBiNjtcbiAgdDE5ICs9IHYgKiBiNztcbiAgdDIwICs9IHYgKiBiODtcbiAgdDIxICs9IHYgKiBiOTtcbiAgdDIyICs9IHYgKiBiMTA7XG4gIHQyMyArPSB2ICogYjExO1xuICB0MjQgKz0gdiAqIGIxMjtcbiAgdDI1ICs9IHYgKiBiMTM7XG4gIHQyNiArPSB2ICogYjE0O1xuICB0MjcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTNdO1xuICB0MTMgKz0gdiAqIGIwO1xuICB0MTQgKz0gdiAqIGIxO1xuICB0MTUgKz0gdiAqIGIyO1xuICB0MTYgKz0gdiAqIGIzO1xuICB0MTcgKz0gdiAqIGI0O1xuICB0MTggKz0gdiAqIGI1O1xuICB0MTkgKz0gdiAqIGI2O1xuICB0MjAgKz0gdiAqIGI3O1xuICB0MjEgKz0gdiAqIGI4O1xuICB0MjIgKz0gdiAqIGI5O1xuICB0MjMgKz0gdiAqIGIxMDtcbiAgdDI0ICs9IHYgKiBiMTE7XG4gIHQyNSArPSB2ICogYjEyO1xuICB0MjYgKz0gdiAqIGIxMztcbiAgdDI3ICs9IHYgKiBiMTQ7XG4gIHQyOCArPSB2ICogYjE1O1xuICB2ID0gYVsxNF07XG4gIHQxNCArPSB2ICogYjA7XG4gIHQxNSArPSB2ICogYjE7XG4gIHQxNiArPSB2ICogYjI7XG4gIHQxNyArPSB2ICogYjM7XG4gIHQxOCArPSB2ICogYjQ7XG4gIHQxOSArPSB2ICogYjU7XG4gIHQyMCArPSB2ICogYjY7XG4gIHQyMSArPSB2ICogYjc7XG4gIHQyMiArPSB2ICogYjg7XG4gIHQyMyArPSB2ICogYjk7XG4gIHQyNCArPSB2ICogYjEwO1xuICB0MjUgKz0gdiAqIGIxMTtcbiAgdDI2ICs9IHYgKiBiMTI7XG4gIHQyNyArPSB2ICogYjEzO1xuICB0MjggKz0gdiAqIGIxNDtcbiAgdDI5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE1XTtcbiAgdDE1ICs9IHYgKiBiMDtcbiAgdDE2ICs9IHYgKiBiMTtcbiAgdDE3ICs9IHYgKiBiMjtcbiAgdDE4ICs9IHYgKiBiMztcbiAgdDE5ICs9IHYgKiBiNDtcbiAgdDIwICs9IHYgKiBiNTtcbiAgdDIxICs9IHYgKiBiNjtcbiAgdDIyICs9IHYgKiBiNztcbiAgdDIzICs9IHYgKiBiODtcbiAgdDI0ICs9IHYgKiBiOTtcbiAgdDI1ICs9IHYgKiBiMTA7XG4gIHQyNiArPSB2ICogYjExO1xuICB0MjcgKz0gdiAqIGIxMjtcbiAgdDI4ICs9IHYgKiBiMTM7XG4gIHQyOSArPSB2ICogYjE0O1xuICB0MzAgKz0gdiAqIGIxNTtcblxuICB0MCAgKz0gMzggKiB0MTY7XG4gIHQxICArPSAzOCAqIHQxNztcbiAgdDIgICs9IDM4ICogdDE4O1xuICB0MyAgKz0gMzggKiB0MTk7XG4gIHQ0ICArPSAzOCAqIHQyMDtcbiAgdDUgICs9IDM4ICogdDIxO1xuICB0NiAgKz0gMzggKiB0MjI7XG4gIHQ3ICArPSAzOCAqIHQyMztcbiAgdDggICs9IDM4ICogdDI0O1xuICB0OSAgKz0gMzggKiB0MjU7XG4gIHQxMCArPSAzOCAqIHQyNjtcbiAgdDExICs9IDM4ICogdDI3O1xuICB0MTIgKz0gMzggKiB0Mjg7XG4gIHQxMyArPSAzOCAqIHQyOTtcbiAgdDE0ICs9IDM4ICogdDMwO1xuICAvLyB0MTUgbGVmdCBhcyBpc1xuXG4gIC8vIGZpcnN0IGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIG9bIDBdID0gdDA7XG4gIG9bIDFdID0gdDE7XG4gIG9bIDJdID0gdDI7XG4gIG9bIDNdID0gdDM7XG4gIG9bIDRdID0gdDQ7XG4gIG9bIDVdID0gdDU7XG4gIG9bIDZdID0gdDY7XG4gIG9bIDddID0gdDc7XG4gIG9bIDhdID0gdDg7XG4gIG9bIDldID0gdDk7XG4gIG9bMTBdID0gdDEwO1xuICBvWzExXSA9IHQxMTtcbiAgb1sxMl0gPSB0MTI7XG4gIG9bMTNdID0gdDEzO1xuICBvWzE0XSA9IHQxNDtcbiAgb1sxNV0gPSB0MTU7XG59XG5cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpO1xufVxuXG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUzOyBhID49IDA7IGEtLSkge1xuICAgIFMoYywgYyk7XG4gICAgaWYoYSAhPT0gMiAmJiBhICE9PSA0KSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUwOyBhID49IDA7IGEtLSkge1xuICAgICAgUyhjLCBjKTtcbiAgICAgIGlmKGEgIT09IDEpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApLCByLCBpO1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMTsgaSsrKSB6W2ldID0gbltpXTtcbiAgelszMV09KG5bMzFdJjEyNyl8NjQ7XG4gIHpbMF0mPTI0ODtcbiAgdW5wYWNrMjU1MTkoeCxwKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBiW2ldPXhbaV07XG4gICAgZFtpXT1hW2ldPWNbaV09MDtcbiAgfVxuICBhWzBdPWRbMF09MTtcbiAgZm9yIChpPTI1NDsgaT49MDsgLS1pKSB7XG4gICAgcj0oeltpPj4+M10+Pj4oaSY3KSkmMTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIEEoYyxiLGQpO1xuICAgIFooYixiLGQpO1xuICAgIFMoZCxlKTtcbiAgICBTKGYsYSk7XG4gICAgTShhLGMsYSk7XG4gICAgTShjLGIsZSk7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgUyhiLGEpO1xuICAgIFooYyxkLGYpO1xuICAgIE0oYSxjLF8xMjE2NjUpO1xuICAgIEEoYSxhLGQpO1xuICAgIE0oYyxjLGEpO1xuICAgIE0oYSxkLGYpO1xuICAgIE0oZCxiLHgpO1xuICAgIFMoYixlKTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgeFtpKzE2XT1hW2ldO1xuICAgIHhbaSszMl09Y1tpXTtcbiAgICB4W2krNDhdPWJbaV07XG4gICAgeFtpKzY0XT1kW2ldO1xuICB9XG4gIHZhciB4MzIgPSB4LnN1YmFycmF5KDMyKTtcbiAgdmFyIHgxNiA9IHguc3ViYXJyYXkoMTYpO1xuICBpbnYyNTUxOSh4MzIseDMyKTtcbiAgTSh4MTYseDE2LHgzMik7XG4gIHBhY2syNTUxOShxLHgxNik7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9rZXlwYWlyKHksIHgpIHtcbiAgcmFuZG9tYnl0ZXMoeCwgMzIpO1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHRfYmFzZSh5LCB4KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KSB7XG4gIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fc2NhbGFybXVsdChzLCB4LCB5KTtcbiAgcmV0dXJuIGNyeXB0b19jb3JlX2hzYWxzYTIwKGssIF8wLCBzLCBzaWdtYSk7XG59XG5cbnZhciBjcnlwdG9fYm94X2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94O1xudmFyIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveF9vcGVuO1xuXG5mdW5jdGlvbiBjcnlwdG9fYm94KGMsIG0sIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X2FmdGVybm0oYywgbSwgZCwgbiwgayk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfb3BlbihtLCBjLCBkLCBuLCB5LCB4KSB7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICByZXR1cm4gY3J5cHRvX2JveF9vcGVuX2FmdGVybm0obSwgYywgZCwgbiwgayk7XG59XG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pIHtcbiAgdmFyIHdoID0gbmV3IEludDMyQXJyYXkoMTYpLCB3bCA9IG5ldyBJbnQzMkFycmF5KDE2KSxcbiAgICAgIGJoMCwgYmgxLCBiaDIsIGJoMywgYmg0LCBiaDUsIGJoNiwgYmg3LFxuICAgICAgYmwwLCBibDEsIGJsMiwgYmwzLCBibDQsIGJsNSwgYmw2LCBibDcsXG4gICAgICB0aCwgdGwsIGksIGosIGgsIGwsIGEsIGIsIGMsIGQ7XG5cbiAgdmFyIGFoMCA9IGhoWzBdLFxuICAgICAgYWgxID0gaGhbMV0sXG4gICAgICBhaDIgPSBoaFsyXSxcbiAgICAgIGFoMyA9IGhoWzNdLFxuICAgICAgYWg0ID0gaGhbNF0sXG4gICAgICBhaDUgPSBoaFs1XSxcbiAgICAgIGFoNiA9IGhoWzZdLFxuICAgICAgYWg3ID0gaGhbN10sXG5cbiAgICAgIGFsMCA9IGhsWzBdLFxuICAgICAgYWwxID0gaGxbMV0sXG4gICAgICBhbDIgPSBobFsyXSxcbiAgICAgIGFsMyA9IGhsWzNdLFxuICAgICAgYWw0ID0gaGxbNF0sXG4gICAgICBhbDUgPSBobFs1XSxcbiAgICAgIGFsNiA9IGhsWzZdLFxuICAgICAgYWw3ID0gaGxbN107XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHdoaWxlIChuID49IDEyOCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBqID0gOCAqIGkgKyBwb3M7XG4gICAgICB3aFtpXSA9IChtW2orMF0gPDwgMjQpIHwgKG1baisxXSA8PCAxNikgfCAobVtqKzJdIDw8IDgpIHwgbVtqKzNdO1xuICAgICAgd2xbaV0gPSAobVtqKzRdIDw8IDI0KSB8IChtW2orNV0gPDwgMTYpIHwgKG1bais2XSA8PCA4KSB8IG1bais3XTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGJoMCA9IGFoMDtcbiAgICAgIGJoMSA9IGFoMTtcbiAgICAgIGJoMiA9IGFoMjtcbiAgICAgIGJoMyA9IGFoMztcbiAgICAgIGJoNCA9IGFoNDtcbiAgICAgIGJoNSA9IGFoNTtcbiAgICAgIGJoNiA9IGFoNjtcbiAgICAgIGJoNyA9IGFoNztcblxuICAgICAgYmwwID0gYWwwO1xuICAgICAgYmwxID0gYWwxO1xuICAgICAgYmwyID0gYWwyO1xuICAgICAgYmwzID0gYWwzO1xuICAgICAgYmw0ID0gYWw0O1xuICAgICAgYmw1ID0gYWw1O1xuICAgICAgYmw2ID0gYWw2O1xuICAgICAgYmw3ID0gYWw3O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBhaDc7XG4gICAgICBsID0gYWw3O1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWExXG4gICAgICBoID0gKChhaDQgPj4+IDE0KSB8IChhbDQgPDwgKDMyLTE0KSkpIF4gKChhaDQgPj4+IDE4KSB8IChhbDQgPDwgKDMyLTE4KSkpIF4gKChhbDQgPj4+ICg0MS0zMikpIHwgKGFoNCA8PCAoMzItKDQxLTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsNCA+Pj4gMTQpIHwgKGFoNCA8PCAoMzItMTQpKSkgXiAoKGFsNCA+Pj4gMTgpIHwgKGFoNCA8PCAoMzItMTgpKSkgXiAoKGFoNCA+Pj4gKDQxLTMyKSkgfCAoYWw0IDw8ICgzMi0oNDEtMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIENoXG4gICAgICBoID0gKGFoNCAmIGFoNSkgXiAofmFoNCAmIGFoNik7XG4gICAgICBsID0gKGFsNCAmIGFsNSkgXiAofmFsNCAmIGFsNik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gS1xuICAgICAgaCA9IEtbaSoyXTtcbiAgICAgIGwgPSBLW2kqMisxXTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyB3XG4gICAgICBoID0gd2hbaSUxNl07XG4gICAgICBsID0gd2xbaSUxNl07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICB0aCA9IGMgJiAweGZmZmYgfCBkIDw8IDE2O1xuICAgICAgdGwgPSBhICYgMHhmZmZmIHwgYiA8PCAxNjtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTBcbiAgICAgIGggPSAoKGFoMCA+Pj4gMjgpIHwgKGFsMCA8PCAoMzItMjgpKSkgXiAoKGFsMCA+Pj4gKDM0LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhbDAgPj4+ICgzOS0zMikpIHwgKGFoMCA8PCAoMzItKDM5LTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsMCA+Pj4gMjgpIHwgKGFoMCA8PCAoMzItMjgpKSkgXiAoKGFoMCA+Pj4gKDM0LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhaDAgPj4+ICgzOS0zMikpIHwgKGFsMCA8PCAoMzItKDM5LTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBNYWpcbiAgICAgIGggPSAoYWgwICYgYWgxKSBeIChhaDAgJiBhaDIpIF4gKGFoMSAmIGFoMik7XG4gICAgICBsID0gKGFsMCAmIGFsMSkgXiAoYWwwICYgYWwyKSBeIChhbDEgJiBhbDIpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBiaDM7XG4gICAgICBsID0gYmwzO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICBhaDEgPSBiaDA7XG4gICAgICBhaDIgPSBiaDE7XG4gICAgICBhaDMgPSBiaDI7XG4gICAgICBhaDQgPSBiaDM7XG4gICAgICBhaDUgPSBiaDQ7XG4gICAgICBhaDYgPSBiaDU7XG4gICAgICBhaDcgPSBiaDY7XG4gICAgICBhaDAgPSBiaDc7XG5cbiAgICAgIGFsMSA9IGJsMDtcbiAgICAgIGFsMiA9IGJsMTtcbiAgICAgIGFsMyA9IGJsMjtcbiAgICAgIGFsNCA9IGJsMztcbiAgICAgIGFsNSA9IGJsNDtcbiAgICAgIGFsNiA9IGJsNTtcbiAgICAgIGFsNyA9IGJsNjtcbiAgICAgIGFsMCA9IGJsNztcblxuICAgICAgaWYgKGklMTYgPT09IDE1KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgaCA9IHdoW2pdO1xuICAgICAgICAgIGwgPSB3bFtqXTtcblxuICAgICAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgICAgIGggPSB3aFsoais5KSUxNl07XG4gICAgICAgICAgbCA9IHdsWyhqKzkpJTE2XTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTBcbiAgICAgICAgICB0aCA9IHdoWyhqKzEpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzEpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMSkgfCAodGwgPDwgKDMyLTEpKSkgXiAoKHRoID4+PiA4KSB8ICh0bCA8PCAoMzItOCkpKSBeICh0aCA+Pj4gNyk7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDEpIHwgKHRoIDw8ICgzMi0xKSkpIF4gKCh0bCA+Pj4gOCkgfCAodGggPDwgKDMyLTgpKSkgXiAoKHRsID4+PiA3KSB8ICh0aCA8PCAoMzItNykpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTFcbiAgICAgICAgICB0aCA9IHdoWyhqKzE0KSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxNCklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxOSkgfCAodGwgPDwgKDMyLTE5KSkpIF4gKCh0bCA+Pj4gKDYxLTMyKSkgfCAodGggPDwgKDMyLSg2MS0zMikpKSkgXiAodGggPj4+IDYpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxOSkgfCAodGggPDwgKDMyLTE5KSkpIF4gKCh0aCA+Pj4gKDYxLTMyKSkgfCAodGwgPDwgKDMyLSg2MS0zMikpKSkgXiAoKHRsID4+PiA2KSB8ICh0aCA8PCAoMzItNikpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgICAgIHdoW2pdID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgICAgIHdsW2pdID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkXG4gICAgaCA9IGFoMDtcbiAgICBsID0gYWwwO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzBdO1xuICAgIGwgPSBobFswXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzBdID0gYWgwID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzBdID0gYWwwID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMTtcbiAgICBsID0gYWwxO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzFdO1xuICAgIGwgPSBobFsxXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzFdID0gYWgxID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzFdID0gYWwxID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMjtcbiAgICBsID0gYWwyO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzJdO1xuICAgIGwgPSBobFsyXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzJdID0gYWgyID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzJdID0gYWwyID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMztcbiAgICBsID0gYWwzO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzNdO1xuICAgIGwgPSBobFszXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzNdID0gYWgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzNdID0gYWwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNDtcbiAgICBsID0gYWw0O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzRdO1xuICAgIGwgPSBobFs0XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzRdID0gYWg0ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzRdID0gYWw0ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNTtcbiAgICBsID0gYWw1O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzVdO1xuICAgIGwgPSBobFs1XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzVdID0gYWg1ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzVdID0gYWw1ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNjtcbiAgICBsID0gYWw2O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzZdO1xuICAgIGwgPSBobFs2XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzZdID0gYWg2ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzZdID0gYWw2ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNztcbiAgICBsID0gYWw3O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzddO1xuICAgIGwgPSBobFs3XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzddID0gYWg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzddID0gYWw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgcG9zICs9IDEyODtcbiAgICBuIC09IDEyODtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgdmFyIGhoID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICBobCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgeCA9IG5ldyBVaW50OEFycmF5KDI1NiksXG4gICAgICBpLCBiID0gbjtcblxuICBoaFswXSA9IDB4NmEwOWU2Njc7XG4gIGhoWzFdID0gMHhiYjY3YWU4NTtcbiAgaGhbMl0gPSAweDNjNmVmMzcyO1xuICBoaFszXSA9IDB4YTU0ZmY1M2E7XG4gIGhoWzRdID0gMHg1MTBlNTI3ZjtcbiAgaGhbNV0gPSAweDliMDU2ODhjO1xuICBoaFs2XSA9IDB4MWY4M2Q5YWI7XG4gIGhoWzddID0gMHg1YmUwY2QxOTtcblxuICBobFswXSA9IDB4ZjNiY2M5MDg7XG4gIGhsWzFdID0gMHg4NGNhYTczYjtcbiAgaGxbMl0gPSAweGZlOTRmODJiO1xuICBobFszXSA9IDB4NWYxZDM2ZjE7XG4gIGhsWzRdID0gMHhhZGU2ODJkMTtcbiAgaGxbNV0gPSAweDJiM2U2YzFmO1xuICBobFs2XSA9IDB4ZmI0MWJkNmI7XG4gIGhsWzddID0gMHgxMzdlMjE3OTtcblxuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pO1xuICBuICU9IDEyODtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gbVtiLW4raV07XG4gIHhbbl0gPSAxMjg7XG5cbiAgbiA9IDI1Ni0xMjgqKG48MTEyPzE6MCk7XG4gIHhbbi05XSA9IDA7XG4gIHRzNjQoeCwgbi04LCAgKGIgLyAweDIwMDAwMDAwKSB8IDAsIGIgPDwgMyk7XG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgeCwgbik7XG5cbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgdHM2NChvdXQsIDgqaSwgaGhbaV0sIGhsW2ldKTtcblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWRkKHAsIHEpIHtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLFxuICAgICAgZyA9IGdmKCksIGggPSBnZigpLCB0ID0gZ2YoKTtcblxuICBaKGEsIHBbMV0sIHBbMF0pO1xuICBaKHQsIHFbMV0sIHFbMF0pO1xuICBNKGEsIGEsIHQpO1xuICBBKGIsIHBbMF0sIHBbMV0pO1xuICBBKHQsIHFbMF0sIHFbMV0pO1xuICBNKGIsIGIsIHQpO1xuICBNKGMsIHBbM10sIHFbM10pO1xuICBNKGMsIGMsIEQyKTtcbiAgTShkLCBwWzJdLCBxWzJdKTtcbiAgQShkLCBkLCBkKTtcbiAgWihlLCBiLCBhKTtcbiAgWihmLCBkLCBjKTtcbiAgQShnLCBkLCBjKTtcbiAgQShoLCBiLCBhKTtcblxuICBNKHBbMF0sIGUsIGYpO1xuICBNKHBbMV0sIGgsIGcpO1xuICBNKHBbMl0sIGcsIGYpO1xuICBNKHBbM10sIGUsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gIE0odHgsIHBbMF0sIHppKTtcbiAgTSh0eSwgcFsxXSwgemkpO1xuICBwYWNrMjU1MTkociwgdHkpO1xuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbn1cblxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpO1xuICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICBmb3IgKGkgPSAyNTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgYiA9IChzWyhpLzgpfDBdID4+IChpJjcpKSAmIDE7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gICAgYWRkKHEsIHApO1xuICAgIGFkZChwLCBwKTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHNldDI1NTE5KHFbMF0sIFgpO1xuICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKTtcbiAgTShxWzNdLCBYLCBZKTtcbiAgc2NhbGFybXVsdChwLCBxLCBzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHNlZWRlZCkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHZhciBpO1xuXG4gIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICBzY2FsYXJiYXNlKHAsIGQpO1xuICBwYWNrKHBrLCBwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaSszMl0gPSBwa1tpXTtcbiAgcmV0dXJuIDA7XG59XG5cbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbMHhlZCwgMHhkMywgMHhmNSwgMHg1YywgMHgxYSwgMHg2MywgMHgxMiwgMHg1OCwgMHhkNiwgMHg5YywgMHhmNywgMHhhMiwgMHhkZSwgMHhmOSwgMHhkZSwgMHgxNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgxMF0pO1xuXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrO1xuICBmb3IgKGkgPSA2MzsgaSA+PSAzMjsgLS1pKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsraikge1xuICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcigoeFtqXSArIDEyOCkgLyAyNTYpO1xuICAgICAgeFtqXSAtPSBjYXJyeSAqIDI1NjtcbiAgICB9XG4gICAgeFtqXSArPSBjYXJyeTtcbiAgICB4W2ldID0gMDtcbiAgfVxuICBjYXJyeSA9IDA7XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgeFtqXSArPSBjYXJyeSAtICh4WzMxXSA+PiA0KSAqIExbal07XG4gICAgY2FycnkgPSB4W2pdID4+IDg7XG4gICAgeFtqXSAmPSAyNTU7XG4gIH1cbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHhbal0gLT0gY2FycnkgKiBMW2pdO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHhbaSsxXSArPSB4W2ldID4+IDg7XG4gICAgcltpXSA9IHhbaV0gJiAyNTU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHIpIHtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgcltpXSA9IDA7XG4gIG1vZEwociwgeCk7XG59XG5cbi8vIE5vdGU6IGRpZmZlcmVuY2UgZnJvbSBDIC0gc21sZW4gcmV0dXJuZWQsIG5vdCBwYXNzZWQgYXMgYXJndW1lbnQuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgbiwgc2spIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBpLCBqLCB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHZhciBzbWxlbiA9IG4gKyA2NDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgc21bNjQgKyBpXSA9IG1baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBzbVszMiArIGldID0gZFszMiArIGldO1xuXG4gIGNyeXB0b19oYXNoKHIsIHNtLnN1YmFycmF5KDMyKSwgbiszMik7XG4gIHJlZHVjZShyKTtcbiAgc2NhbGFyYmFzZShwLCByKTtcbiAgcGFjayhzbSwgcCk7XG5cbiAgZm9yIChpID0gMzI7IGkgPCA2NDsgaSsrKSBzbVtpXSA9IHNrW2ldO1xuICBjcnlwdG9faGFzaChoLCBzbSwgbiArIDY0KTtcbiAgcmVkdWNlKGgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgICB4W2kral0gKz0gaFtpXSAqIGRbal07XG4gICAgfVxuICB9XG5cbiAgbW9kTChzbS5zdWJhcnJheSgzMiksIHgpO1xuICByZXR1cm4gc21sZW47XG59XG5cbmZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSxcbiAgICAgIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSxcbiAgICAgIGRlbjYgPSBnZigpO1xuXG4gIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICBTKG51bSwgclsxXSk7XG4gIE0oZGVuLCBudW0sIEQpO1xuICBaKG51bSwgbnVtLCByWzJdKTtcbiAgQShkZW4sIHJbMl0sIGRlbik7XG5cbiAgUyhkZW4yLCBkZW4pO1xuICBTKGRlbjQsIGRlbjIpO1xuICBNKGRlbjYsIGRlbjQsIGRlbjIpO1xuICBNKHQsIGRlbjYsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcblxuICBwb3cyNTIzKHQsIHQpO1xuICBNKHQsIHQsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHJbMF0sIHQsIGRlbik7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSBNKHJbMF0sIHJbMF0sIEkpO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgcmV0dXJuIC0xO1xuXG4gIGlmIChwYXIyNTUxOShyWzBdKSA9PT0gKHBbMzFdPj43KSkgWihyWzBdLCBnZjAsIHJbMF0pO1xuXG4gIE0oclszXSwgclswXSwgclsxXSk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBuLCBwaykge1xuICB2YXIgaTtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldLFxuICAgICAgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG5cbiAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiAtMTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2krMzJdID0gcGtbaV07XG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICByZWR1Y2UoaCk7XG4gIHNjYWxhcm11bHQocCwgcSwgaCk7XG5cbiAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICBhZGQocCwgcSk7XG4gIHBhY2sodCwgcCk7XG5cbiAgbiAtPSA2NDtcbiAgaWYgKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2kgKyA2NF07XG4gIHJldHVybiBuO1xufVxuXG52YXIgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyA9IDI0LFxuICAgIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgPSAxNixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gICAgY3J5cHRvX2JveF9aRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICAgIGNyeXB0b19zaWduX0JZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1NFRURCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19oYXNoX0JZVEVTID0gNjQ7XG5cbm5hY2wubG93bGV2ZWwgPSB7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwOiBjcnlwdG9fY29yZV9oc2Fsc2EyMCxcbiAgY3J5cHRvX3N0cmVhbV94b3I6IGNyeXB0b19zdHJlYW1feG9yLFxuICBjcnlwdG9fc3RyZWFtOiBjcnlwdG9fc3RyZWFtLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yLFxuICBjcnlwdG9fc3RyZWFtX3NhbHNhMjA6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMCxcbiAgY3J5cHRvX29uZXRpbWVhdXRoOiBjcnlwdG9fb25ldGltZWF1dGgsXG4gIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnk6IGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnksXG4gIGNyeXB0b192ZXJpZnlfMTY6IGNyeXB0b192ZXJpZnlfMTYsXG4gIGNyeXB0b192ZXJpZnlfMzI6IGNyeXB0b192ZXJpZnlfMzIsXG4gIGNyeXB0b19zZWNyZXRib3g6IGNyeXB0b19zZWNyZXRib3gsXG4gIGNyeXB0b19zZWNyZXRib3hfb3BlbjogY3J5cHRvX3NlY3JldGJveF9vcGVuLFxuICBjcnlwdG9fc2NhbGFybXVsdDogY3J5cHRvX3NjYWxhcm11bHQsXG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2U6IGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UsXG4gIGNyeXB0b19ib3hfYmVmb3Jlbm06IGNyeXB0b19ib3hfYmVmb3Jlbm0sXG4gIGNyeXB0b19ib3hfYWZ0ZXJubTogY3J5cHRvX2JveF9hZnRlcm5tLFxuICBjcnlwdG9fYm94OiBjcnlwdG9fYm94LFxuICBjcnlwdG9fYm94X29wZW46IGNyeXB0b19ib3hfb3BlbixcbiAgY3J5cHRvX2JveF9rZXlwYWlyOiBjcnlwdG9fYm94X2tleXBhaXIsXG4gIGNyeXB0b19oYXNoOiBjcnlwdG9faGFzaCxcbiAgY3J5cHRvX3NpZ246IGNyeXB0b19zaWduLFxuICBjcnlwdG9fc2lnbl9rZXlwYWlyOiBjcnlwdG9fc2lnbl9rZXlwYWlyLFxuICBjcnlwdG9fc2lnbl9vcGVuOiBjcnlwdG9fc2lnbl9vcGVuLFxuXG4gIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM6IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUzogY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTLFxuICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMsXG4gIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM6IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMsXG4gIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM6IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUzogY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTLFxuICBjcnlwdG9fYm94X05PTkNFQllURVM6IGNyeXB0b19ib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX2JveF9aRVJPQllURVM6IGNyeXB0b19ib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUzogY3J5cHRvX2JveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zaWduX0JZVEVTOiBjcnlwdG9fc2lnbl9CWVRFUyxcbiAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM6IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMsXG4gIGNyeXB0b19zaWduX1NFRURCWVRFUzogY3J5cHRvX3NpZ25fU0VFREJZVEVTLFxuICBjcnlwdG9faGFzaF9CWVRFUzogY3J5cHRvX2hhc2hfQllURVMsXG5cbiAgZ2Y6IGdmLFxuICBEOiBELFxuICBMOiBMLFxuICBwYWNrMjU1MTk6IHBhY2syNTUxOSxcbiAgdW5wYWNrMjU1MTk6IHVucGFjazI1NTE5LFxuICBNOiBNLFxuICBBOiBBLFxuICBTOiBTLFxuICBaOiBaLFxuICBwb3cyNTIzOiBwb3cyNTIzLFxuICBhZGQ6IGFkZCxcbiAgc2V0MjU1MTk6IHNldDI1NTE5LFxuICBtb2RMOiBtb2RMLFxuICBzY2FsYXJtdWx0OiBzY2FsYXJtdWx0LFxuICBzY2FsYXJiYXNlOiBzY2FsYXJiYXNlLFxufTtcblxuLyogSGlnaC1sZXZlbCBBUEkgKi9cblxuZnVuY3Rpb24gY2hlY2tMZW5ndGhzKGssIG4pIHtcbiAgaWYgKGsubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBrZXkgc2l6ZScpO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbm9uY2Ugc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveExlbmd0aHMocGssIHNrKSB7XG4gIGlmIChway5sZW5ndGggIT09IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICBpZiAoc2subGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVzKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlLCB1c2UgVWludDhBcnJheScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnJbaV0gPSAwO1xufVxuXG5uYWNsLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICByYW5kb21ieXRlcyhiLCBuKTtcbiAgcmV0dXJuIGI7XG59O1xuXG5uYWNsLnNlY3JldGJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgbVtpK2NyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1zZ1tpXTtcbiAgY3J5cHRvX3NlY3JldGJveChjLCBtLCBtLmxlbmd0aCwgbm9uY2UsIGtleSk7XG4gIHJldHVybiBjLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94Lm9wZW4gPSBmdW5jdGlvbihib3gsIG5vbmNlLCBrZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKGJveCwgbm9uY2UsIGtleSk7XG4gIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyArIGJveC5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspIGNbaStjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBib3hbaV07XG4gIGlmIChjLmxlbmd0aCA8IDMyKSByZXR1cm4gbnVsbDtcbiAgaWYgKGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBjLmxlbmd0aCwgbm9uY2UsIGtleSkgIT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4gbS5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyk7XG59O1xuXG5uYWNsLnNlY3JldGJveC5rZXlMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTO1xubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM7XG5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTO1xuXG5uYWNsLnNjYWxhck11bHQgPSBmdW5jdGlvbihuLCBwKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuLCBwKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIGlmIChwLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHAgc2l6ZScpO1xuICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCk7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LmJhc2UgPSBmdW5jdGlvbihuKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhuKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbiBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pO1xuICByZXR1cm4gcTtcbn07XG5cbm5hY2wuc2NhbGFyTXVsdC5zY2FsYXJMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUztcbm5hY2wuc2NhbGFyTXVsdC5ncm91cEVsZW1lbnRMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUztcblxubmFjbC5ib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBuYWNsLnNlY3JldGJveChtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94LmJlZm9yZSA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIGNoZWNrQm94TGVuZ3RocyhwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCBwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBrO1xufTtcblxubmFjbC5ib3guYWZ0ZXIgPSBuYWNsLnNlY3JldGJveDtcblxubmFjbC5ib3gub3BlbiA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94Lm9wZW4obXNnLCBub25jZSwgayk7XG59O1xuXG5uYWNsLmJveC5vcGVuLmFmdGVyID0gbmFjbC5zZWNyZXRib3gub3BlbjtcblxubmFjbC5ib3gua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyk7XG4gIGNyeXB0b19ib3hfa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocGssIHNlY3JldEtleSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuYm94LnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM7XG5uYWNsLmJveC5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTO1xubmFjbC5ib3guc2hhcmVkS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTO1xubmFjbC5ib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fYm94X05PTkNFQllURVM7XG5uYWNsLmJveC5vdmVyaGVhZExlbmd0aCA9IG5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoO1xuXG5uYWNsLnNpZ24gPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBzaWduZWRNc2cgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyttc2cubGVuZ3RoKTtcbiAgY3J5cHRvX3NpZ24oc2lnbmVkTXNnLCBtc2csIG1zZy5sZW5ndGgsIHNlY3JldEtleSk7XG4gIHJldHVybiBzaWduZWRNc2c7XG59O1xuXG5uYWNsLnNpZ24ub3BlbiA9IGZ1bmN0aW9uKHNpZ25lZE1zZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzaWduZWRNc2csIHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KHNpZ25lZE1zZy5sZW5ndGgpO1xuICB2YXIgbWxlbiA9IGNyeXB0b19zaWduX29wZW4odG1wLCBzaWduZWRNc2csIHNpZ25lZE1zZy5sZW5ndGgsIHB1YmxpY0tleSk7XG4gIGlmIChtbGVuIDwgMCkgcmV0dXJuIG51bGw7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkobWxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgbVtpXSA9IHRtcFtpXTtcbiAgcmV0dXJuIG07XG59O1xuXG5uYWNsLnNpZ24uZGV0YWNoZWQgPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICB2YXIgc2lnbmVkTXNnID0gbmFjbC5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAgdmFyIHNpZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHNpZ1tpXSA9IHNpZ25lZE1zZ1tpXTtcbiAgcmV0dXJuIHNpZztcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkgPSBmdW5jdGlvbihtc2csIHNpZywgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZywgcHVibGljS2V5KTtcbiAgaWYgKHNpZy5sZW5ndGggIT09IGNyeXB0b19zaWduX0JZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNpZ25hdHVyZSBzaXplJyk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgdmFyIHNtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspIHNtW2ldID0gc2lnW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBzbVtpK2NyeXB0b19zaWduX0JZVEVTXSA9IG1zZ1tpXTtcbiAgcmV0dXJuIChjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBzbS5sZW5ndGgsIHB1YmxpY0tleSkgPj0gMCk7XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2spO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5zaWduLmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGsubGVuZ3RoOyBpKyspIHBrW2ldID0gc2VjcmV0S2V5WzMyK2ldO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlZWQpO1xuICBpZiAoc2VlZC5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFRURCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWVkIHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaV0gPSBzZWVkW2ldO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM7XG5uYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM7XG5uYWNsLnNpZ24uc2VlZExlbmd0aCA9IGNyeXB0b19zaWduX1NFRURCWVRFUztcbm5hY2wuc2lnbi5zaWduYXR1cmVMZW5ndGggPSBjcnlwdG9fc2lnbl9CWVRFUztcblxubmFjbC5oYXNoID0gZnVuY3Rpb24obXNnKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2cpO1xuICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19oYXNoX0JZVEVTKTtcbiAgY3J5cHRvX2hhc2goaCwgbXNnLCBtc2cubGVuZ3RoKTtcbiAgcmV0dXJuIGg7XG59O1xuXG5uYWNsLmhhc2guaGFzaExlbmd0aCA9IGNyeXB0b19oYXNoX0JZVEVTO1xuXG5uYWNsLnZlcmlmeSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHgsIHkpO1xuICAvLyBaZXJvIGxlbmd0aCBhcmd1bWVudHMgYXJlIGNvbnNpZGVyZWQgbm90IGVxdWFsLlxuICBpZiAoeC5sZW5ndGggPT09IDAgfHwgeS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHZuKHgsIDAsIHksIDAsIHgubGVuZ3RoKSA9PT0gMCkgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5uYWNsLnNldFBSTkcgPSBmdW5jdGlvbihmbikge1xuICByYW5kb21ieXRlcyA9IGZuO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBJbml0aWFsaXplIFBSTkcgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgQ1NQUk5HLlxuICAvLyBJZiBub3QsIG1ldGhvZHMgY2FsbGluZyByYW5kb21ieXRlcyB3aWxsIHRocm93LlxuICB2YXIgY3J5cHRvID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gKHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG8pIDogbnVsbDtcbiAgaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gQnJvd3NlcnMuXG4gICAgdmFyIFFVT1RBID0gNjU1MzY7XG4gICAgbmFjbC5zZXRQUk5HKGZ1bmN0aW9uKHgsIG4pIHtcbiAgICAgIHZhciBpLCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSkge1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHYuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSB2W2ldO1xuICAgICAgY2xlYW51cCh2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0cnVlKSB7XG4gICAgLy8gTm9kZS5qcy5cbiAgICBjcnlwdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICB2YXIgaSwgdiA9IGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICAgIGNsZWFudXAodik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbn0pKCB0cnVlICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgOiAoc2VsZi5uYWNsID0gc2VsZi5uYWNsIHx8IHt9KSk7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpLmRlZmF1bHQ7XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuXG5TdHJlYW1zIGluIGEgV2ViU29ja2V0IGNvbm5lY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5XZSBtb2RlbCBhIFdlYlNvY2tldCBhcyB0d28gZHVwbGV4IHN0cmVhbXM6IG9uZSBzdHJlYW0gaXMgZm9yIHRoZSB3aXJlIHByb3RvY29sXG5vdmVyIGFuIEkvTyBzb2NrZXQsIGFuZCB0aGUgb3RoZXIgaXMgZm9yIGluY29taW5nL291dGdvaW5nIG1lc3NhZ2VzLlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tKyAgICAgICstLS0tLS0tLS0rICAgICAgKy0tLS0tLS0tLS0rXG4gICAgWzFdIHdyaXRlKGNodW5rKSAtLT58IH5+fn5+fn5+ICstLS0tLT58IHBhcnNlKCkgKy0tLS0tPnwgfn5+fn5+fn4gKy0tPiBlbWl0KCdkYXRhJykgWzJdXG4gICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICArLS0tLSstLS0tKyAgICAgIHwgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgSU8gICAgfCAgICAgICAgICAgfCBbNV0gICAgICAgfCBNZXNzYWdlcyB8XG4gICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgIFYgICAgICAgICAgIHwgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLSsgICAgICB8ICAgICAgICAgIHxcbiAgICBbNF0gZW1pdCgnZGF0YScpIDwtLSsgfn5+fn5+fn4gfDwtLS0tLSsgZnJhbWUoKSB8PC0tLS0tKyB+fn5+fn5+fiB8PC0tIHdyaXRlKGNodW5rKSBbM11cbiAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tKyAgICAgICstLS0tLS0tLS0rICAgICAgKy0tLS0tLS0tLS0rXG5cblxuTWVzc2FnZSB0cmFuc2ZlciBpbiBlYWNoIGRpcmVjdGlvbiBpcyBzaW1wbGU6IElPIHJlY2VpdmVzIGEgYnl0ZSBzdHJlYW0gWzFdIGFuZFxuc2VuZHMgdGhpcyBzdHJlYW0gZm9yIHBhcnNpbmcuIFRoZSBwYXJzZXIgd2lsbCBwZXJpb2RpY2FsbHkgZW1pdCBhIGNvbXBsZXRlXG5tZXNzYWdlIHRleHQgb24gdGhlIE1lc3NhZ2VzIHN0cmVhbSBbMl0uIFNpbWlsYXJseSwgd2hlbiBtZXNzYWdlcyBhcmUgd3JpdHRlblxudG8gdGhlIE1lc3NhZ2VzIHN0cmVhbSBbM10sIHRoZXkgYXJlIGZyYW1lZCB1c2luZyB0aGUgV2ViU29ja2V0IHdpcmUgZm9ybWF0IGFuZFxuZW1pdHRlZCB2aWEgSU8gWzRdLlxuXG5UaGVyZSBpcyBhIGZlZWRiYWNrIGxvb3AgdmlhIFs1XSBzaW5jZSBzb21lIGlucHV0IGZyb20gWzFdIHdpbGwgYmUgdGhpbmdzIGxpa2VcbnBpbmcsIHBvbmcgYW5kIGNsb3NlIGZyYW1lcy4gSW4gdGhlc2UgY2FzZXMgdGhlIHByb3RvY29sIHJlc3BvbmRzIGJ5IGVtaXR0aW5nXG5yZXNwb25zZXMgZGlyZWN0bHkgYmFjayB0byBbNF0gcmF0aGVyIHRoYW4gZW1pdHRpbmcgbWVzc2FnZXMgdmlhIFsyXS5cblxuRm9yIHRoZSBwdXJwb3NlcyBvZiBmbG93IGNvbnRyb2wsIHdlIGNvbnNpZGVyIHRoZSBzb3VyY2VzIG9mIGVhY2ggUmVhZGFibGVcbnN0cmVhbSB0byBiZSBhcyBmb2xsb3dzOlxuXG4qIFsyXSByZWNlaXZlcyBpbnB1dCBmcm9tIFsxXVxuKiBbNF0gcmVjZWl2ZXMgaW5wdXQgZnJvbSBbMV0gYW5kIFszXVxuXG5UaGUgY2xhc3NlcyBiZWxvdyBleHByZXNzIHRoZSByZWxhdGlvbnNoaXBzIGRlc2NyaWJlZCBhYm92ZSB3aXRob3V0IHByZXNjcmliaW5nXG5hbnl0aGluZyBhYm91dCBob3cgcGFyc2UoKSBhbmQgZnJhbWUoKSB3b3JrLCBvdGhlciB0aGFuIGFzc3VtaW5nIHRoZXkgZW1pdFxuJ2RhdGEnIGV2ZW50cyB0byB0aGUgSU8gYW5kIE1lc3NhZ2VzIHN0cmVhbXMuIFRoZXkgd2lsbCB3b3JrIHdpdGggYW55IHByb3RvY29sXG5kcml2ZXIgaGF2aW5nIHRoZXNlIHR3byBtZXRob2RzLlxuKiovXG5cblxudmFyIFN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuU3RyZWFtLFxuICAgIHV0aWwgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxudmFyIElPID0gZnVuY3Rpb24oZHJpdmVyKSB7XG4gIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5fcGF1c2VkICA9IGZhbHNlO1xuICB0aGlzLl9kcml2ZXIgID0gZHJpdmVyO1xufTtcbnV0aWwuaW5oZXJpdHMoSU8sIFN0cmVhbSk7XG5cbi8vIFRoZSBJTyBwYXVzZSgpIGFuZCByZXN1bWUoKSBtZXRob2RzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHNvY2tldCB3ZSBhcmVcbi8vIHBpcGluZyB0byBnZXRzIGJhY2tlZCB1cCBhbmQgZHJhaW5zLiBTaW5jZSBJTyBvdXRwdXQgWzRdIGNvbWVzIGZyb20gSU8gaW5wdXRcbi8vIFsxXSBhbmQgTWVzc2FnZXMgaW5wdXQgWzNdLCB3ZSBuZWVkIHRvIHRlbGwgYm90aCBvZiB0aG9zZSB0byByZXR1cm4gZmFsc2Vcbi8vIGZyb20gd3JpdGUoKSB3aGVuIHRoaXMgc3RyZWFtIGlzIHBhdXNlZC5cblxuSU8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIHRoaXMuX2RyaXZlci5tZXNzYWdlcy5fcGF1c2VkID0gdHJ1ZTtcbn07XG5cbklPLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZHJhaW4nKTtcblxuICB2YXIgbWVzc2FnZXMgPSB0aGlzLl9kcml2ZXIubWVzc2FnZXM7XG4gIG1lc3NhZ2VzLl9wYXVzZWQgPSBmYWxzZTtcbiAgbWVzc2FnZXMuZW1pdCgnZHJhaW4nKTtcbn07XG5cbi8vIFdoZW4gd2UgcmVjZWl2ZSBpbnB1dCBmcm9tIGEgc29ja2V0LCBzZW5kIGl0IHRvIHRoZSBwYXJzZXIgYW5kIHRlbGwgdGhlXG4vLyBzb3VyY2Ugd2hldGhlciB0byBiYWNrIG9mZi5cbklPLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIGlmICghdGhpcy53cml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICB0aGlzLl9kcml2ZXIucGFyc2UoY2h1bmspO1xuICByZXR1cm4gIXRoaXMuX3BhdXNlZDtcbn07XG5cbi8vIFRoZSBJTyBlbmQoKSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc29ja2V0IHBpcGluZyBpbnRvIGl0IGVtaXRzXG4vLyAnY2xvc2UnIG9yICdlbmQnLCBpLmUuIHRoZSBzb2NrZXQgaXMgY2xvc2VkLiBJbiB0aGlzIHNpdHVhdGlvbiB0aGUgTWVzc2FnZXNcbi8vIHN0cmVhbSB3aWxsIG5vdCBlbWl0IGFueSBtb3JlIGRhdGEgc28gd2UgZW1pdCAnZW5kJy5cbklPLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaykge1xuICBpZiAoIXRoaXMud3JpdGFibGUpIHJldHVybjtcbiAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmspO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdmFyIG1lc3NhZ2VzID0gdGhpcy5fZHJpdmVyLm1lc3NhZ2VzO1xuICBpZiAobWVzc2FnZXMucmVhZGFibGUpIHtcbiAgICBtZXNzYWdlcy5yZWFkYWJsZSA9IG1lc3NhZ2VzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgbWVzc2FnZXMuZW1pdCgnZW5kJyk7XG4gIH1cbn07XG5cbklPLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW5kKCk7XG59O1xuXG5cbnZhciBNZXNzYWdlcyA9IGZ1bmN0aW9uKGRyaXZlcikge1xuICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuX3BhdXNlZCAgPSBmYWxzZTtcbiAgdGhpcy5fZHJpdmVyICA9IGRyaXZlcjtcbn07XG51dGlsLmluaGVyaXRzKE1lc3NhZ2VzLCBTdHJlYW0pO1xuXG4vLyBUaGUgTWVzc2FnZXMgcGF1c2UoKSBhbmQgcmVzdW1lKCkgbWV0aG9kcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBhcHAgdGhhdCdzXG4vLyBwcm9jZXNzaW5nIHRoZSBtZXNzYWdlcyBnZXRzIGJhY2tlZCB1cCBhbmQgZHJhaW5zLiBJZiB3ZSdyZSBlbWl0dGluZ1xuLy8gbWVzc2FnZXMgdG9vIGZhc3Qgd2Ugc2hvdWxkIHRlbGwgdGhlIHNvdXJjZSB0byBzbG93IGRvd24uIE1lc3NhZ2Ugb3V0cHV0IFsyXVxuLy8gY29tZXMgZnJvbSBJTyBpbnB1dCBbMV0uXG5cbk1lc3NhZ2VzLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9kcml2ZXIuaW8uX3BhdXNlZCA9IHRydWU7XG59O1xuXG5NZXNzYWdlcy5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2RyaXZlci5pby5fcGF1c2VkID0gZmFsc2U7XG4gIHRoaXMuX2RyaXZlci5pby5lbWl0KCdkcmFpbicpO1xufTtcblxuLy8gV2hlbiB3ZSByZWNlaXZlIG1lc3NhZ2VzIGZyb20gdGhlIHVzZXIsIHNlbmQgdGhlbSB0byB0aGUgZm9ybWF0dGVyIGFuZCB0ZWxsXG4vLyB0aGUgc291cmNlIHdoZXRoZXIgdG8gYmFjayBvZmYuXG5NZXNzYWdlcy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGlmICghdGhpcy53cml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB0aGlzLl9kcml2ZXIudGV4dChtZXNzYWdlKTtcbiAgZWxzZSB0aGlzLl9kcml2ZXIuYmluYXJ5KG1lc3NhZ2UpO1xuICByZXR1cm4gIXRoaXMuX3BhdXNlZDtcbn07XG5cbi8vIFRoZSBNZXNzYWdlcyBlbmQoKSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHN0cmVhbSBwaXBpbmcgaW50byBpdCBlbWl0c1xuLy8gJ2VuZCcuIE1hbnkgc3RyZWFtcyBtYXkgYmUgcGlwZWQgaW50byB0aGUgV2ViU29ja2V0IGFuZCBvbmUgb2YgdGhlbSBlbmRpbmdcbi8vIGRvZXMgbm90IG1lYW4gdGhlIHdob2xlIHNvY2tldCBpcyBkb25lLCBzbyBqdXN0IHByb2Nlc3MgdGhlIGlucHV0IGFuZCBtb3ZlXG4vLyBvbiBsZWF2aW5nIHRoZSBzb2NrZXQgb3Blbi5cbk1lc3NhZ2VzLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUobWVzc2FnZSk7XG59O1xuXG5NZXNzYWdlcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge307XG5cblxuZXhwb3J0cy5JTyA9IElPO1xuZXhwb3J0cy5NZXNzYWdlcyA9IE1lc3NhZ2VzO1xuXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyO1xuXG52YXIgU3RyZWFtUmVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3F1ZXVlICAgICA9IFtdO1xuICB0aGlzLl9xdWV1ZVNpemUgPSAwO1xuICB0aGlzLl9vZmZzZXQgICAgPSAwO1xufTtcblxuU3RyZWFtUmVhZGVyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgaWYgKCFidWZmZXIgfHwgYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICB0aGlzLl9xdWV1ZS5wdXNoKGJ1ZmZlcik7XG4gIHRoaXMuX3F1ZXVlU2l6ZSArPSBidWZmZXIubGVuZ3RoO1xufTtcblxuU3RyZWFtUmVhZGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiB0aGlzLl9xdWV1ZVNpemUpIHJldHVybiBudWxsO1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuXG4gIHRoaXMuX3F1ZXVlU2l6ZSAtPSBsZW5ndGg7XG5cbiAgdmFyIHF1ZXVlICA9IHRoaXMuX3F1ZXVlLFxuICAgICAgcmVtYWluID0gbGVuZ3RoLFxuICAgICAgZmlyc3QgID0gcXVldWVbMF0sXG4gICAgICBidWZmZXJzLCBidWZmZXI7XG5cbiAgaWYgKGZpcnN0Lmxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICBpZiAoZmlyc3QubGVuZ3RoID09PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBxdWV1ZS5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBmaXJzdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgcXVldWVbMF0gPSBmaXJzdC5zbGljZShsZW5ndGgpO1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHF1ZXVlLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgIGlmIChyZW1haW4gPCBxdWV1ZVtpXS5sZW5ndGgpIGJyZWFrO1xuICAgIHJlbWFpbiAtPSBxdWV1ZVtpXS5sZW5ndGg7XG4gIH1cbiAgYnVmZmVycyA9IHF1ZXVlLnNwbGljZSgwLCBpKTtcblxuICBpZiAocmVtYWluID4gMCAmJiBxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgYnVmZmVycy5wdXNoKHF1ZXVlWzBdLnNsaWNlKDAsIHJlbWFpbikpO1xuICAgIHF1ZXVlWzBdID0gcXVldWVbMF0uc2xpY2UocmVtYWluKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBsZW5ndGgpO1xufTtcblxuU3RyZWFtUmVhZGVyLnByb3RvdHlwZS5lYWNoQnl0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIHZhciBidWZmZXIsIG4sIGluZGV4O1xuXG4gIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgYnVmZmVyID0gdGhpcy5fcXVldWVbMF07XG4gICAgbiA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgICB3aGlsZSAodGhpcy5fb2Zmc2V0IDwgbikge1xuICAgICAgaW5kZXggPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgYnVmZmVyW2luZGV4XSk7XG4gICAgfVxuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1SZWFkZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQnVmZmVyICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyLFxuICAgIGNyeXB0byAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLFxuICAgIHVybCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICAgIHV0aWwgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIEh0dHBQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSxcbiAgICBCYXNlICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgICBIeWJpICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMiksXG4gICAgUHJveHkgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG52YXIgQ2xpZW50ID0gZnVuY3Rpb24oX3VybCwgb3B0aW9ucykge1xuICB0aGlzLnZlcnNpb24gPSAnaHliaS0nICsgSHliaS5WRVJTSU9OO1xuICBIeWJpLmNhbGwodGhpcywgbnVsbCwgX3VybCwgb3B0aW9ucyk7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gLTE7XG4gIHRoaXMuX2tleSAgICAgICA9IENsaWVudC5nZW5lcmF0ZUtleSgpO1xuICB0aGlzLl9hY2NlcHQgICAgPSBIeWJpLmdlbmVyYXRlQWNjZXB0KHRoaXMuX2tleSk7XG4gIHRoaXMuX2h0dHAgICAgICA9IG5ldyBIdHRwUGFyc2VyKCdyZXNwb25zZScpO1xuXG4gIHZhciB1cmkgID0gdXJsLnBhcnNlKHRoaXMudXJsKSxcbiAgICAgIGF1dGggPSB1cmkuYXV0aCAmJiBCdWZmZXIuZnJvbSh1cmkuYXV0aCwgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgaWYgKHRoaXMuVkFMSURfUFJPVE9DT0xTLmluZGV4T2YodXJpLnByb3RvY29sKSA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudXJsICsgJyBpcyBub3QgYSB2YWxpZCBXZWJTb2NrZXQgVVJMJyk7XG5cbiAgdGhpcy5fcGF0aG5hbWUgPSAodXJpLnBhdGhuYW1lIHx8ICcvJykgKyAodXJpLnNlYXJjaCB8fCAnJyk7XG5cbiAgdGhpcy5faGVhZGVycy5zZXQoJ0hvc3QnLCB1cmkuaG9zdCk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdVcGdyYWRlJywgJ3dlYnNvY2tldCcpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnQ29ubmVjdGlvbicsICdVcGdyYWRlJyk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LUtleScsIHRoaXMuX2tleSk7XG4gIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LVZlcnNpb24nLCBIeWJpLlZFUlNJT04pO1xuXG4gIGlmICh0aGlzLl9wcm90b2NvbHMubGVuZ3RoID4gMClcbiAgICB0aGlzLl9oZWFkZXJzLnNldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcsIHRoaXMuX3Byb3RvY29scy5qb2luKCcsICcpKTtcblxuICBpZiAoYXV0aClcbiAgICB0aGlzLl9oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgYXV0aCk7XG59O1xudXRpbC5pbmhlcml0cyhDbGllbnQsIEh5YmkpO1xuXG5DbGllbnQuZ2VuZXJhdGVLZXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufTtcblxudmFyIGluc3RhbmNlID0ge1xuICBWQUxJRF9QUk9UT0NPTFM6IFsnd3M6JywgJ3dzczonXSxcblxuICBwcm94eTogZnVuY3Rpb24ob3JpZ2luLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCBvcmlnaW4sIG9wdGlvbnMpO1xuICB9LFxuXG4gIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuX3dyaXRlKHRoaXMuX2hhbmRzaGFrZVJlcXVlc3QoKSk7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSAzKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDApIHJldHVybiBIeWJpLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIGNodW5rKTtcblxuICAgIHRoaXMuX2h0dHAucGFyc2UoY2h1bmspO1xuICAgIGlmICghdGhpcy5faHR0cC5pc0NvbXBsZXRlKCkpIHJldHVybjtcblxuICAgIHRoaXMuX3ZhbGlkYXRlSGFuZHNoYWtlKCk7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gMykgcmV0dXJuO1xuXG4gICAgdGhpcy5fb3BlbigpO1xuICAgIHRoaXMucGFyc2UodGhpcy5faHR0cC5ib2R5KTtcbiAgfSxcblxuICBfaGFuZHNoYWtlUmVxdWVzdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4dGVuc2lvbnMgPSB0aGlzLl9leHRlbnNpb25zLmdlbmVyYXRlT2ZmZXIoKTtcbiAgICBpZiAoZXh0ZW5zaW9ucylcbiAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnLCBleHRlbnNpb25zKTtcblxuICAgIHZhciBzdGFydCAgID0gJ0dFVCAnICsgdGhpcy5fcGF0aG5hbWUgKyAnIEhUVFAvMS4xJyxcbiAgICAgICAgaGVhZGVycyA9IFtzdGFydCwgdGhpcy5faGVhZGVycy50b1N0cmluZygpLCAnJ107XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGVhZGVycy5qb2luKCdcXHJcXG4nKSwgJ3V0ZjgnKTtcbiAgfSxcblxuICBfZmFpbEhhbmRzaGFrZTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSAnRXJyb3IgZHVyaW5nIFdlYlNvY2tldCBoYW5kc2hha2U6ICcgKyBtZXNzYWdlO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDM7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG5ldyBCYXNlLkNsb3NlRXZlbnQodGhpcy5FUlJPUlMucHJvdG9jb2xfZXJyb3IsIG1lc3NhZ2UpKTtcbiAgfSxcblxuICBfdmFsaWRhdGVIYW5kc2hha2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHRoaXMuX2h0dHAuc3RhdHVzQ29kZTtcbiAgICB0aGlzLmhlYWRlcnMgICAgPSB0aGlzLl9odHRwLmhlYWRlcnM7XG5cbiAgICBpZiAodGhpcy5faHR0cC5lcnJvcilcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKHRoaXMuX2h0dHAuZXJyb3IubWVzc2FnZSk7XG5cbiAgICBpZiAodGhpcy5faHR0cC5zdGF0dXNDb2RlICE9PSAxMDEpXG4gICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZSgnVW5leHBlY3RlZCByZXNwb25zZSBjb2RlOiAnICsgdGhpcy5faHR0cC5zdGF0dXNDb2RlKTtcblxuICAgIHZhciBoZWFkZXJzICAgID0gdGhpcy5faHR0cC5oZWFkZXJzLFxuICAgICAgICB1cGdyYWRlICAgID0gaGVhZGVyc1sndXBncmFkZSddIHx8ICcnLFxuICAgICAgICBjb25uZWN0aW9uID0gaGVhZGVyc1snY29ubmVjdGlvbiddIHx8ICcnLFxuICAgICAgICBhY2NlcHQgICAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSB8fCAnJyxcbiAgICAgICAgcHJvdG9jb2wgICA9IGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXSB8fCAnJztcblxuICAgIGlmICh1cGdyYWRlID09PSAnJylcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKFwiJ1VwZ3JhZGUnIGhlYWRlciBpcyBtaXNzaW5nXCIpO1xuICAgIGlmICh1cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoXCInVXBncmFkZScgaGVhZGVyIHZhbHVlIGlzIG5vdCAnV2ViU29ja2V0J1wiKTtcblxuICAgIGlmIChjb25uZWN0aW9uID09PSAnJylcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKFwiJ0Nvbm5lY3Rpb24nIGhlYWRlciBpcyBtaXNzaW5nXCIpO1xuICAgIGlmIChjb25uZWN0aW9uLnRvTG93ZXJDYXNlKCkgIT09ICd1cGdyYWRlJylcbiAgICAgIHJldHVybiB0aGlzLl9mYWlsSGFuZHNoYWtlKFwiJ0Nvbm5lY3Rpb24nIGhlYWRlciB2YWx1ZSBpcyBub3QgJ1VwZ3JhZGUnXCIpO1xuXG4gICAgaWYgKGFjY2VwdCAhPT0gdGhpcy5fYWNjZXB0KVxuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoJ1NlYy1XZWJTb2NrZXQtQWNjZXB0IG1pc21hdGNoJyk7XG5cbiAgICB0aGlzLnByb3RvY29sID0gbnVsbDtcblxuICAgIGlmIChwcm90b2NvbCAhPT0gJycpIHtcbiAgICAgIGlmICh0aGlzLl9wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPCAwKVxuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbEhhbmRzaGFrZSgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMuYWN0aXZhdGUodGhpcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhaWxIYW5kc2hha2UoZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgQ2xpZW50LnByb3RvdHlwZVtrZXldID0gaW5zdGFuY2Vba2V5XTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnQ7XG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cblxudmFyIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5leHBvcnRzLkhUVFBQYXJzZXIgPSBIVFRQUGFyc2VyO1xuZnVuY3Rpb24gSFRUUFBhcnNlcih0eXBlKSB7XG4gIGFzc2VydC5vayh0eXBlID09PSBIVFRQUGFyc2VyLlJFUVVFU1QgfHwgdHlwZSA9PT0gSFRUUFBhcnNlci5SRVNQT05TRSB8fCB0eXBlID09PSB1bmRlZmluZWQpO1xuICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTm9kZSB2MTIrXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pbml0aWFsaXplKHR5cGUpO1xuICB9XG4gIHRoaXMubWF4SGVhZGVyU2l6ZT1IVFRQUGFyc2VyLm1heEhlYWRlclNpemVcbn1cbkhUVFBQYXJzZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAodHlwZSwgYXN5bmNfcmVzb3VyY2UpIHtcbiAgYXNzZXJ0Lm9rKHR5cGUgPT09IEhUVFBQYXJzZXIuUkVRVUVTVCB8fCB0eXBlID09PSBIVFRQUGFyc2VyLlJFU1BPTlNFKTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zdGF0ZSA9IHR5cGUgKyAnX0xJTkUnO1xuICB0aGlzLmluZm8gPSB7XG4gICAgaGVhZGVyczogW10sXG4gICAgdXBncmFkZTogZmFsc2VcbiAgfTtcbiAgdGhpcy50cmFpbGVycyA9IFtdO1xuICB0aGlzLmxpbmUgPSAnJztcbiAgdGhpcy5pc0NodW5rZWQgPSBmYWxzZTtcbiAgdGhpcy5jb25uZWN0aW9uID0gJyc7XG4gIHRoaXMuaGVhZGVyU2l6ZSA9IDA7IC8vIGZvciBwcmV2ZW50aW5nIHRvbyBiaWcgaGVhZGVyc1xuICB0aGlzLmJvZHlfYnl0ZXMgPSBudWxsO1xuICB0aGlzLmlzVXNlckNhbGwgPSBmYWxzZTtcbiAgdGhpcy5oYWRFcnJvciA9IGZhbHNlO1xufTtcblxuSFRUUFBhcnNlci5lbmNvZGluZyA9ICdhc2NpaSc7XG5IVFRQUGFyc2VyLm1heEhlYWRlclNpemUgPSA4MCAqIDEwMjQ7IC8vIG1heEhlYWRlclNpemUgKGluIGJ5dGVzKSBpcyBjb25maWd1cmFibGUsIGJ1dCA4MGtiIGJ5IGRlZmF1bHQ7XG5IVFRQUGFyc2VyLlJFUVVFU1QgPSAnUkVRVUVTVCc7XG5IVFRQUGFyc2VyLlJFU1BPTlNFID0gJ1JFU1BPTlNFJztcblxuLy8gTm90ZTogKm5vdCogc3RhcnRpbmcgd2l0aCBrT25IZWFkZXJzPTAgbGluZSB0aGUgTm9kZSBwYXJzZXIsIGJlY2F1c2UgYW55XG4vLyAgIG5ld2x5IGFkZGVkIGNvbnN0YW50cyAoa09uVGltZW91dCBpbiBOb2RlIHYxMi4xOS4wKSB3aWxsIG92ZXJ3cml0ZSAwIVxudmFyIGtPbkhlYWRlcnMgPSBIVFRQUGFyc2VyLmtPbkhlYWRlcnMgPSAxO1xudmFyIGtPbkhlYWRlcnNDb21wbGV0ZSA9IEhUVFBQYXJzZXIua09uSGVhZGVyc0NvbXBsZXRlID0gMjtcbnZhciBrT25Cb2R5ID0gSFRUUFBhcnNlci5rT25Cb2R5ID0gMztcbnZhciBrT25NZXNzYWdlQ29tcGxldGUgPSBIVFRQUGFyc2VyLmtPbk1lc3NhZ2VDb21wbGV0ZSA9IDQ7XG5cbi8vIFNvbWUgaGFuZGxlciBzdHVicywgbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XG5IVFRQUGFyc2VyLnByb3RvdHlwZVtrT25IZWFkZXJzXSA9XG5IVFRQUGFyc2VyLnByb3RvdHlwZVtrT25IZWFkZXJzQ29tcGxldGVdID1cbkhUVFBQYXJzZXIucHJvdG90eXBlW2tPbkJvZHldID1cbkhUVFBQYXJzZXIucHJvdG90eXBlW2tPbk1lc3NhZ2VDb21wbGV0ZV0gPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGNvbXBhdE1vZGUwXzEyID0gdHJ1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVFRQUGFyc2VyLCAna09uRXhlY3V0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGhhY2sgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIGNvbXBhdE1vZGUwXzEyID0gZmFsc2U7XG4gICAgICByZXR1cm4gOTk7XG4gICAgfVxuICB9KTtcblxudmFyIG1ldGhvZHMgPSBleHBvcnRzLm1ldGhvZHMgPSBIVFRQUGFyc2VyLm1ldGhvZHMgPSBbXG4gICdERUxFVEUnLFxuICAnR0VUJyxcbiAgJ0hFQUQnLFxuICAnUE9TVCcsXG4gICdQVVQnLFxuICAnQ09OTkVDVCcsXG4gICdPUFRJT05TJyxcbiAgJ1RSQUNFJyxcbiAgJ0NPUFknLFxuICAnTE9DSycsXG4gICdNS0NPTCcsXG4gICdNT1ZFJyxcbiAgJ1BST1BGSU5EJyxcbiAgJ1BST1BQQVRDSCcsXG4gICdTRUFSQ0gnLFxuICAnVU5MT0NLJyxcbiAgJ0JJTkQnLFxuICAnUkVCSU5EJyxcbiAgJ1VOQklORCcsXG4gICdBQ0wnLFxuICAnUkVQT1JUJyxcbiAgJ01LQUNUSVZJVFknLFxuICAnQ0hFQ0tPVVQnLFxuICAnTUVSR0UnLFxuICAnTS1TRUFSQ0gnLFxuICAnTk9USUZZJyxcbiAgJ1NVQlNDUklCRScsXG4gICdVTlNVQlNDUklCRScsXG4gICdQQVRDSCcsXG4gICdQVVJHRScsXG4gICdNS0NBTEVOREFSJyxcbiAgJ0xJTksnLFxuICAnVU5MSU5LJyxcbiAgJ1NPVVJDRScsXG5dO1xudmFyIG1ldGhvZF9jb25uZWN0ID0gbWV0aG9kcy5pbmRleE9mKCdDT05ORUNUJyk7XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5yZWluaXRpYWxpemUgPSBIVFRQUGFyc2VyO1xuSFRUUFBhcnNlci5wcm90b3R5cGUuY2xvc2UgPVxuSFRUUFBhcnNlci5wcm90b3R5cGUucGF1c2UgPVxuSFRUUFBhcnNlci5wcm90b3R5cGUucmVzdW1lID1cbkhUVFBQYXJzZXIucHJvdG90eXBlLmZyZWUgPSBmdW5jdGlvbiAoKSB7fTtcbkhUVFBQYXJzZXIucHJvdG90eXBlLl9jb21wYXRNb2RlMF8xMSA9IGZhbHNlO1xuSFRUUFBhcnNlci5wcm90b3R5cGUuZ2V0QXN5bmNJZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxudmFyIGhlYWRlclN0YXRlID0ge1xuICBSRVFVRVNUX0xJTkU6IHRydWUsXG4gIFJFU1BPTlNFX0xJTkU6IHRydWUsXG4gIEhFQURFUjogdHJ1ZVxufTtcbkhUVFBQYXJzZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoY2h1bmssIHN0YXJ0LCBsZW5ndGgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhUVFBQYXJzZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgSFRUUFBhcnNlcicpO1xuICB9XG5cbiAgLy8gYmFja3dhcmQgY29tcGF0IHRvIG5vZGUgPCAwLjExLjRcbiAgLy8gTm90ZTogdGhlIHN0YXJ0IGFuZCBsZW5ndGggcGFyYW1zIHdlcmUgcmVtb3ZlZCBpbiBuZXdlciB2ZXJzaW9uXG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgbGVuZ3RoID0gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgPyBsZW5ndGggOiBjaHVuay5sZW5ndGg7XG5cbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLm9mZnNldCA9IHN0YXJ0O1xuICB2YXIgZW5kID0gdGhpcy5lbmQgPSBzdGFydCArIGxlbmd0aDtcbiAgdHJ5IHtcbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCBlbmQpIHtcbiAgICAgIGlmICh0aGlzW3RoaXMuc3RhdGVdKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodGhpcy5pc1VzZXJDYWxsKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRoaXMuaGFkRXJyb3IgPSB0cnVlO1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgdGhpcy5jaHVuayA9IG51bGw7XG4gIGxlbmd0aCA9IHRoaXMub2Zmc2V0IC0gc3RhcnQ7XG4gIGlmIChoZWFkZXJTdGF0ZVt0aGlzLnN0YXRlXSkge1xuICAgIHRoaXMuaGVhZGVyU2l6ZSArPSBsZW5ndGg7XG4gICAgaWYgKHRoaXMuaGVhZGVyU2l6ZSA+ICh0aGlzLm1heEhlYWRlclNpemV8fEhUVFBQYXJzZXIubWF4SGVhZGVyU2l6ZSkpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ21heCBoZWFkZXIgc2l6ZSBleGNlZWRlZCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufTtcblxudmFyIHN0YXRlRmluaXNoQWxsb3dlZCA9IHtcbiAgUkVRVUVTVF9MSU5FOiB0cnVlLFxuICBSRVNQT05TRV9MSU5FOiB0cnVlLFxuICBCT0RZX1JBVzogdHJ1ZVxufTtcbkhUVFBQYXJzZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaGFkRXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFzdGF0ZUZpbmlzaEFsbG93ZWRbdGhpcy5zdGF0ZV0pIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlIGZvciBFT0YnKTtcbiAgfVxuICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0JPRFlfUkFXJykge1xuICAgIHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbk1lc3NhZ2VDb21wbGV0ZV0oKSk7XG4gIH1cbn07XG5cbi8vIFRoZXNlIHRocmVlIG1ldGhvZHMgYXJlIHVzZWQgZm9yIGFuIGludGVybmFsIHNwZWVkIG9wdGltaXphdGlvbiwgYW5kIGl0IGFsc29cbi8vIHdvcmtzIGlmIHRoZXNlcyBhcmUgbm9vcHMuIEJhc2ljYWxseSBjb25zdW1lKCkgYXNrcyB1cyB0byByZWFkIHRoZSBieXRlc1xuLy8gb3Vyc2VsdmVzLCBidXQgaWYgd2UgZG9uJ3QgZG8gaXQgd2UgZ2V0IHRoZW0gdGhyb3VnaCBleGVjdXRlKCkuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lID1cbkhUVFBQYXJzZXIucHJvdG90eXBlLnVuY29uc3VtZSA9XG5IVFRQUGFyc2VyLnByb3RvdHlwZS5nZXRDdXJyZW50QnVmZmVyID0gZnVuY3Rpb24gKCkge307XG5cbi8vRm9yIGNvcnJlY3QgZXJyb3IgaGFuZGxpbmcgLSBzZWUgSFRUUFBhcnNlciNleGVjdXRlXG4vL1VzYWdlOiB0aGlzLnVzZXJDYWxsKCkodXNlckZ1bmN0aW9uKCdhcmcnKSk7XG5IVFRQUGFyc2VyLnByb3RvdHlwZS51c2VyQ2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pc1VzZXJDYWxsID0gdHJ1ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKHJldCkge1xuICAgIHNlbGYuaXNVc2VyQ2FsbCA9IGZhbHNlO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG59O1xuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5uZXh0UmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy51c2VyQ2FsbCgpKHRoaXNba09uTWVzc2FnZUNvbXBsZXRlXSgpKTtcbiAgdGhpcy5yZWluaXRpYWxpemUodGhpcy50eXBlKTtcbn07XG5cbkhUVFBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVMaW5lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW5kID0gdGhpcy5lbmQsXG4gICAgICBjaHVuayA9IHRoaXMuY2h1bms7XG4gIGZvciAodmFyIGkgPSB0aGlzLm9mZnNldDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGNodW5rW2ldID09PSAweDBhKSB7IC8vIFxcblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmUgKyBjaHVuay50b1N0cmluZyhIVFRQUGFyc2VyLmVuY29kaW5nLCB0aGlzLm9mZnNldCwgaSk7XG4gICAgICBpZiAobGluZS5jaGFyQXQobGluZS5sZW5ndGggLSAxKSA9PT0gJ1xccicpIHtcbiAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmUgPSAnJztcbiAgICAgIHRoaXMub2Zmc2V0ID0gaSArIDE7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gIH1cbiAgLy9saW5lIHNwbGl0IG92ZXIgbXVsdGlwbGUgY2h1bmtzXG4gIHRoaXMubGluZSArPSBjaHVuay50b1N0cmluZyhIVFRQUGFyc2VyLmVuY29kaW5nLCB0aGlzLm9mZnNldCwgdGhpcy5lbmQpO1xuICB0aGlzLm9mZnNldCA9IHRoaXMuZW5kO1xufTtcblxudmFyIGhlYWRlckV4cCA9IC9eKFteOiBcXHRdKyk6WyBcXHRdKigoPzouKlteIFxcdF0pfCkvO1xudmFyIGhlYWRlckNvbnRpbnVlRXhwID0gL15bIFxcdF0rKC4qW14gXFx0XSkvO1xuSFRUUFBhcnNlci5wcm90b3R5cGUucGFyc2VIZWFkZXIgPSBmdW5jdGlvbiAobGluZSwgaGVhZGVycykge1xuICBpZiAobGluZS5pbmRleE9mKCdcXHInKSAhPT0gLTEpIHtcbiAgICB0aHJvdyBwYXJzZUVycm9yQ29kZSgnSFBFX0xGX0VYUEVDVEVEJyk7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBoZWFkZXJFeHAuZXhlYyhsaW5lKTtcbiAgdmFyIGsgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgaWYgKGspIHsgLy8gc2tpcCBlbXB0eSBzdHJpbmcgKG1hbGZvcm1lZCBoZWFkZXIpXG4gICAgaGVhZGVycy5wdXNoKGspO1xuICAgIGhlYWRlcnMucHVzaChtYXRjaFsyXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1hdGNoQ29udGludWUgPSBoZWFkZXJDb250aW51ZUV4cC5leGVjKGxpbmUpO1xuICAgIGlmIChtYXRjaENvbnRpbnVlICYmIGhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICBpZiAoaGVhZGVyc1toZWFkZXJzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGhlYWRlcnNbaGVhZGVycy5sZW5ndGggLSAxXSArPSAnICc7XG4gICAgICB9XG4gICAgICBoZWFkZXJzW2hlYWRlcnMubGVuZ3RoIC0gMV0gKz0gbWF0Y2hDb250aW51ZVsxXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZXF1ZXN0RXhwID0gL14oW0EtWi1dKykgKFteIF0rKSBIVFRQXFwvKFxcZClcXC4oXFxkKSQvO1xuSFRUUFBhcnNlci5wcm90b3R5cGUuUkVRVUVTVF9MSU5FID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGluZSA9IHRoaXMuY29uc3VtZUxpbmUoKTtcbiAgaWYgKCFsaW5lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IHJlcXVlc3RFeHAuZXhlYyhsaW5lKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgdGhyb3cgcGFyc2VFcnJvckNvZGUoJ0hQRV9JTlZBTElEX0NPTlNUQU5UJyk7XG4gIH1cbiAgdGhpcy5pbmZvLm1ldGhvZCA9IHRoaXMuX2NvbXBhdE1vZGUwXzExID8gbWF0Y2hbMV0gOiBtZXRob2RzLmluZGV4T2YobWF0Y2hbMV0pO1xuICBpZiAodGhpcy5pbmZvLm1ldGhvZCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVxdWVzdCBtZXRob2QnKTtcbiAgfVxuICB0aGlzLmluZm8udXJsID0gbWF0Y2hbMl07XG4gIHRoaXMuaW5mby52ZXJzaW9uTWFqb3IgPSArbWF0Y2hbM107XG4gIHRoaXMuaW5mby52ZXJzaW9uTWlub3IgPSArbWF0Y2hbNF07XG4gIHRoaXMuYm9keV9ieXRlcyA9IDA7XG4gIHRoaXMuc3RhdGUgPSAnSEVBREVSJztcbn07XG5cbnZhciByZXNwb25zZUV4cCA9IC9eSFRUUFxcLyhcXGQpXFwuKFxcZCkgKFxcZHszfSkgPyguKikkLztcbkhUVFBQYXJzZXIucHJvdG90eXBlLlJFU1BPTlNFX0xJTkUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAoIWxpbmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gcmVzcG9uc2VFeHAuZXhlYyhsaW5lKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgdGhyb3cgcGFyc2VFcnJvckNvZGUoJ0hQRV9JTlZBTElEX0NPTlNUQU5UJyk7XG4gIH1cbiAgdGhpcy5pbmZvLnZlcnNpb25NYWpvciA9ICttYXRjaFsxXTtcbiAgdGhpcy5pbmZvLnZlcnNpb25NaW5vciA9ICttYXRjaFsyXTtcbiAgdmFyIHN0YXR1c0NvZGUgPSB0aGlzLmluZm8uc3RhdHVzQ29kZSA9ICttYXRjaFszXTtcbiAgdGhpcy5pbmZvLnN0YXR1c01lc3NhZ2UgPSBtYXRjaFs0XTtcbiAgLy8gSW1wbGllZCB6ZXJvIGxlbmd0aC5cbiAgaWYgKChzdGF0dXNDb2RlIC8gMTAwIHwgMCkgPT09IDEgfHwgc3RhdHVzQ29kZSA9PT0gMjA0IHx8IHN0YXR1c0NvZGUgPT09IDMwNCkge1xuICAgIHRoaXMuYm9keV9ieXRlcyA9IDA7XG4gIH1cbiAgdGhpcy5zdGF0ZSA9ICdIRUFERVInO1xufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuc2hvdWxkS2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pbmZvLnZlcnNpb25NYWpvciA+IDAgJiYgdGhpcy5pbmZvLnZlcnNpb25NaW5vciA+IDApIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLmluZGV4T2YoJ2Nsb3NlJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuY29ubmVjdGlvbi5pbmRleE9mKCdrZWVwLWFsaXZlJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLmJvZHlfYnl0ZXMgIT09IG51bGwgfHwgdGhpcy5pc0NodW5rZWQpIHsgLy8gfHwgc2tpcEJvZHlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5IVFRQUGFyc2VyLnByb3RvdHlwZS5IRUFERVIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbmZvID0gdGhpcy5pbmZvO1xuICBpZiAobGluZSkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIobGluZSwgaW5mby5oZWFkZXJzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaGVhZGVycyA9IGluZm8uaGVhZGVycztcbiAgICB2YXIgaGFzQ29udGVudExlbmd0aCA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50Q29udGVudExlbmd0aFZhbHVlO1xuICAgIHZhciBoYXNVcGdyYWRlSGVhZGVyID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBzd2l0Y2ggKGhlYWRlcnNbaV0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICd0cmFuc2Zlci1lbmNvZGluZyc6XG4gICAgICAgICAgdGhpcy5pc0NodW5rZWQgPSBoZWFkZXJzW2kgKyAxXS50b0xvd2VyQ2FzZSgpID09PSAnY2h1bmtlZCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbnRlbnQtbGVuZ3RoJzpcbiAgICAgICAgICBjdXJyZW50Q29udGVudExlbmd0aFZhbHVlID0gK2hlYWRlcnNbaSArIDFdO1xuICAgICAgICAgIGlmIChoYXNDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBGaXggZHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoIGhlYWRlciB3aXRoIHNhbWUgdmFsdWVzLlxuICAgICAgICAgICAgLy8gVGhyb3cgZXJyb3Igb25seSBpZiB2YWx1ZXMgYXJlIGRpZmZlcmVudC5cbiAgICAgICAgICAgIC8vIEtub3duIGlzc3VlczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZXF1ZXN0L3JlcXVlc3QvaXNzdWVzLzIwOTEjaXNzdWVjb21tZW50LTMyODcxNTExM1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy82NTE3I2lzc3VlY29tbWVudC0yMTYyNjM3NzFcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGVudExlbmd0aFZhbHVlICE9PSB0aGlzLmJvZHlfYnl0ZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcGFyc2VFcnJvckNvZGUoJ0hQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc0NvbnRlbnRMZW5ndGggPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ib2R5X2J5dGVzID0gY3VycmVudENvbnRlbnRMZW5ndGhWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Nvbm5lY3Rpb24nOlxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiArPSBoZWFkZXJzW2kgKyAxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1cGdyYWRlJzpcbiAgICAgICAgICBoYXNVcGdyYWRlSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBib3RoIGlzQ2h1bmtlZCBhbmQgaGFzQ29udGVudExlbmd0aCwgaXNDaHVua2VkIHdpbnNcbiAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIHNvIHRoZSBib2R5IGlzIHBhcnNlZCB1c2luZyB0aGUgY2h1bmtlZCBtZXRob2QsIGFuZCBtYXRjaGVzXG4gICAgLy8gQ2hyb21lJ3MgYmVoYXZpb3IuICBXZSBjb3VsZCwgbWF5YmUsIGlnbm9yZSB0aGVtIGJvdGggKHdvdWxkIGdldCBjaHVua2VkXG4gICAgLy8gZW5jb2RpbmcgaW50byB0aGUgYm9keSksIGFuZC9vciBkaXNhYmxlIHNob3VsZEtlZXBBbGl2ZSB0byBiZSBtb3JlXG4gICAgLy8gcmVzaWxpZW50LlxuICAgIGlmICh0aGlzLmlzQ2h1bmtlZCAmJiBoYXNDb250ZW50TGVuZ3RoKSB7XG4gICAgICBoYXNDb250ZW50TGVuZ3RoID0gZmFsc2U7XG4gICAgICB0aGlzLmJvZHlfYnl0ZXMgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIExvZ2ljIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9odHRwLXBhcnNlci9ibG9iLzkyMWQ1NTg1NTE1YTE1M2ZhMDBlNDExY2YxNDQyODBjNTliNDFmOTAvaHR0cF9wYXJzZXIuYyNMMTcyNy1MMTczN1xuICAgIC8vIFwiRm9yIHJlc3BvbnNlcywgXCJVcGdyYWRlOiBmb29cIiBhbmQgXCJDb25uZWN0aW9uOiB1cGdyYWRlXCIgYXJlXG4gICAgLy8gICBtYW5kYXRvcnkgb25seSB3aGVuIGl0IGlzIGEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMgcmVzcG9uc2UsXG4gICAgLy8gICBvdGhlcndpc2UgaXQgaXMgcHVyZWx5IGluZm9ybWF0aW9uYWwsIHRvIGFubm91bmNlIHN1cHBvcnQuXG4gICAgaWYgKGhhc1VwZ3JhZGVIZWFkZXIgJiYgdGhpcy5jb25uZWN0aW9uLmluZGV4T2YoJ3VwZ3JhZGUnKSAhPSAtMSkge1xuICAgICAgaW5mby51cGdyYWRlID0gdGhpcy50eXBlID09PSBIVFRQUGFyc2VyLlJFUVVFU1QgfHwgaW5mby5zdGF0dXNDb2RlID09PSAxMDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8udXBncmFkZSA9IGluZm8ubWV0aG9kID09PSBtZXRob2RfY29ubmVjdDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NodW5rZWQgJiYgaW5mby51cGdyYWRlKSB7XG4gICAgICB0aGlzLmlzQ2h1bmtlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGluZm8uc2hvdWxkS2VlcEFsaXZlID0gdGhpcy5zaG91bGRLZWVwQWxpdmUoKTtcbiAgICAvL3Byb2JsZW0gd2hpY2ggYWxzbyBleGlzdHMgaW4gb3JpZ2luYWwgbm9kZTogd2Ugc2hvdWxkIGtub3cgc2tpcEJvZHkgYmVmb3JlIGNhbGxpbmcgb25IZWFkZXJzQ29tcGxldGVcbiAgICB2YXIgc2tpcEJvZHk7XG4gICAgaWYgKGNvbXBhdE1vZGUwXzEyKSB7XG4gICAgICBza2lwQm9keSA9IHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbkhlYWRlcnNDb21wbGV0ZV0oaW5mbykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBza2lwQm9keSA9IHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbkhlYWRlcnNDb21wbGV0ZV0oaW5mby52ZXJzaW9uTWFqb3IsXG4gICAgICAgICAgaW5mby52ZXJzaW9uTWlub3IsIGluZm8uaGVhZGVycywgaW5mby5tZXRob2QsIGluZm8udXJsLCBpbmZvLnN0YXR1c0NvZGUsXG4gICAgICAgICAgaW5mby5zdGF0dXNNZXNzYWdlLCBpbmZvLnVwZ3JhZGUsIGluZm8uc2hvdWxkS2VlcEFsaXZlKSk7XG4gICAgfVxuICAgIGlmIChza2lwQm9keSA9PT0gMikge1xuICAgICAgdGhpcy5uZXh0UmVxdWVzdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2h1bmtlZCAmJiAhc2tpcEJvZHkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAnQk9EWV9DSFVOS0hFQUQnO1xuICAgIH0gZWxzZSBpZiAoc2tpcEJvZHkgfHwgdGhpcy5ib2R5X2J5dGVzID09PSAwKSB7XG4gICAgICB0aGlzLm5leHRSZXF1ZXN0KCk7XG4gICAgICAvLyBGb3Igb2xkZXIgdmVyc2lvbnMgb2Ygbm9kZSAodjYueCBhbmQgb2xkZXI/KSwgdGhhdCByZXR1cm4gc2tpcEJvZHk9MSBvciBza2lwQm9keT10cnVlLFxuICAgICAgLy8gICBuZWVkIHRoaXMgXCJyZXR1cm4gdHJ1ZTtcIiBpZiBpdCdzIGFuIHVwZ3JhZGUgcmVxdWVzdC5cbiAgICAgIHJldHVybiBpbmZvLnVwZ3JhZGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJvZHlfYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAnQk9EWV9SQVcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gJ0JPRFlfU0laRUQnO1xuICAgIH1cbiAgfVxufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9DSFVOS0hFQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuYm9keV9ieXRlcyA9IHBhcnNlSW50KGxpbmUsIDE2KTtcbiAgaWYgKCF0aGlzLmJvZHlfYnl0ZXMpIHtcbiAgICB0aGlzLnN0YXRlID0gJ0JPRFlfQ0hVTktUUkFJTEVSUyc7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGF0ZSA9ICdCT0RZX0NIVU5LJztcbiAgfVxufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9DSFVOSyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHRoaXMuZW5kIC0gdGhpcy5vZmZzZXQsIHRoaXMuYm9keV9ieXRlcyk7XG4gIHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbkJvZHldKHRoaXMuY2h1bmssIHRoaXMub2Zmc2V0LCBsZW5ndGgpKTtcbiAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICB0aGlzLmJvZHlfYnl0ZXMgLT0gbGVuZ3RoO1xuICBpZiAoIXRoaXMuYm9keV9ieXRlcykge1xuICAgIHRoaXMuc3RhdGUgPSAnQk9EWV9DSFVOS0VNUFRZTElORSc7XG4gIH1cbn07XG5cbkhUVFBQYXJzZXIucHJvdG90eXBlLkJPRFlfQ0hVTktFTVBUWUxJTkUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaW5lID0gdGhpcy5jb25zdW1lTGluZSgpO1xuICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydC5lcXVhbChsaW5lLCAnJyk7XG4gIHRoaXMuc3RhdGUgPSAnQk9EWV9DSFVOS0hFQUQnO1xufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9DSFVOS1RSQUlMRVJTID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGluZSA9IHRoaXMuY29uc3VtZUxpbmUoKTtcbiAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobGluZSkge1xuICAgIHRoaXMucGFyc2VIZWFkZXIobGluZSwgdGhpcy50cmFpbGVycyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMudHJhaWxlcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVzZXJDYWxsKCkodGhpc1trT25IZWFkZXJzXSh0aGlzLnRyYWlsZXJzLCAnJykpO1xuICAgIH1cbiAgICB0aGlzLm5leHRSZXF1ZXN0KCk7XG4gIH1cbn07XG5cbkhUVFBQYXJzZXIucHJvdG90eXBlLkJPRFlfUkFXID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5lbmQgLSB0aGlzLm9mZnNldDtcbiAgdGhpcy51c2VyQ2FsbCgpKHRoaXNba09uQm9keV0odGhpcy5jaHVuaywgdGhpcy5vZmZzZXQsIGxlbmd0aCkpO1xuICB0aGlzLm9mZnNldCA9IHRoaXMuZW5kO1xufTtcblxuSFRUUFBhcnNlci5wcm90b3R5cGUuQk9EWV9TSVpFRCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHRoaXMuZW5kIC0gdGhpcy5vZmZzZXQsIHRoaXMuYm9keV9ieXRlcyk7XG4gIHRoaXMudXNlckNhbGwoKSh0aGlzW2tPbkJvZHldKHRoaXMuY2h1bmssIHRoaXMub2Zmc2V0LCBsZW5ndGgpKTtcbiAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICB0aGlzLmJvZHlfYnl0ZXMgLT0gbGVuZ3RoO1xuICBpZiAoIXRoaXMuYm9keV9ieXRlcykge1xuICAgIHRoaXMubmV4dFJlcXVlc3QoKTtcbiAgfVxufTtcblxuLy8gYmFja3dhcmQgY29tcGF0IHRvIG5vZGUgPCAwLjExLjZcblsnSGVhZGVycycsICdIZWFkZXJzQ29tcGxldGUnLCAnQm9keScsICdNZXNzYWdlQ29tcGxldGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBrID0gSFRUUFBhcnNlclsna09uJyArIG5hbWVdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRUUFBhcnNlci5wcm90b3R5cGUsICdvbicgKyBuYW1lLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1trXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHRvKSB7XG4gICAgICAvLyBoYWNrIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICB0aGlzLl9jb21wYXRNb2RlMF8xMSA9IHRydWU7XG4gICAgICBtZXRob2RfY29ubmVjdCA9ICdDT05ORUNUJztcbiAgICAgIHJldHVybiAodGhpc1trXSA9IHRvKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIHBhcnNlRXJyb3JDb2RlKGNvZGUpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUGFyc2UgRXJyb3InKTtcbiAgZXJyLmNvZGUgPSBjb2RlO1xuICByZXR1cm4gZXJyO1xufVxuXG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBQYXJzZXIgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzApLFxuICAgIFBpcGVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cbnZhciBFeHRlbnNpb25zID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3JzdjEgPSB0aGlzLl9yc3YyID0gdGhpcy5fcnN2MyA9IG51bGw7XG5cbiAgdGhpcy5fYnlOYW1lICAgPSB7fTtcbiAgdGhpcy5faW5PcmRlciAgPSBbXTtcbiAgdGhpcy5fc2Vzc2lvbnMgPSBbXTtcbiAgdGhpcy5faW5kZXggICAgPSB7fTtcbn07XG5cbkV4dGVuc2lvbnMuTUVTU0FHRV9PUENPREVTID0gWzEsIDJdO1xuXG52YXIgaW5zdGFuY2UgPSB7XG4gIGFkZDogZnVuY3Rpb24oZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBleHQubmFtZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4dGVuc2lvbi5uYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICBpZiAoZXh0LnR5cGUgIT09ICdwZXJtZXNzYWdlJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0ZW5zaW9uLnR5cGUgbXVzdCBiZSBcInBlcm1lc3NhZ2VcIicpO1xuXG4gICAgaWYgKHR5cGVvZiBleHQucnN2MSAhPT0gJ2Jvb2xlYW4nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHRlbnNpb24ucnN2MSBtdXN0IGJlIHRydWUgb3IgZmFsc2UnKTtcbiAgICBpZiAodHlwZW9mIGV4dC5yc3YyICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4dGVuc2lvbi5yc3YyIG11c3QgYmUgdHJ1ZSBvciBmYWxzZScpO1xuICAgIGlmICh0eXBlb2YgZXh0LnJzdjMgIT09ICdib29sZWFuJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0ZW5zaW9uLnJzdjMgbXVzdCBiZSB0cnVlIG9yIGZhbHNlJyk7XG5cbiAgICBpZiAodGhpcy5fYnlOYW1lLmhhc093blByb3BlcnR5KGV4dC5uYW1lKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FuIGV4dGVuc2lvbiB3aXRoIG5hbWUgXCInICsgZXh0Lm5hbWUgKyAnXCIgaXMgYWxyZWFkeSByZWdpc3RlcmVkJyk7XG5cbiAgICB0aGlzLl9ieU5hbWVbZXh0Lm5hbWVdID0gZXh0O1xuICAgIHRoaXMuX2luT3JkZXIucHVzaChleHQpO1xuICB9LFxuXG4gIGdlbmVyYXRlT2ZmZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZXNzaW9ucyA9IFtdLFxuICAgICAgICBvZmZlciAgICA9IFtdLFxuICAgICAgICBpbmRleCAgICA9IHt9O1xuXG4gICAgdGhpcy5faW5PcmRlci5mb3JFYWNoKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgdmFyIHNlc3Npb24gPSBleHQuY3JlYXRlQ2xpZW50U2Vzc2lvbigpO1xuICAgICAgaWYgKCFzZXNzaW9uKSByZXR1cm47XG5cbiAgICAgIHZhciByZWNvcmQgPSBbZXh0LCBzZXNzaW9uXTtcbiAgICAgIHNlc3Npb25zLnB1c2gocmVjb3JkKTtcbiAgICAgIGluZGV4W2V4dC5uYW1lXSA9IHJlY29yZDtcblxuICAgICAgdmFyIG9mZmVycyA9IHNlc3Npb24uZ2VuZXJhdGVPZmZlcigpO1xuICAgICAgb2ZmZXJzID0gb2ZmZXJzID8gW10uY29uY2F0KG9mZmVycykgOiBbXTtcblxuICAgICAgb2ZmZXJzLmZvckVhY2goZnVuY3Rpb24ob2ZmKSB7XG4gICAgICAgIG9mZmVyLnB1c2goUGFyc2VyLnNlcmlhbGl6ZVBhcmFtcyhleHQubmFtZSwgb2ZmKSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX3Nlc3Npb25zID0gc2Vzc2lvbnM7XG4gICAgdGhpcy5faW5kZXggICAgPSBpbmRleDtcblxuICAgIHJldHVybiBvZmZlci5sZW5ndGggPiAwID8gb2ZmZXIuam9pbignLCAnKSA6IG51bGw7XG4gIH0sXG5cbiAgYWN0aXZhdGU6IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIHZhciByZXNwb25zZXMgPSBQYXJzZXIucGFyc2VIZWFkZXIoaGVhZGVyKSxcbiAgICAgICAgc2Vzc2lvbnMgID0gW107XG5cbiAgICByZXNwb25zZXMuZWFjaE9mZmVyKGZ1bmN0aW9uKG5hbWUsIHBhcmFtcykge1xuICAgICAgdmFyIHJlY29yZCA9IHRoaXMuX2luZGV4W25hbWVdO1xuXG4gICAgICBpZiAoIXJlY29yZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgc2VudCBhbiBleHRlbnNpb24gcmVzcG9uc2UgZm9yIHVua25vd24gZXh0ZW5zaW9uIFwiJyArIG5hbWUgKyAnXCInKTtcblxuICAgICAgdmFyIGV4dCAgICAgID0gcmVjb3JkWzBdLFxuICAgICAgICAgIHNlc3Npb24gID0gcmVjb3JkWzFdLFxuICAgICAgICAgIHJlc2VydmVkID0gdGhpcy5fcmVzZXJ2ZWQoZXh0KTtcblxuICAgICAgaWYgKHJlc2VydmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBzZW50IHR3byBleHRlbnNpb24gcmVzcG9uc2VzIHRoYXQgdXNlIHRoZSBSU1YnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2VydmVkWzBdICsgJyBiaXQ6IFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNlcnZlZFsxXSArICdcIiBhbmQgXCInICsgZXh0Lm5hbWUgKyAnXCInKTtcblxuICAgICAgaWYgKHNlc3Npb24uYWN0aXZhdGUocGFyYW1zKSAhPT0gdHJ1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgc2VudCB1bmFjY2VwdGFibGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgUGFyc2VyLnNlcmlhbGl6ZVBhcmFtcyhuYW1lLCBwYXJhbXMpKTtcblxuICAgICAgdGhpcy5fcmVzZXJ2ZShleHQpO1xuICAgICAgc2Vzc2lvbnMucHVzaChyZWNvcmQpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fc2Vzc2lvbnMgPSBzZXNzaW9ucztcbiAgICB0aGlzLl9waXBlbGluZSA9IG5ldyBQaXBlbGluZShzZXNzaW9ucyk7XG4gIH0sXG5cbiAgZ2VuZXJhdGVSZXNwb25zZTogZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgdmFyIHNlc3Npb25zID0gW10sXG4gICAgICAgIHJlc3BvbnNlID0gW10sXG4gICAgICAgIG9mZmVycyAgID0gUGFyc2VyLnBhcnNlSGVhZGVyKGhlYWRlcik7XG5cbiAgICB0aGlzLl9pbk9yZGVyLmZvckVhY2goZnVuY3Rpb24oZXh0KSB7XG4gICAgICB2YXIgb2ZmZXIgPSBvZmZlcnMuYnlOYW1lKGV4dC5uYW1lKTtcbiAgICAgIGlmIChvZmZlci5sZW5ndGggPT09IDAgfHwgdGhpcy5fcmVzZXJ2ZWQoZXh0KSkgcmV0dXJuO1xuXG4gICAgICB2YXIgc2Vzc2lvbiA9IGV4dC5jcmVhdGVTZXJ2ZXJTZXNzaW9uKG9mZmVyKTtcbiAgICAgIGlmICghc2Vzc2lvbikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9yZXNlcnZlKGV4dCk7XG4gICAgICBzZXNzaW9ucy5wdXNoKFtleHQsIHNlc3Npb25dKTtcbiAgICAgIHJlc3BvbnNlLnB1c2goUGFyc2VyLnNlcmlhbGl6ZVBhcmFtcyhleHQubmFtZSwgc2Vzc2lvbi5nZW5lcmF0ZVJlc3BvbnNlKCkpKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX3Nlc3Npb25zID0gc2Vzc2lvbnM7XG4gICAgdGhpcy5fcGlwZWxpbmUgPSBuZXcgUGlwZWxpbmUoc2Vzc2lvbnMpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmxlbmd0aCA+IDAgPyByZXNwb25zZS5qb2luKCcsICcpIDogbnVsbDtcbiAgfSxcblxuICB2YWxpZEZyYW1lUnN2OiBmdW5jdGlvbihmcmFtZSkge1xuICAgIHZhciBhbGxvd2VkID0geyByc3YxOiBmYWxzZSwgcnN2MjogZmFsc2UsIHJzdjM6IGZhbHNlIH0sXG4gICAgICAgIGV4dDtcblxuICAgIGlmIChFeHRlbnNpb25zLk1FU1NBR0VfT1BDT0RFUy5pbmRleE9mKGZyYW1lLm9wY29kZSkgPj0gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLl9zZXNzaW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZXh0ID0gdGhpcy5fc2Vzc2lvbnNbaV1bMF07XG4gICAgICAgIGFsbG93ZWQucnN2MSA9IGFsbG93ZWQucnN2MSB8fCBleHQucnN2MTtcbiAgICAgICAgYWxsb3dlZC5yc3YyID0gYWxsb3dlZC5yc3YyIHx8IGV4dC5yc3YyO1xuICAgICAgICBhbGxvd2VkLnJzdjMgPSBhbGxvd2VkLnJzdjMgfHwgZXh0LnJzdjM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChhbGxvd2VkLnJzdjEgfHwgIWZyYW1lLnJzdjEpICYmXG4gICAgICAgICAgIChhbGxvd2VkLnJzdjIgfHwgIWZyYW1lLnJzdjIpICYmXG4gICAgICAgICAgIChhbGxvd2VkLnJzdjMgfHwgIWZyYW1lLnJzdjMpO1xuICB9LFxuXG4gIHByb2Nlc3NJbmNvbWluZ01lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcGlwZWxpbmUucHJvY2Vzc0luY29taW5nTWVzc2FnZShtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCk7XG4gIH0sXG5cbiAgcHJvY2Vzc091dGdvaW5nTWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9waXBlbGluZS5wcm9jZXNzT3V0Z29pbmdNZXNzYWdlKG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuX3BpcGVsaW5lKSByZXR1cm4gY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgICB0aGlzLl9waXBlbGluZS5jbG9zZShjYWxsYmFjaywgY29udGV4dCk7XG4gIH0sXG5cbiAgX3Jlc2VydmU6IGZ1bmN0aW9uKGV4dCkge1xuICAgIHRoaXMuX3JzdjEgPSB0aGlzLl9yc3YxIHx8IChleHQucnN2MSAmJiBleHQubmFtZSk7XG4gICAgdGhpcy5fcnN2MiA9IHRoaXMuX3JzdjIgfHwgKGV4dC5yc3YyICYmIGV4dC5uYW1lKTtcbiAgICB0aGlzLl9yc3YzID0gdGhpcy5fcnN2MyB8fCAoZXh0LnJzdjMgJiYgZXh0Lm5hbWUpO1xuICB9LFxuXG4gIF9yZXNlcnZlZDogZnVuY3Rpb24oZXh0KSB7XG4gICAgaWYgKHRoaXMuX3JzdjEgJiYgZXh0LnJzdjEpIHJldHVybiBbMSwgdGhpcy5fcnN2MV07XG4gICAgaWYgKHRoaXMuX3JzdjIgJiYgZXh0LnJzdjIpIHJldHVybiBbMiwgdGhpcy5fcnN2Ml07XG4gICAgaWYgKHRoaXMuX3JzdjMgJiYgZXh0LnJzdjMpIHJldHVybiBbMywgdGhpcy5fcnN2M107XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIEV4dGVuc2lvbnMucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuc2lvbnM7XG5cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgVE9LRU4gICAgPSAvKFshI1xcJCUmJ1xcKlxcK1xcLVxcLlxcXl9gXFx8fjAtOUEtWmEtel0rKS8sXG4gICAgTk9UT0tFTiAgPSAvKFteISNcXCQlJidcXCpcXCtcXC1cXC5cXF5fYFxcfH4wLTlBLVphLXpdKS9nLFxuICAgIFFVT1RFRCAgID0gL1wiKCg/OlxcXFxbXFx4MDAtXFx4N2ZdfFteXFx4MDAtXFx4MDhcXHgwYS1cXHgxZlxceDdmXCJcXFxcXSkqKVwiLyxcbiAgICBQQVJBTSAgICA9IG5ldyBSZWdFeHAoVE9LRU4uc291cmNlICsgJyg/Oj0oPzonICsgVE9LRU4uc291cmNlICsgJ3wnICsgUVVPVEVELnNvdXJjZSArICcpKT8nKSxcbiAgICBFWFQgICAgICA9IG5ldyBSZWdFeHAoVE9LRU4uc291cmNlICsgJyg/OiAqOyAqJyArIFBBUkFNLnNvdXJjZSArICcpKicsICdnJyksXG4gICAgRVhUX0xJU1QgPSBuZXcgUmVnRXhwKCdeJyArIEVYVC5zb3VyY2UgKyAnKD86ICosIConICsgRVhULnNvdXJjZSArICcpKiQnKSxcbiAgICBOVU1CRVIgICA9IC9eLT8oMHxbMS05XVswLTldKikoXFwuWzAtOV0rKT8kLztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFBhcnNlciA9IHtcbiAgcGFyc2VIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIHZhciBvZmZlcnMgPSBuZXcgT2ZmZXJzKCk7XG4gICAgaWYgKGhlYWRlciA9PT0gJycgfHwgaGVhZGVyID09PSB1bmRlZmluZWQpIHJldHVybiBvZmZlcnM7XG5cbiAgICBpZiAoIUVYVF9MSVNULnRlc3QoaGVhZGVyKSlcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyOiAnICsgaGVhZGVyKTtcblxuICAgIHZhciB2YWx1ZXMgPSBoZWFkZXIubWF0Y2goRVhUKTtcblxuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgcGFyYW1zID0gdmFsdWUubWF0Y2gobmV3IFJlZ0V4cChQQVJBTS5zb3VyY2UsICdnJykpLFxuICAgICAgICAgIG5hbWUgICA9IHBhcmFtcy5zaGlmdCgpLFxuICAgICAgICAgIG9mZmVyICA9IHt9O1xuXG4gICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICB2YXIgYXJncyA9IHBhcmFtLm1hdGNoKFBBUkFNKSwga2V5ID0gYXJnc1sxXSwgZGF0YTtcblxuICAgICAgICBpZiAoYXJnc1syXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGF0YSA9IGFyZ3NbMl07XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGF0YSA9IGFyZ3NbM10ucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE5VTUJFUi50ZXN0KGRhdGEpKSBkYXRhID0gcGFyc2VGbG9hdChkYXRhKTtcblxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvZmZlciwga2V5KSkge1xuICAgICAgICAgIG9mZmVyW2tleV0gPSBbXS5jb25jYXQob2ZmZXJba2V5XSk7XG4gICAgICAgICAgb2ZmZXJba2V5XS5wdXNoKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZmVyW2tleV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIG9mZmVycy5wdXNoKG5hbWUsIG9mZmVyKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiBvZmZlcnM7XG4gIH0sXG5cbiAgc2VyaWFsaXplUGFyYW1zOiBmdW5jdGlvbihuYW1lLCBwYXJhbXMpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICB2YXIgcHJpbnQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHsgcHJpbnQoa2V5LCB2KSB9KTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YWx1ZXMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKE5PVE9LRU4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goa2V5ICsgJz1cIicgKyB2YWx1ZS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykgcHJpbnQoa2V5LCBwYXJhbXNba2V5XSk7XG5cbiAgICByZXR1cm4gW25hbWVdLmNvbmNhdCh2YWx1ZXMpLmpvaW4oJzsgJyk7XG4gIH1cbn07XG5cbnZhciBPZmZlcnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYnlOYW1lICA9IHt9O1xuICB0aGlzLl9pbk9yZGVyID0gW107XG59O1xuXG5PZmZlcnMucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihuYW1lLCBwYXJhbXMpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2J5TmFtZSwgbmFtZSkpXG4gICAgdGhpcy5fYnlOYW1lW25hbWVdID0gW107XG5cbiAgdGhpcy5fYnlOYW1lW25hbWVdLnB1c2gocGFyYW1zKTtcbiAgdGhpcy5faW5PcmRlci5wdXNoKHsgbmFtZTogbmFtZSwgcGFyYW1zOiBwYXJhbXMgfSk7XG59O1xuXG5PZmZlcnMucHJvdG90eXBlLmVhY2hPZmZlciA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ID0gdGhpcy5faW5PcmRlcjtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBsaXN0Lmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGxpc3RbaV0ubmFtZSwgbGlzdFtpXS5wYXJhbXMpO1xufTtcblxuT2ZmZXJzLnByb3RvdHlwZS5ieU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9ieU5hbWVbbmFtZV0gfHwgW107XG59O1xuXG5PZmZlcnMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2luT3JkZXIuc2xpY2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyO1xuXG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIENlbGwgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpLFxuICAgIFBsZWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgUGlwZWxpbmUgPSBmdW5jdGlvbihzZXNzaW9ucykge1xuICB0aGlzLl9jZWxscyAgID0gc2Vzc2lvbnMubWFwKGZ1bmN0aW9uKHNlc3Npb24pIHsgcmV0dXJuIG5ldyBDZWxsKHNlc3Npb24pIH0pO1xuICB0aGlzLl9zdG9wcGVkID0geyBpbmNvbWluZzogZmFsc2UsIG91dGdvaW5nOiBmYWxzZSB9O1xufTtcblxuUGlwZWxpbmUucHJvdG90eXBlLnByb2Nlc3NJbmNvbWluZ01lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAodGhpcy5fc3RvcHBlZC5pbmNvbWluZykgcmV0dXJuO1xuICB0aGlzLl9sb29wKCdpbmNvbWluZycsIHRoaXMuX2NlbGxzLmxlbmd0aCAtIDEsIC0xLCAtMSwgbWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xufTtcblxuUGlwZWxpbmUucHJvdG90eXBlLnByb2Nlc3NPdXRnb2luZ01lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAodGhpcy5fc3RvcHBlZC5vdXRnb2luZykgcmV0dXJuO1xuICB0aGlzLl9sb29wKCdvdXRnb2luZycsIDAsIHRoaXMuX2NlbGxzLmxlbmd0aCwgMSwgbWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xufTtcblxuUGlwZWxpbmUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgdGhpcy5fc3RvcHBlZCA9IHsgaW5jb21pbmc6IHRydWUsIG91dGdvaW5nOiB0cnVlIH07XG5cbiAgdmFyIGNsb3NlZCA9IHRoaXMuX2NlbGxzLm1hcChmdW5jdGlvbihhKSB7IHJldHVybiBhLmNsb3NlKCkgfSk7XG4gIGlmIChjYWxsYmFjaylcbiAgICBQbGVkZ2UuYWxsKGNsb3NlZCkudGhlbihmdW5jdGlvbigpIHsgY2FsbGJhY2suY2FsbChjb250ZXh0KSB9KTtcbn07XG5cblBpcGVsaW5lLnByb3RvdHlwZS5fbG9vcCA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgc3RhcnQsIGVuZCwgc3RlcCwgbWVzc2FnZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgdmFyIGNlbGxzID0gdGhpcy5fY2VsbHMsXG4gICAgICBuICAgICA9IGNlbGxzLmxlbmd0aCxcbiAgICAgIHNlbGYgID0gdGhpcztcblxuICB3aGlsZSAobi0tKSBjZWxsc1tuXS5wZW5kaW5nKGRpcmVjdGlvbik7XG5cbiAgdmFyIHBpcGUgPSBmdW5jdGlvbihpbmRleCwgZXJyb3IsIG1zZykge1xuICAgIGlmIChpbmRleCA9PT0gZW5kKSByZXR1cm4gY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnJvciwgbXNnKTtcblxuICAgIGNlbGxzW2luZGV4XVtkaXJlY3Rpb25dKGVycm9yLCBtc2csIGZ1bmN0aW9uKGVyciwgbSkge1xuICAgICAgaWYgKGVycikgc2VsZi5fc3RvcHBlZFtkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgIHBpcGUoaW5kZXggKyBzdGVwLCBlcnIsIG0pO1xuICAgIH0pO1xuICB9O1xuICBwaXBlKHN0YXJ0LCBudWxsLCBtZXNzYWdlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGlwZWxpbmU7XG5cblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRnVuY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpLFxuICAgIFBsZWRnZSAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIENlbGwgPSBmdW5jdGlvbih0dXBsZSkge1xuICB0aGlzLl9leHQgICAgID0gdHVwbGVbMF07XG4gIHRoaXMuX3Nlc3Npb24gPSB0dXBsZVsxXTtcblxuICB0aGlzLl9mdW5jdG9ycyA9IHtcbiAgICBpbmNvbWluZzogbmV3IEZ1bmN0b3IodGhpcy5fc2Vzc2lvbiwgJ3Byb2Nlc3NJbmNvbWluZ01lc3NhZ2UnKSxcbiAgICBvdXRnb2luZzogbmV3IEZ1bmN0b3IodGhpcy5fc2Vzc2lvbiwgJ3Byb2Nlc3NPdXRnb2luZ01lc3NhZ2UnKVxuICB9O1xufTtcblxuQ2VsbC5wcm90b3R5cGUucGVuZGluZyA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICB2YXIgZnVuY3RvciA9IHRoaXMuX2Z1bmN0b3JzW2RpcmVjdGlvbl07XG4gIGlmICghZnVuY3Rvci5fc3RvcHBlZCkgZnVuY3Rvci5wZW5kaW5nICs9IDE7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5pbmNvbWluZyA9IGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICB0aGlzLl9leGVjKCdpbmNvbWluZycsIGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCk7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5vdXRnb2luZyA9IGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICB0aGlzLl9leGVjKCdvdXRnb2luZycsIGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCk7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbG9zZWQgPSB0aGlzLl9jbG9zZWQgfHwgbmV3IFBsZWRnZSgpO1xuICB0aGlzLl9kb0Nsb3NlKCk7XG4gIHJldHVybiB0aGlzLl9jbG9zZWQ7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5fZXhlYyA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZXJyb3IsIG1lc3NhZ2UsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIHRoaXMuX2Z1bmN0b3JzW2RpcmVjdGlvbl0uY2FsbChlcnJvciwgbWVzc2FnZSwgZnVuY3Rpb24oZXJyLCBtc2cpIHtcbiAgICBpZiAoZXJyKSBlcnIubWVzc2FnZSA9IHRoaXMuX2V4dC5uYW1lICsgJzogJyArIGVyci5tZXNzYWdlO1xuICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyLCBtc2cpO1xuICAgIHRoaXMuX2RvQ2xvc2UoKTtcbiAgfSwgdGhpcyk7XG59O1xuXG5DZWxsLnByb3RvdHlwZS5fZG9DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmluICA9IHRoaXMuX2Z1bmN0b3JzLmluY29taW5nLFxuICAgICAgZm91dCA9IHRoaXMuX2Z1bmN0b3JzLm91dGdvaW5nO1xuXG4gIGlmICghdGhpcy5fY2xvc2VkIHx8IGZpbi5wZW5kaW5nICsgZm91dC5wZW5kaW5nICE9PSAwKSByZXR1cm47XG4gIGlmICh0aGlzLl9zZXNzaW9uKSB0aGlzLl9zZXNzaW9uLmNsb3NlKCk7XG4gIHRoaXMuX3Nlc3Npb24gPSBudWxsO1xuICB0aGlzLl9jbG9zZWQuZG9uZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsO1xuXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFJpbmdCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIEZ1bmN0b3IgPSBmdW5jdGlvbihzZXNzaW9uLCBtZXRob2QpIHtcbiAgdGhpcy5fc2Vzc2lvbiA9IHNlc3Npb247XG4gIHRoaXMuX21ldGhvZCAgPSBtZXRob2Q7XG4gIHRoaXMuX3F1ZXVlICAgPSBuZXcgUmluZ0J1ZmZlcihGdW5jdG9yLlFVRVVFX1NJWkUpO1xuICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gIHRoaXMucGVuZGluZyAgPSAwO1xufTtcblxuRnVuY3Rvci5RVUVVRV9TSVpFID0gODtcblxuRnVuY3Rvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKGVycm9yLCBtZXNzYWdlLCBjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAodGhpcy5fc3RvcHBlZCkgcmV0dXJuO1xuXG4gIHZhciByZWNvcmQgPSB7IGVycm9yOiBlcnJvciwgbWVzc2FnZTogbWVzc2FnZSwgY2FsbGJhY2s6IGNhbGxiYWNrLCBjb250ZXh0OiBjb250ZXh0LCBkb25lOiBmYWxzZSB9LFxuICAgICAgY2FsbGVkID0gZmFsc2UsXG4gICAgICBzZWxmICAgPSB0aGlzO1xuXG4gIHRoaXMuX3F1ZXVlLnB1c2gocmVjb3JkKTtcblxuICBpZiAocmVjb3JkLmVycm9yKSB7XG4gICAgcmVjb3JkLmRvbmUgPSB0cnVlO1xuICAgIHRoaXMuX3N0b3AoKTtcbiAgICByZXR1cm4gdGhpcy5fZmx1c2hRdWV1ZSgpO1xuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihlcnIsIG1zZykge1xuICAgIGlmICghKGNhbGxlZCBeIChjYWxsZWQgPSB0cnVlKSkpIHJldHVybjtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHNlbGYuX3N0b3AoKTtcbiAgICAgIHJlY29yZC5lcnJvciAgID0gZXJyO1xuICAgICAgcmVjb3JkLm1lc3NhZ2UgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvcmQubWVzc2FnZSA9IG1zZztcbiAgICB9XG5cbiAgICByZWNvcmQuZG9uZSA9IHRydWU7XG4gICAgc2VsZi5fZmx1c2hRdWV1ZSgpO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgdGhpcy5fc2Vzc2lvblt0aGlzLl9tZXRob2RdKG1lc3NhZ2UsIGhhbmRsZXIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBoYW5kbGVyKGVycik7XG4gIH1cbn07XG5cbkZ1bmN0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGVuZGluZyAgPSB0aGlzLl9xdWV1ZS5sZW5ndGg7XG4gIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xufTtcblxuRnVuY3Rvci5wcm90b3R5cGUuX2ZsdXNoUXVldWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWUsIHJlY29yZDtcblxuICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCAmJiBxdWV1ZS5wZWVrKCkuZG9uZSkge1xuICAgIHJlY29yZCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKHJlY29yZC5lcnJvcikge1xuICAgICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgICAgIHF1ZXVlLmNsZWFyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGVuZGluZyAtPSAxO1xuICAgIH1cbiAgICByZWNvcmQuY2FsbGJhY2suY2FsbChyZWNvcmQuY29udGV4dCwgcmVjb3JkLmVycm9yLCByZWNvcmQubWVzc2FnZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3RvcjtcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGcmFtZSA9IGZ1bmN0aW9uKCkge307XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgZmluYWw6ICAgICAgICBmYWxzZSxcbiAgcnN2MTogICAgICAgICBmYWxzZSxcbiAgcnN2MjogICAgICAgICBmYWxzZSxcbiAgcnN2MzogICAgICAgICBmYWxzZSxcbiAgb3Bjb2RlOiAgICAgICBudWxsLFxuICBtYXNrZWQ6ICAgICAgIGZhbHNlLFxuICBtYXNraW5nS2V5OiAgIG51bGwsXG4gIGxlbmd0aEJ5dGVzOiAgMSxcbiAgbGVuZ3RoOiAgICAgICAwLFxuICBwYXlsb2FkOiAgICAgIG51bGxcbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgRnJhbWUucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lO1xuXG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuQnVmZmVyO1xuXG52YXIgTWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJzdjEgICAgPSBmYWxzZTtcbiAgdGhpcy5yc3YyICAgID0gZmFsc2U7XG4gIHRoaXMucnN2MyAgICA9IGZhbHNlO1xuICB0aGlzLm9wY29kZSAgPSBudWxsO1xuICB0aGlzLmxlbmd0aCAgPSAwO1xuICB0aGlzLl9jaHVua3MgPSBbXTtcbn07XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSA9IHRoaXMuZGF0YSB8fCBCdWZmZXIuY29uY2F0KHRoaXMuX2NodW5rcywgdGhpcy5sZW5ndGgpO1xuICB9LFxuXG4gIHB1c2hGcmFtZTogZnVuY3Rpb24oZnJhbWUpIHtcbiAgICB0aGlzLnJzdjEgPSB0aGlzLnJzdjEgfHwgZnJhbWUucnN2MTtcbiAgICB0aGlzLnJzdjIgPSB0aGlzLnJzdjIgfHwgZnJhbWUucnN2MjtcbiAgICB0aGlzLnJzdjMgPSB0aGlzLnJzdjMgfHwgZnJhbWUucnN2MztcblxuICAgIGlmICh0aGlzLm9wY29kZSA9PT0gbnVsbCkgdGhpcy5vcGNvZGUgPSBmcmFtZS5vcGNvZGU7XG5cbiAgICB0aGlzLl9jaHVua3MucHVzaChmcmFtZS5wYXlsb2FkKTtcbiAgICB0aGlzLmxlbmd0aCArPSBmcmFtZS5sZW5ndGg7XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgTWVzc2FnZS5wcm90b3R5cGVba2V5XSA9IGluc3RhbmNlW2tleV07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZTtcblxuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBCdWZmZXIgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5CdWZmZXIsXG4gICAgU3RyZWFtICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuU3RyZWFtLFxuICAgIHVybCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICAgIHV0aWwgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIEJhc2UgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuICAgIEhlYWRlcnMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLFxuICAgIEh0dHBQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIFBPUlRTID0geyAnd3M6JzogODAsICd3c3M6JzogNDQzIH07XG5cbnZhciBQcm94eSA9IGZ1bmN0aW9uKGNsaWVudCwgb3JpZ2luLCBvcHRpb25zKSB7XG4gIHRoaXMuX2NsaWVudCAgPSBjbGllbnQ7XG4gIHRoaXMuX2h0dHAgICAgPSBuZXcgSHR0cFBhcnNlcigncmVzcG9uc2UnKTtcbiAgdGhpcy5fb3JpZ2luICA9ICh0eXBlb2YgY2xpZW50LnVybCA9PT0gJ29iamVjdCcpID8gY2xpZW50LnVybCA6IHVybC5wYXJzZShjbGllbnQudXJsKTtcbiAgdGhpcy5fdXJsICAgICA9ICh0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JykgPyBvcmlnaW4gOiB1cmwucGFyc2Uob3JpZ2luKTtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX3N0YXRlICAgPSAwO1xuXG4gIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5fcGF1c2VkICA9IGZhbHNlO1xuXG4gIHRoaXMuX2hlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnSG9zdCcsIHRoaXMuX29yaWdpbi5ob3N0KTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ0Nvbm5lY3Rpb24nLCAna2VlcC1hbGl2ZScpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnUHJveHktQ29ubmVjdGlvbicsICdrZWVwLWFsaXZlJyk7XG5cbiAgdmFyIGF1dGggPSB0aGlzLl91cmwuYXV0aCAmJiBCdWZmZXIuZnJvbSh0aGlzLl91cmwuYXV0aCwgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGlmIChhdXRoKSB0aGlzLl9oZWFkZXJzLnNldCgnUHJveHktQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgYXV0aCk7XG59O1xudXRpbC5pbmhlcml0cyhQcm94eSwgU3RyZWFtKTtcblxudmFyIGluc3RhbmNlID0ge1xuICBzZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5faGVhZGVycy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IDApIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IDE7XG5cbiAgICB2YXIgb3JpZ2luID0gdGhpcy5fb3JpZ2luLFxuICAgICAgICBwb3J0ICAgPSBvcmlnaW4ucG9ydCB8fCBQT1JUU1tvcmlnaW4ucHJvdG9jb2xdLFxuICAgICAgICBzdGFydCAgPSAnQ09OTkVDVCAnICsgb3JpZ2luLmhvc3RuYW1lICsgJzonICsgcG9ydCArICcgSFRUUC8xLjEnO1xuXG4gICAgdmFyIGhlYWRlcnMgPSBbc3RhcnQsIHRoaXMuX2hlYWRlcnMudG9TdHJpbmcoKSwgJyddO1xuXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgQnVmZmVyLmZyb20oaGVhZGVycy5qb2luKCdcXHJcXG4nKSwgJ3V0ZjgnKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG5cbiAgcmVzdW1lOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0sXG5cbiAgd3JpdGU6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICB0aGlzLl9odHRwLnBhcnNlKGNodW5rKTtcbiAgICBpZiAoIXRoaXMuX2h0dHAuaXNDb21wbGV0ZSgpKSByZXR1cm4gIXRoaXMuX3BhdXNlZDtcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHRoaXMuX2h0dHAuc3RhdHVzQ29kZTtcbiAgICB0aGlzLmhlYWRlcnMgICAgPSB0aGlzLl9odHRwLmhlYWRlcnM7XG5cbiAgICBpZiAodGhpcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIG5ldyBCYXNlLkNvbm5lY3RFdmVudCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBcIkNhbid0IGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBhdCBcIiArIHRoaXMuX29yaWdpbi5ocmVmO1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgfVxuICAgIHRoaXMuZW5kKCk7XG4gICAgcmV0dXJuICF0aGlzLl9wYXVzZWQ7XG4gIH0sXG5cbiAgZW5kOiBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmICghdGhpcy53cml0YWJsZSkgcmV0dXJuO1xuICAgIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rKTtcbiAgICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW5kKCk7XG4gIH1cbn07XG5cbmZvciAodmFyIGtleSBpbiBpbnN0YW5jZSlcbiAgUHJveHkucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3h5O1xuXG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIEh0dHBQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSxcbiAgICBCYXNlICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgICBEcmFmdDc1ICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG4gICAgRHJhZnQ3NiAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpLFxuICAgIEh5YmkgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIFNlcnZlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIG51bGwsIG51bGwsIG9wdGlvbnMpO1xuICB0aGlzLl9odHRwID0gbmV3IEh0dHBQYXJzZXIoJ3JlcXVlc3QnKTtcbn07XG51dGlsLmluaGVyaXRzKFNlcnZlciwgQmFzZSk7XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgRVZFTlRTOiBbJ29wZW4nLCAnbWVzc2FnZScsICdlcnJvcicsICdjbG9zZScsICdwaW5nJywgJ3BvbmcnXSxcblxuICBfYmluZEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge30pO1xuICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7fSk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlKSByZXR1cm4gdGhpcy5fZGVsZWdhdGUucGFyc2UoY2h1bmspO1xuXG4gICAgdGhpcy5faHR0cC5wYXJzZShjaHVuayk7XG4gICAgaWYgKCF0aGlzLl9odHRwLmlzQ29tcGxldGUoKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5tZXRob2QgID0gdGhpcy5faHR0cC5tZXRob2Q7XG4gICAgdGhpcy51cmwgICAgID0gdGhpcy5faHR0cC51cmw7XG4gICAgdGhpcy5oZWFkZXJzID0gdGhpcy5faHR0cC5oZWFkZXJzO1xuICAgIHRoaXMuYm9keSAgICA9IHRoaXMuX2h0dHAuYm9keTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9kZWxlZ2F0ZSA9IFNlcnZlci5odHRwKHRoaXMsIHRoaXMuX29wdGlvbnMpO1xuICAgIHRoaXMuX2RlbGVnYXRlLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcztcbiAgICB0aGlzLl9kZWxlZ2F0ZS5pbyA9IHRoaXMuaW87XG4gICAgdGhpcy5fb3BlbigpO1xuXG4gICAgdGhpcy5FVkVOVFMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgdGhpcy5fZGVsZWdhdGUub24oZXZlbnQsIGZ1bmN0aW9uKGUpIHsgc2VsZi5lbWl0KGV2ZW50LCBlKSB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMucHJvdG9jb2wgPSB0aGlzLl9kZWxlZ2F0ZS5wcm90b2NvbDtcbiAgICB0aGlzLnZlcnNpb24gID0gdGhpcy5fZGVsZWdhdGUudmVyc2lvbjtcblxuICAgIHRoaXMucGFyc2UodGhpcy5faHR0cC5ib2R5KTtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBuZXcgQmFzZS5Db25uZWN0RXZlbnQoKSk7XG4gIH0sXG5cbiAgX29wZW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX19xdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKG1zZykge1xuICAgICAgdGhpcy5fZGVsZWdhdGVbbXNnWzBdXS5hcHBseSh0aGlzLl9kZWxlZ2F0ZSwgbXNnWzFdKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9fcXVldWUgPSBbXTtcbiAgfVxufTtcblxuWydhZGRFeHRlbnNpb24nLCAnc2V0SGVhZGVyJywgJ3N0YXJ0JywgJ2ZyYW1lJywgJ3RleHQnLCAnYmluYXJ5JywgJ3BpbmcnLCAnY2xvc2UnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpbnN0YW5jZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGVbbWV0aG9kXS5hcHBseSh0aGlzLl9kZWxlZ2F0ZSwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX3F1ZXVlLnB1c2goW21ldGhvZCwgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG59KTtcblxuZm9yICh2YXIga2V5IGluIGluc3RhbmNlKVxuICBTZXJ2ZXIucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5TZXJ2ZXIuaXNTZWN1cmVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5jb25uZWN0aW9uICYmIHJlcXVlc3QuY29ubmVjdGlvbi5hdXRob3JpemVkICE9PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICBpZiAocmVxdWVzdC5zb2NrZXQgJiYgcmVxdWVzdC5zb2NrZXQuc2VjdXJlKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcbiAgaWYgKCFoZWFkZXJzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChoZWFkZXJzWydodHRwcyddID09PSAnb24nKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGhlYWRlcnNbJ3gtZm9yd2FyZGVkLXNzbCddID09PSAnb24nKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGhlYWRlcnNbJ3gtZm9yd2FyZGVkLXNjaGVtZSddID09PSAnaHR0cHMnKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10gPT09ICdodHRwcycpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblNlcnZlci5kZXRlcm1pbmVVcmwgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHZhciBzY2hlbWUgPSB0aGlzLmlzU2VjdXJlUmVxdWVzdChyZXF1ZXN0KSA/ICd3c3M6JyA6ICd3czonO1xuICByZXR1cm4gc2NoZW1lICsgJy8vJyArIHJlcXVlc3QuaGVhZGVycy5ob3N0ICsgcmVxdWVzdC51cmw7XG59O1xuXG5TZXJ2ZXIuaHR0cCA9IGZ1bmN0aW9uKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnJlcXVpcmVNYXNraW5nID09PSB1bmRlZmluZWQpIG9wdGlvbnMucmVxdWlyZU1hc2tpbmcgPSB0cnVlO1xuXG4gIHZhciBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgdmVyc2lvbiA9IGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddLFxuICAgICAga2V5ICAgICA9IGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10sXG4gICAgICBrZXkxICAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXkxJ10sXG4gICAgICBrZXkyICAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXkyJ10sXG4gICAgICB1cmwgICAgID0gdGhpcy5kZXRlcm1pbmVVcmwocmVxdWVzdCk7XG5cbiAgaWYgKHZlcnNpb24gfHwga2V5KVxuICAgIHJldHVybiBuZXcgSHliaShyZXF1ZXN0LCB1cmwsIG9wdGlvbnMpO1xuICBlbHNlIGlmIChrZXkxIHx8IGtleTIpXG4gICAgcmV0dXJuIG5ldyBEcmFmdDc2KHJlcXVlc3QsIHVybCwgb3B0aW9ucyk7XG4gIGVsc2VcbiAgICByZXR1cm4gbmV3IERyYWZ0NzUocmVxdWVzdCwgdXJsLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmVyO1xuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJ1ZmZlciAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJ1ZmZlcixcbiAgICBCYXNlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgICBEcmFmdDc1ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG4gICAgY3J5cHRvICA9IF9fd2VicGFja19yZXF1aXJlX18oMyksXG4gICAgdXRpbCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxudmFyIG51bWJlckZyb21LZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIHBhcnNlSW50KChrZXkubWF0Y2goL1swLTldL2cpIHx8IFtdKS5qb2luKCcnKSwgMTApO1xufTtcblxudmFyIHNwYWNlc0luS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHJldHVybiAoa2V5Lm1hdGNoKC8gL2cpIHx8IFtdKS5sZW5ndGg7XG59O1xuXG5cbnZhciBEcmFmdDc2ID0gZnVuY3Rpb24ocmVxdWVzdCwgdXJsLCBvcHRpb25zKSB7XG4gIERyYWZ0NzUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5fc3RhZ2UgID0gLTE7XG4gIHRoaXMuX2JvZHkgICA9IFtdO1xuICB0aGlzLnZlcnNpb24gPSAnaGl4aWUtNzYnO1xuXG4gIHRoaXMuX2hlYWRlcnMuY2xlYXIoKTtcblxuICB0aGlzLl9oZWFkZXJzLnNldCgnVXBncmFkZScsICdXZWJTb2NrZXQnKTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ0Nvbm5lY3Rpb24nLCAnVXBncmFkZScpO1xuICB0aGlzLl9oZWFkZXJzLnNldCgnU2VjLVdlYlNvY2tldC1PcmlnaW4nLCB0aGlzLl9yZXF1ZXN0LmhlYWRlcnMub3JpZ2luKTtcbiAgdGhpcy5faGVhZGVycy5zZXQoJ1NlYy1XZWJTb2NrZXQtTG9jYXRpb24nLCB0aGlzLnVybCk7XG59O1xudXRpbC5pbmhlcml0cyhEcmFmdDc2LCBEcmFmdDc1KTtcblxudmFyIGluc3RhbmNlID0ge1xuICBCT0RZX1NJWkU6IDgsXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghRHJhZnQ3NS5wcm90b3R5cGUuc3RhcnQuY2FsbCh0aGlzKSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NlbmRIYW5kc2hha2VCb2R5KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDMpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSAxKSB0aGlzLl93cml0ZShCdWZmZXIuZnJvbShbMHhGRiwgMHgwMF0pKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAzO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBuZXcgQmFzZS5DbG9zZUV2ZW50KG51bGwsIG51bGwpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfaGFuZHNoYWtlUmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoZWFkZXJzID0gdGhpcy5fcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgICBrZXkxICAgID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXkxJ10sXG4gICAgICAgIGtleTIgICAgPSBoZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleTInXTtcblxuICAgIGlmICgha2V5MSkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGhlYWRlcjogU2VjLVdlYlNvY2tldC1LZXkxJyk7XG4gICAgaWYgKCFrZXkyKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgaGVhZGVyOiBTZWMtV2ViU29ja2V0LUtleTInKTtcblxuICAgIHZhciBudW1iZXIxID0gbnVtYmVyRnJvbUtleShrZXkxKSxcbiAgICAgICAgc3BhY2VzMSA9IHNwYWNlc0luS2V5KGtleTEpLFxuXG4gICAgICAgIG51bWJlcjIgPSBudW1iZXJGcm9tS2V5KGtleTIpLFxuICAgICAgICBzcGFjZXMyID0gc3BhY2VzSW5LZXkoa2V5Mik7XG5cbiAgICBpZiAobnVtYmVyMSAlIHNwYWNlczEgIT09IDAgfHwgbnVtYmVyMiAlIHNwYWNlczIgIT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBzZW50IGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVycycpO1xuXG4gICAgdGhpcy5fa2V5VmFsdWVzID0gW251bWJlcjEgLyBzcGFjZXMxLCBudW1iZXIyIC8gc3BhY2VzMl07XG5cbiAgICB2YXIgc3RhcnQgICA9ICdIVFRQLzEuMSAxMDEgV2ViU29ja2V0IFByb3RvY29sIEhhbmRzaGFrZScsXG4gICAgICAgIGhlYWRlcnMgPSBbc3RhcnQsIHRoaXMuX2hlYWRlcnMudG9TdHJpbmcoKSwgJyddO1xuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhlYWRlcnMuam9pbignXFxyXFxuJyksICdiaW5hcnknKTtcbiAgfSxcblxuICBfaGFuZHNoYWtlU2lnbmF0dXJlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fYm9keS5sZW5ndGggPCB0aGlzLkJPRFlfU0laRSkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgbWQ1ICAgID0gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLFxuICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoOCArIHRoaXMuQk9EWV9TSVpFKTtcblxuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHRoaXMuX2tleVZhbHVlc1swXSwgMCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5fa2V5VmFsdWVzWzFdLCA0KTtcbiAgICBCdWZmZXIuZnJvbSh0aGlzLl9ib2R5KS5jb3B5KGJ1ZmZlciwgOCwgMCwgdGhpcy5CT0RZX1NJWkUpO1xuXG4gICAgbWQ1LnVwZGF0ZShidWZmZXIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShtZDUuZGlnZXN0KCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICB9LFxuXG4gIF9zZW5kSGFuZHNoYWtlQm9keTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9zdGFydGVkKSByZXR1cm47XG4gICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuX2hhbmRzaGFrZVNpZ25hdHVyZSgpO1xuICAgIGlmICghc2lnbmF0dXJlKSByZXR1cm47XG5cbiAgICB0aGlzLl93cml0ZShzaWduYXR1cmUpO1xuICAgIHRoaXMuX3N0YWdlID0gMDtcbiAgICB0aGlzLl9vcGVuKCk7XG5cbiAgICBpZiAodGhpcy5fYm9keS5sZW5ndGggPiB0aGlzLkJPRFlfU0laRSlcbiAgICAgIHRoaXMucGFyc2UodGhpcy5fYm9keS5zbGljZSh0aGlzLkJPRFlfU0laRSkpO1xuICB9LFxuXG4gIF9wYXJzZUxlYWRpbmdCeXRlOiBmdW5jdGlvbihvY3RldCkge1xuICAgIGlmIChvY3RldCAhPT0gMHhGRilcbiAgICAgIHJldHVybiBEcmFmdDc1LnByb3RvdHlwZS5fcGFyc2VMZWFkaW5nQnl0ZS5jYWxsKHRoaXMsIG9jdGV0KTtcblxuICAgIHRoaXMuX2Nsb3NpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2xlbmd0aCAgPSAwO1xuICAgIHRoaXMuX3N0YWdlICAgPSAxO1xuICB9XG59O1xuXG5mb3IgKHZhciBrZXkgaW4gaW5zdGFuY2UpXG4gIERyYWZ0NzYucHJvdG90eXBlW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWZ0NzY7XG5cblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBuZXQgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKSxcbiAgICB0bHMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKSxcbiAgICB1cmwgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICAgIGRyaXZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCksXG4gICAgQVBJICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSksXG4gICAgRXZlbnQgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIERFRkFVTFRfUE9SVFMgICAgPSB7J2h0dHA6JzogODAsICdodHRwczonOiA0NDMsICd3czonOjgwLCAnd3NzOic6IDQ0M30sXG4gICAgU0VDVVJFX1BST1RPQ09MUyA9IFsnaHR0cHM6JywgJ3dzczonXTtcblxudmFyIENsaWVudCA9IGZ1bmN0aW9uKF91cmwsIHByb3RvY29scywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLnVybCAgICAgPSBfdXJsO1xuICB0aGlzLl9kcml2ZXIgPSBkcml2ZXIuY2xpZW50KHRoaXMudXJsLCB7bWF4TGVuZ3RoOiBvcHRpb25zLm1heExlbmd0aCwgcHJvdG9jb2xzOiBwcm90b2NvbHN9KTtcblxuICBbJ29wZW4nLCAnZXJyb3InXS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5fZHJpdmVyLm9uKGV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuaGVhZGVycyAgICA9IHNlbGYuX2RyaXZlci5oZWFkZXJzO1xuICAgICAgc2VsZi5zdGF0dXNDb2RlID0gc2VsZi5fZHJpdmVyLnN0YXR1c0NvZGU7XG4gICAgfSk7XG4gIH0sIHRoaXMpO1xuXG4gIHZhciBwcm94eSAgICAgID0gb3B0aW9ucy5wcm94eSB8fCB7fSxcbiAgICAgIGVuZHBvaW50ICAgPSB1cmwucGFyc2UocHJveHkub3JpZ2luIHx8IHRoaXMudXJsKSxcbiAgICAgIHBvcnQgICAgICAgPSBlbmRwb2ludC5wb3J0IHx8IERFRkFVTFRfUE9SVFNbZW5kcG9pbnQucHJvdG9jb2xdLFxuICAgICAgc2VjdXJlICAgICA9IFNFQ1VSRV9QUk9UT0NPTFMuaW5kZXhPZihlbmRwb2ludC5wcm90b2NvbCkgPj0gMCxcbiAgICAgIG9uQ29ubmVjdCAgPSBmdW5jdGlvbigpIHsgc2VsZi5fb25Db25uZWN0KCkgfSxcbiAgICAgIG5ldE9wdGlvbnMgPSBvcHRpb25zLm5ldCB8fCB7fSxcbiAgICAgIG9yaWdpblRMUyAgPSBvcHRpb25zLnRscyB8fCB7fSxcbiAgICAgIHNvY2tldFRMUyAgPSBwcm94eS5vcmlnaW4gPyAocHJveHkudGxzIHx8IHt9KSA6IG9yaWdpblRMUyxcbiAgICAgIHNlbGYgICAgICAgPSB0aGlzO1xuXG4gIG5ldE9wdGlvbnMuaG9zdCA9IHNvY2tldFRMUy5ob3N0ID0gZW5kcG9pbnQuaG9zdG5hbWU7XG4gIG5ldE9wdGlvbnMucG9ydCA9IHNvY2tldFRMUy5wb3J0ID0gcG9ydDtcblxuICBvcmlnaW5UTFMuY2EgPSBvcmlnaW5UTFMuY2EgfHwgb3B0aW9ucy5jYTtcbiAgc29ja2V0VExTLnNlcnZlcm5hbWUgPSBzb2NrZXRUTFMuc2VydmVybmFtZSB8fCBlbmRwb2ludC5ob3N0bmFtZTtcblxuICB0aGlzLl9zdHJlYW0gPSBzZWN1cmVcbiAgICAgICAgICAgICAgID8gdGxzLmNvbm5lY3Qoc29ja2V0VExTLCBvbkNvbm5lY3QpXG4gICAgICAgICAgICAgICA6IG5ldC5jb25uZWN0KG5ldE9wdGlvbnMsIG9uQ29ubmVjdCk7XG5cbiAgaWYgKHByb3h5Lm9yaWdpbikgdGhpcy5fY29uZmlndXJlUHJveHkocHJveHksIG9yaWdpblRMUyk7XG5cbiAgQVBJLmNhbGwodGhpcywgb3B0aW9ucyk7XG59O1xudXRpbC5pbmhlcml0cyhDbGllbnQsIEFQSSk7XG5cbkNsaWVudC5wcm90b3R5cGUuX29uQ29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd29ya2VyID0gdGhpcy5fcHJveHkgfHwgdGhpcy5fZHJpdmVyO1xuICB3b3JrZXIuc3RhcnQoKTtcbn07XG5cbkNsaWVudC5wcm90b3R5cGUuX2NvbmZpZ3VyZVByb3h5ID0gZnVuY3Rpb24ocHJveHksIG9yaWdpblRMUykge1xuICB2YXIgdXJpICAgID0gdXJsLnBhcnNlKHRoaXMudXJsKSxcbiAgICAgIHNlY3VyZSA9IFNFQ1VSRV9QUk9UT0NPTFMuaW5kZXhPZih1cmkucHJvdG9jb2wpID49IDAsXG4gICAgICBzZWxmICAgPSB0aGlzLFxuICAgICAgbmFtZTtcblxuICB0aGlzLl9wcm94eSA9IHRoaXMuX2RyaXZlci5wcm94eShwcm94eS5vcmlnaW4pO1xuXG4gIGlmIChwcm94eS5oZWFkZXJzKSB7XG4gICAgZm9yIChuYW1lIGluIHByb3h5LmhlYWRlcnMpIHRoaXMuX3Byb3h5LnNldEhlYWRlcihuYW1lLCBwcm94eS5oZWFkZXJzW25hbWVdKTtcbiAgfVxuXG4gIHRoaXMuX3Byb3h5LnBpcGUodGhpcy5fc3RyZWFtLCB7ZW5kOiBmYWxzZX0pO1xuICB0aGlzLl9zdHJlYW0ucGlwZSh0aGlzLl9wcm94eSk7XG5cbiAgdGhpcy5fcHJveHkub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VjdXJlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtzb2NrZXQ6IHNlbGYuX3N0cmVhbSwgc2VydmVybmFtZTogdXJpLmhvc3RuYW1lfTtcbiAgICAgIGZvciAobmFtZSBpbiBvcmlnaW5UTFMpIG9wdGlvbnNbbmFtZV0gPSBvcmlnaW5UTFNbbmFtZV07XG4gICAgICBzZWxmLl9zdHJlYW0gPSB0bHMuY29ubmVjdChvcHRpb25zKTtcbiAgICAgIHNlbGYuX2NvbmZpZ3VyZVN0cmVhbSgpO1xuICAgIH1cbiAgICBzZWxmLl9kcml2ZXIuaW8ucGlwZShzZWxmLl9zdHJlYW0pO1xuICAgIHNlbGYuX3N0cmVhbS5waXBlKHNlbGYuX2RyaXZlci5pbyk7XG4gICAgc2VsZi5fZHJpdmVyLnN0YXJ0KCk7XG4gIH0pO1xuXG4gIHRoaXMuX3Byb3h5Lm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgc2VsZi5fZHJpdmVyLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50O1xuXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV0XCIpO1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRsc1wiKTtcblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgU3RyZWFtICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLlN0cmVhbSxcbiAgICB1dGlsICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgZHJpdmVyICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLFxuICAgIEhlYWRlcnMgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KSxcbiAgICBBUEkgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpLFxuICAgIEV2ZW50VGFyZ2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG4gICAgRXZlbnQgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgRXZlbnRTb3VyY2UgPSBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSwgb3B0aW9ucykge1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fc3RyZWFtID0gcmVzcG9uc2Uuc29ja2V0O1xuICB0aGlzLl9waW5nICAgPSBvcHRpb25zLnBpbmcgIHx8IHRoaXMuREVGQVVMVF9QSU5HO1xuICB0aGlzLl9yZXRyeSAgPSBvcHRpb25zLnJldHJ5IHx8IHRoaXMuREVGQVVMVF9SRVRSWTtcblxuICB2YXIgc2NoZW1lICAgICAgID0gZHJpdmVyLmlzU2VjdXJlUmVxdWVzdChyZXF1ZXN0KSA/ICdodHRwczonIDogJ2h0dHA6JztcbiAgdGhpcy51cmwgICAgICAgICA9IHNjaGVtZSArICcvLycgKyByZXF1ZXN0LmhlYWRlcnMuaG9zdCArIHJlcXVlc3QudXJsO1xuICB0aGlzLmxhc3RFdmVudElkID0gcmVxdWVzdC5oZWFkZXJzWydsYXN0LWV2ZW50LWlkJ10gfHwgJyc7XG4gIHRoaXMucmVhZHlTdGF0ZSAgPSBBUEkuQ09OTkVDVElORztcblxuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCksXG4gICAgICBzZWxmICAgID0gdGhpcztcblxuICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuaGVhZGVycykgaGVhZGVycy5zZXQoa2V5LCBvcHRpb25zLmhlYWRlcnNba2V5XSk7XG4gIH1cblxuICBpZiAoIXRoaXMuX3N0cmVhbSB8fCAhdGhpcy5fc3RyZWFtLndyaXRhYmxlKSByZXR1cm47XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYuX29wZW4oKSB9KTtcblxuICB0aGlzLl9zdHJlYW0uc2V0VGltZW91dCgwKTtcbiAgdGhpcy5fc3RyZWFtLnNldE5vRGVsYXkodHJ1ZSk7XG5cbiAgdmFyIGhhbmRzaGFrZSA9ICdIVFRQLzEuMSAyMDAgT0tcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGU6IHRleHQvZXZlbnQtc3RyZWFtXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbDogbm8tY2FjaGUsIG5vLXN0b3JlXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAnQ29ubmVjdGlvbjogY2xvc2VcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnMudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAnXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAncmV0cnk6ICcgKyBNYXRoLmZsb29yKHRoaXMuX3JldHJ5ICogMTAwMCkgKyAnXFxyXFxuXFxyXFxuJztcblxuICB0aGlzLl93cml0ZShoYW5kc2hha2UpO1xuXG4gIHRoaXMuX3N0cmVhbS5vbignZHJhaW4nLCBmdW5jdGlvbigpIHsgc2VsZi5lbWl0KCdkcmFpbicpIH0pO1xuXG4gIGlmICh0aGlzLl9waW5nKVxuICAgIHRoaXMuX3BpbmdUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkgeyBzZWxmLnBpbmcoKSB9LCB0aGlzLl9waW5nICogMTAwMCk7XG5cbiAgWydlcnJvcicsICdlbmQnXS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi5fc3RyZWFtLm9uKGV2ZW50LCBmdW5jdGlvbigpIHsgc2VsZi5jbG9zZSgpIH0pO1xuICB9KTtcbn07XG51dGlsLmluaGVyaXRzKEV2ZW50U291cmNlLCBTdHJlYW0pO1xuXG5FdmVudFNvdXJjZS5pc0V2ZW50U291cmNlID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnKSByZXR1cm4gZmFsc2U7XG4gIHZhciBhY2NlcHQgPSAocmVxdWVzdC5oZWFkZXJzLmFjY2VwdCB8fCAnJykuc3BsaXQoL1xccyosXFxzKi8pO1xuICByZXR1cm4gYWNjZXB0LmluZGV4T2YoJ3RleHQvZXZlbnQtc3RyZWFtJykgPj0gMDtcbn07XG5cbnZhciBpbnN0YW5jZSA9IHtcbiAgREVGQVVMVF9QSU5HOiAgIDEwLFxuICBERUZBVUxUX1JFVFJZOiAgNSxcblxuICBfd3JpdGU6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJlYW0ud3JpdGUoY2h1bmssICd1dGY4Jyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBfb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gQVBJLkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IEFQSS5PUEVOO1xuXG4gICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdvcGVuJyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdvcGVuJywgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9LFxuXG4gIHdyaXRlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZChtZXNzYWdlKTtcbiAgfSxcblxuICBlbmQ6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfSxcblxuICBzZW5kOiBmdW5jdGlvbihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IEFQSS5PUEVOKSByZXR1cm4gZmFsc2U7XG5cbiAgICBtZXNzYWdlID0gU3RyaW5nKG1lc3NhZ2UpLnJlcGxhY2UoLyhcXHJcXG58XFxyfFxcbikvZywgJyQxZGF0YTogJyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgZnJhbWUgPSAnJztcbiAgICBpZiAob3B0aW9ucy5ldmVudCkgZnJhbWUgKz0gJ2V2ZW50OiAnICsgb3B0aW9ucy5ldmVudCArICdcXHJcXG4nO1xuICAgIGlmIChvcHRpb25zLmlkKSAgICBmcmFtZSArPSAnaWQ6ICcgICAgKyBvcHRpb25zLmlkICAgICsgJ1xcclxcbic7XG4gICAgZnJhbWUgKz0gJ2RhdGE6ICcgKyBtZXNzYWdlICsgJ1xcclxcblxcclxcbic7XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGUoZnJhbWUpO1xuICB9LFxuXG4gIHBpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0ZSgnOlxcclxcblxcclxcbicpO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gQVBJLk9QRU4pIHJldHVybiBmYWxzZTtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IEFQSS5DTE9TRUQ7XG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9waW5nVGltZXIpIGNsZWFySW50ZXJ2YWwodGhpcy5fcGluZ1RpbWVyKTtcbiAgICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9zdHJlYW0uZW5kKCk7XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2Nsb3NlJyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdjbG9zZScsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5mb3IgKHZhciBtZXRob2QgaW4gaW5zdGFuY2UpIEV2ZW50U291cmNlLnByb3RvdHlwZVttZXRob2RdID0gaW5zdGFuY2VbbWV0aG9kXTtcbmZvciAodmFyIGtleSBpbiBFdmVudFRhcmdldCkgRXZlbnRTb3VyY2UucHJvdG90eXBlW2tleV0gPSBFdmVudFRhcmdldFtrZXldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlO1xuXG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTtcblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpO1xuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIHB1c2hlcl93aXRoX2VuY3J5cHRpb25fUHVzaGVyV2l0aEVuY3J5cHRpb247IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Jhc2U2NC50c1xuZnVuY3Rpb24gZW5jb2RlKHMpIHtcbiAgICByZXR1cm4gYnRvYSh1dG9iKHMpKTtcbn1cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIGI2NGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xudmFyIGI2NHRhYiA9IHt9O1xuZm9yICh2YXIgYmFzZTY0X2kgPSAwLCBsID0gYjY0Y2hhcnMubGVuZ3RoOyBiYXNlNjRfaSA8IGw7IGJhc2U2NF9pKyspIHtcbiAgICBiNjR0YWJbYjY0Y2hhcnMuY2hhckF0KGJhc2U2NF9pKV0gPSBiYXNlNjRfaTtcbn1cbnZhciBjYl91dG9iID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGNjIDwgMHg4MFxuICAgICAgICA/IGNcbiAgICAgICAgOiBjYyA8IDB4ODAwXG4gICAgICAgICAgICA/IGZyb21DaGFyQ29kZSgweGMwIHwgKGNjID4+PiA2KSkgKyBmcm9tQ2hhckNvZGUoMHg4MCB8IChjYyAmIDB4M2YpKVxuICAgICAgICAgICAgOiBmcm9tQ2hhckNvZGUoMHhlMCB8ICgoY2MgPj4+IDEyKSAmIDB4MGYpKSArXG4gICAgICAgICAgICAgICAgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKSArXG4gICAgICAgICAgICAgICAgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSk7XG59O1xudmFyIHV0b2IgPSBmdW5jdGlvbiAodSkge1xuICAgIHJldHVybiB1LnJlcGxhY2UoL1teXFx4MDAtXFx4N0ZdL2csIGNiX3V0b2IpO1xufTtcbnZhciBjYl9lbmNvZGUgPSBmdW5jdGlvbiAoY2NjKSB7XG4gICAgdmFyIHBhZGxlbiA9IFswLCAyLCAxXVtjY2MubGVuZ3RoICUgM107XG4gICAgdmFyIG9yZCA9IChjY2MuY2hhckNvZGVBdCgwKSA8PCAxNikgfFxuICAgICAgICAoKGNjYy5sZW5ndGggPiAxID8gY2NjLmNoYXJDb2RlQXQoMSkgOiAwKSA8PCA4KSB8XG4gICAgICAgIChjY2MubGVuZ3RoID4gMiA/IGNjYy5jaGFyQ29kZUF0KDIpIDogMCk7XG4gICAgdmFyIGNoYXJzID0gW1xuICAgICAgICBiNjRjaGFycy5jaGFyQXQob3JkID4+PiAxOCksXG4gICAgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MyksXG4gICAgICAgIHBhZGxlbiA+PSAyID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDYpICYgNjMpLFxuICAgICAgICBwYWRsZW4gPj0gMSA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdChvcmQgJiA2MylcbiAgICBdO1xuICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbn07XG52YXIgYnRvYSA9IGdsb2JhbC5idG9hIHx8XG4gICAgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZSgvW1xcc1xcU117MSwzfS9nLCBjYl9lbmNvZGUpO1xuICAgIH07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdGltZXJzL2Fic3RyYWN0X3RpbWVyLnRzXG5jbGFzcyBUaW1lciB7XG4gICAgY29uc3RydWN0b3Ioc2V0LCBjbGVhciwgZGVsYXksIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2xlYXIgPSBjbGVhcjtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBjYWxsYmFjayh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH1cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVyICE9PSBudWxsO1xuICAgIH1cbiAgICBlbnN1cmVBYm9ydGVkKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgdGhpcy5jbGVhcih0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYWJzdHJhY3RfdGltZXIgPSAoVGltZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3V0aWxzL3RpbWVycy9pbmRleC50c1xuXG5mdW5jdGlvbiB0aW1lcnNfY2xlYXJUaW1lb3V0KHRpbWVyKSB7XG4gICAgZ2xvYmFsLmNsZWFyVGltZW91dCh0aW1lcik7XG59XG5mdW5jdGlvbiB0aW1lcnNfY2xlYXJJbnRlcnZhbCh0aW1lcikge1xuICAgIGdsb2JhbC5jbGVhckludGVydmFsKHRpbWVyKTtcbn1cbmNsYXNzIHRpbWVyc19PbmVPZmZUaW1lciBleHRlbmRzIGFic3RyYWN0X3RpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcihkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIoc2V0VGltZW91dCwgdGltZXJzX2NsZWFyVGltZW91dCwgZGVsYXksIGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyB0aW1lcnNfUGVyaW9kaWNUaW1lciBleHRlbmRzIGFic3RyYWN0X3RpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcihkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIoc2V0SW50ZXJ2YWwsIHRpbWVyc19jbGVhckludGVydmFsLCBkZWxheSwgZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbC50c1xuXG52YXIgVXRpbCA9IHtcbiAgICBub3coKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdykge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlZmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGltZXJzX09uZU9mZlRpbWVyKDAsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG1ldGhvZChuYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIHZhciBib3VuZEFyZ3VtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W25hbWVdLmFwcGx5KG9iamVjdCwgYm91bmRBcmd1bWVudHMuY29uY2F0KGFyZ3VtZW50cykpO1xuICAgICAgICB9O1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsID0gKFV0aWwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3V0aWxzL2NvbGxlY3Rpb25zLnRzXG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgLi4uc291cmNlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zW3Byb3BlcnR5XSAmJlxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNbcHJvcGVydHldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1twcm9wZXJ0eV0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBleHRlbmQodGFyZ2V0W3Byb3BlcnR5XSB8fCB7fSwgZXh0ZW5zaW9uc1twcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGV4dGVuc2lvbnNbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgdmFyIG0gPSBbJ1B1c2hlciddO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbS5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtLnB1c2goc2FmZUpTT05TdHJpbmdpZnkoYXJndW1lbnRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uam9pbignIDogJyk7XG59XG5mdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyYXksIGl0ZW0pIHtcbiAgICB2YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIGlmIChhcnJheSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gb2JqZWN0QXBwbHkob2JqZWN0LCBmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgZihvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBhcHBseShhcnJheSwgZiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZi5jYWxsKGNvbnRleHQgfHwgZ2xvYmFsLCBhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGYoYXJyYXlbaV0sIGksIGFycmF5LCByZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGYpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGYodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXIoYXJyYXksIHRlc3QpIHtcbiAgICB0ZXN0ID1cbiAgICAgICAgdGVzdCB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXN0KGFycmF5W2ldLCBpLCBhcnJheSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXJPYmplY3Qob2JqZWN0LCB0ZXN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKCh0ZXN0ICYmIHRlc3QodmFsdWUsIGtleSwgb2JqZWN0LCByZXN1bHQpKSB8fCBCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmbGF0dGVuKG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBvYmplY3RBcHBseShvYmplY3QsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFueShhcnJheSwgdGVzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdGlvbnNfYWxsKGFycmF5LCB0ZXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5jb2RlUGFyYW1zT2JqZWN0KGRhdGEpIHtcbiAgICByZXR1cm4gbWFwT2JqZWN0KGRhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSBzYWZlSlNPTlN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlbmNvZGUodmFsdWUudG9TdHJpbmcoKSkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRRdWVyeVN0cmluZyhkYXRhKSB7XG4gICAgdmFyIHBhcmFtcyA9IGZpbHRlck9iamVjdChkYXRhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgdmFyIHF1ZXJ5ID0gbWFwKGZsYXR0ZW4oZW5jb2RlUGFyYW1zT2JqZWN0KHBhcmFtcykpLCB1dGlsLm1ldGhvZCgnam9pbicsICc9JykpLmpvaW4oJyYnKTtcbiAgICByZXR1cm4gcXVlcnk7XG59XG5mdW5jdGlvbiBkZWN5Y2xlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBvYmplY3RzID0gW10sIHBhdGhzID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBkZXJleih2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgaSwgbmFtZSwgbnU7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgJHJlZjogcGF0aHNbaV0gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICAgIG51ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVbaV0gPSBkZXJleih2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBudSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVbbmFtZV0gPSBkZXJleih2YWx1ZVtuYW1lXSwgcGF0aCArICdbJyArIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnU7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pKG9iamVjdCwgJyQnKTtcbn1cbmZ1bmN0aW9uIHNhZmVKU09OU3RyaW5naWZ5KHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3VyY2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGVjeWNsZU9iamVjdChzb3VyY2UpKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZGVmYXVsdHMudHNcbnZhciBEZWZhdWx0cyA9IHtcbiAgICBWRVJTSU9OOiBcIjguMy4wXCIsXG4gICAgUFJPVE9DT0w6IDcsXG4gICAgd3NQb3J0OiA4MCxcbiAgICB3c3NQb3J0OiA0NDMsXG4gICAgd3NQYXRoOiAnJyxcbiAgICBodHRwSG9zdDogJ3NvY2tqcy5wdXNoZXIuY29tJyxcbiAgICBodHRwUG9ydDogODAsXG4gICAgaHR0cHNQb3J0OiA0NDMsXG4gICAgaHR0cFBhdGg6ICcvcHVzaGVyJyxcbiAgICBzdGF0c19ob3N0OiAnc3RhdHMucHVzaGVyLmNvbScsXG4gICAgYXV0aEVuZHBvaW50OiAnL3B1c2hlci9hdXRoJyxcbiAgICBhdXRoVHJhbnNwb3J0OiAnYWpheCcsXG4gICAgYWN0aXZpdHlUaW1lb3V0OiAxMjAwMDAsXG4gICAgcG9uZ1RpbWVvdXQ6IDMwMDAwLFxuICAgIHVuYXZhaWxhYmxlVGltZW91dDogMTAwMDAsXG4gICAgdXNlckF1dGhlbnRpY2F0aW9uOiB7XG4gICAgICAgIGVuZHBvaW50OiAnL3B1c2hlci91c2VyLWF1dGgnLFxuICAgICAgICB0cmFuc3BvcnQ6ICdhamF4J1xuICAgIH0sXG4gICAgY2hhbm5lbEF1dGhvcml6YXRpb246IHtcbiAgICAgICAgZW5kcG9pbnQ6ICcvcHVzaGVyL2F1dGgnLFxuICAgICAgICB0cmFuc3BvcnQ6ICdhamF4J1xuICAgIH0sXG4gICAgY2RuX2h0dHA6IFwiaHR0cDovL2pzLnB1c2hlci5jb21cIixcbiAgICBjZG5faHR0cHM6IFwiaHR0cHM6Ly9qcy5wdXNoZXIuY29tXCIsXG4gICAgZGVwZW5kZW5jeV9zdWZmaXg6IFwiXCJcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWZhdWx0cyA9IChEZWZhdWx0cyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy91cmxfc2NoZW1lcy50c1xuXG5mdW5jdGlvbiBnZXRHZW5lcmljVVJMKGJhc2VTY2hlbWUsIHBhcmFtcywgcGF0aCkge1xuICAgIHZhciBzY2hlbWUgPSBiYXNlU2NoZW1lICsgKHBhcmFtcy51c2VUTFMgPyAncycgOiAnJyk7XG4gICAgdmFyIGhvc3QgPSBwYXJhbXMudXNlVExTID8gcGFyYW1zLmhvc3RUTFMgOiBwYXJhbXMuaG9zdE5vblRMUztcbiAgICByZXR1cm4gc2NoZW1lICsgJzovLycgKyBob3N0ICsgcGF0aDtcbn1cbmZ1bmN0aW9uIGdldEdlbmVyaWNQYXRoKGtleSwgcXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcGF0aCA9ICcvYXBwLycgKyBrZXk7XG4gICAgdmFyIHF1ZXJ5ID0gJz9wcm90b2NvbD0nICtcbiAgICAgICAgZGVmYXVsdHMuUFJPVE9DT0wgK1xuICAgICAgICAnJmNsaWVudD1qcycgK1xuICAgICAgICAnJnZlcnNpb249JyArXG4gICAgICAgIGRlZmF1bHRzLlZFUlNJT04gK1xuICAgICAgICAocXVlcnlTdHJpbmcgPyAnJicgKyBxdWVyeVN0cmluZyA6ICcnKTtcbiAgICByZXR1cm4gcGF0aCArIHF1ZXJ5O1xufVxudmFyIHdzID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICB2YXIgcGF0aCA9IChwYXJhbXMuaHR0cFBhdGggfHwgJycpICsgZ2V0R2VuZXJpY1BhdGgoa2V5LCAnZmxhc2g9ZmFsc2UnKTtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ3dzJywgcGFyYW1zLCBwYXRoKTtcbiAgICB9XG59O1xudmFyIGh0dHAgPSB7XG4gICAgZ2V0SW5pdGlhbDogZnVuY3Rpb24gKGtleSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXRoID0gKHBhcmFtcy5odHRwUGF0aCB8fCAnL3B1c2hlcicpICsgZ2V0R2VuZXJpY1BhdGgoa2V5KTtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ2h0dHAnLCBwYXJhbXMsIHBhdGgpO1xuICAgIH1cbn07XG52YXIgc29ja2pzID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gZ2V0R2VuZXJpY1VSTCgnaHR0cCcsIHBhcmFtcywgcGFyYW1zLmh0dHBQYXRoIHx8ICcvcHVzaGVyJyk7XG4gICAgfSxcbiAgICBnZXRQYXRoOiBmdW5jdGlvbiAoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNQYXRoKGtleSk7XG4gICAgfVxufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9ldmVudHMvY2FsbGJhY2tfcmVnaXN0cnkudHNcblxuY2xhc3MgY2FsbGJhY2tfcmVnaXN0cnlfQ2FsbGJhY2tSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW3ByZWZpeChuYW1lKV07XG4gICAgfVxuICAgIGFkZChuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgcHJlZml4ZWRFdmVudE5hbWUgPSBwcmVmaXgobmFtZSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrc1twcmVmaXhlZEV2ZW50TmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW3ByZWZpeGVkRXZlbnROYW1lXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzW3ByZWZpeGVkRXZlbnROYW1lXS5wdXNoKHtcbiAgICAgICAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZShuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICBpZiAoIW5hbWUgJiYgIWNhbGxiYWNrICYmICFjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lID8gW3ByZWZpeChuYW1lKV0gOiBrZXlzKHRoaXMuX2NhbGxiYWNrcyk7XG4gICAgICAgIGlmIChjYWxsYmFjayB8fCBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNhbGxiYWNrKG5hbWVzLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbENhbGxiYWNrcyhuYW1lcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2FsbGJhY2sobmFtZXMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGFwcGx5KG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW25hbWVdID0gZmlsdGVyKHRoaXMuX2NhbGxiYWNrc1tuYW1lXSB8fCBbXSwgZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gYmluZGluZy5mbikgfHxcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQgJiYgY29udGV4dCAhPT0gYmluZGluZy5jb250ZXh0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbmFtZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIHJlbW92ZUFsbENhbGxiYWNrcyhuYW1lcykge1xuICAgICAgICBhcHBseShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbbmFtZV07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZWZpeChuYW1lKSB7XG4gICAgcmV0dXJuICdfJyArIG5hbWU7XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZXZlbnRzL2Rpc3BhdGNoZXIudHNcblxuXG5jbGFzcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGZhaWxUaHJvdWdoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IGNhbGxiYWNrX3JlZ2lzdHJ5X0NhbGxiYWNrUmVnaXN0cnkoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuZmFpbFRocm91Z2ggPSBmYWlsVGhyb3VnaDtcbiAgICB9XG4gICAgYmluZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJpbmRfZ2xvYmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnJlbW92ZShldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9nbG9iYWwoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3MgPSBmaWx0ZXIodGhpcy5nbG9iYWxfY2FsbGJhY2tzIHx8IFtdLCBjID0+IGMgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9hbGwoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgIHRoaXMudW5iaW5kX2dsb2JhbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIGRhdGEsIG1ldGFkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbG9iYWxfY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3NbaV0oZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGRhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrcyAmJiBjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uZm4uYXBwbHkoY2FsbGJhY2tzW2ldLmNvbnRleHQgfHwgZ2xvYmFsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZhaWxUaHJvdWdoKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWxUaHJvdWdoKGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2xvZ2dlci50c1xuXG5cbmNsYXNzIGxvZ2dlcl9Mb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdsb2JhbExvZyA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLmNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMubG9nKHRoaXMuZ2xvYmFsTG9nLCBhcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMubG9nKHRoaXMuZ2xvYmFsTG9nV2FybiwgYXJncyk7XG4gICAgfVxuICAgIGVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5sb2codGhpcy5nbG9iYWxMb2dFcnJvciwgYXJncyk7XG4gICAgfVxuICAgIGdsb2JhbExvZ1dhcm4obWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgZ2xvYmFsLmNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdsb2JhbExvZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICBnbG9iYWwuY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nV2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2coZGVmYXVsdExvZ2dpbmdGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IHN0cmluZ2lmeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoY29yZV9wdXNoZXIubG9nKSB7XG4gICAgICAgICAgICBjb3JlX3B1c2hlci5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29yZV9wdXNoZXIubG9nVG9Db25zb2xlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2cgPSBkZWZhdWx0TG9nZ2luZ0Z1bmN0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBsb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsb2dnZXIgPSAobmV3IGxvZ2dlcl9Mb2dnZXIoKSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnRfY29ubmVjdGlvbi50c1xuXG5cblxuXG5cbmNsYXNzIHRyYW5zcG9ydF9jb25uZWN0aW9uX1RyYW5zcG9ydENvbm5lY3Rpb24gZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGhvb2tzLCBuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSA9IG5vZGVfcnVudGltZS50cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXI7XG4gICAgICAgIHRoaXMuaG9va3MgPSBob29rcztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICduZXcnO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gb3B0aW9ucy50aW1lbGluZTtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVvdXQgPSBvcHRpb25zLmFjdGl2aXR5VGltZW91dDtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMudGltZWxpbmUuZ2VuZXJhdGVVbmlxdWVJRCgpO1xuICAgIH1cbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3MoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaG9va3MuaGFuZGxlc0FjdGl2aXR5Q2hlY2tzKTtcbiAgICB9XG4gICAgc3VwcG9ydHNQaW5nKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhvb2tzLnN1cHBvcnRzUGluZyk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCB8fCB0aGlzLnN0YXRlICE9PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IHRoaXMuaG9va3MudXJscy5nZXRJbml0aWFsKHRoaXMua2V5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSB0aGlzLmhvb2tzLmdldFNvY2tldCh1cmwsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwuZGVmZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0Nvbm5lY3RpbmcnLCB7IHRyYW5zcG9ydDogdGhpcy5uYW1lLCB1cmwgfSk7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgdXRpbC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ29wZW4nICYmIHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmJlZm9yZU9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MuYmVmb3JlT3Blbih0aGlzLnNvY2tldCwgdGhpcy5ob29rcy51cmxzLmdldFBhdGgodGhpcy5rZXksIHRoaXMub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ29wZW4nKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7IHR5cGU6ICdXZWJTb2NrZXRFcnJvcicsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5lcnJvcih0aGlzLmJ1aWxkVGltZWxpbmVNZXNzYWdlKHsgZXJyb3I6IGVycm9yLnRvU3RyaW5nKCkgfSkpO1xuICAgIH1cbiAgICBvbkNsb3NlKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nsb3NlZCcsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjbG9zZUV2ZW50LmNvZGUsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBjbG9zZUV2ZW50LnJlYXNvbixcbiAgICAgICAgICAgICAgICB3YXNDbGVhbjogY2xvc2VFdmVudC53YXNDbGVhblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgfVxuICAgIG9uQWN0aXZpdHkoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnYWN0aXZpdHknKTtcbiAgICB9XG4gICAgYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSBjbG9zZUV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZShjbG9zZUV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQub25hY3Rpdml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShzdGF0ZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHRoaXMuYnVpbGRUaW1lbGluZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVtaXQoc3RhdGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIGJ1aWxkVGltZWxpbmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7IGNpZDogdGhpcy5pZCB9LCBtZXNzYWdlKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnQudHNcblxuY2xhc3MgdHJhbnNwb3J0X1RyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3IoaG9va3MpIHtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZChlbnZpcm9ubWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob29rcy5pc1N1cHBvcnRlZChlbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbm5lY3Rpb24obmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zcG9ydF9jb25uZWN0aW9uX1RyYW5zcG9ydENvbm5lY3Rpb24odGhpcy5ob29rcywgbmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL3RyYW5zcG9ydHMvdHJhbnNwb3J0cy50c1xuXG5cblxuXG52YXIgV1NUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCh7XG4gICAgdXJsczogd3MsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiBmYWxzZSxcbiAgICBzdXBwb3J0c1Bpbmc6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4obm9kZV9ydW50aW1lLmdldFdlYlNvY2tldEFQSSgpKTtcbiAgICB9LFxuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKG5vZGVfcnVudGltZS5nZXRXZWJTb2NrZXRBUEkoKSk7XG4gICAgfSxcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVfcnVudGltZS5jcmVhdGVXZWJTb2NrZXQodXJsKTtcbiAgICB9XG59KTtcbnZhciBodHRwQ29uZmlndXJhdGlvbiA9IHtcbiAgICB1cmxzOiBodHRwLFxuICAgIGhhbmRsZXNBY3Rpdml0eUNoZWNrczogZmFsc2UsXG4gICAgc3VwcG9ydHNQaW5nOiB0cnVlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbnZhciBzdHJlYW1pbmdDb25maWd1cmF0aW9uID0gZXh0ZW5kKHtcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVfcnVudGltZS5IVFRQRmFjdG9yeS5jcmVhdGVTdHJlYW1pbmdTb2NrZXQodXJsKTtcbiAgICB9XG59LCBodHRwQ29uZmlndXJhdGlvbik7XG52YXIgcG9sbGluZ0NvbmZpZ3VyYXRpb24gPSBleHRlbmQoe1xuICAgIGdldFNvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gbm9kZV9ydW50aW1lLkhUVFBGYWN0b3J5LmNyZWF0ZVBvbGxpbmdTb2NrZXQodXJsKTtcbiAgICB9XG59LCBodHRwQ29uZmlndXJhdGlvbik7XG52YXIgeGhyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbm9kZV9ydW50aW1lLmlzWEhSU3VwcG9ydGVkKCk7XG4gICAgfVxufTtcbnZhciBYSFJTdHJlYW1pbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCgoZXh0ZW5kKHt9LCBzdHJlYW1pbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSkpO1xudmFyIFhIUlBvbGxpbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydChleHRlbmQoe30sIHBvbGxpbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSk7XG52YXIgVHJhbnNwb3J0cyA9IHtcbiAgICB3czogV1NUcmFuc3BvcnQsXG4gICAgeGhyX3N0cmVhbWluZzogWEhSU3RyZWFtaW5nVHJhbnNwb3J0LFxuICAgIHhocl9wb2xsaW5nOiBYSFJQb2xsaW5nVHJhbnNwb3J0XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0cyA9IChUcmFuc3BvcnRzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL2Fzc2lzdGFudF90b190aGVfdHJhbnNwb3J0X21hbmFnZXIudHNcblxuXG5jbGFzcyBhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLm1pblBpbmdEZWxheSA9IG9wdGlvbnMubWluUGluZ0RlbGF5O1xuICAgICAgICB0aGlzLm1heFBpbmdEZWxheSA9IG9wdGlvbnMubWF4UGluZ0RlbGF5O1xuICAgICAgICB0aGlzLnBpbmdEZWxheSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY3JlYXRlQ29ubmVjdGlvbihuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogdGhpcy5waW5nRGVsYXlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ29ubmVjdGlvbihuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG9wZW5UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB2YXIgb25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51bmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgICAgICBvcGVuVGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQ2xvc2VkID0gY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnVuYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA9PT0gMTAwMiB8fCBjbG9zZUV2ZW50LmNvZGUgPT09IDEwMDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIucmVwb3J0RGVhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjbG9zZUV2ZW50Lndhc0NsZWFuICYmIG9wZW5UaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlmZXNwYW4gPSB1dGlsLm5vdygpIC0gb3BlblRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBpZiAobGlmZXNwYW4gPCAyICogdGhpcy5tYXhQaW5nRGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLnJlcG9ydERlYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGluZ0RlbGF5ID0gTWF0aC5tYXgobGlmZXNwYW4gLyAyLCB0aGlzLm1pblBpbmdEZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25uZWN0aW9uLmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5pc0FsaXZlKCkgJiYgdGhpcy50cmFuc3BvcnQuaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25uZWN0aW9uL3Byb3RvY29sL3Byb3RvY29sLnRzXG5jb25zdCBQcm90b2NvbCA9IHtcbiAgICBkZWNvZGVNZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZURhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2VFdmVudC5kYXRhKTtcbiAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudERhdGEgPSBtZXNzYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwdXNoZXJFdmVudERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaGVyRXZlbnREYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlRGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHB1c2hlckV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlRGF0YS5ldmVudCxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBtZXNzYWdlRGF0YS5jaGFubmVsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHB1c2hlckV2ZW50RGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlRGF0YS51c2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgcHVzaGVyRXZlbnQudXNlcl9pZCA9IG1lc3NhZ2VEYXRhLnVzZXJfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVzaGVyRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ01lc3NhZ2VQYXJzZUVycm9yJywgZXJyb3I6IGUsIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVuY29kZU1lc3NhZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXZlbnQpO1xuICAgIH0sXG4gICAgcHJvY2Vzc0hhbmRzaGFrZTogZnVuY3Rpb24gKG1lc3NhZ2VFdmVudCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFByb3RvY29sLmRlY29kZU1lc3NhZ2UobWVzc2FnZUV2ZW50KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnQgPT09ICdwdXNoZXI6Y29ubmVjdGlvbl9lc3RhYmxpc2hlZCcpIHtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZS5kYXRhLmFjdGl2aXR5X3RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTm8gYWN0aXZpdHkgdGltZW91dCBzcGVjaWZpZWQgaW4gaGFuZHNoYWtlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICBpZDogbWVzc2FnZS5kYXRhLnNvY2tldF9pZCxcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IG1lc3NhZ2UuZGF0YS5hY3Rpdml0eV90aW1lb3V0ICogMTAwMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmV2ZW50ID09PSAncHVzaGVyOmVycm9yJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuZ2V0Q2xvc2VBY3Rpb24obWVzc2FnZS5kYXRhKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5nZXRDbG9zZUVycm9yKG1lc3NhZ2UuZGF0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBoYW5kc2hha2UnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRDbG9zZUFjdGlvbjogZnVuY3Rpb24gKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQwMDApIHtcbiAgICAgICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgPj0gMTAwMiAmJiBjbG9zZUV2ZW50LmNvZGUgPD0gMTAwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYmFja29mZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPT09IDQwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAndGxzX29ubHknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQxMDApIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xvc2VFdmVudC5jb2RlIDwgNDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuICdiYWNrb2ZmJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPCA0MzAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JldHJ5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncmVmdXNlZCc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldENsb3NlRXJyb3I6IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgIT09IDEwMDAgJiYgY2xvc2VFdmVudC5jb2RlICE9PSAxMDAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQdXNoZXJFcnJvcicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjbG9zZUV2ZW50LmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNsb3NlRXZlbnQucmVhc29uIHx8IGNsb3NlRXZlbnQubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwcm90b2NvbCA9IChQcm90b2NvbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9jb25uZWN0aW9uLnRzXG5cblxuXG5cbmNsYXNzIGNvbm5lY3Rpb25fQ29ubmVjdGlvbiBleHRlbmRzIGRpc3BhdGNoZXJfRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoaWQsIHRyYW5zcG9ydCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLmFjdGl2aXR5VGltZW91dCA9IHRyYW5zcG9ydC5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgIH1cbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5oYW5kbGVzQWN0aXZpdHlDaGVja3MoKTtcbiAgICB9XG4gICAgc2VuZChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgICBzZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0geyBldmVudDogbmFtZSwgZGF0YTogZGF0YSB9O1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgZXZlbnQuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdFdmVudCBzZW50JywgZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHByb3RvY29sLmVuY29kZU1lc3NhZ2UoZXZlbnQpKTtcbiAgICB9XG4gICAgcGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5waW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRfZXZlbnQoJ3B1c2hlcjpwaW5nJywge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoZXJFdmVudCA9IHByb3RvY29sLmRlY29kZU1lc3NhZ2UobWVzc2FnZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZXNzYWdlUGFyc2VFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VFdmVudC5kYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHVzaGVyRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0V2ZW50IHJlY2QnLCBwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHVzaGVyRXZlbnQuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1c2hlcjplcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1B1c2hlckVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHVzaGVyRXZlbnQuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBvbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHB1c2hlckV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aXZpdHk6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2aXR5Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlZDogY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQgJiYgY2xvc2VFdmVudC5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VFdmVudChjbG9zZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1bmJpbmRMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICBvYmplY3RBcHBseShsaXN0ZW5lcnMsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBvYmplY3RBcHBseShsaXN0ZW5lcnMsIChsaXN0ZW5lciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmJpbmQoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUNsb3NlRXZlbnQoY2xvc2VFdmVudCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gcHJvdG9jb2wuZ2V0Q2xvc2VBY3Rpb24oY2xvc2VFdmVudCk7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoYWN0aW9uLCB7IGFjdGlvbjogYWN0aW9uLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9oYW5kc2hha2UvaW5kZXgudHNcblxuXG5cbmNsYXNzIGhhbmRzaGFrZV9IYW5kc2hha2Uge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5iaW5kTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBiaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLm9uTWVzc2FnZSA9IG0gPT4ge1xuICAgICAgICAgICAgdGhpcy51bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb3RvY29sLnByb2Nlc3NIYW5kc2hha2UobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKCdlcnJvcicsIHsgZXJyb3I6IGUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjdGlvbiA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaCgnY29ubmVjdGVkJywge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBuZXcgY29ubmVjdGlvbl9Db25uZWN0aW9uKHJlc3VsdC5pZCwgdGhpcy50cmFuc3BvcnQpLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IHJlc3VsdC5hY3Rpdml0eVRpbWVvdXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKHJlc3VsdC5hY3Rpb24sIHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2xvc2VkID0gY2xvc2VFdmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHByb3RvY29sLmdldENsb3NlQWN0aW9uKGNsb3NlRXZlbnQpIHx8ICdiYWNrb2ZmJztcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaChhY3Rpb24sIHsgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5iaW5kKCdtZXNzYWdlJywgdGhpcy5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5iaW5kKCdjbG9zZWQnLCB0aGlzLm9uQ2xvc2VkKTtcbiAgICB9XG4gICAgdW5iaW5kTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoJ21lc3NhZ2UnLCB0aGlzLm9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnVuYmluZCgnY2xvc2VkJywgdGhpcy5vbkNsb3NlZCk7XG4gICAgfVxuICAgIGZpbmlzaChhY3Rpb24sIHBhcmFtcykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGV4dGVuZCh7IHRyYW5zcG9ydDogdGhpcy50cmFuc3BvcnQsIGFjdGlvbjogYWN0aW9uIH0sIHBhcmFtcykpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90aW1lbGluZS90aW1lbGluZV9zZW5kZXIudHNcblxuY2xhc3MgdGltZWxpbmVfc2VuZGVyX1RpbWVsaW5lU2VuZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0aW1lbGluZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gdGltZWxpbmU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIHNlbmQodXNlVExTLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVsaW5lLnNlbmQobm9kZV9ydW50aW1lLlRpbWVsaW5lVHJhbnNwb3J0LmdldEFnZW50KHRoaXMsIHVzZVRMUyksIGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvZXJyb3JzLnRzXG5jbGFzcyBCYWRFdmVudE5hbWUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgQmFkQ2hhbm5lbE5hbWUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgUmVxdWVzdFRpbWVkT3V0IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFRyYW5zcG9ydFByaW9yaXR5VG9vTG93IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFRyYW5zcG9ydENsb3NlZCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBVbnN1cHBvcnRlZEZlYXR1cmUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgVW5zdXBwb3J0ZWRUcmFuc3BvcnQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgVW5zdXBwb3J0ZWRTdHJhdGVneSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBIVFRQQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1cywgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy91cmxfc3RvcmUudHNcbmNvbnN0IHVybFN0b3JlID0ge1xuICAgIGJhc2VVcmw6ICdodHRwczovL3B1c2hlci5jb20nLFxuICAgIHVybHM6IHtcbiAgICAgICAgYXV0aGVudGljYXRpb25FbmRwb2ludDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NoYW5uZWxzL3NlcnZlcl9hcGkvYXV0aGVudGljYXRpbmdfdXNlcnMnXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGhvcml6YXRpb25FbmRwb2ludDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NoYW5uZWxzL3NlcnZlcl9hcGkvYXV0aG9yaXppbmctdXNlcnMvJ1xuICAgICAgICB9LFxuICAgICAgICBqYXZhc2NyaXB0UXVpY2tTdGFydDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2phdmFzY3JpcHRfcXVpY2tfc3RhcnQnXG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJpbmdDbGllbnRFdmVudHM6IHtcbiAgICAgICAgICAgIHBhdGg6ICcvZG9jcy9jbGllbnRfYXBpX2d1aWRlL2NsaWVudF9ldmVudHMjdHJpZ2dlci1ldmVudHMnXG4gICAgICAgIH0sXG4gICAgICAgIGVuY3J5cHRlZENoYW5uZWxTdXBwb3J0OiB7XG4gICAgICAgICAgICBmdWxsVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL3B1c2hlci9wdXNoZXItanMvdHJlZS9jYzQ5MTAxNTM3MWE0YmRlNTc0M2QxYzg3YTBmYmFjMGZlYjUzMTk1I2VuY3J5cHRlZC1jaGFubmVsLXN1cHBvcnQnXG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgYnVpbGRMb2dTdWZmaXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgY29uc3QgdXJsUHJlZml4ID0gJ1NlZTonO1xuICAgIGNvbnN0IHVybE9iaiA9IHVybFN0b3JlLnVybHNba2V5XTtcbiAgICBpZiAoIXVybE9iailcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGxldCB1cmw7XG4gICAgaWYgKHVybE9iai5mdWxsVXJsKSB7XG4gICAgICAgIHVybCA9IHVybE9iai5mdWxsVXJsO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmxPYmoucGF0aCkge1xuICAgICAgICB1cmwgPSB1cmxTdG9yZS5iYXNlVXJsICsgdXJsT2JqLnBhdGg7XG4gICAgfVxuICAgIGlmICghdXJsKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGAke3VybFByZWZpeH0gJHt1cmx9YDtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1cmxfc3RvcmUgPSAoeyBidWlsZExvZ1N1ZmZpeCB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9jaGFubmVsLnRzXG5cblxuXG5cblxuY2xhc3MgY2hhbm5lbF9DaGFubmVsIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgc3VwZXIoZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiAnICsgbmFtZSArICcgZm9yICcgKyBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnB1c2hlciA9IHB1c2hlcjtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBhdXRob3JpemUoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7IGF1dGg6ICcnIH0pO1xuICAgIH1cbiAgICB0cmlnZ2VyKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIGlmIChldmVudC5pbmRleE9mKCdjbGllbnQtJykgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCYWRFdmVudE5hbWUoXCJFdmVudCAnXCIgKyBldmVudCArIFwiJyBkb2VzIG5vdCBzdGFydCB3aXRoICdjbGllbnQtJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgndHJpZ2dlcmluZ0NsaWVudEV2ZW50cycpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYENsaWVudCBldmVudCB0cmlnZ2VyZWQgYmVmb3JlIGNoYW5uZWwgJ3N1YnNjcmlwdGlvbl9zdWNjZWVkZWQnIGV2ZW50IC4gJHtzdWZmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoZXZlbnQsIGRhdGEsIHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uU3VjY2VlZGVkRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fY291bnQnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkNvdW50RXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnVuc3Vic2NyaWJlKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlU3Vic2NyaXB0aW9uQ291bnRFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5zdWJzY3JpcHRpb25fY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ291bnQgPSBldmVudC5kYXRhLnN1YnNjcmlwdGlvbl9jb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fY291bnQnLCBldmVudC5kYXRhKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRob3JpemUodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zb2NrZXRfaWQsIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOnN1YnNjcmlwdGlvbl9lcnJvcicsIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0F1dGhFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgaW5zdGFuY2VvZiBIVFRQQXV0aEVycm9yID8geyBzdGF0dXM6IGVycm9yLnN0YXR1cyB9IDoge30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjpzdWJzY3JpYmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGF1dGg6IGRhdGEuYXV0aCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbF9kYXRhOiBkYXRhLmNoYW5uZWxfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjp1bnN1YnNjcmliZScsIHtcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMubmFtZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlaW5zdGF0ZVN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY2hhbm5lbHMvcHJpdmF0ZV9jaGFubmVsLnRzXG5cbmNsYXNzIHByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbCBleHRlbmRzIGNoYW5uZWxfQ2hhbm5lbCB7XG4gICAgYXV0aG9yaXplKHNvY2tldElkLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoZXIuY29uZmlnLmNoYW5uZWxBdXRob3JpemVyKHtcbiAgICAgICAgICAgIGNoYW5uZWxOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBzb2NrZXRJZDogc29ja2V0SWRcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9tZW1iZXJzLnRzXG5cbmNsYXNzIG1lbWJlcnNfTWVtYmVycyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgZ2V0KGlkKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tZW1iZXJzLCBpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGluZm86IHRoaXMubWVtYmVyc1tpZF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIG9iamVjdEFwcGx5KHRoaXMubWVtYmVycywgKG1lbWJlciwgaWQpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZ2V0KGlkKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRNeUlEKGlkKSB7XG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xuICAgIH1cbiAgICBvblN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25EYXRhKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IHN1YnNjcmlwdGlvbkRhdGEucHJlc2VuY2UuaGFzaDtcbiAgICAgICAgdGhpcy5jb3VudCA9IHN1YnNjcmlwdGlvbkRhdGEucHJlc2VuY2UuY291bnQ7XG4gICAgICAgIHRoaXMubWUgPSB0aGlzLmdldCh0aGlzLm15SUQpO1xuICAgIH1cbiAgICBhZGRNZW1iZXIobWVtYmVyRGF0YSkge1xuICAgICAgICBpZiAodGhpcy5nZXQobWVtYmVyRGF0YS51c2VyX2lkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVtYmVyc1ttZW1iZXJEYXRhLnVzZXJfaWRdID0gbWVtYmVyRGF0YS51c2VyX2luZm87XG4gICAgICAgIHJldHVybiB0aGlzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpO1xuICAgIH1cbiAgICByZW1vdmVNZW1iZXIobWVtYmVyRGF0YSkge1xuICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5nZXQobWVtYmVyRGF0YS51c2VyX2lkKTtcbiAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWVtYmVyc1ttZW1iZXJEYXRhLnVzZXJfaWRdO1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1iZXI7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMubXlJRCA9IG51bGw7XG4gICAgICAgIHRoaXMubWUgPSBudWxsO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9wcmVzZW5jZV9jaGFubmVsLnRzXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5cblxuXG5cbmNsYXNzIHByZXNlbmNlX2NoYW5uZWxfUHJlc2VuY2VDaGFubmVsIGV4dGVuZHMgcHJpdmF0ZV9jaGFubmVsX1ByaXZhdGVDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgcHVzaGVyKTtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbmV3IG1lbWJlcnNfTWVtYmVycygpO1xuICAgIH1cbiAgICBhdXRob3JpemUoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyLmF1dGhvcml6ZShzb2NrZXRJZCwgKGVycm9yLCBhdXRoRGF0YSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGF1dGhEYXRhID0gYXV0aERhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGhEYXRhLmNoYW5uZWxfZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFubmVsRGF0YSA9IEpTT04ucGFyc2UoYXV0aERhdGEuY2hhbm5lbF9kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldE15SUQoY2hhbm5lbERhdGEudXNlcl9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnB1c2hlci51c2VyLnNpZ25pbkRvbmVQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wdXNoZXIudXNlci51c2VyX2RhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldE15SUQodGhpcy5wdXNoZXIudXNlci51c2VyX2RhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnYXV0aG9yaXphdGlvbkVuZHBvaW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEludmFsaWQgYXV0aCByZXNwb25zZSBmb3IgY2hhbm5lbCAnJHt0aGlzLm5hbWV9JywgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkICdjaGFubmVsX2RhdGEnIGZpZWxkLiAke3N1ZmZpeH0sIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBvciB0aGUgdXNlciBzaG91bGQgYmUgc2lnbmVkIGluLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soJ0ludmFsaWQgYXV0aCByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGF1dGhEYXRhKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludGVybmFsRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICBpZiAoZXZlbnQudXNlcl9pZCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnVzZXJfaWQgPSBldmVudC51c2VyX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUludGVybmFsRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX2NvdW50JzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkNvdW50RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHVzaGVyX2ludGVybmFsOm1lbWJlcl9hZGRlZCc6XG4gICAgICAgICAgICAgICAgdmFyIGFkZGVkTWVtYmVyID0gdGhpcy5tZW1iZXJzLmFkZE1lbWJlcihkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjptZW1iZXJfYWRkZWQnLCBhZGRlZE1lbWJlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6bWVtYmVyX3JlbW92ZWQnOlxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkTWVtYmVyID0gdGhpcy5tZW1iZXJzLnJlbW92ZU1lbWJlcihkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE1lbWJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjptZW1iZXJfcmVtb3ZlZCcsIHJlbW92ZWRNZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hlci51bnN1YnNjcmliZSh0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzLm9uU3Vic2NyaXB0aW9uKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwdXNoZXI6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcsIHRoaXMubWVtYmVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLnJlc2V0KCk7XG4gICAgICAgIHN1cGVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi91dGY4L2xpYi91dGY4LmpzXG52YXIgdXRmOCA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvYmFzZTY0L2xpYi9iYXNlNjQuanNcbnZhciBiYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2VuY3J5cHRlZF9jaGFubmVsLnRzXG5cblxuXG5cblxuY2xhc3MgZW5jcnlwdGVkX2NoYW5uZWxfRW5jcnlwdGVkQ2hhbm5lbCBleHRlbmRzIHByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcHVzaGVyLCBuYWNsKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHB1c2hlcik7XG4gICAgICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uYWNsID0gbmFjbDtcbiAgICB9XG4gICAgYXV0aG9yaXplKHNvY2tldElkLCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlci5hdXRob3JpemUoc29ja2V0SWQsIChlcnJvciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBhdXRoRGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNoYXJlZFNlY3JldCA9IGF1dGhEYXRhWydzaGFyZWRfc2VjcmV0J107XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFNlY3JldCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgTm8gc2hhcmVkX3NlY3JldCBrZXkgaW4gYXV0aCBwYXlsb2FkIGZvciBlbmNyeXB0ZWQgY2hhbm5lbDogJHt0aGlzLm5hbWV9YCksIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2V5ID0gT2JqZWN0KGJhc2U2NFtcImRlY29kZVwiXSkoc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgIGRlbGV0ZSBhdXRoRGF0YVsnc2hhcmVkX3NlY3JldCddO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYXV0aERhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJpZ2dlcihldmVudCwgZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGZWF0dXJlKCdDbGllbnQgZXZlbnRzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBmb3IgZW5jcnlwdGVkIGNoYW5uZWxzJyk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMCB8fFxuICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgc3VwZXIuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlRW5jcnlwdGVkRXZlbnQoZXZlbnROYW1lLCBkYXRhKTtcbiAgICB9XG4gICAgaGFuZGxlRW5jcnlwdGVkRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdSZWNlaXZlZCBlbmNyeXB0ZWQgZXZlbnQgYmVmb3JlIGtleSBoYXMgYmVlbiByZXRyaWV2ZWQgZnJvbSB0aGUgYXV0aEVuZHBvaW50Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmNpcGhlcnRleHQgfHwgIWRhdGEubm9uY2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignVW5leHBlY3RlZCBmb3JtYXQgZm9yIGVuY3J5cHRlZCBldmVudCwgZXhwZWN0ZWQgb2JqZWN0IHdpdGggYGNpcGhlcnRleHRgIGFuZCBgbm9uY2VgIGZpZWxkcywgZ290OiAnICtcbiAgICAgICAgICAgICAgICBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2lwaGVyVGV4dCA9IE9iamVjdChiYXNlNjRbXCJkZWNvZGVcIl0pKGRhdGEuY2lwaGVydGV4dCk7XG4gICAgICAgIGlmIChjaXBoZXJUZXh0Lmxlbmd0aCA8IHRoaXMubmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IGNpcGhlcnRleHQgbGVuZ3RoIHRvIGJlICR7dGhpcy5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aH0sIGdvdDogJHtjaXBoZXJUZXh0Lmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9uY2UgPSBPYmplY3QoYmFzZTY0W1wiZGVjb2RlXCJdKShkYXRhLm5vbmNlKTtcbiAgICAgICAgaWYgKG5vbmNlLmxlbmd0aCA8IHRoaXMubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IG5vbmNlIGxlbmd0aCB0byBiZSAke3RoaXMubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGh9LCBnb3Q6ICR7bm9uY2UubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlcyA9IHRoaXMubmFjbC5zZWNyZXRib3gub3BlbihjaXBoZXJUZXh0LCBub25jZSwgdGhpcy5rZXkpO1xuICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRmFpbGVkIHRvIGRlY3J5cHQgYW4gZXZlbnQsIHByb2JhYmx5IGJlY2F1c2UgaXQgd2FzIGVuY3J5cHRlZCB3aXRoIGEgZGlmZmVyZW50IGtleS4gRmV0Y2hpbmcgYSBuZXcga2V5IGZyb20gdGhlIGF1dGhFbmRwb2ludC4uLicpO1xuICAgICAgICAgICAgdGhpcy5hdXRob3JpemUodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zb2NrZXRfaWQsIChlcnJvciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbWFrZSBhIHJlcXVlc3QgdG8gdGhlIGF1dGhFbmRwb2ludDogJHthdXRoRGF0YX0uIFVuYWJsZSB0byBmZXRjaCBuZXcga2V5LCBzbyBkcm9wcGluZyBlbmNyeXB0ZWQgZXZlbnRgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlcyA9IHRoaXMubmFjbC5zZWNyZXRib3gub3BlbihjaXBoZXJUZXh0LCBub25jZSwgdGhpcy5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBkZWNyeXB0IGV2ZW50IHdpdGggbmV3IGtleS4gRHJvcHBpbmcgZW5jcnlwdGVkIGV2ZW50YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCB0aGlzLmdldERhdGFUb0VtaXQoYnl0ZXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoZXZlbnQsIHRoaXMuZ2V0RGF0YVRvRW1pdChieXRlcykpO1xuICAgIH1cbiAgICBnZXREYXRhVG9FbWl0KGJ5dGVzKSB7XG4gICAgICAgIGxldCByYXcgPSBPYmplY3QodXRmOFtcImRlY29kZVwiXSkoYnl0ZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiByYXc7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9jb25uZWN0aW9uX21hbmFnZXIudHNcblxuXG5cblxuXG5jbGFzcyBjb25uZWN0aW9uX21hbmFnZXJfQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ2luaXRpYWxpemVkJztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSB0aGlzLm9wdGlvbnMudGltZWxpbmU7XG4gICAgICAgIHRoaXMudXNpbmdUTFMgPSB0aGlzLm9wdGlvbnMudXNlVExTO1xuICAgICAgICB0aGlzLmVycm9yQ2FsbGJhY2tzID0gdGhpcy5idWlsZEVycm9yQ2FsbGJhY2tzKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcyA9IHRoaXMuYnVpbGRDb25uZWN0aW9uQ2FsbGJhY2tzKHRoaXMuZXJyb3JDYWxsYmFja3MpO1xuICAgICAgICB0aGlzLmhhbmRzaGFrZUNhbGxiYWNrcyA9IHRoaXMuYnVpbGRIYW5kc2hha2VDYWxsYmFja3ModGhpcy5lcnJvckNhbGxiYWNrcyk7XG4gICAgICAgIHZhciBOZXR3b3JrID0gbm9kZV9ydW50aW1lLmdldE5ldHdvcmsoKTtcbiAgICAgICAgTmV0d29yay5iaW5kKCdvbmxpbmUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBuZXRpbmZvOiAnb25saW5lJyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ3VuYXZhaWxhYmxlJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0cnlJbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE5ldHdvcmsuYmluZCgnb2ZmbGluZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IG5ldGluZm86ICdvZmZsaW5lJyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0cmF0ZWd5KCk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gfHwgdGhpcy5ydW5uZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgnZmFpbGVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgnY29ubmVjdGluZycpO1xuICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICB0aGlzLnNldFVuYXZhaWxhYmxlVGltZXIoKTtcbiAgICB9XG4gICAgc2VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEludGVybmFsbHkoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgfVxuICAgIGlzVXNpbmdUTFMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzaW5nVExTO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IChlcnJvciwgaGFuZHNoYWtlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5lciA9IHRoaXMuc3RyYXRlZ3kuY29ubmVjdCgwLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlLmFjdGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0hhbmRzaGFrZUVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBoYW5kc2hha2UuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmUuZXJyb3IoeyBoYW5kc2hha2VFcnJvcjogaGFuZHNoYWtlLmVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kc2hha2VDYWxsYmFja3NbaGFuZHNoYWtlLmFjdGlvbl0oaGFuZHNoYWtlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVubmVyID0gdGhpcy5zdHJhdGVneS5jb25uZWN0KDAsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYWJvcnRDb25uZWN0aW5nKCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMucnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLnJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdEludGVybmFsbHkoKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIHRoaXMuY2xlYXJSZXRyeVRpbWVyKCk7XG4gICAgICAgIHRoaXMuY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5hYmFuZG9uQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0cmF0ZWd5KCkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5vcHRpb25zLmdldFN0cmF0ZWd5KHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgICAgICAgIHVzZVRMUzogdGhpcy51c2luZ1RMU1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0cnlJbihkZWxheSkge1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBhY3Rpb246ICdyZXRyeScsIGRlbGF5OiBkZWxheSB9KTtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW5nX2luJywgTWF0aC5yb3VuZChkZWxheSAvIDEwMDApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJ5VGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKGRlbGF5IHx8IDAsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEludGVybmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJSZXRyeVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZXRyeVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRVbmF2YWlsYWJsZVRpbWVyKCkge1xuICAgICAgICB0aGlzLnVuYXZhaWxhYmxlVGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKHRoaXMub3B0aW9ucy51bmF2YWlsYWJsZVRpbWVvdXQsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoJ3VuYXZhaWxhYmxlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhclVuYXZhaWxhYmxlVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuYXZhaWxhYmxlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudW5hdmFpbGFibGVUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZEFjdGl2aXR5Q2hlY2soKSB7XG4gICAgICAgIHRoaXMuc3RvcEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnBpbmcoKTtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcih0aGlzLm9wdGlvbnMucG9uZ1RpbWVvdXQsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmUuZXJyb3IoeyBwb25nX3RpbWVkX291dDogdGhpcy5vcHRpb25zLnBvbmdUaW1lb3V0IH0pO1xuICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzZXRBY3Rpdml0eUNoZWNrKCkge1xuICAgICAgICB0aGlzLnN0b3BBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gJiYgIXRoaXMuY29ubmVjdGlvbi5oYW5kbGVzQWN0aXZpdHlDaGVja3MoKSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcih0aGlzLmFjdGl2aXR5VGltZW91dCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3BBY3Rpdml0eUNoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5hY3Rpdml0eVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2aXR5VGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkQ29ubmVjdGlvbkNhbGxiYWNrcyhlcnJvckNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBlcnJvckNhbGxiYWNrcywge1xuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaW5nOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kX2V2ZW50KCdwdXNoZXI6cG9uZycsIHt9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3Rpdml0eTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJhbmRvbkNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRSZXRyeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnlJbigxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZEhhbmRzaGFrZUNhbGxiYWNrcyhlcnJvckNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBlcnJvckNhbGxiYWNrcywge1xuICAgICAgICAgICAgY29ubmVjdGVkOiAoaGFuZHNoYWtlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVvdXQgPSBNYXRoLm1pbih0aGlzLm9wdGlvbnMuYWN0aXZpdHlUaW1lb3V0LCBoYW5kc2hha2UuYWN0aXZpdHlUaW1lb3V0LCBoYW5kc2hha2UuY29ubmVjdGlvbi5hY3Rpdml0eVRpbWVvdXQgfHwgSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uKGhhbmRzaGFrZS5jb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldF9pZCA9IHRoaXMuY29ubmVjdGlvbi5pZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdjb25uZWN0ZWQnLCB7IHNvY2tldF9pZDogdGhpcy5zb2NrZXRfaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZEVycm9yQ2FsbGJhY2tzKCkge1xuICAgICAgICBsZXQgd2l0aEVycm9yRW1pdHRlZCA9IGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgeyB0eXBlOiAnV2ViU29ja2V0RXJyb3InLCBlcnJvcjogcmVzdWx0LmVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRsc19vbmx5OiB3aXRoRXJyb3JFbWl0dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzaW5nVExTID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0cmF0ZWd5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZWZ1c2VkOiB3aXRoRXJyb3JFbWl0dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYmFja29mZjogd2l0aEVycm9yRW1pdHRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDEwMDApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXRyeTogd2l0aEVycm9yRW1pdHRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGZvciAodmFyIGV2ZW50IGluIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoZXZlbnQsIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgfVxuICAgIGFiYW5kb25Db25uZWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgZm9yICh2YXIgZXZlbnQgaW4gdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24udW5iaW5kKGV2ZW50LCB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3NbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBkYXRhKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gbmV3U3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZURlc2NyaXB0aW9uID0gbmV3U3RhdGU7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGVEZXNjcmlwdGlvbiA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZURlc2NyaXB0aW9uICs9ICcgd2l0aCBuZXcgc29ja2V0IElEICcgKyBkYXRhLnNvY2tldF9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnU3RhdGUgY2hhbmdlZCcsIHByZXZpb3VzU3RhdGUgKyAnIC0+ICcgKyBuZXdTdGF0ZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IHN0YXRlOiBuZXdTdGF0ZSwgcGFyYW1zOiBkYXRhIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGF0ZV9jaGFuZ2UnLCB7IHByZXZpb3VzOiBwcmV2aW91c1N0YXRlLCBjdXJyZW50OiBuZXdTdGF0ZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChuZXdTdGF0ZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkUmV0cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2NoYW5uZWxzLnRzXG5cblxuXG5cbmNsYXNzIGNoYW5uZWxzX0NoYW5uZWxzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IHt9O1xuICAgIH1cbiAgICBhZGQobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGFubmVsc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tuYW1lXSA9IGNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tuYW1lXTtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdmFsdWVzKHRoaXMuY2hhbm5lbHMpO1xuICAgIH1cbiAgICBmaW5kKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgfVxuICAgIHJlbW92ZShuYW1lKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tuYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBvYmplY3RBcHBseSh0aGlzLmNoYW5uZWxzLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgY2hhbm5lbC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZigncHJpdmF0ZS1lbmNyeXB0ZWQtJykgPT09IDApIHtcbiAgICAgICAgaWYgKHB1c2hlci5jb25maWcubmFjbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlRW5jcnlwdGVkQ2hhbm5lbChuYW1lLCBwdXNoZXIsIHB1c2hlci5jb25maWcubmFjbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVyck1zZyA9ICdUcmllZCB0byBzdWJzY3JpYmUgdG8gYSBwcml2YXRlLWVuY3J5cHRlZC0gY2hhbm5lbCBidXQgbm8gbmFjbCBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUnO1xuICAgICAgICBsZXQgc3VmZml4ID0gdXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCdlbmNyeXB0ZWRDaGFubmVsU3VwcG9ydCcpO1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGZWF0dXJlKGAke2Vyck1zZ30uICR7c3VmZml4fWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3ByaXZhdGUtJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlUHJpdmF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdwcmVzZW5jZS0nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVQcmVzZW5jZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCcjJykgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEJhZENoYW5uZWxOYW1lKCdDYW5ub3QgY3JlYXRlIGEgY2hhbm5lbCB3aXRoIG5hbWUgXCInICsgbmFtZSArICdcIi4nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvZmFjdG9yeS50c1xuXG5cblxuXG5cblxuXG5cblxudmFyIEZhY3RvcnkgPSB7XG4gICAgY3JlYXRlQ2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2hhbm5lbHNfQ2hhbm5lbHMoKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbm5lY3Rpb25NYW5hZ2VyKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbm5lY3Rpb25fbWFuYWdlcl9Db25uZWN0aW9uTWFuYWdlcihrZXksIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjaGFubmVsX0NoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9LFxuICAgIGNyZWF0ZVByaXZhdGVDaGFubmVsKG5hbWUsIHB1c2hlcikge1xuICAgICAgICByZXR1cm4gbmV3IHByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH0sXG4gICAgY3JlYXRlUHJlc2VuY2VDaGFubmVsKG5hbWUsIHB1c2hlcikge1xuICAgICAgICByZXR1cm4gbmV3IHByZXNlbmNlX2NoYW5uZWxfUHJlc2VuY2VDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfSxcbiAgICBjcmVhdGVFbmNyeXB0ZWRDaGFubmVsKG5hbWUsIHB1c2hlciwgbmFjbCkge1xuICAgICAgICByZXR1cm4gbmV3IGVuY3J5cHRlZF9jaGFubmVsX0VuY3J5cHRlZENoYW5uZWwobmFtZSwgcHVzaGVyLCBuYWNsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVRpbWVsaW5lU2VuZGVyKHRpbWVsaW5lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGltZWxpbmVfc2VuZGVyX1RpbWVsaW5lU2VuZGVyKHRpbWVsaW5lLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhhbmRzaGFrZSh0cmFuc3BvcnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgaGFuZHNoYWtlX0hhbmRzaGFrZSh0cmFuc3BvcnQsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGNyZWF0ZUFzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlcihtYW5hZ2VyLCB0cmFuc3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlcihtYW5hZ2VyLCB0cmFuc3BvcnQsIG9wdGlvbnMpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmYWN0b3J5ID0gKEZhY3RvcnkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RyYW5zcG9ydHMvdHJhbnNwb3J0X21hbmFnZXIudHNcblxuY2xhc3MgdHJhbnNwb3J0X21hbmFnZXJfVHJhbnNwb3J0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmxpdmVzTGVmdCA9IHRoaXMub3B0aW9ucy5saXZlcyB8fCBJbmZpbml0eTtcbiAgICB9XG4gICAgZ2V0QXNzaXN0YW50KHRyYW5zcG9ydCkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIodGhpcywgdHJhbnNwb3J0LCB7XG4gICAgICAgICAgICBtaW5QaW5nRGVsYXk6IHRoaXMub3B0aW9ucy5taW5QaW5nRGVsYXksXG4gICAgICAgICAgICBtYXhQaW5nRGVsYXk6IHRoaXMub3B0aW9ucy5tYXhQaW5nRGVsYXlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQWxpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdmVzTGVmdCA+IDA7XG4gICAgfVxuICAgIHJlcG9ydERlYXRoKCkge1xuICAgICAgICB0aGlzLmxpdmVzTGVmdCAtPSAxO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL3NlcXVlbnRpYWxfc3RyYXRlZ3kudHNcblxuXG5cbmNsYXNzIHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVnaWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ2llcyA9IHN0cmF0ZWdpZXM7XG4gICAgICAgIHRoaXMubG9vcCA9IEJvb2xlYW4ob3B0aW9ucy5sb29wKTtcbiAgICAgICAgdGhpcy5mYWlsRmFzdCA9IEJvb2xlYW4ob3B0aW9ucy5mYWlsRmFzdCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgdGhpcy50aW1lb3V0TGltaXQgPSBvcHRpb25zLnRpbWVvdXRMaW1pdDtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5zdHJhdGVnaWVzLCB1dGlsLm1ldGhvZCgnaXNTdXBwb3J0ZWQnKSk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdHJhdGVnaWVzID0gdGhpcy5zdHJhdGVnaWVzO1xuICAgICAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICB2YXIgcnVubmVyID0gbnVsbDtcbiAgICAgICAgdmFyIHRyeU5leHRTdHJhdGVneSA9IChlcnJvciwgaGFuZHNoYWtlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaGFuZHNoYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50ICUgc3RyYXRlZ2llcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50IDwgc3RyYXRlZ2llcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSB0aW1lb3V0ICogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0LCB0aGlzLnRpbWVvdXRMaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcnVubmVyID0gdGhpcy50cnlTdHJhdGVneShzdHJhdGVnaWVzW2N1cnJlbnRdLCBtaW5Qcmlvcml0eSwgeyB0aW1lb3V0LCBmYWlsRmFzdDogdGhpcy5mYWlsRmFzdCB9LCB0cnlOZXh0U3RyYXRlZ3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBydW5uZXIgPSB0aGlzLnRyeVN0cmF0ZWd5KHN0cmF0ZWdpZXNbY3VycmVudF0sIG1pblByaW9yaXR5LCB7IHRpbWVvdXQ6IHRpbWVvdXQsIGZhaWxGYXN0OiB0aGlzLmZhaWxGYXN0IH0sIHRyeU5leHRTdHJhdGVneSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cnlTdHJhdGVneShzdHJhdGVneSwgbWluUHJpb3JpdHksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgICAgIHZhciBydW5uZXIgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKG9wdGlvbnMudGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVubmVyID0gc3RyYXRlZ3kuY29ubmVjdChtaW5Qcmlvcml0eSwgZnVuY3Rpb24gKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiB0aW1lciAmJiB0aW1lci5pc1J1bm5pbmcoKSAmJiAhb3B0aW9ucy5mYWlsRmFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIHRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBoYW5kc2hha2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9iZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5LnRzXG5cblxuY2xhc3MgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVnaWVzKSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ2llcyA9IHN0cmF0ZWdpZXM7XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuc3RyYXRlZ2llcywgdXRpbC5tZXRob2QoJ2lzU3VwcG9ydGVkJykpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY29ubmVjdCh0aGlzLnN0cmF0ZWdpZXMsIG1pblByaW9yaXR5LCBmdW5jdGlvbiAoaSwgcnVubmVycykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyc1tpXS5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsUnVubmVyc0ZhaWxlZChydW5uZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBseShydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KGhhbmRzaGFrZS50cmFuc3BvcnQucHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhbmRzaGFrZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb25uZWN0KHN0cmF0ZWdpZXMsIG1pblByaW9yaXR5LCBjYWxsYmFja0J1aWxkZXIpIHtcbiAgICB2YXIgcnVubmVycyA9IG1hcChzdHJhdGVnaWVzLCBmdW5jdGlvbiAoc3RyYXRlZ3ksIGksIF8sIHJzKSB7XG4gICAgICAgIHJldHVybiBzdHJhdGVneS5jb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFja0J1aWxkZXIoaSwgcnMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXBwbHkocnVubmVycywgYWJvcnRSdW5uZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgYXBwbHkocnVubmVycywgZnVuY3Rpb24gKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gYWxsUnVubmVyc0ZhaWxlZChydW5uZXJzKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25zX2FsbChydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHJ1bm5lci5lcnJvcik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhYm9ydFJ1bm5lcihydW5uZXIpIHtcbiAgICBpZiAoIXJ1bm5lci5lcnJvciAmJiAhcnVubmVyLmFib3J0ZWQpIHtcbiAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgIHJ1bm5lci5hYm9ydGVkID0gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy93ZWJzb2NrZXRfcHJpb3JpdGl6ZWRfY2FjaGVkX3N0cmF0ZWd5LnRzXG5cblxuXG5cbmNsYXNzIHdlYnNvY2tldF9wcmlvcml0aXplZF9jYWNoZWRfc3RyYXRlZ3lfV2ViU29ja2V0UHJpb3JpdGl6ZWRDYWNoZWRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ3ksIHRyYW5zcG9ydHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzO1xuICAgICAgICB0aGlzLnR0bCA9IG9wdGlvbnMudHRsIHx8IDE4MDAgKiAxMDAwO1xuICAgICAgICB0aGlzLnVzaW5nVExTID0gb3B0aW9ucy51c2VUTFM7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSBvcHRpb25zLnRpbWVsaW5lO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHVzaW5nVExTID0gdGhpcy51c2luZ1RMUztcbiAgICAgICAgdmFyIGluZm8gPSBmZXRjaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKTtcbiAgICAgICAgdmFyIGNhY2hlU2tpcENvdW50ID0gaW5mbyAmJiBpbmZvLmNhY2hlU2tpcENvdW50ID8gaW5mby5jYWNoZVNraXBDb3VudCA6IDA7XG4gICAgICAgIHZhciBzdHJhdGVnaWVzID0gW3RoaXMuc3RyYXRlZ3ldO1xuICAgICAgICBpZiAoaW5mbyAmJiBpbmZvLnRpbWVzdGFtcCArIHRoaXMudHRsID49IHV0aWwubm93KCkpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbaW5mby50cmFuc3BvcnRdO1xuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGlmIChbJ3dzJywgJ3dzcyddLmluY2x1ZGVzKGluZm8udHJhbnNwb3J0KSB8fCBjYWNoZVNraXBDb3VudCA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaW5mby50cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlbmN5OiBpbmZvLmxhdGVuY3lcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmF0ZWdpZXMucHVzaChuZXcgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3koW3RyYW5zcG9ydF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IGluZm8ubGF0ZW5jeSAqIDIgKyAxMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbEZhc3Q6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVTa2lwQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0VGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgdmFyIHJ1bm5lciA9IHN0cmF0ZWdpZXNcbiAgICAgICAgICAgIC5wb3AoKVxuICAgICAgICAgICAgLmNvbm5lY3QobWluUHJpb3JpdHksIGZ1bmN0aW9uIGNiKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGZsdXNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVnaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXAgPSB1dGlsLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIgPSBzdHJhdGVnaWVzLnBvcCgpLmNvbm5lY3QobWluUHJpb3JpdHksIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yZVRyYW5zcG9ydENhY2hlKHVzaW5nVExTLCBoYW5kc2hha2UudHJhbnNwb3J0Lm5hbWUsIHV0aWwubm93KCkgLSBzdGFydFRpbWVzdGFtcCwgY2FjaGVTa2lwQ291bnQpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhbmRzaGFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIG1pblByaW9yaXR5ID0gcDtcbiAgICAgICAgICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUcmFuc3BvcnRDYWNoZUtleSh1c2luZ1RMUykge1xuICAgIHJldHVybiAncHVzaGVyVHJhbnNwb3J0JyArICh1c2luZ1RMUyA/ICdUTFMnIDogJ05vblRMUycpO1xufVxuZnVuY3Rpb24gZmV0Y2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUykge1xuICAgIHZhciBzdG9yYWdlID0gbm9kZV9ydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZENhY2hlID0gc3RvcmFnZVtnZXRUcmFuc3BvcnRDYWNoZUtleSh1c2luZ1RMUyldO1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHNlcmlhbGl6ZWRDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGZsdXNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc3RvcmVUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUywgdHJhbnNwb3J0LCBsYXRlbmN5LCBjYWNoZVNraXBDb3VudCkge1xuICAgIHZhciBzdG9yYWdlID0gbm9kZV9ydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdG9yYWdlW2dldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKV0gPSBzYWZlSlNPTlN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB1dGlsLm5vdygpLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IGxhdGVuY3ksXG4gICAgICAgICAgICAgICAgY2FjaGVTa2lwQ291bnQ6IGNhY2hlU2tpcENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmx1c2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUykge1xuICAgIHZhciBzdG9yYWdlID0gbm9kZV9ydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmFnZVtnZXRUcmFuc3BvcnRDYWNoZUtleSh1c2luZ1RMUyldO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9kZWxheWVkX3N0cmF0ZWd5LnRzXG5cbmNsYXNzIGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVneSwgeyBkZWxheTogbnVtYmVyIH0pIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7IGRlbGF5OiBudW1iZXIgfTtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmlzU3VwcG9ydGVkKCk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdHJhdGVneSA9IHRoaXMuc3RyYXRlZ3k7XG4gICAgICAgIHZhciBydW5uZXI7XG4gICAgICAgIHZhciB0aW1lciA9IG5ldyB0aW1lcnNfT25lT2ZmVGltZXIodGhpcy5vcHRpb25zLmRlbGF5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBzdHJhdGVneS5jb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBtaW5Qcmlvcml0eSA9IHA7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvaWZfc3RyYXRlZ3kudHNcbmNsYXNzIElmU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKHRlc3QsIHRydWVCcmFuY2gsIGZhbHNlQnJhbmNoKSB7XG4gICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgIHRoaXMudHJ1ZUJyYW5jaCA9IHRydWVCcmFuY2g7XG4gICAgICAgIHRoaXMuZmFsc2VCcmFuY2ggPSBmYWxzZUJyYW5jaDtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHZhciBicmFuY2ggPSB0aGlzLnRlc3QoKSA/IHRoaXMudHJ1ZUJyYW5jaCA6IHRoaXMuZmFsc2VCcmFuY2g7XG4gICAgICAgIHJldHVybiBicmFuY2guaXNTdXBwb3J0ZWQoKTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGJyYW5jaCA9IHRoaXMudGVzdCgpID8gdGhpcy50cnVlQnJhbmNoIDogdGhpcy5mYWxzZUJyYW5jaDtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5jb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvZmlyc3RfY29ubmVjdGVkX3N0cmF0ZWd5LnRzXG5jbGFzcyBGaXJzdENvbm5lY3RlZFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVneSkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcnVubmVyID0gdGhpcy5zdHJhdGVneS5jb25uZWN0KG1pblByaW9yaXR5LCBmdW5jdGlvbiAoZXJyb3IsIGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgaWYgKGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGhhbmRzaGFrZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy9kZWZhdWx0X3N0cmF0ZWd5LnRzXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gdGVzdFN1cHBvcnRzU3RyYXRlZ3koc3RyYXRlZ3kpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9O1xufVxudmFyIGdldERlZmF1bHRTdHJhdGVneSA9IGZ1bmN0aW9uIChjb25maWcsIGJhc2VPcHRpb25zLCBkZWZpbmVUcmFuc3BvcnQpIHtcbiAgICB2YXIgZGVmaW5lZFRyYW5zcG9ydHMgPSB7fTtcbiAgICBmdW5jdGlvbiBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneShuYW1lLCB0eXBlLCBwcmlvcml0eSwgb3B0aW9ucywgbWFuYWdlcikge1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0KGNvbmZpZywgbmFtZSwgdHlwZSwgcHJpb3JpdHksIG9wdGlvbnMsIG1hbmFnZXIpO1xuICAgICAgICBkZWZpbmVkVHJhbnNwb3J0c1tuYW1lXSA9IHRyYW5zcG9ydDtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICB9XG4gICAgdmFyIHdzX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlT3B0aW9ucywge1xuICAgICAgICBob3N0Tm9uVExTOiBjb25maWcud3NIb3N0ICsgJzonICsgY29uZmlnLndzUG9ydCxcbiAgICAgICAgaG9zdFRMUzogY29uZmlnLndzSG9zdCArICc6JyArIGNvbmZpZy53c3NQb3J0LFxuICAgICAgICBodHRwUGF0aDogY29uZmlnLndzUGF0aFxuICAgIH0pO1xuICAgIHZhciB3c3Nfb3B0aW9ucyA9IGV4dGVuZCh7fSwgd3Nfb3B0aW9ucywge1xuICAgICAgICB1c2VUTFM6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgaHR0cF9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZU9wdGlvbnMsIHtcbiAgICAgICAgaG9zdE5vblRMUzogY29uZmlnLmh0dHBIb3N0ICsgJzonICsgY29uZmlnLmh0dHBQb3J0LFxuICAgICAgICBob3N0VExTOiBjb25maWcuaHR0cEhvc3QgKyAnOicgKyBjb25maWcuaHR0cHNQb3J0LFxuICAgICAgICBodHRwUGF0aDogY29uZmlnLmh0dHBQYXRoXG4gICAgfSk7XG4gICAgdmFyIHRpbWVvdXRzID0ge1xuICAgICAgICBsb29wOiB0cnVlLFxuICAgICAgICB0aW1lb3V0OiAxNTAwMCxcbiAgICAgICAgdGltZW91dExpbWl0OiA2MDAwMFxuICAgIH07XG4gICAgdmFyIHdzX21hbmFnZXIgPSBuZXcgdHJhbnNwb3J0X21hbmFnZXJfVHJhbnNwb3J0TWFuYWdlcih7XG4gICAgICAgIG1pblBpbmdEZWxheTogMTAwMDAsXG4gICAgICAgIG1heFBpbmdEZWxheTogY29uZmlnLmFjdGl2aXR5VGltZW91dFxuICAgIH0pO1xuICAgIHZhciBzdHJlYW1pbmdfbWFuYWdlciA9IG5ldyB0cmFuc3BvcnRfbWFuYWdlcl9UcmFuc3BvcnRNYW5hZ2VyKHtcbiAgICAgICAgbGl2ZXM6IDIsXG4gICAgICAgIG1pblBpbmdEZWxheTogMTAwMDAsXG4gICAgICAgIG1heFBpbmdEZWxheTogY29uZmlnLmFjdGl2aXR5VGltZW91dFxuICAgIH0pO1xuICAgIHZhciB3c190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgnd3MnLCAnd3MnLCAzLCB3c19vcHRpb25zLCB3c19tYW5hZ2VyKTtcbiAgICB2YXIgd3NzX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd3c3MnLCAnd3MnLCAzLCB3c3Nfb3B0aW9ucywgd3NfbWFuYWdlcik7XG4gICAgdmFyIHhocl9zdHJlYW1pbmdfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3hocl9zdHJlYW1pbmcnLCAneGhyX3N0cmVhbWluZycsIDEsIGh0dHBfb3B0aW9ucywgc3RyZWFtaW5nX21hbmFnZXIpO1xuICAgIHZhciB4aHJfcG9sbGluZ190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgneGhyX3BvbGxpbmcnLCAneGhyX3BvbGxpbmcnLCAxLCBodHRwX29wdGlvbnMpO1xuICAgIHZhciB3c19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt3c190cmFuc3BvcnRdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHdzc19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt3c3NfdHJhbnNwb3J0XSwgdGltZW91dHMpO1xuICAgIHZhciBzdHJlYW1pbmdfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbeGhyX3N0cmVhbWluZ190cmFuc3BvcnRdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHBvbGxpbmdfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbeGhyX3BvbGxpbmdfdHJhbnNwb3J0XSwgdGltZW91dHMpO1xuICAgIHZhciBodHRwX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3koW1xuICAgICAgICBuZXcgSWZTdHJhdGVneSh0ZXN0U3VwcG9ydHNTdHJhdGVneShzdHJlYW1pbmdfbG9vcCksIG5ldyBiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5X0Jlc3RDb25uZWN0ZWRFdmVyU3RyYXRlZ3koW1xuICAgICAgICAgICAgc3RyZWFtaW5nX2xvb3AsXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3kocG9sbGluZ19sb29wLCB7IGRlbGF5OiA0MDAwIH0pXG4gICAgICAgIF0pLCBwb2xsaW5nX2xvb3ApXG4gICAgXSwgdGltZW91dHMpO1xuICAgIHZhciB3c1N0cmF0ZWd5O1xuICAgIGlmIChiYXNlT3B0aW9ucy51c2VUTFMpIHtcbiAgICAgICAgd3NTdHJhdGVneSA9IG5ldyBiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5X0Jlc3RDb25uZWN0ZWRFdmVyU3RyYXRlZ3koW1xuICAgICAgICAgICAgd3NfbG9vcCxcbiAgICAgICAgICAgIG5ldyBkZWxheWVkX3N0cmF0ZWd5X0RlbGF5ZWRTdHJhdGVneShodHRwX2xvb3AsIHsgZGVsYXk6IDIwMDAgfSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3c1N0cmF0ZWd5ID0gbmV3IGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3lfQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneShbXG4gICAgICAgICAgICB3c19sb29wLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5KHdzc19sb29wLCB7IGRlbGF5OiAyMDAwIH0pLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5KGh0dHBfbG9vcCwgeyBkZWxheTogNTAwMCB9KVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB3ZWJzb2NrZXRfcHJpb3JpdGl6ZWRfY2FjaGVkX3N0cmF0ZWd5X1dlYlNvY2tldFByaW9yaXRpemVkQ2FjaGVkU3RyYXRlZ3kobmV3IEZpcnN0Q29ubmVjdGVkU3RyYXRlZ3kobmV3IElmU3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3kod3NfdHJhbnNwb3J0KSwgd3NTdHJhdGVneSwgaHR0cF9sb29wKSksIGRlZmluZWRUcmFuc3BvcnRzLCB7XG4gICAgICAgIHR0bDogMTgwMDAwMCxcbiAgICAgICAgdGltZWxpbmU6IGJhc2VPcHRpb25zLnRpbWVsaW5lLFxuICAgICAgICB1c2VUTFM6IGJhc2VPcHRpb25zLnVzZVRMU1xuICAgIH0pO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRlZmF1bHRfc3RyYXRlZ3kgPSAoZ2V0RGVmYXVsdFN0cmF0ZWd5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy90cmFuc3BvcnRzL3RyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyLnRzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRfY29ubmVjdGlvbl9pbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudGltZWxpbmUuaW5mbyhzZWxmLmJ1aWxkVGltZWxpbmVNZXNzYWdlKHtcbiAgICAgICAgdHJhbnNwb3J0OiBzZWxmLm5hbWUgKyAoc2VsZi5vcHRpb25zLnVzZVRMUyA/ICdzJyA6ICcnKVxuICAgIH0pKTtcbiAgICBpZiAoc2VsZi5ob29rcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgc2VsZi5jaGFuZ2VTdGF0ZSgnaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgIH1cbn0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9yZXF1ZXN0LnRzXG5cblxuY29uc3QgTUFYX0JVRkZFUl9MRU5HVEggPSAyNTYgKiAxMDI0O1xuY2xhc3MgaHR0cF9yZXF1ZXN0X0hUVFBSZXF1ZXN0IGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihob29rcywgbWV0aG9kLCB1cmwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxuICAgIHN0YXJ0KHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMueGhyID0gdGhpcy5ob29rcy5nZXRSZXF1ZXN0KHRoaXMpO1xuICAgICAgICB0aGlzLnVubG9hZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBub2RlX3J1bnRpbWUuYWRkVW5sb2FkTGlzdGVuZXIodGhpcy51bmxvYWRlcik7XG4gICAgICAgIHRoaXMueGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChwYXlsb2FkKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnVubG9hZGVyKSB7XG4gICAgICAgICAgICBub2RlX3J1bnRpbWUucmVtb3ZlVW5sb2FkTGlzdGVuZXIodGhpcy51bmxvYWRlcik7XG4gICAgICAgICAgICB0aGlzLnVubG9hZGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy54aHIpIHtcbiAgICAgICAgICAgIHRoaXMuaG9va3MuYWJvcnRSZXF1ZXN0KHRoaXMueGhyKTtcbiAgICAgICAgICAgIHRoaXMueGhyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNodW5rKHN0YXR1cywgZGF0YSkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGNodW5rID0gdGhpcy5hZHZhbmNlQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjaHVuaycsIHsgc3RhdHVzOiBzdGF0dXMsIGRhdGE6IGNodW5rIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNCdWZmZXJUb29Mb25nKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2J1ZmZlcl90b29fbG9uZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkdmFuY2VCdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIHZhciB1bnJlYWREYXRhID0gYnVmZmVyLnNsaWNlKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB2YXIgZW5kT2ZMaW5lUG9zaXRpb24gPSB1bnJlYWREYXRhLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICBpZiAoZW5kT2ZMaW5lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGVuZE9mTGluZVBvc2l0aW9uICsgMTtcbiAgICAgICAgICAgIHJldHVybiB1bnJlYWREYXRhLnNsaWNlKDAsIGVuZE9mTGluZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQnVmZmVyVG9vTG9uZyhidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyLmxlbmd0aCA+IE1BWF9CVUZGRVJfTEVOR1RIO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9odHRwL3N0YXRlLnRzXG52YXIgU3RhdGU7XG4oZnVuY3Rpb24gKFN0YXRlKSB7XG4gICAgU3RhdGVbU3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QRU5cIl0gPSAxXSA9IFwiT1BFTlwiO1xuICAgIFN0YXRlW1N0YXRlW1wiQ0xPU0VEXCJdID0gM10gPSBcIkNMT1NFRFwiO1xufSkoU3RhdGUgfHwgKFN0YXRlID0ge30pKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN0YXRlID0gKFN0YXRlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9odHRwL2h0dHBfc29ja2V0LnRzXG5cblxuXG52YXIgYXV0b0luY3JlbWVudCA9IDE7XG5jbGFzcyBodHRwX3NvY2tldF9IVFRQU29ja2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihob29rcywgdXJsKSB7XG4gICAgICAgIHRoaXMuaG9va3MgPSBob29rcztcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gcmFuZG9tTnVtYmVyKDEwMDApICsgJy8nICsgcmFuZG9tU3RyaW5nKDgpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gZ2V0TG9jYXRpb24odXJsKTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGUuQ09OTkVDVElORztcbiAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XG4gICAgfVxuICAgIHNlbmQocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmF3KEpTT04uc3RyaW5naWZ5KFtwYXlsb2FkXSkpO1xuICAgIH1cbiAgICBwaW5nKCkge1xuICAgICAgICB0aGlzLmhvb2tzLnNlbmRIZWFydGJlYXQodGhpcyk7XG4gICAgfVxuICAgIGNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLm9uQ2xvc2UoY29kZSwgcmVhc29uLCB0cnVlKTtcbiAgICB9XG4gICAgc2VuZFJhdyhwYXlsb2FkKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLk9QRU4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9kZV9ydW50aW1lLmNyZWF0ZVNvY2tldFJlcXVlc3QoJ1BPU1QnLCBnZXRVbmlxdWVVUkwoZ2V0U2VuZFVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLnNlc3Npb24pKSkuc3RhcnQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XG4gICAgfVxuICAgIG9uQ2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICAgICAgICB0aGlzLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlLkNMT1NFRDtcbiAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgIHdhc0NsZWFuOiB3YXNDbGVhblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DaHVuayhjaHVuaykge1xuICAgICAgICBpZiAoY2h1bmsuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF5bG9hZDtcbiAgICAgICAgdmFyIHR5cGUgPSBjaHVuay5kYXRhLnNsaWNlKDAsIDEpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ3t9Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk9wZW4ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICdbXScpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF5bG9hZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXZlbnQocGF5bG9hZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY2h1bmsuZGF0YS5zbGljZSgxKSB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIHRoaXMub25FdmVudChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgIHRoaXMuaG9va3Mub25IZWFydGJlYXQodGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICdbXScpO1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW4ob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi5iYXNlID0gcmVwbGFjZUhvc3QodGhpcy5sb2NhdGlvbi5iYXNlLCBvcHRpb25zLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlLk9QRU47XG4gICAgICAgICAgICBpZiAodGhpcy5vbm9wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5PUEVOICYmIHRoaXMub25tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm9ubWVzc2FnZSh7IGRhdGE6IGV2ZW50IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQWN0aXZpdHkoKSB7XG4gICAgICAgIGlmICh0aGlzLm9uYWN0aXZpdHkpIHtcbiAgICAgICAgICAgIHRoaXMub25hY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMub25lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuU3RyZWFtKCkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG5vZGVfcnVudGltZS5jcmVhdGVTb2NrZXRSZXF1ZXN0KCdQT1NUJywgZ2V0VW5pcXVlVVJMKHRoaXMuaG9va3MuZ2V0UmVjZWl2ZVVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLnNlc3Npb24pKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmJpbmQoJ2NodW5rJywgY2h1bmsgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNodW5rKGNodW5rKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmJpbmQoJ2ZpbmlzaGVkJywgc3RhdHVzID0+IHtcbiAgICAgICAgICAgIHRoaXMuaG9va3Mub25GaW5pc2hlZCh0aGlzLCBzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnYnVmZmVyX3Rvb19sb25nJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdXRpbC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoMTAwNiwgJ0NvdWxkIG5vdCBzdGFydCBzdHJlYW1pbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZVN0cmVhbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS51bmJpbmRfYWxsKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TG9jYXRpb24odXJsKSB7XG4gICAgdmFyIHBhcnRzID0gLyhbXlxcP10qKVxcLyooXFw/Py4qKS8uZXhlYyh1cmwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IHBhcnRzWzFdLFxuICAgICAgICBxdWVyeVN0cmluZzogcGFydHNbMl1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VuZFVSTCh1cmwsIHNlc3Npb24pIHtcbiAgICByZXR1cm4gdXJsLmJhc2UgKyAnLycgKyBzZXNzaW9uICsgJy94aHJfc2VuZCc7XG59XG5mdW5jdGlvbiBnZXRVbmlxdWVVUkwodXJsKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnO1xuICAgIHJldHVybiB1cmwgKyBzZXBhcmF0b3IgKyAndD0nICsgK25ldyBEYXRlKCkgKyAnJm49JyArIGF1dG9JbmNyZW1lbnQrKztcbn1cbmZ1bmN0aW9uIHJlcGxhY2VIb3N0KHVybCwgaG9zdG5hbWUpIHtcbiAgICB2YXIgdXJsUGFydHMgPSAvKGh0dHBzPzpcXC9cXC8pKFteXFwvOl0rKSgoXFwvfDopPy4qKS8uZXhlYyh1cmwpO1xuICAgIHJldHVybiB1cmxQYXJ0c1sxXSArIGhvc3RuYW1lICsgdXJsUGFydHNbM107XG59XG5mdW5jdGlvbiByYW5kb21OdW1iZXIobWF4KSB7XG4gICAgcmV0dXJuIG5vZGVfcnVudGltZS5yYW5kb21JbnQobWF4KTtcbn1cbmZ1bmN0aW9uIHJhbmRvbVN0cmluZyhsZW5ndGgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChyYW5kb21OdW1iZXIoMzIpLnRvU3RyaW5nKDMyKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3NvY2tldCA9IChodHRwX3NvY2tldF9IVFRQU29ja2V0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9odHRwL2h0dHBfc3RyZWFtaW5nX3NvY2tldC50c1xudmFyIGh0dHBfc3RyZWFtaW5nX3NvY2tldF9ob29rcyA9IHtcbiAgICBnZXRSZWNlaXZlVVJMOiBmdW5jdGlvbiAodXJsLCBzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB1cmwuYmFzZSArICcvJyArIHNlc3Npb24gKyAnL3hocl9zdHJlYW1pbmcnICsgdXJsLnF1ZXJ5U3RyaW5nO1xuICAgIH0sXG4gICAgb25IZWFydGJlYXQ6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0LnNlbmRSYXcoJ1tdJyk7XG4gICAgfSxcbiAgICBzZW5kSGVhcnRiZWF0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHNvY2tldC5zZW5kUmF3KCdbXScpO1xuICAgIH0sXG4gICAgb25GaW5pc2hlZDogZnVuY3Rpb24gKHNvY2tldCwgc3RhdHVzKSB7XG4gICAgICAgIHNvY2tldC5vbkNsb3NlKDEwMDYsICdDb25uZWN0aW9uIGludGVycnVwdGVkICgnICsgc3RhdHVzICsgJyknLCBmYWxzZSk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfc3RyZWFtaW5nX3NvY2tldCA9IChodHRwX3N0cmVhbWluZ19zb2NrZXRfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9wb2xsaW5nX3NvY2tldC50c1xudmFyIGh0dHBfcG9sbGluZ19zb2NrZXRfaG9va3MgPSB7XG4gICAgZ2V0UmVjZWl2ZVVSTDogZnVuY3Rpb24gKHVybCwgc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gdXJsLmJhc2UgKyAnLycgKyBzZXNzaW9uICsgJy94aHInICsgdXJsLnF1ZXJ5U3RyaW5nO1xuICAgIH0sXG4gICAgb25IZWFydGJlYXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB9LFxuICAgIHNlbmRIZWFydGJlYXQ6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0LnNlbmRSYXcoJ1tdJyk7XG4gICAgfSxcbiAgICBvbkZpbmlzaGVkOiBmdW5jdGlvbiAoc29ja2V0LCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICBzb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb2NrZXQub25DbG9zZSgxMDA2LCAnQ29ubmVjdGlvbiBpbnRlcnJ1cHRlZCAoJyArIHN0YXR1cyArICcpJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfcG9sbGluZ19zb2NrZXQgPSAoaHR0cF9wb2xsaW5nX3NvY2tldF9ob29rcyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL2lzb21vcnBoaWMvaHR0cC9odHRwX3hocl9yZXF1ZXN0LnRzXG5cbnZhciBodHRwX3hocl9yZXF1ZXN0X2hvb2tzID0ge1xuICAgIGdldFJlcXVlc3Q6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gbm9kZV9ydW50aW1lLmdldFhIUkFQSSgpO1xuICAgICAgICB2YXIgeGhyID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoeGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUZXh0ICYmIHhoci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uQ2h1bmsoeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVGV4dCAmJiB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbkNodW5rKHhoci5zdGF0dXMsIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KCdmaW5pc2hlZCcsIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcbiAgICBhYm9ydFJlcXVlc3Q6IGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3hocl9yZXF1ZXN0ID0gKGh0dHBfeGhyX3JlcXVlc3RfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2h0dHAvaHR0cC50c1xuXG5cblxuXG5cbnZhciBIVFRQID0ge1xuICAgIGNyZWF0ZVN0cmVhbWluZ1NvY2tldCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29ja2V0KGh0dHBfc3RyZWFtaW5nX3NvY2tldCwgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVBvbGxpbmdTb2NrZXQodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvY2tldChodHRwX3BvbGxpbmdfc29ja2V0LCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlU29ja2V0KGhvb2tzLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwX3NvY2tldChob29rcywgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVhIUihtZXRob2QsIHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXF1ZXN0KGh0dHBfeGhyX3JlcXVlc3QsIG1ldGhvZCwgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVJlcXVlc3QoaG9va3MsIG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgaHR0cF9yZXF1ZXN0X0hUVFBSZXF1ZXN0KGhvb2tzLCBtZXRob2QsIHVybCk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfaHR0cCA9IChIVFRQKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy9ydW50aW1lLnRzXG5cblxuXG5cblxudmFyIElzb21vcnBoaWMgPSB7XG4gICAgZ2V0RGVmYXVsdFN0cmF0ZWd5OiBkZWZhdWx0X3N0cmF0ZWd5LFxuICAgIFRyYW5zcG9ydHM6IHRyYW5zcG9ydHMsXG4gICAgdHJhbnNwb3J0Q29ubmVjdGlvbkluaXRpYWxpemVyOiB0cmFuc3BvcnRfY29ubmVjdGlvbl9pbml0aWFsaXplcixcbiAgICBIVFRQRmFjdG9yeTogaHR0cF9odHRwLFxuICAgIHNldHVwKFB1c2hlckNsYXNzKSB7XG4gICAgICAgIFB1c2hlckNsYXNzLnJlYWR5KCk7XG4gICAgfSxcbiAgICBnZXRMb2NhbFN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBnZXRDbGllbnRGZWF0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMoZmlsdGVyT2JqZWN0KHsgd3M6IHRyYW5zcG9ydHMud3MgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmlzU3VwcG9ydGVkKHt9KTtcbiAgICAgICAgfSkpO1xuICAgIH0sXG4gICAgZ2V0UHJvdG9jb2woKSB7XG4gICAgICAgIHJldHVybiAnaHR0cDonO1xuICAgIH0sXG4gICAgaXNYSFJTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgY3JlYXRlU29ja2V0UmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgICAgICBpZiAodGhpcy5pc1hIUlN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5IVFRQRmFjdG9yeS5jcmVhdGVYSFIobWV0aG9kLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0Nyb3NzLW9yaWdpbiBIVFRQIHJlcXVlc3RzIGFyZSBub3Qgc3VwcG9ydGVkJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlWEhSKCkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzLmdldFhIUkFQSSgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgfSxcbiAgICBjcmVhdGVXZWJTb2NrZXQodXJsKSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0V2ViU29ja2V0QVBJKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IodXJsKTtcbiAgICB9LFxuICAgIGFkZFVubG9hZExpc3RlbmVyKGxpc3RlbmVyKSB7IH0sXG4gICAgcmVtb3ZlVW5sb2FkTGlzdGVuZXIobGlzdGVuZXIpIHsgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJ1bnRpbWUgPSAoSXNvbW9ycGhpYyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZmF5ZS13ZWJzb2NrZXQvbGliL2ZheWUvd2Vic29ja2V0LmpzXG52YXIgd2Vic29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMveG1saHR0cHJlcXVlc3QvbGliL1hNTEh0dHBSZXF1ZXN0LmpzXG52YXIgWE1MSHR0cFJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvbm9kZS9uZXRfaW5mby50c1xuXG5jbGFzcyBuZXRfaW5mb19OZXRJbmZvIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBpc09ubGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxudmFyIG5ldF9pbmZvX05ldHdvcmsgPSBuZXcgbmV0X2luZm9fTmV0SW5mbygpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvb3B0aW9ucy50c1xudmFyIEF1dGhSZXF1ZXN0VHlwZTtcbihmdW5jdGlvbiAoQXV0aFJlcXVlc3RUeXBlKSB7XG4gICAgQXV0aFJlcXVlc3RUeXBlW1wiVXNlckF1dGhlbnRpY2F0aW9uXCJdID0gXCJ1c2VyLWF1dGhlbnRpY2F0aW9uXCI7XG4gICAgQXV0aFJlcXVlc3RUeXBlW1wiQ2hhbm5lbEF1dGhvcml6YXRpb25cIl0gPSBcImNoYW5uZWwtYXV0aG9yaXphdGlvblwiO1xufSkoQXV0aFJlcXVlc3RUeXBlIHx8IChBdXRoUmVxdWVzdFR5cGUgPSB7fSkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2F1dGgveGhyX2F1dGgudHNcblxuXG5cblxuY29uc3QgYWpheCA9IGZ1bmN0aW9uIChjb250ZXh0LCBxdWVyeSwgYXV0aE9wdGlvbnMsIGF1dGhSZXF1ZXN0VHlwZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB4aHIgPSBub2RlX3J1bnRpbWUuY3JlYXRlWEhSKCk7XG4gICAgeGhyLm9wZW4oJ1BPU1QnLCBhdXRoT3B0aW9ucy5lbmRwb2ludCwgdHJ1ZSk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICBmb3IgKHZhciBoZWFkZXJOYW1lIGluIGF1dGhPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgYXV0aE9wdGlvbnMuaGVhZGVyc1toZWFkZXJOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZHluYW1pY0hlYWRlcnMgPSBhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIoKTtcbiAgICAgICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBkeW5hbWljSGVhZGVycykge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgZHluYW1pY0hlYWRlcnNbaGVhZGVyTmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEhUVFBBdXRoRXJyb3IoMjAwLCBgSlNPTiByZXR1cm5lZCBmcm9tICR7YXV0aFJlcXVlc3RUeXBlLnRvU3RyaW5nKCl9IGVuZHBvaW50IHdhcyBpbnZhbGlkLCB5ZXQgc3RhdHVzIGNvZGUgd2FzIDIwMC4gRGF0YSB3YXM6ICR7eGhyLnJlc3BvbnNlVGV4dH1gKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXV0aFJlcXVlc3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0aFJlcXVlc3RUeXBlLlVzZXJBdXRoZW50aWNhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnYXV0aGVudGljYXRpb25FbmRwb2ludCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0aFJlcXVlc3RUeXBlLkNoYW5uZWxBdXRob3JpemF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gYENsaWVudHMgbXVzdCBiZSBhdXRob3JpemVkIHRvIGpvaW4gcHJpdmF0ZSBvciBwcmVzZW5jZSBjaGFubmVscy4gJHt1cmxfc3RvcmUuYnVpbGRMb2dTdWZmaXgoJ2F1dGhvcml6YXRpb25FbmRwb2ludCcpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEhUVFBBdXRoRXJyb3IoeGhyLnN0YXR1cywgYFVuYWJsZSB0byByZXRyaWV2ZSBhdXRoIHN0cmluZyBmcm9tICR7YXV0aFJlcXVlc3RUeXBlLnRvU3RyaW5nKCl9IGVuZHBvaW50IC0gYCArXG4gICAgICAgICAgICAgICAgICAgIGByZWNlaXZlZCBzdGF0dXM6ICR7eGhyLnN0YXR1c30gZnJvbSAke2F1dGhPcHRpb25zLmVuZHBvaW50fS4gJHtzdWZmaXh9YCksIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChxdWVyeSk7XG4gICAgcmV0dXJuIHhocjtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfYXV0aCA9IChhamF4KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy90aW1lbGluZS94aHJfdGltZWxpbmUudHNcblxuXG5cbnZhciBnZXRBZ2VudCA9IGZ1bmN0aW9uIChzZW5kZXIsIHVzZVRMUykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICdodHRwJyArICh1c2VUTFMgPyAncycgOiAnJykgKyAnOi8vJztcbiAgICAgICAgdmFyIHVybCA9IHNjaGVtZSArIChzZW5kZXIuaG9zdCB8fCBzZW5kZXIub3B0aW9ucy5ob3N0KSArIHNlbmRlci5vcHRpb25zLnBhdGg7XG4gICAgICAgIHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSk7XG4gICAgICAgIHVybCArPSAnLycgKyAyICsgJz8nICsgcXVlcnk7XG4gICAgICAgIHZhciB4aHIgPSBub2RlX3J1bnRpbWUuY3JlYXRlWEhSKCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgc3RhdHVzLCByZXNwb25zZVRleHQgfSA9IHhocjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaW1lbGluZVNlbmRlciBFcnJvcjogcmVjZWl2ZWQgJHtzdGF0dXN9IGZyb20gc3RhdHMucHVzaGVyLmNvbWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB7IGhvc3QgfSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaW1lbGluZVNlbmRlckVycm9yOiBpbnZhbGlkIHJlc3BvbnNlICR7cmVzcG9uc2VUZXh0fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaG9zdCkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kZXIuaG9zdCA9IGhvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH07XG59O1xudmFyIHhocl90aW1lbGluZV94aHIgPSB7XG4gICAgbmFtZTogJ3hocicsXG4gICAgZ2V0QWdlbnRcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfdGltZWxpbmUgPSAoeGhyX3RpbWVsaW5lX3hocik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJjcnlwdG9cIlxudmFyIGV4dGVybmFsX2NyeXB0b18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9ub2RlL3J1bnRpbWUudHNcblxuXG5cblxuXG5cblxuY29uc3QgeyBnZXREZWZhdWx0U3RyYXRlZ3k6IHJ1bnRpbWVfZ2V0RGVmYXVsdFN0cmF0ZWd5LCBUcmFuc3BvcnRzOiBydW50aW1lX1RyYW5zcG9ydHMsIHNldHVwLCBnZXRQcm90b2NvbCwgaXNYSFJTdXBwb3J0ZWQsIGdldExvY2FsU3RvcmFnZSwgY3JlYXRlWEhSLCBjcmVhdGVXZWJTb2NrZXQsIGFkZFVubG9hZExpc3RlbmVyLCByZW1vdmVVbmxvYWRMaXN0ZW5lciwgdHJhbnNwb3J0Q29ubmVjdGlvbkluaXRpYWxpemVyLCBjcmVhdGVTb2NrZXRSZXF1ZXN0LCBIVFRQRmFjdG9yeSB9ID0gcnVudGltZTtcbmNvbnN0IE5vZGVKUyA9IHtcbiAgICBnZXREZWZhdWx0U3RyYXRlZ3k6IHJ1bnRpbWVfZ2V0RGVmYXVsdFN0cmF0ZWd5LFxuICAgIFRyYW5zcG9ydHM6IHJ1bnRpbWVfVHJhbnNwb3J0cyxcbiAgICBzZXR1cCxcbiAgICBnZXRQcm90b2NvbCxcbiAgICBpc1hIUlN1cHBvcnRlZCxcbiAgICBjcmVhdGVTb2NrZXRSZXF1ZXN0LFxuICAgIGdldExvY2FsU3RvcmFnZSxcbiAgICBjcmVhdGVYSFIsXG4gICAgY3JlYXRlV2ViU29ja2V0LFxuICAgIGFkZFVubG9hZExpc3RlbmVyLFxuICAgIHJlbW92ZVVubG9hZExpc3RlbmVyLFxuICAgIHRyYW5zcG9ydENvbm5lY3Rpb25Jbml0aWFsaXplcixcbiAgICBIVFRQRmFjdG9yeSxcbiAgICBUaW1lbGluZVRyYW5zcG9ydDogeGhyX3RpbWVsaW5lLFxuICAgIGdldEF1dGhvcml6ZXJzKCkge1xuICAgICAgICByZXR1cm4geyBhamF4OiB4aHJfYXV0aCB9O1xuICAgIH0sXG4gICAgZ2V0V2ViU29ja2V0QVBJKCkge1xuICAgICAgICByZXR1cm4gd2Vic29ja2V0W1wiQ2xpZW50XCJdO1xuICAgIH0sXG4gICAgZ2V0WEhSQVBJKCkge1xuICAgICAgICByZXR1cm4gWE1MSHR0cFJlcXVlc3RbXCJYTUxIdHRwUmVxdWVzdFwiXTtcbiAgICB9LFxuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXRfaW5mb19OZXR3b3JrO1xuICAgIH0sXG4gICAgcmFuZG9tSW50KG1heCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX2NyeXB0b19bXCJyYW5kb21JbnRcIl0pKG1heCk7XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG5vZGVfcnVudGltZSA9IChOb2RlSlMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RpbWVsaW5lL2xldmVsLnRzXG52YXIgVGltZWxpbmVMZXZlbDtcbihmdW5jdGlvbiAoVGltZWxpbmVMZXZlbCkge1xuICAgIFRpbWVsaW5lTGV2ZWxbVGltZWxpbmVMZXZlbFtcIkVSUk9SXCJdID0gM10gPSBcIkVSUk9SXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiSU5GT1wiXSA9IDZdID0gXCJJTkZPXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiREVCVUdcIl0gPSA3XSA9IFwiREVCVUdcIjtcbn0pKFRpbWVsaW5lTGV2ZWwgfHwgKFRpbWVsaW5lTGV2ZWwgPSB7fSkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGltZWxpbmVfbGV2ZWwgPSAoVGltZWxpbmVMZXZlbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdGltZWxpbmUvdGltZWxpbmUudHNcblxuXG5cbmNsYXNzIHRpbWVsaW5lX1RpbWVsaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuc2VudCA9IDA7XG4gICAgICAgIHRoaXMudW5pcXVlSUQgPSAwO1xuICAgIH1cbiAgICBsb2cobGV2ZWwsIGV2ZW50KSB7XG4gICAgICAgIGlmIChsZXZlbCA8PSB0aGlzLm9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXh0ZW5kKHt9LCBldmVudCwgeyB0aW1lc3RhbXA6IHV0aWwubm93KCkgfSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW1pdCAmJiB0aGlzLmV2ZW50cy5sZW5ndGggPiB0aGlzLm9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVycm9yKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nKHRpbWVsaW5lX2xldmVsLkVSUk9SLCBldmVudCk7XG4gICAgfVxuICAgIGluZm8oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2codGltZWxpbmVfbGV2ZWwuSU5GTywgZXZlbnQpO1xuICAgIH1cbiAgICBkZWJ1ZyhldmVudCkge1xuICAgICAgICB0aGlzLmxvZyh0aW1lbGluZV9sZXZlbC5ERUJVRywgZXZlbnQpO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBzZW5kKHNlbmRmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGEgPSBleHRlbmQoe1xuICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5zZXNzaW9uLFxuICAgICAgICAgICAgYnVuZGxlOiB0aGlzLnNlbnQgKyAxLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGxpYjogJ2pzJyxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMub3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5vcHRpb25zLmNsdXN0ZXIsXG4gICAgICAgICAgICBmZWF0dXJlczogdGhpcy5vcHRpb25zLmZlYXR1cmVzLFxuICAgICAgICAgICAgdGltZWxpbmU6IHRoaXMuZXZlbnRzXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICBzZW5kZm4oZGF0YSwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdlbmVyYXRlVW5pcXVlSUQoKSB7XG4gICAgICAgIHRoaXMudW5pcXVlSUQrKztcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pcXVlSUQ7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvdHJhbnNwb3J0X3N0cmF0ZWd5LnRzXG5cblxuXG5cbmNsYXNzIHRyYW5zcG9ydF9zdHJhdGVneV9UcmFuc3BvcnRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcHJpb3JpdHksIHRyYW5zcG9ydCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmlzU3VwcG9ydGVkKHtcbiAgICAgICAgICAgIHVzZVRMUzogdGhpcy5vcHRpb25zLnVzZVRMU1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsQXR0ZW1wdChuZXcgVW5zdXBwb3J0ZWRTdHJhdGVneSgpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcmlvcml0eSA8IG1pblByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbEF0dGVtcHQobmV3IFRyYW5zcG9ydFByaW9yaXR5VG9vTG93KCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydC5jcmVhdGVDb25uZWN0aW9uKHRoaXMubmFtZSwgdGhpcy5wcmlvcml0eSwgdGhpcy5vcHRpb25zLmtleSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdmFyIGhhbmRzaGFrZSA9IG51bGw7XG4gICAgICAgIHZhciBvbkluaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnaW5pdGlhbGl6ZWQnLCBvbkluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5jb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoYW5kc2hha2UgPSBmYWN0b3J5LmNyZWF0ZUhhbmRzaGFrZSh0cmFuc3BvcnQsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25DbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkVHJhbnNwb3J0O1xuICAgICAgICAgICAgc2VyaWFsaXplZFRyYW5zcG9ydCA9IHNhZmVKU09OU3RyaW5naWZ5KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgVHJhbnNwb3J0Q2xvc2VkKHNlcmlhbGl6ZWRUcmFuc3BvcnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVuYmluZExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2luaXRpYWxpemVkJywgb25Jbml0aWFsaXplZCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdpbml0aWFsaXplZCcsIG9uSW5pdGlhbGl6ZWQpO1xuICAgICAgICB0cmFuc3BvcnQuYmluZCgnb3BlbicsIG9uT3Blbik7XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICB0cmFuc3BvcnQuYmluZCgnY2xvc2VkJywgb25DbG9zZWQpO1xuICAgICAgICB0cmFuc3BvcnQuaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBwID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJpb3JpdHkgPCBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZmFpbEF0dGVtcHQoZXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgdXRpbC5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAoKSB7IH1cbiAgICB9O1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvc3RyYXRlZ3lfYnVpbGRlci50c1xuXG5cblxuXG5cbmNvbnN0IHsgVHJhbnNwb3J0czogc3RyYXRlZ3lfYnVpbGRlcl9UcmFuc3BvcnRzIH0gPSBub2RlX3J1bnRpbWU7XG52YXIgc3RyYXRlZ3lfYnVpbGRlcl9kZWZpbmVUcmFuc3BvcnQgPSBmdW5jdGlvbiAoY29uZmlnLCBuYW1lLCB0eXBlLCBwcmlvcml0eSwgb3B0aW9ucywgbWFuYWdlcikge1xuICAgIHZhciB0cmFuc3BvcnRDbGFzcyA9IHN0cmF0ZWd5X2J1aWxkZXJfVHJhbnNwb3J0c1t0eXBlXTtcbiAgICBpZiAoIXRyYW5zcG9ydENsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRyYW5zcG9ydCh0eXBlKTtcbiAgICB9XG4gICAgdmFyIGVuYWJsZWQgPSAoIWNvbmZpZy5lbmFibGVkVHJhbnNwb3J0cyB8fFxuICAgICAgICBhcnJheUluZGV4T2YoY29uZmlnLmVuYWJsZWRUcmFuc3BvcnRzLCBuYW1lKSAhPT0gLTEpICYmXG4gICAgICAgICghY29uZmlnLmRpc2FibGVkVHJhbnNwb3J0cyB8fFxuICAgICAgICAgICAgYXJyYXlJbmRleE9mKGNvbmZpZy5kaXNhYmxlZFRyYW5zcG9ydHMsIG5hbWUpID09PSAtMSk7XG4gICAgdmFyIHRyYW5zcG9ydDtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGlnbm9yZU51bGxPcmlnaW46IGNvbmZpZy5pZ25vcmVOdWxsT3JpZ2luIH0sIG9wdGlvbnMpO1xuICAgICAgICB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X3N0cmF0ZWd5X1RyYW5zcG9ydFN0cmF0ZWd5KG5hbWUsIHByaW9yaXR5LCBtYW5hZ2VyID8gbWFuYWdlci5nZXRBc3Npc3RhbnQodHJhbnNwb3J0Q2xhc3MpIDogdHJhbnNwb3J0Q2xhc3MsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJhbnNwb3J0ID0gc3RyYXRlZ3lfYnVpbGRlcl9VbnN1cHBvcnRlZFN0cmF0ZWd5O1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0O1xufTtcbnZhciBzdHJhdGVneV9idWlsZGVyX1Vuc3VwcG9ydGVkU3RyYXRlZ3kgPSB7XG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY29ubmVjdDogZnVuY3Rpb24gKF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFVuc3VwcG9ydGVkU3RyYXRlZ3koKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9vcHRpb25zLnRzXG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyAnWW91IG11c3QgcGFzcyBhbiBvcHRpb25zIG9iamVjdCc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNsdXN0ZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyAnT3B0aW9ucyBvYmplY3QgbXVzdCBwcm92aWRlIGEgY2x1c3Rlcic7XG4gICAgfVxuICAgIGlmICgnZGlzYWJsZVN0YXRzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdUaGUgZGlzYWJsZVN0YXRzIG9wdGlvbiBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGVuYWJsZVN0YXRzJyk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvdXNlcl9hdXRoZW50aWNhdG9yLnRzXG5cblxuY29uc3QgY29tcG9zZUNoYW5uZWxRdWVyeSA9IChwYXJhbXMsIGF1dGhPcHRpb25zKSA9PiB7XG4gICAgdmFyIHF1ZXJ5ID0gJ3NvY2tldF9pZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zb2NrZXRJZCk7XG4gICAgZm9yICh2YXIga2V5IGluIGF1dGhPcHRpb25zLnBhcmFtcykge1xuICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoYXV0aE9wdGlvbnMucGFyYW1zW2tleV0pO1xuICAgIH1cbiAgICBpZiAoYXV0aE9wdGlvbnMucGFyYW1zUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZHluYW1pY1BhcmFtcyA9IGF1dGhPcHRpb25zLnBhcmFtc1Byb3ZpZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkeW5hbWljUGFyYW1zKSB7XG4gICAgICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGR5bmFtaWNQYXJhbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xufTtcbmNvbnN0IFVzZXJBdXRoZW50aWNhdG9yID0gKGF1dGhPcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBub2RlX3J1bnRpbWUuZ2V0QXV0aG9yaXplcnMoKVthdXRoT3B0aW9ucy50cmFuc3BvcnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBgJyR7YXV0aE9wdGlvbnMudHJhbnNwb3J0fScgaXMgbm90IGEgcmVjb2duaXplZCBhdXRoIHRyYW5zcG9ydGA7XG4gICAgfVxuICAgIHJldHVybiAocGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCBxdWVyeSA9IGNvbXBvc2VDaGFubmVsUXVlcnkocGFyYW1zLCBhdXRoT3B0aW9ucyk7XG4gICAgICAgIG5vZGVfcnVudGltZS5nZXRBdXRob3JpemVycygpW2F1dGhPcHRpb25zLnRyYW5zcG9ydF0obm9kZV9ydW50aW1lLCBxdWVyeSwgYXV0aE9wdGlvbnMsIEF1dGhSZXF1ZXN0VHlwZS5Vc2VyQXV0aGVudGljYXRpb24sIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHVzZXJfYXV0aGVudGljYXRvciA9IChVc2VyQXV0aGVudGljYXRvcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvYXV0aC9jaGFubmVsX2F1dGhvcml6ZXIudHNcblxuXG5jb25zdCBjaGFubmVsX2F1dGhvcml6ZXJfY29tcG9zZUNoYW5uZWxRdWVyeSA9IChwYXJhbXMsIGF1dGhPcHRpb25zKSA9PiB7XG4gICAgdmFyIHF1ZXJ5ID0gJ3NvY2tldF9pZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zb2NrZXRJZCk7XG4gICAgcXVlcnkgKz0gJyZjaGFubmVsX25hbWU9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY2hhbm5lbE5hbWUpO1xuICAgIGZvciAodmFyIGtleSBpbiBhdXRoT3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgcXVlcnkgKz1cbiAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgK1xuICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGF1dGhPcHRpb25zLnBhcmFtc1trZXldKTtcbiAgICB9XG4gICAgaWYgKGF1dGhPcHRpb25zLnBhcmFtc1Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGR5bmFtaWNQYXJhbXMgPSBhdXRoT3B0aW9ucy5wYXJhbXNQcm92aWRlcigpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZHluYW1pY1BhcmFtcykge1xuICAgICAgICAgICAgcXVlcnkgKz1cbiAgICAgICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChkeW5hbWljUGFyYW1zW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbn07XG5jb25zdCBDaGFubmVsQXV0aG9yaXplciA9IChhdXRoT3B0aW9ucykgPT4ge1xuICAgIGlmICh0eXBlb2Ygbm9kZV9ydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgYCcke2F1dGhPcHRpb25zLnRyYW5zcG9ydH0nIGlzIG5vdCBhIHJlY29nbml6ZWQgYXV0aCB0cmFuc3BvcnRgO1xuICAgIH1cbiAgICByZXR1cm4gKHBhcmFtcywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjaGFubmVsX2F1dGhvcml6ZXJfY29tcG9zZUNoYW5uZWxRdWVyeShwYXJhbXMsIGF1dGhPcHRpb25zKTtcbiAgICAgICAgbm9kZV9ydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XShub2RlX3J1bnRpbWUsIHF1ZXJ5LCBhdXRoT3B0aW9ucywgQXV0aFJlcXVlc3RUeXBlLkNoYW5uZWxBdXRob3JpemF0aW9uLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjaGFubmVsX2F1dGhvcml6ZXIgPSAoQ2hhbm5lbEF1dGhvcml6ZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvZGVwcmVjYXRlZF9jaGFubmVsX2F1dGhvcml6ZXIudHNcbmNvbnN0IENoYW5uZWxBdXRob3JpemVyUHJveHkgPSAocHVzaGVyLCBhdXRoT3B0aW9ucywgY2hhbm5lbEF1dGhvcml6ZXJHZW5lcmF0b3IpID0+IHtcbiAgICBjb25zdCBkZXByZWNhdGVkQXV0aG9yaXplck9wdGlvbnMgPSB7XG4gICAgICAgIGF1dGhUcmFuc3BvcnQ6IGF1dGhPcHRpb25zLnRyYW5zcG9ydCxcbiAgICAgICAgYXV0aEVuZHBvaW50OiBhdXRoT3B0aW9ucy5lbmRwb2ludCxcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgcGFyYW1zOiBhdXRoT3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICBoZWFkZXJzOiBhdXRoT3B0aW9ucy5oZWFkZXJzXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAocGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCBjaGFubmVsID0gcHVzaGVyLmNoYW5uZWwocGFyYW1zLmNoYW5uZWxOYW1lKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbEF1dGhvcml6ZXIgPSBjaGFubmVsQXV0aG9yaXplckdlbmVyYXRvcihjaGFubmVsLCBkZXByZWNhdGVkQXV0aG9yaXplck9wdGlvbnMpO1xuICAgICAgICBjaGFubmVsQXV0aG9yaXplci5hdXRob3JpemUocGFyYW1zLnNvY2tldElkLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29uZmlnLnRzXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0Q29uZmlnKG9wdHMsIHB1c2hlcikge1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgIGFjdGl2aXR5VGltZW91dDogb3B0cy5hY3Rpdml0eVRpbWVvdXQgfHwgZGVmYXVsdHMuYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICBjbHVzdGVyOiBvcHRzLmNsdXN0ZXIsXG4gICAgICAgIGh0dHBQYXRoOiBvcHRzLmh0dHBQYXRoIHx8IGRlZmF1bHRzLmh0dHBQYXRoLFxuICAgICAgICBodHRwUG9ydDogb3B0cy5odHRwUG9ydCB8fCBkZWZhdWx0cy5odHRwUG9ydCxcbiAgICAgICAgaHR0cHNQb3J0OiBvcHRzLmh0dHBzUG9ydCB8fCBkZWZhdWx0cy5odHRwc1BvcnQsXG4gICAgICAgIHBvbmdUaW1lb3V0OiBvcHRzLnBvbmdUaW1lb3V0IHx8IGRlZmF1bHRzLnBvbmdUaW1lb3V0LFxuICAgICAgICBzdGF0c0hvc3Q6IG9wdHMuc3RhdHNIb3N0IHx8IGRlZmF1bHRzLnN0YXRzX2hvc3QsXG4gICAgICAgIHVuYXZhaWxhYmxlVGltZW91dDogb3B0cy51bmF2YWlsYWJsZVRpbWVvdXQgfHwgZGVmYXVsdHMudW5hdmFpbGFibGVUaW1lb3V0LFxuICAgICAgICB3c1BhdGg6IG9wdHMud3NQYXRoIHx8IGRlZmF1bHRzLndzUGF0aCxcbiAgICAgICAgd3NQb3J0OiBvcHRzLndzUG9ydCB8fCBkZWZhdWx0cy53c1BvcnQsXG4gICAgICAgIHdzc1BvcnQ6IG9wdHMud3NzUG9ydCB8fCBkZWZhdWx0cy53c3NQb3J0LFxuICAgICAgICBlbmFibGVTdGF0czogZ2V0RW5hYmxlU3RhdHNDb25maWcob3B0cyksXG4gICAgICAgIGh0dHBIb3N0OiBnZXRIdHRwSG9zdChvcHRzKSxcbiAgICAgICAgdXNlVExTOiBzaG91bGRVc2VUTFMob3B0cyksXG4gICAgICAgIHdzSG9zdDogZ2V0V2Vic29ja2V0SG9zdChvcHRzKSxcbiAgICAgICAgdXNlckF1dGhlbnRpY2F0b3I6IGJ1aWxkVXNlckF1dGhlbnRpY2F0b3Iob3B0cyksXG4gICAgICAgIGNoYW5uZWxBdXRob3JpemVyOiBidWlsZENoYW5uZWxBdXRob3JpemVyKG9wdHMsIHB1c2hlcilcbiAgICB9O1xuICAgIGlmICgnZGlzYWJsZWRUcmFuc3BvcnRzJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcuZGlzYWJsZWRUcmFuc3BvcnRzID0gb3B0cy5kaXNhYmxlZFRyYW5zcG9ydHM7XG4gICAgaWYgKCdlbmFibGVkVHJhbnNwb3J0cycgaW4gb3B0cylcbiAgICAgICAgY29uZmlnLmVuYWJsZWRUcmFuc3BvcnRzID0gb3B0cy5lbmFibGVkVHJhbnNwb3J0cztcbiAgICBpZiAoJ2lnbm9yZU51bGxPcmlnaW4nIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy5pZ25vcmVOdWxsT3JpZ2luID0gb3B0cy5pZ25vcmVOdWxsT3JpZ2luO1xuICAgIGlmICgndGltZWxpbmVQYXJhbXMnIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy50aW1lbGluZVBhcmFtcyA9IG9wdHMudGltZWxpbmVQYXJhbXM7XG4gICAgaWYgKCduYWNsJyBpbiBvcHRzKSB7XG4gICAgICAgIGNvbmZpZy5uYWNsID0gb3B0cy5uYWNsO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gZ2V0SHR0cEhvc3Qob3B0cykge1xuICAgIGlmIChvcHRzLmh0dHBIb3N0KSB7XG4gICAgICAgIHJldHVybiBvcHRzLmh0dHBIb3N0O1xuICAgIH1cbiAgICBpZiAob3B0cy5jbHVzdGVyKSB7XG4gICAgICAgIHJldHVybiBgc29ja2pzLSR7b3B0cy5jbHVzdGVyfS5wdXNoZXIuY29tYDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzLmh0dHBIb3N0O1xufVxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0SG9zdChvcHRzKSB7XG4gICAgaWYgKG9wdHMud3NIb3N0KSB7XG4gICAgICAgIHJldHVybiBvcHRzLndzSG9zdDtcbiAgICB9XG4gICAgcmV0dXJuIGdldFdlYnNvY2tldEhvc3RGcm9tQ2x1c3RlcihvcHRzLmNsdXN0ZXIpO1xufVxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0SG9zdEZyb21DbHVzdGVyKGNsdXN0ZXIpIHtcbiAgICByZXR1cm4gYHdzLSR7Y2x1c3Rlcn0ucHVzaGVyLmNvbWA7XG59XG5mdW5jdGlvbiBzaG91bGRVc2VUTFMob3B0cykge1xuICAgIGlmIChub2RlX3J1bnRpbWUuZ2V0UHJvdG9jb2woKSA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdHMuZm9yY2VUTFMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRFbmFibGVTdGF0c0NvbmZpZyhvcHRzKSB7XG4gICAgaWYgKCdlbmFibGVTdGF0cycgaW4gb3B0cykge1xuICAgICAgICByZXR1cm4gb3B0cy5lbmFibGVTdGF0cztcbiAgICB9XG4gICAgaWYgKCdkaXNhYmxlU3RhdHMnIGluIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuICFvcHRzLmRpc2FibGVTdGF0cztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYnVpbGRVc2VyQXV0aGVudGljYXRvcihvcHRzKSB7XG4gICAgY29uc3QgdXNlckF1dGhlbnRpY2F0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cy51c2VyQXV0aGVudGljYXRpb24pLCBvcHRzLnVzZXJBdXRoZW50aWNhdGlvbik7XG4gICAgaWYgKCdjdXN0b21IYW5kbGVyJyBpbiB1c2VyQXV0aGVudGljYXRpb24gJiZcbiAgICAgICAgdXNlckF1dGhlbnRpY2F0aW9uWydjdXN0b21IYW5kbGVyJ10gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdXNlckF1dGhlbnRpY2F0aW9uWydjdXN0b21IYW5kbGVyJ107XG4gICAgfVxuICAgIHJldHVybiB1c2VyX2F1dGhlbnRpY2F0b3IodXNlckF1dGhlbnRpY2F0aW9uKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hhbm5lbEF1dGgob3B0cywgcHVzaGVyKSB7XG4gICAgbGV0IGNoYW5uZWxBdXRob3JpemF0aW9uO1xuICAgIGlmICgnY2hhbm5lbEF1dGhvcml6YXRpb24nIGluIG9wdHMpIHtcbiAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLmNoYW5uZWxBdXRob3JpemF0aW9uKSwgb3B0cy5jaGFubmVsQXV0aG9yaXphdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbiA9IHtcbiAgICAgICAgICAgIHRyYW5zcG9ydDogb3B0cy5hdXRoVHJhbnNwb3J0IHx8IGRlZmF1bHRzLmF1dGhUcmFuc3BvcnQsXG4gICAgICAgICAgICBlbmRwb2ludDogb3B0cy5hdXRoRW5kcG9pbnQgfHwgZGVmYXVsdHMuYXV0aEVuZHBvaW50XG4gICAgICAgIH07XG4gICAgICAgIGlmICgnYXV0aCcgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKCdwYXJhbXMnIGluIG9wdHMuYXV0aClcbiAgICAgICAgICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbi5wYXJhbXMgPSBvcHRzLmF1dGgucGFyYW1zO1xuICAgICAgICAgICAgaWYgKCdoZWFkZXJzJyBpbiBvcHRzLmF1dGgpXG4gICAgICAgICAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24uaGVhZGVycyA9IG9wdHMuYXV0aC5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnYXV0aG9yaXplcicgaW4gb3B0cylcbiAgICAgICAgICAgIGNoYW5uZWxBdXRob3JpemF0aW9uLmN1c3RvbUhhbmRsZXIgPSBDaGFubmVsQXV0aG9yaXplclByb3h5KHB1c2hlciwgY2hhbm5lbEF1dGhvcml6YXRpb24sIG9wdHMuYXV0aG9yaXplcik7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsQXV0aG9yaXphdGlvbjtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hhbm5lbEF1dGhvcml6ZXIob3B0cywgcHVzaGVyKSB7XG4gICAgY29uc3QgY2hhbm5lbEF1dGhvcml6YXRpb24gPSBidWlsZENoYW5uZWxBdXRoKG9wdHMsIHB1c2hlcik7XG4gICAgaWYgKCdjdXN0b21IYW5kbGVyJyBpbiBjaGFubmVsQXV0aG9yaXphdGlvbiAmJlxuICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvblsnY3VzdG9tSGFuZGxlciddICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWxBdXRob3JpemF0aW9uWydjdXN0b21IYW5kbGVyJ107XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsX2F1dGhvcml6ZXIoY2hhbm5lbEF1dGhvcml6YXRpb24pO1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3dhdGNobGlzdC50c1xuXG5cbmNsYXNzIHdhdGNobGlzdF9XYXRjaGxpc3RGYWNhZGUgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIGNhbGxiYWNrcyBvbiB3YXRjaGxpc3QgZXZlbnRzIGZvciAke2V2ZW50TmFtZX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICB0aGlzLmJpbmRXYXRjaGxpc3RJbnRlcm5hbEV2ZW50KCk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KHB1c2hlckV2ZW50KSB7XG4gICAgICAgIHB1c2hlckV2ZW50LmRhdGEuZXZlbnRzLmZvckVhY2god2F0Y2hsaXN0RXZlbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHdhdGNobGlzdEV2ZW50Lm5hbWUsIHdhdGNobGlzdEV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmRXYXRjaGxpc3RJbnRlcm5hbEV2ZW50KCkge1xuICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ21lc3NhZ2UnLCBwdXNoZXJFdmVudCA9PiB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gcHVzaGVyRXZlbnQuZXZlbnQ7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncHVzaGVyX2ludGVybmFsOndhdGNobGlzdF9ldmVudHMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudChwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy9mbGF0X3Byb21pc2UudHNcbmZ1bmN0aW9uIGZsYXRQcm9taXNlKCkge1xuICAgIGxldCByZXNvbHZlLCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmbGF0X3Byb21pc2UgPSAoZmxhdFByb21pc2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3VzZXIudHNcblxuXG5cblxuXG5jbGFzcyB1c2VyX1VzZXJGYWNhZGUgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiB1c2VyIGZvciAnICsgZXZlbnROYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZXJfZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2lnbmluRG9uZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zaWduaW5Eb25lUmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uQXV0aG9yaXplID0gKGVyciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3IgZHVyaW5nIHNpZ25pbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjpzaWduaW4nLCB7XG4gICAgICAgICAgICAgICAgYXV0aDogYXV0aERhdGEuYXV0aCxcbiAgICAgICAgICAgICAgICB1c2VyX2RhdGE6IGF1dGhEYXRhLnVzZXJfZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ3N0YXRlX2NoYW5nZScsICh7IHByZXZpb3VzLCBjdXJyZW50IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAhPT0gJ2Nvbm5lY3RlZCcgJiYgY3VycmVudCA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWduaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ2Nvbm5lY3RlZCcgJiYgY3VycmVudCAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV3U2lnbmluUHJvbWlzZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndhdGNobGlzdCA9IG5ldyB3YXRjaGxpc3RfV2F0Y2hsaXN0RmFjYWRlKHB1c2hlcik7XG4gICAgICAgIHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uYmluZCgnbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXI6c2lnbmluX3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TaWduaW5TdWNjZXNzKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5uYW1lID09PSBldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25pbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NpZ25pbigpO1xuICAgIH1cbiAgICBfc2lnbmluKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpO1xuICAgICAgICBpZiAodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hlci5jb25maWcudXNlckF1dGhlbnRpY2F0b3Ioe1xuICAgICAgICAgICAgc29ja2V0SWQ6IHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkXG4gICAgICAgIH0sIHRoaXMuX29uQXV0aG9yaXplKTtcbiAgICB9XG4gICAgX29uU2lnbmluU3VjY2VzcyhkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJfZGF0YSA9IEpTT04ucGFyc2UoZGF0YS51c2VyX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCBwYXJzaW5nIHVzZXIgZGF0YSBhZnRlciBzaWduaW46ICR7ZGF0YS51c2VyX2RhdGF9YCk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnVzZXJfZGF0YS5pZCAhPT0gJ3N0cmluZycgfHwgdGhpcy51c2VyX2RhdGEuaWQgPT09ICcnKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYHVzZXJfZGF0YSBkb2Vzbid0IGNvbnRhaW4gYW4gaWQuIHVzZXJfZGF0YTogJHt0aGlzLnVzZXJfZGF0YX1gKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduaW5Eb25lUmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVDaGFubmVscygpO1xuICAgIH1cbiAgICBfc3Vic2NyaWJlQ2hhbm5lbHMoKSB7XG4gICAgICAgIGNvbnN0IGVuc3VyZV9zdWJzY3JpYmVkID0gY2hhbm5lbCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5yZWluc3RhdGVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG5ldyBjaGFubmVsX0NoYW5uZWwoYCNzZXJ2ZXItdG8tdXNlci0ke3RoaXMudXNlcl9kYXRhLmlkfWAsIHRoaXMucHVzaGVyKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmJpbmRfZ2xvYmFsKChldmVudE5hbWUsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwIHx8XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZW5zdXJlX3N1YnNjcmliZWQodGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsKTtcbiAgICB9XG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIHRoaXMudXNlcl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLnVuYmluZF9hbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlclRvVXNlckNoYW5uZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaWduaW5Eb25lUHJvbWlzZSAmJiAhdGhpcy5zaWduaW5Eb25lUHJvbWlzZS5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3Q6IF8gfSA9IGZsYXRfcHJvbWlzZSgpO1xuICAgICAgICBwcm9taXNlLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc2V0RG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UuZG9uZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHByb21pc2UudGhlbihzZXREb25lKS5jYXRjaChzZXREb25lKTtcbiAgICAgICAgdGhpcy5zaWduaW5Eb25lUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvcHVzaGVyLnRzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIHB1c2hlcl9QdXNoZXIge1xuICAgIHN0YXRpYyByZWFkeSgpIHtcbiAgICAgICAgcHVzaGVyX1B1c2hlci5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwdXNoZXJfUHVzaGVyLmluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzW2ldLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2xpZW50RmVhdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGZpbHRlck9iamVjdCh7IHdzOiBub2RlX3J1bnRpbWUuVHJhbnNwb3J0cy53cyB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuaXNTdXBwb3J0ZWQoe30pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGFwcF9rZXksIG9wdGlvbnMpIHtcbiAgICAgICAgY2hlY2tBcHBLZXkoYXBwX2tleSk7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5rZXkgPSBhcHBfa2V5O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGdldENvbmZpZyhvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IGZhY3RvcnkuY3JlYXRlQ2hhbm5lbHMoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlciA9IG5ldyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uSUQgPSBub2RlX3J1bnRpbWUucmFuZG9tSW50KDEwMDAwMDAwMDApO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gbmV3IHRpbWVsaW5lX1RpbWVsaW5lKHRoaXMua2V5LCB0aGlzLnNlc3Npb25JRCwge1xuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5jb25maWcuY2x1c3RlcixcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwdXNoZXJfUHVzaGVyLmdldENsaWVudEZlYXR1cmVzKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuY29uZmlnLnRpbWVsaW5lUGFyYW1zIHx8IHt9LFxuICAgICAgICAgICAgbGltaXQ6IDUwLFxuICAgICAgICAgICAgbGV2ZWw6IHRpbWVsaW5lX2xldmVsLklORk8sXG4gICAgICAgICAgICB2ZXJzaW9uOiBkZWZhdWx0cy5WRVJTSU9OXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlU3RhdHMpIHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXIgPSBmYWN0b3J5LmNyZWF0ZVRpbWVsaW5lU2VuZGVyKHRoaXMudGltZWxpbmUsIHtcbiAgICAgICAgICAgICAgICBob3N0OiB0aGlzLmNvbmZpZy5zdGF0c0hvc3QsXG4gICAgICAgICAgICAgICAgcGF0aDogJy90aW1lbGluZS92Mi8nICsgbm9kZV9ydW50aW1lLlRpbWVsaW5lVHJhbnNwb3J0Lm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRTdHJhdGVneSA9IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZV9ydW50aW1lLmdldERlZmF1bHRTdHJhdGVneSh0aGlzLmNvbmZpZywgb3B0aW9ucywgc3RyYXRlZ3lfYnVpbGRlcl9kZWZpbmVUcmFuc3BvcnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBmYWN0b3J5LmNyZWF0ZUNvbm5lY3Rpb25NYW5hZ2VyKHRoaXMua2V5LCB7XG4gICAgICAgICAgICBnZXRTdHJhdGVneTogZ2V0U3RyYXRlZ3ksXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogdGhpcy5jb25maWcuYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICAgICAgcG9uZ1RpbWVvdXQ6IHRoaXMuY29uZmlnLnBvbmdUaW1lb3V0LFxuICAgICAgICAgICAgdW5hdmFpbGFibGVUaW1lb3V0OiB0aGlzLmNvbmZpZy51bmF2YWlsYWJsZVRpbWVvdXQsXG4gICAgICAgICAgICB1c2VUTFM6IEJvb2xlYW4odGhpcy5jb25maWcudXNlVExTKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlQWxsKCk7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXIuc2VuZCh0aGlzLmNvbm5lY3Rpb24uaXNVc2luZ1RMUygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5iaW5kKCdtZXNzYWdlJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICAgICAgdmFyIGludGVybmFsID0gZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMDtcbiAgICAgICAgICAgIGlmIChldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIuZW1pdChldmVudC5ldmVudCwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnY29ubmVjdGluZycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Rpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICBwdXNoZXJfUHVzaGVyLmluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBpbnN0YW5jZXM6IHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzLmxlbmd0aCB9KTtcbiAgICAgICAgdGhpcy51c2VyID0gbmV3IHVzZXJfVXNlckZhY2FkZSh0aGlzKTtcbiAgICAgICAgaWYgKHB1c2hlcl9QdXNoZXIuaXNSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hhbm5lbChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzLmZpbmQobmFtZSk7XG4gICAgfVxuICAgIGFsbENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVscy5hbGwoKTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmVTZW5kZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50aW1lbGluZVNlbmRlclRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVzaW5nVExTID0gdGhpcy5jb25uZWN0aW9uLmlzVXNpbmdUTFMoKTtcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVTZW5kZXIgPSB0aGlzLnRpbWVsaW5lU2VuZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXJUaW1lciA9IG5ldyB0aW1lcnNfUGVyaW9kaWNUaW1lcig2MDAwMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZVNlbmRlci5zZW5kKHVzaW5nVExTKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlclRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlclRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kKGV2ZW50X25hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIuYmluZChldmVudF9uYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci51bmJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmluZF9nbG9iYWwoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci5iaW5kX2dsb2JhbChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmRfZ2xvYmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIudW5iaW5kX2dsb2JhbChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmRfYWxsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIudW5iaW5kX2FsbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3Vic2NyaWJlQWxsKCkge1xuICAgICAgICB2YXIgY2hhbm5lbE5hbWU7XG4gICAgICAgIGZvciAoY2hhbm5lbE5hbWUgaW4gdGhpcy5jaGFubmVscy5jaGFubmVscykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHMuY2hhbm5lbHMuaGFzT3duUHJvcGVydHkoY2hhbm5lbE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoY2hhbm5lbE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShjaGFubmVsX25hbWUpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmFkZChjaGFubmVsX25hbWUsIHRoaXMpO1xuICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjaGFubmVsLnJlaW5zdGF0ZVN1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKGNoYW5uZWxfbmFtZSkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChjaGFubmVsX25hbWUpO1xuICAgICAgICBpZiAoY2hhbm5lbCAmJiBjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuY2FuY2VsU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVscy5yZW1vdmUoY2hhbm5lbF9uYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsICYmIGNoYW5uZWwuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kX2V2ZW50KGV2ZW50X25hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kX2V2ZW50KGV2ZW50X25hbWUsIGRhdGEsIGNoYW5uZWwpO1xuICAgIH1cbiAgICBzaG91bGRVc2VUTFMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy51c2VUTFM7XG4gICAgfVxuICAgIHNpZ25pbigpIHtcbiAgICAgICAgdGhpcy51c2VyLnNpZ25pbigpO1xuICAgIH1cbn1cbnB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzID0gW107XG5wdXNoZXJfUHVzaGVyLmlzUmVhZHkgPSBmYWxzZTtcbnB1c2hlcl9QdXNoZXIubG9nVG9Db25zb2xlID0gZmFsc2U7XG5wdXNoZXJfUHVzaGVyLlJ1bnRpbWUgPSBub2RlX3J1bnRpbWU7XG5wdXNoZXJfUHVzaGVyLlNjcmlwdFJlY2VpdmVycyA9IG5vZGVfcnVudGltZS5TY3JpcHRSZWNlaXZlcnM7XG5wdXNoZXJfUHVzaGVyLkRlcGVuZGVuY2llc1JlY2VpdmVycyA9IG5vZGVfcnVudGltZS5EZXBlbmRlbmNpZXNSZWNlaXZlcnM7XG5wdXNoZXJfUHVzaGVyLmF1dGhfY2FsbGJhY2tzID0gbm9kZV9ydW50aW1lLmF1dGhfY2FsbGJhY2tzO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29yZV9wdXNoZXIgPSAocHVzaGVyX1B1c2hlcik7XG5mdW5jdGlvbiBjaGVja0FwcEtleShrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93ICdZb3UgbXVzdCBwYXNzIHlvdXIgYXBwIGtleSB3aGVuIHlvdSBpbnN0YW50aWF0ZSBQdXNoZXIuJztcbiAgICB9XG59XG5ub2RlX3J1bnRpbWUuc2V0dXAocHVzaGVyX1B1c2hlcik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdHdlZXRuYWNsL25hY2wtZmFzdC5qc1xudmFyIG5hY2xfZmFzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3B1c2hlci13aXRoLWVuY3J5cHRpb24udHNcblxuXG5cbmNsYXNzIHB1c2hlcl93aXRoX2VuY3J5cHRpb25fUHVzaGVyV2l0aEVuY3J5cHRpb24gZXh0ZW5kcyBjb3JlX3B1c2hlciB7XG4gICAgY29uc3RydWN0b3IoYXBwX2tleSwgb3B0aW9ucykge1xuICAgICAgICBjb3JlX3B1c2hlci5sb2dUb0NvbnNvbGUgPSBwdXNoZXJfd2l0aF9lbmNyeXB0aW9uX1B1c2hlcldpdGhFbmNyeXB0aW9uLmxvZ1RvQ29uc29sZTtcbiAgICAgICAgY29yZV9wdXNoZXIubG9nID0gcHVzaGVyX3dpdGhfZW5jcnlwdGlvbl9QdXNoZXJXaXRoRW5jcnlwdGlvbi5sb2c7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5uYWNsID0gbmFjbF9mYXN0O1xuICAgICAgICBzdXBlcihhcHBfa2V5LCBvcHRpb25zKTtcbiAgICB9XG59XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pusher-js/dist/node/pusher.js\n");

/***/ })

};
;